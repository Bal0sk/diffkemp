; ModuleID = 'drivers/usb/core/devio.bc'
source_filename = "drivers/usb/core/devio.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.atomic_t = type { i32 }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.page = type { i64, %struct.address_space*, %struct.anon.15, %union.anon.21, %union.anon.23, [8 x i8] }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.40, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.41, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.42, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.7, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type opaque
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%union.anon.7 = type { %struct.list_head }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.5 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.5 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.6, i32 }
%union.anon.6 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%struct.atomic64_t = type { i64 }
%union.anon.40 = type { i32 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%union.anon.41 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type { i8*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.8 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.8 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.42 = type { %struct.pipe_inode_info* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.14, i32 }
%union.anon.14 = type { i8* }
%struct.swap_info_struct = type opaque
%struct.anon.15 = type { %union.anon.16, %union.anon.17 }
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.21 = type { %struct.list_head }
%union.anon.23 = type { i64 }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.list_head }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.10, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.11, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.12, %union.anon.13 }
%union.anon.10 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.11 = type { i64 }
%union.anon.12 = type { %struct.list_head }
%union.anon.13 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, i32, i32, i8, i8 }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.24 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.27, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.30 }
%union.anon.27 = type { %struct.anon.28 }
%struct.anon.28 = type { i64, i64 }
%union.anon.30 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.32 }
%union.anon.32 = type { %struct.anon.36, [80 x i8] }
%struct.anon.36 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.usb_dynids, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %struct.atomic_t, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32 }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.ep_device = type opaque
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.usb_dynids = type { %struct.spinlock, %struct.list_head }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, i32, [64 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page* }
%struct.kmem_cache_order_objects = type { i64 }
%struct.kmem_cache_node = type opaque
%struct.dev_state = type { %struct.list_head, %struct.usb_device*, %struct.file*, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.__wait_queue_head, i32, %struct.pid*, %struct.cred*, i8*, i64, i32, i32 }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type { %struct.usb_device*, i32, i32, %struct.spinlock, %struct.list_head, %struct.work_struct }
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, %struct.list_head, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ss_container_id_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.kref, [0 x %struct.usb_host_interface] }
%struct.wusb_dev = type opaque
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.async = type { %struct.list_head, %struct.dev_state*, %struct.pid*, %struct.cred*, i32, i32, i8*, i8*, %struct.urb*, i32, i32, i32, i8, i8 }
%struct.urb = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb_iso_packet_descriptor] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, i8 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.usb_iso_packet_descriptor = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer32 = type { i8, i8, i16, i16, i16, i32, i32 }
%struct.usbdevfs_bulktransfer32 = type { i32, i32, i32, i32 }
%struct.usbdevfs_ctrltransfer = type { i8, i8, i16, i16, i16, i32, i8* }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.mm_segment_t, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.mm_segment_t = type { i64 }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.43 }
%union.anon.43 = type { %struct.anon.44 }
%struct.anon.44 = type { i32*, i32, i32, i32, i64, i32* }
%struct.usbdevfs_bulktransfer = type { i32, i32, i32, i8* }
%struct.usbdevfs_getdriver = type { i32, [256 x i8] }
%struct.usbdevfs_connectinfo = type { i32, i8 }
%struct.usbdevfs_setinterface = type { i32, i32 }
%struct.usbdevfs_urb = type { i8, i8, i32, i32, i8*, i32, i32, i32, i32, i32, i32, i8*, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_iso_packet_desc = type { i32, i32, i32 }
%struct.usbdevfs_disconnectsignal32 = type { i32, i32 }
%struct.usbdevfs_urb32 = type { i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [0 x %struct.usbdevfs_iso_packet_desc] }
%struct.usbdevfs_ioctl = type { i32, i32, i8* }
%struct.usbdevfs_ioctl32 = type { i32, i32, i32 }
%struct.__large_struct = type { [100 x i64] }
%struct.usbdevfs_disconnectsignal = type { i32, i8* }
%struct.usbdevfs_disconnect_claim = type { i32, i32, [256 x i8] }
%struct.usb_ctrlrequest = type { i8, i8, i16, i16, i16 }
%struct.anon.37 = type { i8*, i16 }
%struct.__raw_tickets = type { i8, i8 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }

@usbfs_mutex = global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @usbfs_mutex to i8*), i64 8) to %struct.list_head*) }, %struct.task_struct* null, i8* null }, align 8
@__param_str_usbfs_snoop = internal constant [20 x i8] c"usbcore.usbfs_snoop\00", align 16
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@usbfs_snoop = internal global i8 0, align 1
@__param_usbfs_snoop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_usbfs_snoop, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 420, i16 -1, %union.anon.5 { i8* @usbfs_snoop } }, section "__param", align 8
@__param_str_usbfs_memory_mb = internal constant [24 x i8] c"usbcore.usbfs_memory_mb\00", align 16
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@usbfs_memory_mb = internal global i32 16, align 4
@__param_usbfs_memory_mb = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_usbfs_memory_mb, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @usbfs_memory_mb to i8*) } }, section "__param", align 8
@.str = private unnamed_addr constant [6 x i8] c"usbfs\00", align 1
@usbfs_driver = global %struct.usb_driver { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @driver_probe, void (%struct.usb_interface*)* @driver_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @driver_suspend, i32 (%struct.usb_interface*)* @driver_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* null, %struct.usb_dynids zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 0 }, align 8
@usbdev_file_operations = constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @usbdev_lseek, i64 (%struct.file*, i8*, i64, i64*)* @usbdev_read, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @usbdev_poll, i64 (%struct.file*, i32, i64)* @usbdev_ioctl, i64 (%struct.file*, i32, i64)* @usbdev_compat_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @usbdev_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.1 = private unnamed_addr constant [11 x i8] c"usb_device\00", align 1
@.str.2 = private unnamed_addr constant [44 x i8] c"\013Unable to register minors for usb_device\0A\00", align 1
@usb_device_cdev = internal global %struct.cdev zeroinitializer, align 8
@.str.3 = private unnamed_addr constant [37 x i8] c"\013Unable to get usb_device major %d\0A\00", align 1
@usbdev_nb = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @usbdev_notify, %struct.notifier_block* null, i32 0 }, align 8
@smp_ops = external global %struct.smp_ops, align 8
@current_task = external global %struct.task_struct*, align 8
@.str.4 = private unnamed_addr constant [34 x i8] c"interface number %u out of range\0A\00", align 1
@.str.5 = private unnamed_addr constant [13 x i8] c"%s: CONTROL\0A\00", align 1
@__func__.usbdev_do_ioctl = private unnamed_addr constant [16 x i8] c"usbdev_do_ioctl\00", align 1
@.str.6 = private unnamed_addr constant [10 x i8] c"%s: BULK\0A\00", align 1
@.str.7 = private unnamed_addr constant [13 x i8] c"%s: RESETEP\0A\00", align 1
@.str.8 = private unnamed_addr constant [11 x i8] c"%s: RESET\0A\00", align 1
@.str.9 = private unnamed_addr constant [16 x i8] c"%s: CLEAR_HALT\0A\00", align 1
@.str.10 = private unnamed_addr constant [15 x i8] c"%s: GETDRIVER\0A\00", align 1
@.str.11 = private unnamed_addr constant [17 x i8] c"%s: CONNECTINFO\0A\00", align 1
@.str.12 = private unnamed_addr constant [18 x i8] c"%s: SETINTERFACE\0A\00", align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"%s: SETCONFIGURATION\0A\00", align 1
@.str.14 = private unnamed_addr constant [15 x i8] c"%s: SUBMITURB\0A\00", align 1
@.str.15 = private unnamed_addr constant [15 x i8] c"%s: CONTROL32\0A\00", align 1
@.str.16 = private unnamed_addr constant [12 x i8] c"%s: BULK32\0A\00", align 1
@.str.17 = private unnamed_addr constant [18 x i8] c"%s: DISCSIGNAL32\0A\00", align 1
@.str.18 = private unnamed_addr constant [17 x i8] c"%s: SUBMITURB32\0A\00", align 1
@.str.19 = private unnamed_addr constant [15 x i8] c"%s: REAPURB32\0A\00", align 1
@.str.20 = private unnamed_addr constant [21 x i8] c"%s: REAPURBNDELAY32\0A\00", align 1
@.str.21 = private unnamed_addr constant [13 x i8] c"%s: IOCTL32\0A\00", align 1
@.str.22 = private unnamed_addr constant [16 x i8] c"%s: DISCARDURB\0A\00", align 1
@.str.23 = private unnamed_addr constant [13 x i8] c"%s: REAPURB\0A\00", align 1
@.str.24 = private unnamed_addr constant [19 x i8] c"%s: REAPURBNDELAY\0A\00", align 1
@.str.25 = private unnamed_addr constant [16 x i8] c"%s: DISCSIGNAL\0A\00", align 1
@.str.26 = private unnamed_addr constant [20 x i8] c"%s: CLAIMINTERFACE\0A\00", align 1
@.str.27 = private unnamed_addr constant [22 x i8] c"%s: RELEASEINTERFACE\0A\00", align 1
@.str.28 = private unnamed_addr constant [11 x i8] c"%s: IOCTL\0A\00", align 1
@.str.29 = private unnamed_addr constant [16 x i8] c"%s: CLAIM_PORT\0A\00", align 1
@.str.30 = private unnamed_addr constant [18 x i8] c"%s: RELEASE_PORT\0A\00", align 1
@.str.31 = private unnamed_addr constant [83 x i8] c"control urb: bRequestType=%02x bRequest=%02x wValue=%04x wIndex=%04x wLength=%04x\0A\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"\017\00", align 1
@.str.33 = private unnamed_addr constant [66 x i8] c"usbfs: USBDEVFS_CONTROL failed cmd %s rqt %u rq %u len %u ret %d\0A\00", align 1
@.str.34 = private unnamed_addr constant [62 x i8] c"usbfs: process %d (%s) did not claim interface %u before use\0A\00", align 1
@usbfs_memory_usage = internal global %struct.atomic_t zeroinitializer, align 4
@kernel_stack = external global i64, align 8
@snoop_urb.types = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.36, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0)], align 16
@.str.35 = private unnamed_addr constant [5 x i8] c"isoc\00", align 1
@.str.36 = private unnamed_addr constant [4 x i8] c"int\00", align 1
@.str.37 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"bulk\00", align 1
@snoop_urb.dirs = internal global [2 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.39, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.40, i32 0, i32 0)], align 16
@.str.39 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.40 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.41 = private unnamed_addr constant [35 x i8] c"userurb %p, ep%d %s-%s, length %u\0A\00", align 1
@.str.42 = private unnamed_addr constant [52 x i8] c"userurb %p, ep%d %s-%s, actual_length %u status %d\0A\00", align 1
@.str.43 = private unnamed_addr constant [35 x i8] c"ep%d %s-%s, length %u, timeout %d\0A\00", align 1
@.str.44 = private unnamed_addr constant [41 x i8] c"ep%d %s-%s, actual_length %u, status %d\0A\00", align 1
@.str.45 = private unnamed_addr constant [7 x i8] c"data: \00", align 1
@.str.46 = private unnamed_addr constant [20 x i8] c"include/linux/usb.h\00", align 1
@.str.47 = private unnamed_addr constant [62 x i8] c"usbfs: interface %d claimed by %s while '%s' sets config #%d\0A\00", align 1
@.str.48 = private unnamed_addr constant [35 x i8] c"usbfs: usb_submit_urb returned %d\0A\00", align 1
@.str.49 = private unnamed_addr constant [28 x i8] c"include/linux/scatterlist.h\00", align 1
@phys_base = external global i64, align 8
@.str.50 = private unnamed_addr constant [14 x i8] c"urb complete\0A\00", align 1
@.str.51 = private unnamed_addr constant [21 x i8] c"disconnect by usbfs\0A\00", align 1
@.str.52 = private unnamed_addr constant [35 x i8] c"port %d claimed by process %d: %s\0A\00", align 1
@usbdev_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.53 = private unnamed_addr constant [10 x i8] c"&ps->wait\00", align 1
@.str.54 = private unnamed_addr constant [26 x i8] c"opened by process %d: %s\0A\00", align 1
@usb_bus_type = external global %struct.bus_type, align 8
@llvm.used = appending global [2 x i8*] [i8* bitcast (%struct.kernel_param* @__param_usbfs_snoop to i8*), i8* bitcast (%struct.kernel_param* @__param_usbfs_memory_mb to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_os_allocate(i64 %size) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmalloc(i64 %size, i32 %cond)
  ret i8* %call10
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_os_acquire_object(%struct.kmem_cache* %cache) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmem_cache_zalloc(%struct.kmem_cache* %cache, i32 %cond)
  ret i8* %call10
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @acpi_os_get_thread_id() #0 {
entry:
  %call = call %struct.task_struct* @get_current()
  %0 = ptrtoint %struct.task_struct* %call to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #1 {
entry:
  ret i32 -19
}

; Function Attrs: nounwind uwtable
define internal void @driver_disconnect(%struct.usb_interface* %intf) #1 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.dev_state*
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !12
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %2 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !34
  %conv = zext i8 %2 to i32
  %tobool = icmp ne %struct.dev_state* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %conv1 = zext i32 %conv to i64
  %cmp = icmp ult i64 %conv1, 64
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 1)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  call void @clear_bit(i32 %conv, i64* %ifclaimed)
  br label %if.end8

if.else:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call7 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.4, i32 0, i32 0), i32 %conv)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* null)
  call void @destroy_async_on_interface(%struct.dev_state* %0, i32 %conv)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end8, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_suspend(%struct.usb_interface* %intf, i32 %msg.coerce) #1 {
entry:
  %msg = alloca %struct.pm_message, align 4
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %msg, i32 0, i32 0
  store i32 %msg.coerce, i32* %coerce.dive, align 4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @driver_resume(%struct.usb_interface* %intf) #1 {
entry:
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_lseek(%struct.file* %file, i64 %offset, i32 %orig) #1 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %i_mutex = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 23
  call void @mutex_lock(%struct.mutex* %i_mutex)
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %orig, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %orig, 1
  br i1 %SwitchLeaf2, label %sw.bb2, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %orig, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  store i64 %offset, i64* %f_pos, align 8, !tbaa !37
  br label %sw.epilog.sink.split

sw.bb2:                                           ; preds = %LeafBlock1
  %f_pos3 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %0 = load i64, i64* %f_pos3, align 8, !tbaa !37
  %add = add nsw i64 %0, %offset
  store i64 %add, i64* %f_pos3, align 8, !tbaa !37
  br label %sw.epilog.sink.split

sw.epilog.sink.split:                             ; preds = %sw.bb, %sw.bb2
  %f_pos4 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %1 = load i64, i64* %f_pos4, align 8, !tbaa !37
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.epilog.sink.split
  %ret.0 = phi i64 [ -22, %NewDefault ], [ %1, %sw.epilog.sink.split ]
  %call6 = call %struct.inode* @file_inode(%struct.file* %file)
  %i_mutex7 = getelementptr inbounds %struct.inode, %struct.inode* %call6, i32 0, i32 23
  call void @mutex_unlock(%struct.mutex* %i_mutex7)
  ret i64 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_read(%struct.file* %file, i8* %buf, i64 %nbytes, i64* %ppos) #1 {
entry:
  %temp_desc = alloca %struct.usb_device_descriptor, align 1
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !43
  %1 = bitcast i8* %0 to %struct.dev_state*
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %3 = load i64, i64* %ppos, align 8, !tbaa !46
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %call = call i32 @connected(%struct.dev_state* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %err

if.else:                                          ; preds = %entry
  %cmp = icmp slt i64 %3, 0
  br i1 %cmp, label %err, label %if.end4

if.end4:                                          ; preds = %if.else
  %cmp5 = icmp ult i64 %3, 18
  br i1 %cmp5, label %if.then6, label %if.end38

if.then6:                                         ; preds = %if.end4
  %4 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 18, i8* %4) #7
  %cmp7 = icmp uge i64 18, 64
  %5 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %6 = bitcast %struct.usb_device_descriptor* %descriptor to i8*
  br i1 %cmp7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.then6
  %call9 = call i8* @__memcpy(i8* %5, i8* %6, i64 18)
  br label %do.body

if.else10:                                        ; preds = %if.then6
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 18, i32 1, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.then8, %if.else10
  %__ret.0 = phi i8* [ %call9, %if.then8 ], [ %5, %if.else10 ]
  %bcdUSB = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 2
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 7
  %idProduct = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 8
  %bcdDevice = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %temp_desc, i32 0, i32 9
  %sub = sub i64 18, %3
  %conv = trunc i64 %sub to i32
  %conv22 = zext i32 %conv to i64
  %cmp23 = icmp ugt i64 %conv22, %nbytes
  %conv26 = trunc i64 %nbytes to i32
  %len.0 = select i1 %cmp23, i32 %conv26, i32 %conv
  %7 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %3
  %call28 = call i32 @copy_to_user(i8* %buf, i8* %add.ptr, i32 %len.0)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %do.body
  %conv32 = zext i32 %len.0 to i64
  %8 = load i64, i64* %ppos, align 8, !tbaa !46
  %add = add nsw i64 %8, %conv32
  store i64 %add, i64* %ppos, align 8, !tbaa !46
  %idx.ext = zext i32 %len.0 to i64
  %add.ptr33 = getelementptr inbounds i8, i8* %buf, i64 %idx.ext
  %conv34 = zext i32 %len.0 to i64
  %sub35 = sub i64 %nbytes, %conv34
  %conv36 = zext i32 %len.0 to i64
  %add37 = add nsw i64 0, %conv36
  br label %cleanup

cleanup:                                          ; preds = %do.body, %if.end31
  %ret.0 = phi i64 [ %add37, %if.end31 ], [ -14, %do.body ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end31 ], [ 2, %do.body ]
  %nbytes.addr.0 = phi i64 [ %sub35, %if.end31 ], [ %nbytes, %do.body ]
  %buf.addr.0 = phi i8* [ %add.ptr33, %if.end31 ], [ %buf, %do.body ]
  %9 = bitcast %struct.usb_device_descriptor* %temp_desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 18, i8* %9) #7
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %if.end38, label %err

if.end38:                                         ; preds = %cleanup, %if.end4
  %ret.1 = phi i64 [ 0, %if.end4 ], [ %ret.0, %cleanup ]
  %nbytes.addr.1 = phi i64 [ %nbytes, %if.end4 ], [ %nbytes.addr.0, %cleanup ]
  %buf.addr.1 = phi i8* [ %buf, %if.end4 ], [ %buf.addr.0, %cleanup ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end38
  %pos.0 = phi i64 [ 18, %if.end38 ], [ %pos.1, %for.inc ]
  %ret.2 = phi i64 [ %ret.1, %if.end38 ], [ %ret.5, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end38 ], [ %inc, %for.inc ]
  %nbytes.addr.2 = phi i64 [ %nbytes.addr.1, %if.end38 ], [ %nbytes.addr.5, %for.inc ]
  %buf.addr.2 = phi i8* [ %buf.addr.1, %if.end38 ], [ %buf.addr.5, %for.inc ]
  %tobool39 = icmp ne i64 %nbytes.addr.2, 0
  br i1 %tobool39, label %land.rhs, label %err

land.rhs:                                         ; preds = %for.cond
  %descriptor40 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 12
  %bNumConfigurations = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor40, i32 0, i32 13
  %10 = load i8, i8* %bNumConfigurations, align 1, !tbaa !47
  %conv41 = zext i8 %10 to i32
  %cmp42 = icmp slt i32 %i.0, %conv41
  br i1 %cmp42, label %for.body, label %err

for.body:                                         ; preds = %land.rhs
  %rawdescriptors = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %11 = load i8**, i8*** %rawdescriptors, align 8, !tbaa !55
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8*, i8** %11, i64 %idxprom
  %12 = load i8*, i8** %arrayidx, align 8, !tbaa !56
  %13 = bitcast i8* %12 to %struct.usb_config_descriptor*
  %wTotalLength = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %13, i32 0, i32 2
  %14 = load i16, i16* %wTotalLength, align 1, !tbaa !57
  %conv44 = zext i16 %14 to i32
  %15 = load i64, i64* %ppos, align 8, !tbaa !46
  %conv45 = zext i32 %conv44 to i64
  %add46 = add nsw i64 %pos.0, %conv45
  %cmp47 = icmp slt i64 %15, %add46
  br i1 %cmp47, label %if.then49, label %if.end100

if.then49:                                        ; preds = %for.body
  %config50 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 14
  %16 = load %struct.usb_host_config*, %struct.usb_host_config** %config50, align 8, !tbaa !59
  %idxprom51 = sext i32 %i.0 to i64
  %arrayidx52 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %16, i64 %idxprom51
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %arrayidx52, i32 0, i32 0
  %wTotalLength53 = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 2
  %17 = load i16, i16* %wTotalLength53, align 2, !tbaa !60
  %conv54 = zext i16 %17 to i32
  %conv55 = zext i32 %conv44 to i64
  %18 = load i64, i64* %ppos, align 8, !tbaa !46
  %sub56 = sub nsw i64 %18, %pos.0
  %sub57 = sub nsw i64 %conv55, %sub56
  %conv58 = trunc i64 %sub57 to i32
  %conv59 = zext i32 %conv58 to i64
  %cmp60 = icmp ugt i64 %conv59, %nbytes.addr.2
  %conv63 = trunc i64 %nbytes.addr.2 to i32
  %conv63.conv58 = select i1 %cmp60, i32 %conv63, i32 %conv58
  %conv65 = zext i32 %conv54 to i64
  %19 = load i64, i64* %ppos, align 8, !tbaa !46
  %sub66 = sub nsw i64 %19, %pos.0
  %cmp67 = icmp sgt i64 %conv65, %sub66
  br i1 %cmp67, label %if.then69, label %if.end88

if.then69:                                        ; preds = %if.then49
  %20 = load i64, i64* %ppos, align 8, !tbaa !46
  %sub70 = sub nsw i64 %20, %pos.0
  %conv71 = zext i32 %conv54 to i64
  %sub72 = sub nsw i64 %conv71, %sub70
  %conv73 = trunc i64 %sub72 to i32
  %rawdescriptors74 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 18
  %21 = load i8**, i8*** %rawdescriptors74, align 8, !tbaa !55
  %idxprom75 = sext i32 %i.0 to i64
  %arrayidx76 = getelementptr inbounds i8*, i8** %21, i64 %idxprom75
  %22 = load i8*, i8** %arrayidx76, align 8, !tbaa !56
  %23 = load i64, i64* %ppos, align 8, !tbaa !46
  %sub77 = sub nsw i64 %23, %pos.0
  %add.ptr78 = getelementptr inbounds i8, i8* %22, i64 %sub77
  %24 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %24) #7
  store i32 %conv63.conv58, i32* %_min1, align 4, !tbaa !62
  %25 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %25) #7
  store i32 %conv73, i32* %_min2, align 4, !tbaa !62
  %cmp79 = icmp eq i32* %_min1, %_min2
  %conv80 = zext i1 %cmp79 to i32
  %26 = load i32, i32* %_min1, align 4, !tbaa !62
  %27 = load i32, i32* %_min2, align 4, !tbaa !62
  %cmp82 = icmp ult i32 %26, %27
  %28 = load i32, i32* %_min1, align 4
  %29 = load i32, i32* %_min2, align 4
  %cond = select i1 %cmp82, i32 %28, i32 %29
  %30 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #7
  %31 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #7
  %call84 = call i32 @copy_to_user(i8* %buf.addr.2, i8* %add.ptr78, i32 %cond)
  %tobool85 = icmp ne i32 %call84, 0
  br i1 %tobool85, label %cleanup97, label %if.end88

if.end88:                                         ; preds = %if.then69, %if.then49
  %conv89 = zext i32 %conv63.conv58 to i64
  %32 = load i64, i64* %ppos, align 8, !tbaa !46
  %add90 = add nsw i64 %32, %conv89
  store i64 %add90, i64* %ppos, align 8, !tbaa !46
  %idx.ext91 = zext i32 %conv63.conv58 to i64
  %add.ptr92 = getelementptr inbounds i8, i8* %buf.addr.2, i64 %idx.ext91
  %conv93 = zext i32 %conv63.conv58 to i64
  %sub94 = sub i64 %nbytes.addr.2, %conv93
  %conv95 = zext i32 %conv63.conv58 to i64
  %add96 = add nsw i64 %ret.2, %conv95
  br label %cleanup97

cleanup97:                                        ; preds = %if.then69, %if.end88
  %ret.3 = phi i64 [ %add96, %if.end88 ], [ -14, %if.then69 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end88 ], [ 2, %if.then69 ]
  %nbytes.addr.3 = phi i64 [ %sub94, %if.end88 ], [ %nbytes.addr.2, %if.then69 ]
  %buf.addr.3 = phi i8* [ %add.ptr92, %if.end88 ], [ %buf.addr.2, %if.then69 ]
  %cond1 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %cond1, label %if.end100, label %cleanup103

if.end100:                                        ; preds = %cleanup97, %for.body
  %ret.4 = phi i64 [ %ret.2, %for.body ], [ %ret.3, %cleanup97 ]
  %nbytes.addr.4 = phi i64 [ %nbytes.addr.2, %for.body ], [ %nbytes.addr.3, %cleanup97 ]
  %buf.addr.4 = phi i8* [ %buf.addr.2, %for.body ], [ %buf.addr.3, %cleanup97 ]
  %conv101 = zext i32 %conv44 to i64
  %add102 = add nsw i64 %pos.0, %conv101
  br label %cleanup103

cleanup103:                                       ; preds = %cleanup97, %if.end100
  %pos.1 = phi i64 [ %pos.0, %cleanup97 ], [ %add102, %if.end100 ]
  %ret.5 = phi i64 [ %ret.3, %cleanup97 ], [ %ret.4, %if.end100 ]
  %cleanup.dest.slot.2 = phi i32 [ %cleanup.dest.slot.1, %cleanup97 ], [ 0, %if.end100 ]
  %nbytes.addr.5 = phi i64 [ %nbytes.addr.3, %cleanup97 ], [ %nbytes.addr.4, %if.end100 ]
  %buf.addr.5 = phi i8* [ %buf.addr.3, %cleanup97 ], [ %buf.addr.4, %if.end100 ]
  br label %NodeBlock

NodeBlock:                                        ; preds = %cleanup103
  %Pivot = icmp slt i32 %cleanup.dest.slot.2, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %cleanup.dest.slot.2, 2
  br i1 %SwitchLeaf4, label %err, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.2, 0
  br i1 %SwitchLeaf, label %for.inc, label %NewDefault

for.inc:                                          ; preds = %LeafBlock
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

err:                                              ; preds = %LeafBlock3, %land.rhs, %for.cond, %cleanup, %if.else, %entry
  %ret.6 = phi i64 [ %ret.0, %cleanup ], [ -19, %entry ], [ -22, %if.else ], [ %ret.2, %for.cond ], [ %ret.2, %land.rhs ], [ %ret.5, %LeafBlock3 ]
  %dev107 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev107)
  br label %cleanup108

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock
  br label %cleanup108

cleanup108:                                       ; preds = %NewDefault, %err
  %retval.0 = phi i64 [ %ret.6, %err ], [ undef, %NewDefault ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !43
  %1 = bitcast i8* %0 to %struct.dev_state*
  %wait1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 6
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %wait1, %struct.poll_table_struct* %wait)
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 8
  %2 = load i32, i32* %f_mode, align 4, !tbaa !63
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 5
  %call = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool2 = icmp ne i32 %call, 0
  %or = or i32 0, 260
  %.or = select i1 %tobool2, i32 0, i32 %or
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %mask.0 = phi i32 [ 0, %entry ], [ %.or, %land.lhs.true ]
  %call3 = call i32 @connected(%struct.dev_state* %1)
  %tobool4 = icmp ne i32 %call3, 0
  %or6 = or i32 %mask.0, 24
  %mask.0.or6 = select i1 %tobool4, i32 %mask.0, i32 %or6
  ret i32 %mask.0.or6
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #1 {
entry:
  %0 = inttoptr i64 %arg to i8*
  %call = call i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %0)
  %conv = trunc i64 %call to i32
  %conv1 = sext i32 %conv to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_compat_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #1 {
entry:
  %conv = trunc i64 %arg to i32
  %call = call i8* @compat_ptr(i32 %conv)
  %call1 = call i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %call)
  %conv2 = trunc i64 %call1 to i32
  %conv3 = sext i32 %conv2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_open(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %.compoundliteral = alloca %struct.raw_spinlock, align 2
  %call = call i8* @kmalloc(i64 144, i32 208)
  %0 = bitcast i8* %call to %struct.dev_state*
  %tobool = icmp ne %struct.dev_state* %0, null
  br i1 %tobool, label %if.end, label %out_free_ps

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @usbfs_mutex)
  %call1 = call i32 @imajor(%struct.inode* %inode)
  %cmp = icmp eq i32 %call1, 189
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %1 = load i32, i32* %i_rdev, align 4, !tbaa !64
  %call3 = call %struct.usb_device* @usbdev_lookup_by_devt(i32 %1)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %dev.0 = phi %struct.usb_device* [ %call3, %if.then2 ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @usbfs_mutex)
  %tobool5 = icmp ne %struct.usb_device* %dev.0, null
  br i1 %tobool5, label %if.end7, label %out_free_ps

if.end7:                                          ; preds = %if.end4
  %dev8 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev8)
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 3
  %2 = load i32, i32* %state, align 8, !tbaa !72
  %cmp9 = icmp eq i32 %2, 0
  br i1 %cmp9, label %out_unlock_device, label %if.end11

if.end11:                                         ; preds = %if.end7
  %call12 = call i32 @usb_autoresume_device(%struct.usb_device* %dev.0)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %out_unlock_device, label %if.end15

if.end15:                                         ; preds = %if.end11
  %dev16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 1
  store %struct.usb_device* %dev.0, %struct.usb_device** %dev16, align 8, !tbaa !44
  %file17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 2
  store %struct.file* %file, %struct.file** %file17, align 8, !tbaa !73
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %call18 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %lock20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %3 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock20, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %3 to %struct.raw_spinlock*
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %.compoundliteral, i32 0, i32 0
  %4 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %raw_lock, i32 0, i32 0
  %head_tail = bitcast %union.anon.1* %4 to i16*
  store i16 0, i16* %head_tail, align 2, !tbaa !74
  %5 = bitcast %struct.raw_spinlock* %rlock to i8*
  %6 = bitcast %struct.raw_spinlock* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 2, i32 2, i1 false), !tbaa.struct !75
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 0
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  call void @INIT_LIST_HEAD(%struct.list_head* %async_pending)
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 5
  call void @INIT_LIST_HEAD(%struct.list_head* %async_completed)
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 6
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %wait, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.53, i32 0, i32 0), %struct.lock_class_key* @usbdev_open.__key)
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 7
  store i32 0, i32* %discsignr, align 8, !tbaa !77
  %call26 = call %struct.task_struct* @get_current()
  %call27 = call %struct.pid* @task_pid(%struct.task_struct* %call26)
  %call28 = call %struct.pid* @get_pid(%struct.pid* %call27)
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 8
  store %struct.pid* %call28, %struct.pid** %disc_pid, align 8, !tbaa !78
  %call32 = call %struct.task_struct* @get_current()
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call32, i32 0, i32 63
  %7 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !79
  %call33 = call %struct.cred* @get_cred(%struct.cred* %7)
  %cred34 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 9
  store %struct.cred* %call33, %struct.cred** %cred34, align 8, !tbaa !106
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 10
  store i8* null, i8** %disccontext, align 8, !tbaa !107
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 11
  store i64 0, i64* %ifclaimed, align 8, !tbaa !108
  %call35 = call %struct.task_struct* @get_current()
  %secid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 12
  call void @security_task_getsecid(%struct.task_struct* %call35, i32* %secid)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !109
  %list36 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 0
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 27
  call void @list_add_tail(%struct.list_head* %list36, %struct.list_head* %filelist)
  %8 = bitcast %struct.dev_state* %0 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %8, i8** %private_data, align 8, !tbaa !43
  %dev37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev37)
  %9 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool39 = trunc i8 %9 to i1
  br i1 %tobool39, label %if.then40, label %cleanup

if.then40:                                        ; preds = %if.end15
  %dev41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  %call42 = call %struct.task_struct* @get_current()
  %call43 = call i32 @task_pid_nr(%struct.task_struct* %call42)
  %call44 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call44, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %call45 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev41, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.54, i32 0, i32 0), i32 %call43, i8* %arraydecay)
  br label %cleanup

out_unlock_device:                                ; preds = %if.end11, %if.end7
  %ret.0 = phi i32 [ -19, %if.end7 ], [ %call12, %if.end11 ]
  %dev49 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev.0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev49)
  call void @usb_put_dev(%struct.usb_device* %dev.0)
  br label %out_free_ps

out_free_ps:                                      ; preds = %if.end4, %entry, %out_unlock_device
  %ret.1 = phi i32 [ %ret.0, %out_unlock_device ], [ -12, %entry ], [ -19, %if.end4 ]
  %10 = bitcast %struct.dev_state* %0 to i8*
  call void @kfree(i8* %10)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then40, %out_free_ps
  %retval.0 = phi i32 [ %ret.1, %out_free_ps ], [ %call12, %if.then40 ], [ %call12, %if.end15 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_release(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !43
  %1 = bitcast i8* %0 to %struct.dev_state*
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  call void @usb_hub_release_all_ports(%struct.usb_device* %2, %struct.dev_state* %1)
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %ifnum.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 11
  %3 = load i64, i64* %ifclaimed, align 8, !tbaa !108
  %tobool = icmp ne i64 %3, 0
  %conv = zext i32 %ifnum.0 to i64
  %cmp = icmp ult i64 %conv, 64
  %4 = select i1 %tobool, i1 %cmp, i1 false
  br i1 %4, label %cond.false, label %for.end

cond.false:                                       ; preds = %for.cond
  %ifclaimed6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 11
  %call7 = call i32 @variable_test_bit(i32 %ifnum.0, i64* %ifclaimed6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then, label %for.inc

if.then:                                          ; preds = %cond.false
  %call9 = call i32 @releaseintf(%struct.dev_state* %1, i32 %ifnum.0)
  br label %for.inc

for.inc:                                          ; preds = %cond.false, %if.then
  %inc = add i32 %ifnum.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @destroy_all_async(%struct.dev_state* %1)
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev10)
  call void @usb_put_dev(%struct.usb_device* %2)
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 8
  %5 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !78
  call void @put_pid(%struct.pid* %5)
  %cred = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 9
  %6 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !106
  call void @put_cred(%struct.cred* %6)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %call13 = call %struct.async* @async_getcompleted(%struct.dev_state* %1)
  %tobool12 = icmp ne %struct.async* %call13, null
  br i1 %tobool12, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @free_async(%struct.async* %call13)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %7 = bitcast %struct.dev_state* %1 to i8*
  call void @kfree(i8* %7)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @usb_devio_init() #1 section ".init.text" {
entry:
  %call = call i32 @register_chrdev_region(i32 198180864, i32 8192, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.1, i32 0, i32 0))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.2, i32 0, i32 0))
  br label %out

if.end:                                           ; preds = %entry
  call void @cdev_init(%struct.cdev* @usb_device_cdev, %struct.file_operations* @usbdev_file_operations)
  %call3 = call i32 @cdev_add(%struct.cdev* @usb_device_cdev, i32 198180864, i32 8192)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.3, i32 0, i32 0), i32 189)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  br label %out

if.end7:                                          ; preds = %if.end
  call void @usb_register_notify(%struct.notifier_block* @usbdev_nb)
  br label %out

out:                                              ; preds = %if.then5, %if.end7, %if.then
  %retval1.0 = phi i32 [ %call, %if.then ], [ %call3, %if.then5 ], [ %call3, %if.end7 ]
  ret i32 %retval1.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

declare i32 @register_chrdev_region(i32, i32, i8*) #3

declare i32 @printk(i8*, ...) #3

declare void @cdev_init(%struct.cdev*, %struct.file_operations*) #3

declare i32 @cdev_add(%struct.cdev*, i32, i32) #3

declare void @usb_register_notify(%struct.notifier_block*) #3

declare void @unregister_chrdev_region(i32, i32) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define void @usb_devio_cleanup() #1 {
entry:
  call void @usb_unregister_notify(%struct.notifier_block* @usbdev_nb)
  call void @cdev_del(%struct.cdev* @usb_device_cdev)
  call void @unregister_chrdev_region(i32 198180864, i32 8192)
  ret void
}

declare void @usb_unregister_notify(%struct.notifier_block*) #3

declare void @cdev_del(%struct.cdev*) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #4 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #0 {
entry:
  %call = call i64 @native_save_fl()
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #0 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i8* @__kmalloc(i64, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @native_save_fl() #0 {
entry:
  %flags = alloca i64, align 8
  %0 = bitcast i64* %flags to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  call void asm sideeffect "# __raw_save_flags\0A\09pushf ; pop $0", "=*rm,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags) #7, !srcloc !112
  %1 = load i64, i64* %flags, align 8, !tbaa !113
  %2 = bitcast i64* %flags to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmem_cache_zalloc(%struct.kmem_cache* %k, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmem_cache_alloc(%struct.kmem_cache* %k, i32 %or)
  ret i8* %call
}

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #4 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !114
  ret %struct.task_struct* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface* %intf) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

; Function Attrs: alwaysinline nounwind uwtable
define internal void @clear_bit(i32 %nr, i64* %addr) #4 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !115
  ret void
}

declare i32 @dev_warn(%struct.device*, i8*, ...) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %data) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async_on_interface(%struct.dev_state* %ps, i32 %ifnum) #1 {
entry:
  %hitlist = alloca %struct.list_head, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast %struct.list_head* %hitlist to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  call void @INIT_LIST_HEAD(%struct.list_head* %hitlist)
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_pending, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %.sink = phi %struct.list_head* [ %6, %for.inc ], [ %5, %entry ]
  %p.0 = phi %struct.list_head* [ %5, %entry ], [ %6, %for.inc ]
  %next13 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next13, align 8, !tbaa !116
  %async_pending6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp7 = icmp ne %struct.list_head* %p.0, %async_pending6
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = bitcast %struct.list_head* %p.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr to %struct.async*
  %ifnum10 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 5
  %9 = load i32, i32* %ifnum10, align 4, !tbaa !117
  %cmp11 = icmp eq i32 %ifnum, %9
  br i1 %cmp11, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_move_tail(%struct.list_head* %p.0, %struct.list_head* %hitlist)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %lock14 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock14, i64 %call2)
  call void @destroy_async(%struct.dev_state* %ps, %struct.list_head* %hitlist)
  %10 = bitcast %struct.list_head* %hitlist to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %10) #7
  ret void
}

declare i8* @dev_get_drvdata(%struct.device*) #3

declare i32 @dev_set_drvdata(%struct.device*, i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !119
  ret void
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_move_tail(%struct.list_head* %list, %struct.list_head* %head) #0 {
entry:
  call void @__list_del_entry(%struct.list_head* %list)
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @destroy_async(%struct.dev_state* %ps, %struct.list_head* %list) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy12 = alloca i64, align 8
  %__dummy213 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %lock17 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call18 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock17)
  %call19 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call18)
  %call5 = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 8
  %7 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !120
  %call8 = call %struct.urb* @usb_get_urb(%struct.urb* %7)
  %lock9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock9, i64 %call19)
  call void @usb_kill_urb(%struct.urb* %7)
  call void @usb_free_urb(%struct.urb* %7)
  %8 = bitcast i64* %__dummy12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #7
  %9 = bitcast i64* %__dummy213 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #7
  %cmp14 = icmp eq i64* %__dummy12, %__dummy213
  %conv15 = zext i1 %cmp14 to i32
  %10 = bitcast i64* %__dummy213 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %11 = bitcast i64* %__dummy12 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %lock24 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock24, i64 %call19)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #0 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !119
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #0 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !119
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !119
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !119
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !116
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !119
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %new, %struct.list_head** %next4, align 8, !tbaa !116
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !116
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #0 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

declare %struct.urb* @usb_get_urb(%struct.urb*) #3

declare void @usb_kill_urb(%struct.urb*) #3

declare void @usb_free_urb(%struct.urb*) #3

declare void @mutex_lock(%struct.mutex*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #0 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !121
  ret %struct.inode* %0
}

declare void @mutex_unlock(%struct.mutex*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_lock(%struct.device* %dev) #0 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_lock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @connected(%struct.dev_state* %ps) #1 {
entry:
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 0
  %call = call i32 @list_empty(%struct.list_head* %list)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !72
  %cmp = icmp ne i32 %1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

declare i8* @__memcpy(i8*, i8*, i64) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @copy_to_user(i8* %dst, i8* %src, i32 %size) #4 {
entry:
  call void @might_fault()
  %call = call i64 @_copy_to_user(i8* %dst, i8* %src, i32 %size)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @device_unlock(%struct.device* %dev) #0 {
entry:
  %mutex = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 5
  call void @mutex_unlock(%struct.mutex* %mutex)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @might_fault() #0 {
entry:
  %call = call i32 @_cond_resched()
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #3

declare i32 @_cond_resched() #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #0 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !122
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !122
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @usbdev_do_ioctl(%struct.file* %file, i32 %cmd, i8* %p) #1 {
entry:
  %coerce = alloca %struct.timespec, align 8
  %coerce31 = alloca %struct.timespec, align 8
  %coerce47 = alloca %struct.timespec, align 8
  %coerce73 = alloca %struct.timespec, align 8
  %coerce129 = alloca %struct.timespec, align 8
  %coerce145 = alloca %struct.timespec, align 8
  %coerce161 = alloca %struct.timespec, align 8
  %coerce187 = alloca %struct.timespec, align 8
  %coerce318 = alloca %struct.timespec, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !43
  %1 = bitcast i8* %0 to %struct.dev_state*
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %1, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %f_mode = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 8
  %3 = load i32, i32* %f_mode, align 4, !tbaa !63
  %and = and i32 %3, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev2)
  %call3 = call i32 @connected(%struct.dev_state* %1)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %dev6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev6)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  br label %NodeBlock95

NodeBlock95:                                      ; preds = %if.end7
  %Pivot96 = icmp slt i32 %cmd, -1072933614
  br i1 %Pivot96, label %NodeBlock43, label %NodeBlock93

NodeBlock93:                                      ; preds = %NodeBlock95
  %Pivot94 = icmp slt i32 %cmd, 21780
  br i1 %Pivot94, label %NodeBlock69, label %NodeBlock91

NodeBlock91:                                      ; preds = %NodeBlock93
  %Pivot92 = icmp slt i32 %cmd, 1074287884
  br i1 %Pivot92, label %NodeBlock77, label %NodeBlock89

NodeBlock89:                                      ; preds = %NodeBlock91
  %Pivot90 = icmp slt i32 %cmd, 1074287889
  br i1 %Pivot90, label %NodeBlock81, label %NodeBlock87

NodeBlock87:                                      ; preds = %NodeBlock89
  %Pivot88 = icmp slt i32 %cmd, 1090802952
  br i1 %Pivot88, label %LeafBlock83, label %LeafBlock85

LeafBlock85:                                      ; preds = %NodeBlock87
  %SwitchLeaf86 = icmp eq i32 %cmd, 1090802952
  br i1 %SwitchLeaf86, label %do.body76, label %NewDefault

LeafBlock83:                                      ; preds = %NodeBlock87
  %SwitchLeaf84 = icmp eq i32 %cmd, 1074287889
  br i1 %SwitchLeaf84, label %do.body86, label %NewDefault

NodeBlock81:                                      ; preds = %NodeBlock89
  %Pivot82 = icmp slt i32 %cmd, 1074287885
  br i1 %Pivot82, label %do.body231, label %LeafBlock79

LeafBlock79:                                      ; preds = %NodeBlock81
  %SwitchLeaf80 = icmp eq i32 %cmd, 1074287885
  br i1 %SwitchLeaf80, label %do.body241, label %NewDefault

NodeBlock77:                                      ; preds = %NodeBlock91
  %Pivot78 = icmp slt i32 %cmd, 1074025740
  br i1 %Pivot78, label %LeafBlock71, label %NodeBlock75

NodeBlock75:                                      ; preds = %NodeBlock77
  %Pivot76 = icmp slt i32 %cmd, 1074025741
  br i1 %Pivot76, label %do.body190, label %LeafBlock73

LeafBlock73:                                      ; preds = %NodeBlock75
  %SwitchLeaf74 = icmp eq i32 %cmd, 1074025741
  br i1 %SwitchLeaf74, label %do.body200, label %NewDefault

LeafBlock71:                                      ; preds = %NodeBlock77
  %SwitchLeaf72 = icmp eq i32 %cmd, 21780
  br i1 %SwitchLeaf72, label %do.body50, label %NewDefault

NodeBlock69:                                      ; preds = %NodeBlock93
  %Pivot70 = icmp slt i32 %cmd, -1072671470
  br i1 %Pivot70, label %NodeBlock53, label %NodeBlock67

NodeBlock67:                                      ; preds = %NodeBlock69
  %Pivot68 = icmp slt i32 %cmd, -1072147198
  br i1 %Pivot68, label %NodeBlock59, label %NodeBlock65

NodeBlock65:                                      ; preds = %NodeBlock67
  %Pivot66 = icmp slt i32 %cmd, 21771
  br i1 %Pivot66, label %LeafBlock61, label %LeafBlock63

LeafBlock63:                                      ; preds = %NodeBlock65
  %SwitchLeaf64 = icmp eq i32 %cmd, 21771
  br i1 %SwitchLeaf64, label %do.body221, label %NewDefault

LeafBlock61:                                      ; preds = %NodeBlock65
  %SwitchLeaf62 = icmp eq i32 %cmd, -1072147198
  br i1 %SwitchLeaf62, label %do.body18, label %NewDefault

NodeBlock59:                                      ; preds = %NodeBlock67
  %Pivot60 = icmp slt i32 %cmd, -1072147200
  br i1 %Pivot60, label %LeafBlock55, label %LeafBlock57

LeafBlock57:                                      ; preds = %NodeBlock59
  %SwitchLeaf58 = icmp eq i32 %cmd, -1072147200
  br i1 %SwitchLeaf58, label %do.body, label %NewDefault

LeafBlock55:                                      ; preds = %NodeBlock59
  %SwitchLeaf56 = icmp eq i32 %cmd, -1072671470
  br i1 %SwitchLeaf56, label %do.body281, label %NewDefault

NodeBlock53:                                      ; preds = %NodeBlock69
  %Pivot54 = icmp slt i32 %cmd, -1072671488
  br i1 %Pivot54, label %LeafBlock45, label %NodeBlock51

NodeBlock51:                                      ; preds = %NodeBlock53
  %Pivot52 = icmp slt i32 %cmd, -1072671486
  br i1 %Pivot52, label %LeafBlock47, label %LeafBlock49

LeafBlock49:                                      ; preds = %NodeBlock51
  %SwitchLeaf50 = icmp eq i32 %cmd, -1072671486
  br i1 %SwitchLeaf50, label %do.body148, label %NewDefault

LeafBlock47:                                      ; preds = %NodeBlock51
  %SwitchLeaf48 = icmp eq i32 %cmd, -1072671488
  br i1 %SwitchLeaf48, label %do.body132, label %NewDefault

LeafBlock45:                                      ; preds = %NodeBlock53
  %SwitchLeaf46 = icmp eq i32 %cmd, -1072933614
  br i1 %SwitchLeaf46, label %do.body210, label %NewDefault

NodeBlock43:                                      ; preds = %NodeBlock95
  %Pivot44 = icmp slt i32 %cmd, -2147199718
  br i1 %Pivot44, label %NodeBlock15, label %NodeBlock41

NodeBlock41:                                      ; preds = %NodeBlock43
  %Pivot42 = icmp slt i32 %cmd, -2146413298
  br i1 %Pivot42, label %NodeBlock25, label %NodeBlock39

NodeBlock39:                                      ; preds = %NodeBlock41
  %Pivot40 = icmp slt i32 %cmd, -2143791862
  br i1 %Pivot40, label %NodeBlock31, label %NodeBlock37

NodeBlock37:                                      ; preds = %NodeBlock39
  %Pivot38 = icmp slt i32 %cmd, -2130160357
  br i1 %Pivot38, label %LeafBlock33, label %LeafBlock35

LeafBlock35:                                      ; preds = %NodeBlock37
  %SwitchLeaf36 = icmp eq i32 %cmd, -2130160357
  br i1 %SwitchLeaf36, label %sw.bb312, label %NewDefault

LeafBlock33:                                      ; preds = %NodeBlock37
  %SwitchLeaf34 = icmp eq i32 %cmd, -2143791862
  br i1 %SwitchLeaf34, label %do.body116, label %NewDefault

NodeBlock31:                                      ; preds = %NodeBlock39
  %Pivot32 = icmp slt i32 %cmd, -2144578294
  br i1 %Pivot32, label %LeafBlock27, label %LeafBlock29

LeafBlock29:                                      ; preds = %NodeBlock31
  %SwitchLeaf30 = icmp eq i32 %cmd, -2144578294
  br i1 %SwitchLeaf30, label %do.body174, label %NewDefault

LeafBlock27:                                      ; preds = %NodeBlock31
  %SwitchLeaf28 = icmp eq i32 %cmd, -2146413298
  br i1 %SwitchLeaf28, label %do.body251, label %NewDefault

NodeBlock25:                                      ; preds = %NodeBlock41
  %Pivot26 = icmp slt i32 %cmd, -2146937596
  br i1 %Pivot26, label %LeafBlock17, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %cmd, -2146937586
  br i1 %Pivot24, label %LeafBlock19, label %LeafBlock21

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %cmd, -2146937586
  br i1 %SwitchLeaf22, label %do.body164, label %NewDefault

LeafBlock19:                                      ; preds = %NodeBlock23
  %SwitchLeaf20 = icmp eq i32 %cmd, -2146937596
  br i1 %SwitchLeaf20, label %do.body96, label %NewDefault

LeafBlock17:                                      ; preds = %NodeBlock25
  %SwitchLeaf18 = icmp eq i32 %cmd, -2147199718
  br i1 %SwitchLeaf18, label %sw.bb310, label %NewDefault

NodeBlock15:                                      ; preds = %NodeBlock43
  %Pivot16 = icmp slt i32 %cmd, -2147199728
  br i1 %Pivot16, label %NodeBlock3, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %cmd, -2147199720
  br i1 %Pivot14, label %NodeBlock9, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %cmd, -2147199719
  br i1 %Pivot12, label %do.body291, label %do.body301

NodeBlock9:                                       ; preds = %NodeBlock13
  %Pivot10 = icmp slt i32 %cmd, -2147199723
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %cmd, -2147199723
  br i1 %SwitchLeaf8, label %do.body60, label %NewDefault

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %cmd, -2147199728
  br i1 %SwitchLeaf6, label %do.body271, label %NewDefault

NodeBlock3:                                       ; preds = %NodeBlock15
  %Pivot4 = icmp slt i32 %cmd, -2147199739
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, -2147199729
  br i1 %Pivot, label %LeafBlock1, label %do.body261

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, -2147199739
  br i1 %SwitchLeaf2, label %do.body106, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, -2147199741
  br i1 %SwitchLeaf, label %do.body34, label %NewDefault

do.body:                                          ; preds = %LeafBlock57
  %4 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool8 = trunc i8 %4 to i1
  br i1 %tobool8, label %if.then9, label %do.end

if.then9:                                         ; preds = %do.body
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call11 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev10, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then9, %do.body
  %call13 = call i32 @proc_control(%struct.dev_state* %1, i8* %p)
  %cmp = icmp sge i32 %call13, 0
  br i1 %cmp, label %if.then14, label %sw.epilog

if.then14:                                        ; preds = %do.end
  %i_mtime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call15 = call { i64, i64 } @current_kernel_time()
  %5 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %6 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call15, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call15, 1
  store i64 %9, i64* %8, align 8
  %10 = bitcast %struct.timespec* %i_mtime to i8*
  %11 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body18:                                        ; preds = %LeafBlock61
  %12 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool19 = trunc i8 %12 to i1
  br i1 %tobool19, label %if.then20, label %do.end25

if.then20:                                        ; preds = %do.body18
  %dev21 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call22 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev21, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end25

do.end25:                                         ; preds = %if.then20, %do.body18
  %call26 = call i32 @proc_bulk(%struct.dev_state* %1, i8* %p)
  %cmp27 = icmp sge i32 %call26, 0
  br i1 %cmp27, label %if.then28, label %sw.epilog

if.then28:                                        ; preds = %do.end25
  %i_mtime29 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call30 = call { i64, i64 } @current_kernel_time()
  %13 = bitcast %struct.timespec* %coerce31 to { i64, i64 }*
  %14 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = extractvalue { i64, i64 } %call30, 0
  store i64 %15, i64* %14, align 8
  %16 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = extractvalue { i64, i64 } %call30, 1
  store i64 %17, i64* %16, align 8
  %18 = bitcast %struct.timespec* %i_mtime29 to i8*
  %19 = bitcast %struct.timespec* %coerce31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body34:                                        ; preds = %LeafBlock
  %20 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool35 = trunc i8 %20 to i1
  br i1 %tobool35, label %if.then36, label %do.end41

if.then36:                                        ; preds = %do.body34
  %dev37 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call38 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev37, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end41

do.end41:                                         ; preds = %if.then36, %do.body34
  %call42 = call i32 @proc_resetep(%struct.dev_state* %1, i8* %p)
  %cmp43 = icmp sge i32 %call42, 0
  br i1 %cmp43, label %if.then44, label %sw.epilog

if.then44:                                        ; preds = %do.end41
  %i_mtime45 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call46 = call { i64, i64 } @current_kernel_time()
  %21 = bitcast %struct.timespec* %coerce47 to { i64, i64 }*
  %22 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 0
  %23 = extractvalue { i64, i64 } %call46, 0
  store i64 %23, i64* %22, align 8
  %24 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %21, i32 0, i32 1
  %25 = extractvalue { i64, i64 } %call46, 1
  store i64 %25, i64* %24, align 8
  %26 = bitcast %struct.timespec* %i_mtime45 to i8*
  %27 = bitcast %struct.timespec* %coerce47 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %27, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body50:                                        ; preds = %LeafBlock71
  %28 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool51 = trunc i8 %28 to i1
  br i1 %tobool51, label %if.then52, label %do.end57

if.then52:                                        ; preds = %do.body50
  %dev53 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call54 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev53, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end57

do.end57:                                         ; preds = %if.then52, %do.body50
  %call58 = call i32 @proc_resetdevice(%struct.dev_state* %1)
  br label %sw.epilog

do.body60:                                        ; preds = %LeafBlock7
  %29 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool61 = trunc i8 %29 to i1
  br i1 %tobool61, label %if.then62, label %do.end67

if.then62:                                        ; preds = %do.body60
  %dev63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call64 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev63, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end67

do.end67:                                         ; preds = %if.then62, %do.body60
  %call68 = call i32 @proc_clearhalt(%struct.dev_state* %1, i8* %p)
  %cmp69 = icmp sge i32 %call68, 0
  br i1 %cmp69, label %if.then70, label %sw.epilog

if.then70:                                        ; preds = %do.end67
  %i_mtime71 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call72 = call { i64, i64 } @current_kernel_time()
  %30 = bitcast %struct.timespec* %coerce73 to { i64, i64 }*
  %31 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 0
  %32 = extractvalue { i64, i64 } %call72, 0
  store i64 %32, i64* %31, align 8
  %33 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %30, i32 0, i32 1
  %34 = extractvalue { i64, i64 } %call72, 1
  store i64 %34, i64* %33, align 8
  %35 = bitcast %struct.timespec* %i_mtime71 to i8*
  %36 = bitcast %struct.timespec* %coerce73 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %35, i8* %36, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body76:                                        ; preds = %LeafBlock85
  %37 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool77 = trunc i8 %37 to i1
  br i1 %tobool77, label %if.then78, label %do.end83

if.then78:                                        ; preds = %do.body76
  %dev79 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call80 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev79, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end83

do.end83:                                         ; preds = %if.then78, %do.body76
  %call84 = call i32 @proc_getdriver(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body86:                                        ; preds = %LeafBlock83
  %38 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool87 = trunc i8 %38 to i1
  br i1 %tobool87, label %if.then88, label %do.end93

if.then88:                                        ; preds = %do.body86
  %dev89 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call90 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev89, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end93

do.end93:                                         ; preds = %if.then88, %do.body86
  %call94 = call i32 @proc_connectinfo(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body96:                                        ; preds = %LeafBlock19
  %39 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool97 = trunc i8 %39 to i1
  br i1 %tobool97, label %if.then98, label %do.end103

if.then98:                                        ; preds = %do.body96
  %dev99 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call100 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev99, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end103

do.end103:                                        ; preds = %if.then98, %do.body96
  %call104 = call i32 @proc_setintf(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body106:                                       ; preds = %LeafBlock1
  %40 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool107 = trunc i8 %40 to i1
  br i1 %tobool107, label %if.then108, label %do.end113

if.then108:                                       ; preds = %do.body106
  %dev109 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call110 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev109, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end113

do.end113:                                        ; preds = %if.then108, %do.body106
  %call114 = call i32 @proc_setconfig(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body116:                                       ; preds = %LeafBlock33
  %41 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool117 = trunc i8 %41 to i1
  br i1 %tobool117, label %if.then118, label %do.end123

if.then118:                                       ; preds = %do.body116
  %dev119 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call120 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev119, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end123

do.end123:                                        ; preds = %if.then118, %do.body116
  %call124 = call i32 @proc_submiturb(%struct.dev_state* %1, i8* %p)
  %cmp125 = icmp sge i32 %call124, 0
  br i1 %cmp125, label %if.then126, label %sw.epilog

if.then126:                                       ; preds = %do.end123
  %i_mtime127 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call128 = call { i64, i64 } @current_kernel_time()
  %42 = bitcast %struct.timespec* %coerce129 to { i64, i64 }*
  %43 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 0
  %44 = extractvalue { i64, i64 } %call128, 0
  store i64 %44, i64* %43, align 8
  %45 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %42, i32 0, i32 1
  %46 = extractvalue { i64, i64 } %call128, 1
  store i64 %46, i64* %45, align 8
  %47 = bitcast %struct.timespec* %i_mtime127 to i8*
  %48 = bitcast %struct.timespec* %coerce129 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %47, i8* %48, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body132:                                       ; preds = %LeafBlock47
  %49 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool133 = trunc i8 %49 to i1
  br i1 %tobool133, label %if.then134, label %do.end139

if.then134:                                       ; preds = %do.body132
  %dev135 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call136 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev135, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end139

do.end139:                                        ; preds = %if.then134, %do.body132
  %50 = bitcast i8* %p to %struct.usbdevfs_ctrltransfer32*
  %call140 = call i32 @proc_control_compat(%struct.dev_state* %1, %struct.usbdevfs_ctrltransfer32* %50)
  %cmp141 = icmp sge i32 %call140, 0
  br i1 %cmp141, label %if.then142, label %sw.epilog

if.then142:                                       ; preds = %do.end139
  %i_mtime143 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call144 = call { i64, i64 } @current_kernel_time()
  %51 = bitcast %struct.timespec* %coerce145 to { i64, i64 }*
  %52 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 0
  %53 = extractvalue { i64, i64 } %call144, 0
  store i64 %53, i64* %52, align 8
  %54 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %51, i32 0, i32 1
  %55 = extractvalue { i64, i64 } %call144, 1
  store i64 %55, i64* %54, align 8
  %56 = bitcast %struct.timespec* %i_mtime143 to i8*
  %57 = bitcast %struct.timespec* %coerce145 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %56, i8* %57, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body148:                                       ; preds = %LeafBlock49
  %58 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool149 = trunc i8 %58 to i1
  br i1 %tobool149, label %if.then150, label %do.end155

if.then150:                                       ; preds = %do.body148
  %dev151 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call152 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev151, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.16, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end155

do.end155:                                        ; preds = %if.then150, %do.body148
  %59 = bitcast i8* %p to %struct.usbdevfs_bulktransfer32*
  %call156 = call i32 @proc_bulk_compat(%struct.dev_state* %1, %struct.usbdevfs_bulktransfer32* %59)
  %cmp157 = icmp sge i32 %call156, 0
  br i1 %cmp157, label %if.then158, label %sw.epilog

if.then158:                                       ; preds = %do.end155
  %i_mtime159 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call160 = call { i64, i64 } @current_kernel_time()
  %60 = bitcast %struct.timespec* %coerce161 to { i64, i64 }*
  %61 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %60, i32 0, i32 0
  %62 = extractvalue { i64, i64 } %call160, 0
  store i64 %62, i64* %61, align 8
  %63 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %60, i32 0, i32 1
  %64 = extractvalue { i64, i64 } %call160, 1
  store i64 %64, i64* %63, align 8
  %65 = bitcast %struct.timespec* %i_mtime159 to i8*
  %66 = bitcast %struct.timespec* %coerce161 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %65, i8* %66, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body164:                                       ; preds = %LeafBlock21
  %67 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool165 = trunc i8 %67 to i1
  br i1 %tobool165, label %if.then166, label %do.end171

if.then166:                                       ; preds = %do.body164
  %dev167 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call168 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev167, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end171

do.end171:                                        ; preds = %if.then166, %do.body164
  %call172 = call i32 @proc_disconnectsignal_compat(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body174:                                       ; preds = %LeafBlock29
  %68 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool175 = trunc i8 %68 to i1
  br i1 %tobool175, label %if.then176, label %do.end181

if.then176:                                       ; preds = %do.body174
  %dev177 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call178 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev177, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.18, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end181

do.end181:                                        ; preds = %if.then176, %do.body174
  %call182 = call i32 @proc_submiturb_compat(%struct.dev_state* %1, i8* %p)
  %cmp183 = icmp sge i32 %call182, 0
  br i1 %cmp183, label %if.then184, label %sw.epilog

if.then184:                                       ; preds = %do.end181
  %i_mtime185 = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 16
  %call186 = call { i64, i64 } @current_kernel_time()
  %69 = bitcast %struct.timespec* %coerce187 to { i64, i64 }*
  %70 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 0
  %71 = extractvalue { i64, i64 } %call186, 0
  store i64 %71, i64* %70, align 8
  %72 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %69, i32 0, i32 1
  %73 = extractvalue { i64, i64 } %call186, 1
  store i64 %73, i64* %72, align 8
  %74 = bitcast %struct.timespec* %i_mtime185 to i8*
  %75 = bitcast %struct.timespec* %coerce187 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %74, i8* %75, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %sw.epilog

do.body190:                                       ; preds = %NodeBlock75
  %76 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool191 = trunc i8 %76 to i1
  br i1 %tobool191, label %if.then192, label %do.end197

if.then192:                                       ; preds = %do.body190
  %dev193 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call194 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev193, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end197

do.end197:                                        ; preds = %if.then192, %do.body190
  %call198 = call i32 @proc_reapurb_compat(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body200:                                       ; preds = %LeafBlock73
  %77 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool201 = trunc i8 %77 to i1
  br i1 %tobool201, label %if.then202, label %do.end207

if.then202:                                       ; preds = %do.body200
  %dev203 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call204 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev203, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.20, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end207

do.end207:                                        ; preds = %if.then202, %do.body200
  %call208 = call i32 @proc_reapurbnonblock_compat(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body210:                                       ; preds = %LeafBlock45
  %78 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool211 = trunc i8 %78 to i1
  br i1 %tobool211, label %if.then212, label %do.end217

if.then212:                                       ; preds = %do.body210
  %dev213 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call214 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev213, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.21, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end217

do.end217:                                        ; preds = %if.then212, %do.body210
  %call218 = call i32 @ptr_to_compat(i8* %p)
  %call219 = call i32 @proc_ioctl_compat(%struct.dev_state* %1, i32 %call218)
  br label %sw.epilog

do.body221:                                       ; preds = %LeafBlock63
  %79 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool222 = trunc i8 %79 to i1
  br i1 %tobool222, label %if.then223, label %do.end228

if.then223:                                       ; preds = %do.body221
  %dev224 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call225 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev224, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.22, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end228

do.end228:                                        ; preds = %if.then223, %do.body221
  %call229 = call i32 @proc_unlinkurb(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body231:                                       ; preds = %NodeBlock81
  %80 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool232 = trunc i8 %80 to i1
  br i1 %tobool232, label %if.then233, label %do.end238

if.then233:                                       ; preds = %do.body231
  %dev234 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call235 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev234, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end238

do.end238:                                        ; preds = %if.then233, %do.body231
  %call239 = call i32 @proc_reapurb(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body241:                                       ; preds = %LeafBlock79
  %81 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool242 = trunc i8 %81 to i1
  br i1 %tobool242, label %if.then243, label %do.end248

if.then243:                                       ; preds = %do.body241
  %dev244 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call245 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev244, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end248

do.end248:                                        ; preds = %if.then243, %do.body241
  %call249 = call i32 @proc_reapurbnonblock(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body251:                                       ; preds = %LeafBlock27
  %82 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool252 = trunc i8 %82 to i1
  br i1 %tobool252, label %if.then253, label %do.end258

if.then253:                                       ; preds = %do.body251
  %dev254 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call255 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev254, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.25, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end258

do.end258:                                        ; preds = %if.then253, %do.body251
  %call259 = call i32 @proc_disconnectsignal(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body261:                                       ; preds = %NodeBlock
  %83 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool262 = trunc i8 %83 to i1
  br i1 %tobool262, label %if.then263, label %do.end268

if.then263:                                       ; preds = %do.body261
  %dev264 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call265 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev264, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end268

do.end268:                                        ; preds = %if.then263, %do.body261
  %call269 = call i32 @proc_claiminterface(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body271:                                       ; preds = %LeafBlock5
  %84 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool272 = trunc i8 %84 to i1
  br i1 %tobool272, label %if.then273, label %do.end278

if.then273:                                       ; preds = %do.body271
  %dev274 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call275 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev274, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.27, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end278

do.end278:                                        ; preds = %if.then273, %do.body271
  %call279 = call i32 @proc_releaseinterface(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body281:                                       ; preds = %LeafBlock55
  %85 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool282 = trunc i8 %85 to i1
  br i1 %tobool282, label %if.then283, label %do.end288

if.then283:                                       ; preds = %do.body281
  %dev284 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call285 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev284, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end288

do.end288:                                        ; preds = %if.then283, %do.body281
  %call289 = call i32 @proc_ioctl_default(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body291:                                       ; preds = %NodeBlock11
  %86 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool292 = trunc i8 %86 to i1
  br i1 %tobool292, label %if.then293, label %do.end298

if.then293:                                       ; preds = %do.body291
  %dev294 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call295 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev294, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.29, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end298

do.end298:                                        ; preds = %if.then293, %do.body291
  %call299 = call i32 @proc_claim_port(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

do.body301:                                       ; preds = %NodeBlock11
  %87 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool302 = trunc i8 %87 to i1
  br i1 %tobool302, label %if.then303, label %do.end308

if.then303:                                       ; preds = %do.body301
  %dev304 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call305 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev304, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.30, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__func__.usbdev_do_ioctl, i32 0, i32 0))
  br label %do.end308

do.end308:                                        ; preds = %if.then303, %do.body301
  %call309 = call i32 @proc_release_port(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

sw.bb310:                                         ; preds = %LeafBlock17
  %call311 = call i32 @proc_get_capabilities(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

sw.bb312:                                         ; preds = %LeafBlock35
  %call313 = call i32 @proc_disconnect_claim(%struct.dev_state* %1, i8* %p)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock85, %LeafBlock83, %LeafBlock79, %LeafBlock73, %LeafBlock71, %LeafBlock63, %LeafBlock61, %LeafBlock57, %LeafBlock55, %LeafBlock49, %LeafBlock47, %LeafBlock45, %LeafBlock35, %LeafBlock33, %LeafBlock29, %LeafBlock27, %LeafBlock21, %LeafBlock19, %LeafBlock17, %LeafBlock7, %LeafBlock5, %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %do.end181, %if.then184, %do.end155, %if.then158, %do.end139, %if.then142, %do.end123, %if.then126, %do.end67, %if.then70, %do.end41, %if.then44, %do.end25, %if.then28, %do.end, %if.then14, %sw.bb312, %sw.bb310, %do.end308, %do.end298, %do.end288, %do.end278, %do.end268, %do.end258, %do.end248, %do.end238, %do.end228, %do.end217, %do.end207, %do.end197, %do.end171, %do.end113, %do.end103, %do.end93, %do.end83, %do.end57
  %ret.0 = phi i32 [ -25, %NewDefault ], [ %call313, %sw.bb312 ], [ %call311, %sw.bb310 ], [ %call309, %do.end308 ], [ %call299, %do.end298 ], [ %call289, %do.end288 ], [ %call279, %do.end278 ], [ %call269, %do.end268 ], [ %call259, %do.end258 ], [ %call249, %do.end248 ], [ %call239, %do.end238 ], [ %call229, %do.end228 ], [ %call219, %do.end217 ], [ %call208, %do.end207 ], [ %call198, %do.end197 ], [ %call172, %do.end171 ], [ %call114, %do.end113 ], [ %call104, %do.end103 ], [ %call94, %do.end93 ], [ %call84, %do.end83 ], [ %call58, %do.end57 ], [ %call13, %if.then14 ], [ %call13, %do.end ], [ %call26, %if.then28 ], [ %call26, %do.end25 ], [ %call42, %if.then44 ], [ %call42, %do.end41 ], [ %call68, %if.then70 ], [ %call68, %do.end67 ], [ %call124, %if.then126 ], [ %call124, %do.end123 ], [ %call140, %if.then142 ], [ %call140, %do.end139 ], [ %call156, %if.then158 ], [ %call156, %do.end155 ], [ %call182, %if.then184 ], [ %call182, %do.end181 ]
  %dev314 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev314)
  %cmp315 = icmp sge i32 %ret.0, 0
  br i1 %cmp315, label %if.then316, label %if.end319

if.then316:                                       ; preds = %sw.epilog
  %i_atime = getelementptr inbounds %struct.inode, %struct.inode* %call, i32 0, i32 15
  %call317 = call { i64, i64 } @current_kernel_time()
  %88 = bitcast %struct.timespec* %coerce318 to { i64, i64 }*
  %89 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 0
  %90 = extractvalue { i64, i64 } %call317, 0
  store i64 %90, i64* %89, align 8
  %91 = getelementptr inbounds { i64, i64 }, { i64, i64 }* %88, i32 0, i32 1
  %92 = extractvalue { i64, i64 } %call317, 1
  store i64 %92, i64* %91, align 8
  %93 = bitcast %struct.timespec* %i_atime to i8*
  %94 = bitcast %struct.timespec* %coerce318 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %93, i8* %94, i64 16, i32 8, i1 false), !tbaa.struct !124
  br label %if.end319

if.end319:                                        ; preds = %if.then316, %sw.epilog
  %conv = sext i32 %ret.0 to i64
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end319, %if.then5
  %retval.0 = phi i64 [ %conv, %if.end319 ], [ -19, %if.then5 ], [ -1, %entry ]
  ret i64 %retval.0
}

declare i32 @_dev_info(%struct.device*, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal i32 @proc_control(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %ctrl = alloca %struct.usbdevfs_ctrltransfer, align 8
  %_max1 = alloca i32, align 4
  %_max2 = alloca i32, align 4
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %_max183 = alloca i32, align 4
  %_max284 = alloca i32, align 4
  %_max1134 = alloca i32, align 4
  %_max2135 = alloca i32, align 4
  %_min1145 = alloca i32, align 4
  %_min2146 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %1 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %1) #7
  %2 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  %call = call i64 @copy_from_user(i8* %2, i8* %arg, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %bRequestType = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %3 = load i8, i8* %bRequestType, align 8, !tbaa !125
  %conv = zext i8 %3 to i32
  %bRequest = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %4 = load i8, i8* %bRequest, align 1, !tbaa !127
  %conv2 = zext i8 %4 to i32
  %wIndex = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %5 = load i16, i16* %wIndex, align 4, !tbaa !128
  %conv3 = zext i16 %5 to i32
  %call4 = call i32 @check_ctrlrecip(%struct.dev_state* %ps, i32 %conv, i32 %conv2, i32 %conv3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end
  %wLength8 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %6 = load i16, i16* %wLength8, align 2, !tbaa !129
  %conv9 = zext i16 %6 to i32
  %conv10 = zext i32 %conv9 to i64
  %cmp = icmp ugt i64 %conv10, 4096
  br i1 %cmp, label %cleanup, label %if.end13

if.end13:                                         ; preds = %if.end7
  %call14 = call i32 @usbfs_increase_memory_usage(i32 4296)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end13
  %call18 = call i64 @__get_free_pages(i32 208, i32 0)
  %7 = inttoptr i64 %call18 to i8*
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %if.end21, label %done

if.end21:                                         ; preds = %if.end17
  %timeout = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 5
  %8 = load i32, i32* %timeout, align 8, !tbaa !130
  %9 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool22 = trunc i8 %9 to i1
  br i1 %tobool22, label %if.then23, label %do.end

if.then23:                                        ; preds = %if.end21
  %dev24 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %bRequestType25 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %10 = load i8, i8* %bRequestType25, align 8, !tbaa !125
  %conv26 = zext i8 %10 to i32
  %bRequest27 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %11 = load i8, i8* %bRequest27, align 1, !tbaa !127
  %conv28 = zext i8 %11 to i32
  %wValue = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %call29 = call zeroext i16 @__le16_to_cpup(i16* %wValue)
  %conv30 = zext i16 %call29 to i32
  %wIndex31 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %call32 = call zeroext i16 @__le16_to_cpup(i16* %wIndex31)
  %conv33 = zext i16 %call32 to i32
  %wLength34 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %call35 = call zeroext i16 @__le16_to_cpup(i16* %wLength34)
  %conv36 = zext i16 %call35 to i32
  %call37 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev24, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.31, i32 0, i32 0), i32 %conv26, i32 %conv28, i32 %conv30, i32 %conv33, i32 %conv36)
  br label %do.end

do.end:                                           ; preds = %if.then23, %if.end21
  %bRequestType39 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %12 = load i8, i8* %bRequestType39, align 8, !tbaa !125
  %conv40 = zext i8 %12 to i32
  %and = and i32 %conv40, 128
  %tobool41 = icmp ne i32 %and, 0
  %wLength43 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %13 = load i16, i16* %wLength43, align 2, !tbaa !129
  br i1 %tobool41, label %if.then42, label %if.else

if.then42:                                        ; preds = %do.end
  %conv44 = zext i16 %13 to i32
  %tobool45 = icmp ne i32 %conv44, 0
  br i1 %tobool45, label %land.lhs.true, label %if.end56

land.lhs.true:                                    ; preds = %if.then42
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %14 = load i8*, i8** %data, align 8, !tbaa !131
  %wLength46 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %15 = load i16, i16* %wLength46, align 2, !tbaa !129
  %conv47 = zext i16 %15 to i64
  %call48 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call48, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %16 = load i64, i64* %seg, align 8, !tbaa !132
  %17 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %14, i64 %conv47, i64 %16) #8, !srcloc !135
  %asmresult = extractvalue { i64, i64 } %17, 0
  %asmresult49 = extractvalue { i64, i64 } %17, 1
  %cmp50 = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp50, true
  %lnot52 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot52 to i32
  %conv53 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv53, i64 1)
  %tobool54 = icmp ne i64 %expval, 0
  br i1 %tobool54, label %if.end56, label %done

if.end56:                                         ; preds = %land.lhs.true, %if.then42
  %call57 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or = or i32 -2147483648, %call57
  %or58 = or i32 %or, 128
  %wLength59 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %18 = load i16, i16* %wLength59, align 2, !tbaa !129
  %conv60 = zext i16 %18 to i32
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or58, i32 %conv60, i32 %8, i32 0, i8* null, i32 0)
  %dev61 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev61)
  %bRequest62 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %19 = load i8, i8* %bRequest62, align 1, !tbaa !127
  %bRequestType63 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %20 = load i8, i8* %bRequestType63, align 8, !tbaa !125
  %wValue64 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %21 = load i16, i16* %wValue64, align 2, !tbaa !136
  %wIndex65 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %22 = load i16, i16* %wIndex65, align 4, !tbaa !128
  %wLength66 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %23 = load i16, i16* %wLength66, align 2, !tbaa !129
  %call67 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or58, i8 zeroext %19, i8 zeroext %20, i16 zeroext %21, i16 zeroext %22, i8* %7, i16 zeroext %23, i32 %8)
  %dev68 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev68)
  %24 = bitcast i32* %_max1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %24) #7
  store i32 %call67, i32* %_max1, align 4, !tbaa !62
  %25 = bitcast i32* %_max2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %25) #7
  store i32 0, i32* %_max2, align 4, !tbaa !62
  %cmp69 = icmp eq i32* %_max1, %_max2
  %conv70 = zext i1 %cmp69 to i32
  %26 = load i32, i32* %_max1, align 4, !tbaa !62
  %27 = load i32, i32* %_max2, align 4, !tbaa !62
  %cmp72 = icmp sgt i32 %26, %27
  %28 = load i32, i32* %_max1, align 4
  %29 = load i32, i32* %_max2, align 4
  %cond = select i1 %cmp72, i32 %28, i32 %29
  %30 = bitcast i32* %_max2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %30) #7
  %31 = bitcast i32* %_max1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %31) #7
  %32 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %32) #7
  store i32 %call67, i32* %_min1, align 4, !tbaa !62
  %33 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %33) #7
  store i32 0, i32* %_min2, align 4, !tbaa !62
  %cmp74 = icmp eq i32* %_min1, %_min2
  %conv75 = zext i1 %cmp74 to i32
  %34 = load i32, i32* %_min1, align 4, !tbaa !62
  %35 = load i32, i32* %_min2, align 4, !tbaa !62
  %cmp77 = icmp slt i32 %34, %35
  %36 = load i32, i32* %_min1, align 4
  %37 = load i32, i32* %_min2, align 4
  %cond82 = select i1 %cmp77, i32 %36, i32 %37
  %38 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %38) #7
  %39 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %39) #7
  %40 = bitcast i32* %_max183 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %40) #7
  store i32 %call67, i32* %_max183, align 4, !tbaa !62
  %41 = bitcast i32* %_max284 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %41) #7
  store i32 0, i32* %_max284, align 4, !tbaa !62
  %cmp85 = icmp eq i32* %_max183, %_max284
  %conv86 = zext i1 %cmp85 to i32
  %42 = load i32, i32* %_max183, align 4, !tbaa !62
  %43 = load i32, i32* %_max284, align 4, !tbaa !62
  %cmp88 = icmp sgt i32 %42, %43
  %44 = load i32, i32* %_max183, align 4
  %45 = load i32, i32* %_max284, align 4
  %cond93 = select i1 %cmp88, i32 %44, i32 %45
  %46 = bitcast i32* %_max284 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %46) #7
  %47 = bitcast i32* %_max183 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %47) #7
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or58, i32 %cond, i32 %cond82, i32 1, i8* %7, i32 %cond93)
  %cmp94 = icmp sgt i32 %call67, 0
  br i1 %cmp94, label %land.lhs.true96, label %if.end156

land.lhs.true96:                                  ; preds = %if.end56
  %wLength97 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %48 = load i16, i16* %wLength97, align 2, !tbaa !129
  %conv98 = zext i16 %48 to i32
  %tobool99 = icmp ne i32 %conv98, 0
  br i1 %tobool99, label %if.then100, label %if.end156

if.then100:                                       ; preds = %land.lhs.true96
  %data101 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %49 = load i8*, i8** %data101, align 8, !tbaa !131
  %call102 = call i32 @copy_to_user(i8* %49, i8* %7, i32 %call67)
  %tobool103 = icmp ne i32 %call102, 0
  br i1 %tobool103, label %done, label %if.end156

if.else:                                          ; preds = %do.end
  %tobool108 = icmp ne i16 %13, 0
  br i1 %tobool108, label %if.then109, label %if.end117

if.then109:                                       ; preds = %if.else
  %data110 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 6
  %50 = load i8*, i8** %data110, align 8, !tbaa !131
  %wLength111 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %51 = load i16, i16* %wLength111, align 2, !tbaa !129
  %conv112 = zext i16 %51 to i64
  %call113 = call i64 @copy_from_user(i8* %7, i8* %50, i64 %conv112)
  %tobool114 = icmp ne i64 %call113, 0
  br i1 %tobool114, label %done, label %if.end117

if.end117:                                        ; preds = %if.then109, %if.else
  %call118 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or119 = or i32 -2147483648, %call118
  %wLength120 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %52 = load i16, i16* %wLength120, align 2, !tbaa !129
  %conv121 = zext i16 %52 to i32
  %wLength122 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %53 = load i16, i16* %wLength122, align 2, !tbaa !129
  %conv123 = zext i16 %53 to i32
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or119, i32 %conv121, i32 %8, i32 0, i8* %7, i32 %conv123)
  %dev124 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev124)
  %call125 = call i32 @__create_pipe(%struct.usb_device* %0, i32 0)
  %or126 = or i32 -2147483648, %call125
  %bRequest127 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %54 = load i8, i8* %bRequest127, align 1, !tbaa !127
  %bRequestType128 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %55 = load i8, i8* %bRequestType128, align 8, !tbaa !125
  %wValue129 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 2
  %56 = load i16, i16* %wValue129, align 2, !tbaa !136
  %wIndex130 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 3
  %57 = load i16, i16* %wIndex130, align 4, !tbaa !128
  %wLength131 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %58 = load i16, i16* %wLength131, align 2, !tbaa !129
  %call132 = call i32 @usb_control_msg(%struct.usb_device* %0, i32 %or126, i8 zeroext %54, i8 zeroext %55, i16 zeroext %56, i16 zeroext %57, i8* %7, i16 zeroext %58, i32 %8)
  %dev133 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev133)
  %59 = bitcast i32* %_max1134 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %59) #7
  store i32 %call132, i32* %_max1134, align 4, !tbaa !62
  %60 = bitcast i32* %_max2135 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %60) #7
  store i32 0, i32* %_max2135, align 4, !tbaa !62
  %cmp136 = icmp eq i32* %_max1134, %_max2135
  %conv137 = zext i1 %cmp136 to i32
  %61 = load i32, i32* %_max1134, align 4, !tbaa !62
  %62 = load i32, i32* %_max2135, align 4, !tbaa !62
  %cmp139 = icmp sgt i32 %61, %62
  %63 = load i32, i32* %_max1134, align 4
  %64 = load i32, i32* %_max2135, align 4
  %cond144 = select i1 %cmp139, i32 %63, i32 %64
  %65 = bitcast i32* %_max2135 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %65) #7
  %66 = bitcast i32* %_max1134 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %66) #7
  %67 = bitcast i32* %_min1145 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %67) #7
  store i32 %call132, i32* %_min1145, align 4, !tbaa !62
  %68 = bitcast i32* %_min2146 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %68) #7
  store i32 0, i32* %_min2146, align 4, !tbaa !62
  %cmp147 = icmp eq i32* %_min1145, %_min2146
  %conv148 = zext i1 %cmp147 to i32
  %69 = load i32, i32* %_min1145, align 4, !tbaa !62
  %70 = load i32, i32* %_min2146, align 4, !tbaa !62
  %cmp150 = icmp slt i32 %69, %70
  %71 = load i32, i32* %_min1145, align 4
  %72 = load i32, i32* %_min2146, align 4
  %cond155 = select i1 %cmp150, i32 %71, i32 %72
  %73 = bitcast i32* %_min2146 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %73) #7
  %74 = bitcast i32* %_min1145 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %74) #7
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %or119, i32 %cond144, i32 %cond155, i32 1, i8* null, i32 0)
  br label %if.end156

if.end156:                                        ; preds = %if.end56, %land.lhs.true96, %if.then100, %if.end117
  %i.0 = phi i32 [ %call132, %if.end117 ], [ %call67, %if.then100 ], [ %call67, %land.lhs.true96 ], [ %call67, %if.end56 ]
  %cmp157 = icmp slt i32 %i.0, 0
  %cmp160 = icmp ne i32 %i.0, -32
  %or.cond = and i1 %cmp157, %cmp160
  br i1 %or.cond, label %if.then162, label %done

if.then162:                                       ; preds = %if.end156
  %dev163 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  %call164 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call164, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %bRequestType165 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 0
  %75 = load i8, i8* %bRequestType165, align 8, !tbaa !125
  %conv166 = zext i8 %75 to i32
  %bRequest167 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 1
  %76 = load i8, i8* %bRequest167, align 1, !tbaa !127
  %conv168 = zext i8 %76 to i32
  %wLength169 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %ctrl, i32 0, i32 4
  %77 = load i16, i16* %wLength169, align 2, !tbaa !129
  %conv170 = zext i16 %77 to i32
  %call171 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev163, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.33, i32 0, i32 0), i8* %arraydecay, i32 %conv166, i32 %conv168, i32 %conv170, i32 %i.0)
  br label %done

done:                                             ; preds = %if.end156, %if.then162, %if.then109, %if.then100, %land.lhs.true, %if.end17
  %ret.0 = phi i32 [ -12, %if.end17 ], [ -22, %land.lhs.true ], [ -14, %if.then100 ], [ -14, %if.then109 ], [ %i.0, %if.then162 ], [ %i.0, %if.end156 ]
  %78 = ptrtoint i8* %7 to i64
  call void @free_pages(i64 %78, i32 0)
  call void @usbfs_decrease_memory_usage(i32 4296)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.end7, %if.end, %entry, %done
  %retval.0 = phi i32 [ %ret.0, %done ], [ -14, %entry ], [ %call4, %if.end ], [ -22, %if.end7 ], [ %call14, %if.end13 ]
  %79 = bitcast %struct.usbdevfs_ctrltransfer* %ctrl to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %79) #7
  ret i32 %retval.0
}

declare { i64, i64 } @current_kernel_time() #3

; Function Attrs: nounwind uwtable
define internal i32 @proc_bulk(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %bulk = alloca %struct.usbdevfs_bulktransfer, align 8
  %len2 = alloca i32, align 4
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %1 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %1) #7
  %2 = bitcast i32* %len2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %3 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  %call = call i64 @copy_from_user(i8* %3, i8* %arg, i64 24)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !44
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %5 = load i32, i32* %ep, align 8, !tbaa !137
  %call3 = call i32 @findintfep(%struct.usb_device* %4, i32 %5)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call3)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end5
  %ep10 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %6 = load i32, i32* %ep10, align 8, !tbaa !137
  %and = and i32 %6, 128
  %tobool11 = icmp ne i32 %and, 0
  %ep13 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %7 = load i32, i32* %ep13, align 8, !tbaa !137
  %and14 = and i32 %7, 127
  %call15 = call i32 @__create_pipe(%struct.usb_device* %0, i32 %and14)
  %or = or i32 -1073741824, %call15
  %or16 = or i32 %or, 128
  %pipe.0 = select i1 %tobool11, i32 %or16, i32 %or
  %ep22 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %8 = load i32, i32* %ep22, align 8, !tbaa !137
  %and23 = and i32 %8, 128
  %tobool24 = icmp ne i32 %and23, 0
  %lnot = xor i1 %tobool24, true
  %lnot.ext = zext i1 %lnot to i32
  %call25 = call zeroext i16 @usb_maxpacket(%struct.usb_device* %0, i32 %pipe.0, i32 %lnot.ext)
  %tobool26 = icmp ne i16 %call25, 0
  br i1 %tobool26, label %if.end28, label %cleanup

if.end28:                                         ; preds = %if.end9
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 1
  %9 = load i32, i32* %len, align 4, !tbaa !139
  %cmp29 = icmp uge i32 %9, 2146483647
  br i1 %cmp29, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.end28
  %conv = zext i32 %9 to i64
  %add = add i64 %conv, 192
  %conv32 = trunc i64 %add to i32
  %call33 = call i32 @usbfs_increase_memory_usage(i32 %conv32)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %cleanup, label %if.end36

if.end36:                                         ; preds = %if.end31
  %conv37 = zext i32 %9 to i64
  %call38 = call i8* @kmalloc(i64 %conv37, i32 208)
  %tobool39 = icmp ne i8* %call38, null
  br i1 %tobool39, label %if.end41, label %done

if.end41:                                         ; preds = %if.end36
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 2
  %10 = load i32, i32* %timeout, align 8, !tbaa !140
  %ep42 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 0
  %11 = load i32, i32* %ep42, align 8, !tbaa !137
  %and43 = and i32 %11, 128
  %tobool44 = icmp ne i32 %and43, 0
  %tobool46 = icmp ne i32 %9, 0
  br i1 %tobool44, label %if.then45, label %if.else73

if.then45:                                        ; preds = %if.end41
  br i1 %tobool46, label %land.lhs.true, label %if.end59

land.lhs.true:                                    ; preds = %if.then45
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %12 = load i8*, i8** %data, align 8, !tbaa !141
  %conv47 = zext i32 %9 to i64
  %call48 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call48, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %13 = load i64, i64* %seg, align 8, !tbaa !132
  %14 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %12, i64 %conv47, i64 %13) #8, !srcloc !142
  %asmresult = extractvalue { i64, i64 } %14, 0
  %asmresult49 = extractvalue { i64, i64 } %14, 1
  %cmp50 = icmp eq i64 %asmresult, 0
  %lnot52 = xor i1 %cmp50, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %conv56 = sext i32 %lnot.ext55 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv56, i64 1)
  %tobool57 = icmp ne i64 %expval, 0
  br i1 %tobool57, label %if.end59, label %done

if.end59:                                         ; preds = %land.lhs.true, %if.then45
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %9, i32 %10, i32 0, i8* null, i32 0)
  %dev60 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev60)
  %call61 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call38, i32 %9, i32* %len2, i32 %10)
  %dev62 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev62)
  %15 = load i32, i32* %len2, align 4, !tbaa !62
  %16 = load i32, i32* %len2, align 4, !tbaa !62
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %15, i32 %call61, i32 1, i8* %call38, i32 %16)
  %tobool63 = icmp eq i32 %call61, 0
  %17 = load i32, i32* %len2, align 4
  %tobool65 = icmp ne i32 %17, 0
  %or.cond = and i1 %tobool63, %tobool65
  br i1 %or.cond, label %if.then66, label %if.end86

if.then66:                                        ; preds = %if.end59
  %data67 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %18 = load i8*, i8** %data67, align 8, !tbaa !141
  %19 = load i32, i32* %len2, align 4, !tbaa !62
  %call68 = call i32 @copy_to_user(i8* %18, i8* %call38, i32 %19)
  %tobool69 = icmp ne i32 %call68, 0
  br i1 %tobool69, label %done, label %if.end86

if.else73:                                        ; preds = %if.end41
  br i1 %tobool46, label %if.then75, label %if.end82

if.then75:                                        ; preds = %if.else73
  %data76 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %bulk, i32 0, i32 3
  %20 = load i8*, i8** %data76, align 8, !tbaa !141
  %conv77 = zext i32 %9 to i64
  %call78 = call i64 @copy_from_user(i8* %call38, i8* %20, i64 %conv77)
  %tobool79 = icmp ne i64 %call78, 0
  br i1 %tobool79, label %done, label %if.end82

if.end82:                                         ; preds = %if.then75, %if.else73
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %9, i32 %10, i32 0, i8* %call38, i32 %9)
  %dev83 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev83)
  %call84 = call i32 @usb_bulk_msg(%struct.usb_device* %0, i32 %pipe.0, i8* %call38, i32 %9, i32* %len2, i32 %10)
  %dev85 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 11
  call void @device_lock(%struct.device* %dev85)
  %21 = load i32, i32* %len2, align 4, !tbaa !62
  call void @snoop_urb(%struct.usb_device* %0, i8* null, i32 %pipe.0, i32 %21, i32 %call84, i32 1, i8* null, i32 0)
  br label %if.end86

if.end86:                                         ; preds = %if.end59, %if.then66, %if.end82
  %i.0 = phi i32 [ %call84, %if.end82 ], [ %call61, %if.then66 ], [ %call61, %if.end59 ]
  %cmp87 = icmp slt i32 %i.0, 0
  %22 = load i32, i32* %len2, align 4
  %cond = select i1 %cmp87, i32 %i.0, i32 %22
  br label %done

done:                                             ; preds = %if.end86, %if.then75, %if.then66, %land.lhs.true, %if.end36
  %ret.0 = phi i32 [ -12, %if.end36 ], [ -22, %land.lhs.true ], [ -14, %if.then66 ], [ -14, %if.then75 ], [ %cond, %if.end86 ]
  call void @kfree(i8* %call38)
  %conv89 = zext i32 %9 to i64
  %add90 = add i64 %conv89, 192
  %conv91 = trunc i64 %add90 to i32
  call void @usbfs_decrease_memory_usage(i32 %conv91)
  br label %cleanup

cleanup:                                          ; preds = %if.end31, %if.end28, %if.end9, %if.end5, %if.end, %entry, %done
  %retval.0 = phi i32 [ %ret.0, %done ], [ -14, %entry ], [ %call3, %if.end ], [ %call6, %if.end5 ], [ -22, %if.end9 ], [ -22, %if.end28 ], [ %call33, %if.end31 ]
  %23 = bitcast i32* %len2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %23) #7
  %24 = bitcast %struct.usbdevfs_bulktransfer* %bulk to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %24) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_resetep(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #7, !srcloc !143
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %dev9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev9, align 8, !tbaa !44
  call void @usb_reset_endpoint(%struct.usb_device* %5, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry, %if.end8
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -14, %entry ], [ %call, %if.end ], [ %call5, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_resetdevice(%struct.dev_state* %ps) #1 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %call = call i32 @usb_reset_device(%struct.usb_device* %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_clearhalt(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #7, !srcloc !144
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %call = call i32 @findintfep(%struct.usb_device* %4, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end4
  %and = and i32 %conv, 128
  %tobool9 = icmp ne i32 %and, 0
  %dev11 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev11, align 8, !tbaa !44
  %and12 = and i32 %conv, 127
  %call13 = call i32 @__create_pipe(%struct.usb_device* %5, i32 %and12)
  %or = or i32 -1073741824, %call13
  %or14 = or i32 %or, 128
  %pipe.0 = select i1 %tobool9, i32 %or14, i32 %or
  %dev20 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev20, align 8, !tbaa !44
  %call21 = call i32 @usb_clear_halt(%struct.usb_device* %6, i32 %pipe.0)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry, %if.end8
  %retval.0 = phi i32 [ %call21, %if.end8 ], [ -14, %entry ], [ %call, %if.end ], [ %call5, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_getdriver(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %gd = alloca %struct.usbdevfs_getdriver, align 4
  %0 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  call void @llvm.lifetime.start.p0i8(i64 260, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 260)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %interface = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4, !tbaa !145
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %2, i32 %3)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %lor.lhs.false, label %cleanup

lor.lhs.false:                                    ; preds = %if.end
  %dev3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !147
  %tobool4 = icmp ne %struct.device_driver* %4, null
  br i1 %tobool4, label %if.else, label %cleanup

if.else:                                          ; preds = %lor.lhs.false
  %driver6 = getelementptr inbounds %struct.usbdevfs_getdriver, %struct.usbdevfs_getdriver* %gd, i32 0, i32 1
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver6, i32 0, i32 0
  %dev7 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver8 = getelementptr inbounds %struct.device, %struct.device* %dev7, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver8, align 8, !tbaa !147
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %5, i32 0, i32 0
  %6 = load i8*, i8** %name, align 8, !tbaa !148
  %call9 = call i64 @strlcpy(i8* %arraydecay, i8* %6, i64 256)
  %7 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  %call10 = call i32 @copy_to_user(i8* %arg, i8* %7, i32 260)
  %tobool11 = icmp ne i32 %call10, 0
  %8 = zext i1 %tobool11 to i64
  %cond = select i1 %tobool11, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.else, %lor.lhs.false, %if.end, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %cond, %if.else ], [ -61, %lor.lhs.false ], [ -61, %if.end ]
  %9 = bitcast %struct.usbdevfs_getdriver* %gd to i8*
  call void @llvm.lifetime.end.p0i8(i64 260, i8* %9) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_connectinfo(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %ci = alloca %struct.usbdevfs_connectinfo, align 4
  %0 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %devnum = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 0
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %1 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %devnum1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %1, i32 0, i32 0
  %2 = load i32, i32* %devnum1, align 8, !tbaa !150
  store i32 %2, i32* %devnum, align 4, !tbaa !151
  %slow = getelementptr inbounds %struct.usbdevfs_connectinfo, %struct.usbdevfs_connectinfo* %ci, i32 0, i32 1
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !44
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 4
  %4 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp = icmp eq i32 %4, 1
  %conv = zext i1 %cmp to i32
  %conv3 = trunc i32 %conv to i8
  store i8 %conv3, i8* %slow, align 4, !tbaa !154
  %5 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  %call = call i32 @copy_to_user(i8* %arg, i8* %5, i32 8)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 -14, i32 0
  %6 = bitcast %struct.usbdevfs_connectinfo* %ci to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_setintf(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %setintf = alloca %struct.usbdevfs_setinterface, align 4
  %0 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %interface = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %2 = load i32, i32* %interface, align 4, !tbaa !155
  %call1 = call i32 @checkintf(%struct.dev_state* %ps, i32 %2)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %interface5 = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 0
  %4 = load i32, i32* %interface5, align 4, !tbaa !155
  %altsetting = getelementptr inbounds %struct.usbdevfs_setinterface, %struct.usbdevfs_setinterface* %setintf, i32 0, i32 1
  %5 = load i32, i32* %altsetting, align 4, !tbaa !157
  %call6 = call i32 @usb_set_interface(%struct.usb_device* %3, i32 %4, i32 %5)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end4
  %retval.0 = phi i32 [ %call6, %if.end4 ], [ -14, %entry ], [ %call1, %if.end ]
  %6 = bitcast %struct.usbdevfs_setinterface* %setintf to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_setconfig(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #7, !srcloc !158
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %actconfig2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 15
  %5 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig2, align 8, !tbaa !159
  %tobool3 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool3, label %if.then4, label %if.end23

if.then4:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then4
  %i.0 = phi i32 [ 0, %if.then4 ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %6 = load i8, i8* %bNumInterfaces, align 4, !tbaa !160
  %conv5 = zext i8 %6 to i32
  %cmp = icmp slt i32 %i.0, %conv5
  br i1 %cmp, label %for.body, label %if.end23

for.body:                                         ; preds = %for.cond
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %7 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !56
  %call = call i32 @usb_interface_claimed(%struct.usb_interface* %7)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %dev9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %dev9, align 8, !tbaa !44
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 11
  %interface11 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom12 = sext i32 %i.0 to i64
  %arrayidx13 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface11, i64 0, i64 %idxprom12
  %9 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx13, align 8, !tbaa !56
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %9, i32 0, i32 1
  %10 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !161
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %10, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 2
  %11 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !34
  %conv15 = zext i8 %11 to i32
  %interface16 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 3
  %idxprom17 = sext i32 %i.0 to i64
  %arrayidx18 = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface16, i64 0, i64 %idxprom17
  %12 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx18, align 8, !tbaa !56
  %dev19 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %12, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev19, i32 0, i32 7
  %13 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !147
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %13, i32 0, i32 0
  %14 = load i8*, i8** %name, align 8, !tbaa !148
  %call20 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call20, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %call21 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev10, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.47, i32 0, i32 0), i32 %conv15, i8* %14, i8* %arraydecay, i32 %conv)
  br label %if.end23

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.end23:                                         ; preds = %if.then8, %for.cond, %if.end
  %status.1 = phi i32 [ 0, %if.end ], [ -16, %if.then8 ], [ 0, %for.cond ]
  %cmp24 = icmp eq i32 %status.1, 0
  br i1 %cmp24, label %if.then26, label %cleanup

if.then26:                                        ; preds = %if.end23
  %tobool27 = icmp ne %struct.usb_host_config* %5, null
  br i1 %tobool27, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then26
  %desc28 = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %5, i32 0, i32 0
  %bConfigurationValue = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc28, i32 0, i32 4
  %15 = load i8, i8* %bConfigurationValue, align 1, !tbaa !162
  %conv29 = zext i8 %15 to i32
  %cmp30 = icmp eq i32 %conv29, %conv
  br i1 %cmp30, label %if.then32, label %if.else

if.then32:                                        ; preds = %land.lhs.true
  %dev33 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %16 = load %struct.usb_device*, %struct.usb_device** %dev33, align 8, !tbaa !44
  %call34 = call i32 @usb_reset_configuration(%struct.usb_device* %16)
  br label %cleanup

if.else:                                          ; preds = %land.lhs.true, %if.then26
  %dev35 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %17 = load %struct.usb_device*, %struct.usb_device** %dev35, align 8, !tbaa !44
  %call36 = call i32 @usb_set_configuration(%struct.usb_device* %17, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end23, %if.else, %if.then32, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %status.1, %if.end23 ], [ %call34, %if.then32 ], [ %call36, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_submiturb(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 56)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %arg to %struct.usbdevfs_urb*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %call1 = call i32 @proc_do_submiturb(%struct.dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %3 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.end.p0i8(i64 56, i8* %3) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_control_compat(%struct.dev_state* %ps, %struct.usbdevfs_ctrltransfer32* %p32) #1 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_ctrltransfer*
  %1 = bitcast %struct.usbdevfs_ctrltransfer* %0 to i8*
  %2 = bitcast %struct.usbdevfs_ctrltransfer32* %p32 to i8*
  %call1 = call i64 @copy_in_user(i8* %1, i8* %2, i32 12)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %data = getelementptr inbounds %struct.usbdevfs_ctrltransfer32, %struct.usbdevfs_ctrltransfer32* %p32, i32 0, i32 6
  %3 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4) #7, !srcloc !163
  %asmresult = extractvalue { i32*, i64 } %3, 0
  %asmresult2 = extractvalue { i32*, i64 } %3, 1
  %4 = ptrtoint i32* %asmresult to i64
  %5 = trunc i64 %4 to i32
  %conv = trunc i64 %asmresult2 to i32
  %tobool3 = icmp ne i32 %5, 0
  br i1 %tobool3, label %cleanup, label %lor.lhs.false4

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %call5 = call i8* @compat_ptr(i32 %conv)
  %data6 = getelementptr inbounds %struct.usbdevfs_ctrltransfer, %struct.usbdevfs_ctrltransfer* %0, i32 0, i32 6
  %6 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call5, i8** %data6) #7, !srcloc !164
  %7 = ptrtoint i8* %6 to i64
  %8 = trunc i64 %7 to i32
  %tobool8 = icmp ne i32 %8, 0
  br i1 %tobool8, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false4
  %9 = bitcast %struct.usbdevfs_ctrltransfer* %0 to i8*
  %call9 = call i32 @proc_control(%struct.dev_state* %ps, i8* %9)
  br label %cleanup

cleanup:                                          ; preds = %entry, %lor.lhs.false, %lor.lhs.false4, %if.end
  %retval.0 = phi i32 [ %call9, %if.end ], [ -14, %lor.lhs.false4 ], [ -14, %lor.lhs.false ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_bulk_compat(%struct.dev_state* %ps, %struct.usbdevfs_bulktransfer32* %p32) #1 {
entry:
  %call = call i8* @compat_alloc_user_space(i64 24)
  %0 = bitcast i8* %call to %struct.usbdevfs_bulktransfer*
  call void @might_fault()
  %ep = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 0
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %ep, i64 4) #7, !srcloc !165
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  call void @might_fault()
  %ep2 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 0
  %4 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv, i32* %ep2) #7, !srcloc !166
  %tobool4 = icmp ne i32 %4, 0
  br i1 %tobool4, label %cleanup, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  call void @might_fault()
  %len = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 1
  %5 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %len, i64 4) #7, !srcloc !167
  %asmresult8 = extractvalue { i32*, i64 } %5, 0
  %asmresult9 = extractvalue { i32*, i64 } %5, 1
  %6 = ptrtoint i32* %asmresult8 to i64
  %7 = trunc i64 %6 to i32
  %conv10 = trunc i64 %asmresult9 to i32
  %tobool12 = icmp ne i32 %7, 0
  br i1 %tobool12, label %cleanup, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false5
  call void @might_fault()
  %len16 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 1
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv10, i32* %len16) #7, !srcloc !168
  %tobool18 = icmp ne i32 %8, 0
  br i1 %tobool18, label %cleanup, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %lor.lhs.false13
  call void @might_fault()
  %timeout = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 2
  %9 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %timeout, i64 4) #7, !srcloc !169
  %asmresult22 = extractvalue { i32*, i64 } %9, 0
  %asmresult23 = extractvalue { i32*, i64 } %9, 1
  %10 = ptrtoint i32* %asmresult22 to i64
  %11 = trunc i64 %10 to i32
  %conv24 = trunc i64 %asmresult23 to i32
  %tobool26 = icmp ne i32 %11, 0
  br i1 %tobool26, label %cleanup, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %lor.lhs.false19
  call void @might_fault()
  %timeout30 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 2
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %conv24, i32* %timeout30) #7, !srcloc !170
  %tobool32 = icmp ne i32 %12, 0
  br i1 %tobool32, label %cleanup, label %lor.lhs.false33

lor.lhs.false33:                                  ; preds = %lor.lhs.false27
  call void @might_fault()
  %data = getelementptr inbounds %struct.usbdevfs_bulktransfer32, %struct.usbdevfs_bulktransfer32* %p32, i32 0, i32 3
  %13 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %data, i64 4) #7, !srcloc !171
  %asmresult36 = extractvalue { i32*, i64 } %13, 0
  %asmresult37 = extractvalue { i32*, i64 } %13, 1
  %14 = ptrtoint i32* %asmresult36 to i64
  %15 = trunc i64 %14 to i32
  %conv38 = trunc i64 %asmresult37 to i32
  %tobool40 = icmp ne i32 %15, 0
  br i1 %tobool40, label %cleanup, label %lor.lhs.false41

lor.lhs.false41:                                  ; preds = %lor.lhs.false33
  call void @might_fault()
  %call44 = call i8* @compat_ptr(i32 %conv38)
  %data45 = getelementptr inbounds %struct.usbdevfs_bulktransfer, %struct.usbdevfs_bulktransfer* %0, i32 0, i32 3
  %16 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %call44, i8** %data45) #7, !srcloc !172
  %17 = ptrtoint i8* %16 to i64
  %18 = trunc i64 %17 to i32
  %tobool47 = icmp ne i32 %18, 0
  br i1 %tobool47, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false41
  %19 = bitcast %struct.usbdevfs_bulktransfer* %0 to i8*
  %call48 = call i32 @proc_bulk(%struct.dev_state* %ps, i8* %19)
  br label %cleanup

cleanup:                                          ; preds = %entry, %lor.lhs.false, %lor.lhs.false5, %lor.lhs.false13, %lor.lhs.false19, %lor.lhs.false27, %lor.lhs.false33, %lor.lhs.false41, %if.end
  %retval.0 = phi i32 [ %call48, %if.end ], [ -14, %lor.lhs.false41 ], [ -14, %lor.lhs.false33 ], [ -14, %lor.lhs.false27 ], [ -14, %lor.lhs.false19 ], [ -14, %lor.lhs.false13 ], [ -14, %lor.lhs.false5 ], [ -14, %lor.lhs.false ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnectsignal_compat(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %ds = alloca %struct.usbdevfs_disconnectsignal32, align 4
  %0 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 8)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 4, !tbaa !173
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 7
  store i32 %2, i32* %discsignr, align 8, !tbaa !77
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal32, %struct.usbdevfs_disconnectsignal32* %ds, i32 0, i32 1
  %3 = load i32, i32* %context, align 4, !tbaa !175
  %call1 = call i8* @compat_ptr(i32 %3)
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 10
  store i8* %call1, i8** %disccontext, align 8, !tbaa !107
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %4 = bitcast %struct.usbdevfs_disconnectsignal32* %ds to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_submiturb_compat(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %uurb = alloca %struct.usbdevfs_urb, align 8
  %0 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* %0) #7
  %1 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %call = call i32 @get_urb32(%struct.usbdevfs_urb* %uurb, %struct.usbdevfs_urb32* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i8* %arg to %struct.usbdevfs_urb32*
  %iso_frame_desc = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc, i32 0, i32 0
  %call1 = call i32 @proc_do_submiturb(%struct.dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %arraydecay, i8* %arg)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %3 = bitcast %struct.usbdevfs_urb* %uurb to i8*
  call void @llvm.lifetime.end.p0i8(i64 56, i8* %3) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurb_compat(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %call = call %struct.async* @reap_as(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl_compat(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call3 = call %struct.task_struct* @get_current()
  %call4 = call i32 @signal_pending(%struct.task_struct* %call3)
  %tobool5 = icmp ne i32 %call4, 0
  %. = select i1 %tobool5, i32 -4, i32 -5
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurbnonblock_compat(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl_compat(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %retval1.0 = phi i32 [ %call2, %if.then ], [ -11, %entry ]
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl_compat(%struct.dev_state* %ps, i32 %arg) #1 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %conv = zext i32 %arg to i64
  %conv1 = trunc i64 %conv to i32
  %call = call i8* @compat_ptr(i32 %conv1)
  %1 = bitcast i8* %call to %struct.usbdevfs_ioctl32*
  %call2 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call2, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %2 = load i64, i64* %seg, align 8, !tbaa !132
  %3 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.usbdevfs_ioctl32* %1, i64 12, i64 %2) #8, !srcloc !176
  %asmresult = extractvalue { i64, i64 } %3, 0
  %asmresult3 = extractvalue { i64, i64 } %3, 1
  %cmp = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %1, i32 0, i32 0
  %4 = bitcast i32* %ifno to %struct.__large_struct*
  %5 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %4, i32 -14, i32 0) #7, !srcloc !177
  %asmresult7 = extractvalue { i32, i64 } %5, 0
  %asmresult8 = extractvalue { i32, i64 } %5, 1
  %conv9 = trunc i64 %asmresult8 to i32
  %ifno10 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 0
  store i32 %conv9, i32* %ifno10, align 8, !tbaa !178
  %tobool12 = icmp ne i32 %asmresult7, 0
  br i1 %tobool12, label %cleanup, label %do.body16

do.body16:                                        ; preds = %do.body
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %1, i32 0, i32 1
  %6 = bitcast i32* %ioctl_code to %struct.__large_struct*
  %7 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 0) #7, !srcloc !180
  %asmresult17 = extractvalue { i32, i64 } %7, 0
  %asmresult18 = extractvalue { i32, i64 } %7, 1
  %conv21 = trunc i64 %asmresult18 to i32
  %ioctl_code22 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 1
  store i32 %conv21, i32* %ioctl_code22, align 4, !tbaa !181
  %tobool24 = icmp ne i32 %asmresult17, 0
  br i1 %tobool24, label %cleanup, label %do.body28

do.body28:                                        ; preds = %do.body16
  %data = getelementptr inbounds %struct.usbdevfs_ioctl32, %struct.usbdevfs_ioctl32* %1, i32 0, i32 2
  %8 = bitcast i32* %data to %struct.__large_struct*
  %9 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 0) #7, !srcloc !182
  %asmresult29 = extractvalue { i32, i64 } %9, 0
  %asmresult30 = extractvalue { i32, i64 } %9, 1
  %conv33 = trunc i64 %asmresult30 to i32
  %tobool35 = icmp ne i32 %asmresult29, 0
  br i1 %tobool35, label %cleanup, label %if.end

if.end:                                           ; preds = %do.body28
  %call36 = call i8* @compat_ptr(i32 %conv33)
  %data37 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctrl, i32 0, i32 2
  store i8* %call36, i8** %data37, align 8, !tbaa !183
  %call38 = call i32 @proc_ioctl(%struct.dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %entry, %do.body, %do.body16, %do.body28, %if.end
  %retval.0 = phi i32 [ %call38, %if.end ], [ -14, %do.body28 ], [ -14, %do.body16 ], [ -14, %do.body ], [ -14, %entry ]
  %10 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %10) #7
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @ptr_to_compat(i8* %uptr) #0 {
entry:
  %0 = ptrtoint i8* %uptr to i64
  %conv = trunc i64 %0 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_unlinkurb(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %call5 = call %struct.async* @async_getpending(%struct.dev_state* %ps, i8* %arg)
  %tobool = icmp ne %struct.async* %call5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %lock6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock6, i64 %call2)
  br label %cleanup

if.end:                                           ; preds = %entry
  %urb7 = getelementptr inbounds %struct.async, %struct.async* %call5, i32 0, i32 8
  %4 = load %struct.urb*, %struct.urb** %urb7, align 8, !tbaa !120
  %call8 = call %struct.urb* @usb_get_urb(%struct.urb* %4)
  %lock9 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock9, i64 %call2)
  call void @usb_kill_urb(%struct.urb* %4)
  call void @usb_free_urb(%struct.urb* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ 0, %if.end ], [ -22, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurb(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %call = call %struct.async* @reap_as(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call3 = call %struct.task_struct* @get_current()
  %call4 = call i32 @signal_pending(%struct.task_struct* %call3)
  %tobool5 = icmp ne i32 %call4, 0
  %. = select i1 %tobool5, i32 -4, i32 -5
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call2, %if.then ], [ %., %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_reapurbnonblock(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %call = call %struct.async* @async_getcompleted(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = bitcast i8* %arg to i8**
  %call2 = call i32 @processcompl(%struct.async* %call, i8** %0)
  call void @free_async(%struct.async* %call)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %retval1.0 = phi i32 [ %call2, %if.then ], [ -11, %entry ]
  ret i32 %retval1.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnectsignal(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %ds = alloca %struct.usbdevfs_disconnectsignal, align 8
  %0 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %signr = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 0
  %2 = load i32, i32* %signr, align 8, !tbaa !184
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 7
  store i32 %2, i32* %discsignr, align 8, !tbaa !77
  %context = getelementptr inbounds %struct.usbdevfs_disconnectsignal, %struct.usbdevfs_disconnectsignal* %ds, i32 0, i32 1
  %3 = load i8*, i8** %context, align 8, !tbaa !186
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 10
  store i8* %3, i8** %disccontext, align 8, !tbaa !107
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ 0, %if.end ], [ -14, %entry ]
  %4 = bitcast %struct.usbdevfs_disconnectsignal* %ds to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %4) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_claiminterface(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #7, !srcloc !187
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @claimintf(%struct.dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_releaseinterface(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #7, !srcloc !188
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @releaseintf(%struct.dev_state* %ps, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  call void @destroy_async_on_interface(%struct.dev_state* %ps, i32 %conv)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end4
  %retval.0 = phi i32 [ 0, %if.end4 ], [ -14, %entry ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl_default(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %ctrl = alloca %struct.usbdevfs_ioctl, align 8
  %0 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 16)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @proc_ioctl(%struct.dev_state* %ps, %struct.usbdevfs_ioctl* %ctrl)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call1, %if.end ], [ -14, %entry ]
  %2 = bitcast %struct.usbdevfs_ioctl* %ctrl to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %2) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_claim_port(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #7, !srcloc !189
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %call = call i32 @usb_hub_claim_port(%struct.usb_device* %4, i32 %conv, %struct.dev_state* %ps)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %5 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool4 = trunc i8 %5 to i1
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %do.body
  %dev6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev6, align 8, !tbaa !44
  %dev7 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 11
  %call8 = call %struct.task_struct* @get_current()
  %call9 = call i32 @task_pid_nr(%struct.task_struct* %call8)
  %call10 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call10, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %call11 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev7, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.52, i32 0, i32 0), i32 %conv, i32 %call9, i8* %arraydecay)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then5, %do.body, %entry
  %retval.0 = phi i32 [ -14, %entry ], [ %call, %do.body ], [ %call, %if.then5 ], [ %call, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_release_port(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  call void @might_fault()
  %0 = bitcast i8* %arg to i32*
  %1 = call { i32*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i32* %0, i64 4) #7, !srcloc !190
  %asmresult = extractvalue { i32*, i64 } %1, 0
  %asmresult1 = extractvalue { i32*, i64 } %1, 1
  %2 = ptrtoint i32* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult1 to i32
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %call = call i32 @usb_hub_release_port(%struct.usb_device* %4, i32 %conv, %struct.dev_state* %ps)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi i32 [ %call, %if.end ], [ -14, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_get_capabilities(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 9
  %1 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !191
  %no_stop_on_short = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %1, i32 0, i32 6
  %bf.load = load i8, i8* %no_stop_on_short, align 1
  %bf.lshr = lshr i8 %bf.load, 2
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  %or = or i32 5, 2
  %.or = select i1 %tobool, i32 5, i32 %or
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %bus2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 9
  %3 = load %struct.usb_bus*, %struct.usb_bus** %bus2, align 8, !tbaa !191
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %3, i32 0, i32 7
  %4 = load i32, i32* %sg_tablesize, align 4, !tbaa !192
  %tobool3 = icmp ne i32 %4, 0
  %or5 = or i32 %.or, 8
  %caps.1 = select i1 %tobool3, i32 %or5, i32 %.or
  call void @might_fault()
  %5 = bitcast i8* %arg to i32*
  %6 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %caps.1, i32* %5) #7, !srcloc !195
  %tobool7 = icmp ne i32 %6, 0
  %. = select i1 %tobool7, i32 -14, i32 0
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_disconnect_claim(%struct.dev_state* %ps, i8* %arg) #1 {
entry:
  %dc = alloca %struct.usbdevfs_disconnect_claim, align 4
  %0 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  call void @llvm.lifetime.start.p0i8(i64 264, i8* %0) #7
  %1 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %arg, i64 264)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup36, label %if.end

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %interface = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %3 = load i32, i32* %interface, align 4, !tbaa !196
  %call1 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %2, i32 %3)
  %tobool2 = icmp ne %struct.usb_interface* %call1, null
  br i1 %tobool2, label %if.end4, label %cleanup36

if.end4:                                          ; preds = %if.end
  %dev5 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev5, i32 0, i32 7
  %4 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !147
  %tobool6 = icmp ne %struct.device_driver* %4, null
  br i1 %tobool6, label %if.then7, label %if.end33

if.then7:                                         ; preds = %if.end4
  %dev9 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver10 = getelementptr inbounds %struct.device, %struct.device* %dev9, i32 0, i32 7
  %5 = load %struct.device_driver*, %struct.device_driver** %driver10, align 8, !tbaa !147
  %6 = bitcast %struct.device_driver* %5 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 -104
  %7 = bitcast i8* %add.ptr to %struct.usb_driver*
  %flags = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %8 = load i32, i32* %flags, align 4, !tbaa !198
  %and = and i32 %8, 1
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %if.then7
  %driver12 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %driver12, i32 0, i32 0
  %dev13 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver14 = getelementptr inbounds %struct.device, %struct.device* %dev13, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver14, align 8, !tbaa !147
  %name = getelementptr inbounds %struct.device_driver, %struct.device_driver* %9, i32 0, i32 0
  %10 = load i8*, i8** %name, align 8, !tbaa !148
  %call15 = call i32 @strncmp(i8* %arraydecay, i8* %10, i64 256)
  %cmp = icmp ne i32 %call15, 0
  br i1 %cmp, label %cleanup, label %if.end17

if.end17:                                         ; preds = %land.lhs.true, %if.then7
  %flags18 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 1
  %11 = load i32, i32* %flags18, align 4, !tbaa !198
  %and19 = and i32 %11, 2
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %land.lhs.true21, label %if.end30

land.lhs.true21:                                  ; preds = %if.end17
  %driver22 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 2
  %arraydecay23 = getelementptr inbounds [256 x i8], [256 x i8]* %driver22, i32 0, i32 0
  %dev24 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %driver25 = getelementptr inbounds %struct.device, %struct.device* %dev24, i32 0, i32 7
  %12 = load %struct.device_driver*, %struct.device_driver** %driver25, align 8, !tbaa !147
  %name26 = getelementptr inbounds %struct.device_driver, %struct.device_driver* %12, i32 0, i32 0
  %13 = load i8*, i8** %name26, align 8, !tbaa !148
  %call27 = call i32 @strncmp(i8* %arraydecay23, i8* %13, i64 256)
  %cmp28 = icmp eq i32 %call27, 0
  br i1 %cmp28, label %cleanup, label %if.end30

if.end30:                                         ; preds = %land.lhs.true21, %if.end17
  %dev31 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call1, i32 0, i32 7
  %call32 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev31, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.51, i32 0, i32 0))
  call void @usb_driver_release_interface(%struct.usb_driver* %7, %struct.usb_interface* %call1)
  br label %cleanup

cleanup:                                          ; preds = %land.lhs.true21, %land.lhs.true, %if.end30
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end30 ], [ 1, %land.lhs.true ], [ 1, %land.lhs.true21 ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %if.end33, label %cleanup36

if.end33:                                         ; preds = %cleanup, %if.end4
  %interface34 = getelementptr inbounds %struct.usbdevfs_disconnect_claim, %struct.usbdevfs_disconnect_claim* %dc, i32 0, i32 0
  %14 = load i32, i32* %interface34, align 4, !tbaa !196
  %call35 = call i32 @claimintf(%struct.dev_state* %ps, i32 %14)
  br label %cleanup36

cleanup36:                                        ; preds = %if.end, %entry, %cleanup, %if.end33
  %retval.1 = phi i32 [ -16, %cleanup ], [ %call35, %if.end33 ], [ -14, %entry ], [ -22, %if.end ]
  %15 = bitcast %struct.usbdevfs_disconnect_claim* %dc to i8*
  call void @llvm.lifetime.end.p0i8(i64 264, i8* %15) #7
  ret i32 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #0 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %entry ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind uwtable
define internal i32 @check_ctrlrecip(%struct.dev_state* %ps, i32 %requesttype, i32 %request, i32 %index) #1 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !72
  %cmp = icmp ne i32 %1, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %state2 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 3
  %3 = load i32, i32* %state2, align 8, !tbaa !72
  %cmp3 = icmp ne i32 %3, 6
  br i1 %cmp3, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %dev5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %4 = load %struct.usb_device*, %struct.usb_device** %dev5, align 8, !tbaa !44
  %state6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %4, i32 0, i32 3
  %5 = load i32, i32* %state6, align 8, !tbaa !72
  %cmp7 = icmp ne i32 %5, 7
  br i1 %cmp7, label %cleanup, label %if.end

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %and = and i32 96, %requesttype
  %cmp8 = icmp eq i32 64, %and
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %cmp11 = icmp eq i32 %requesttype, 161
  %cmp13 = icmp eq i32 %request, 0
  %or.cond = and i1 %cmp11, %cmp13
  br i1 %or.cond, label %if.then14, label %if.end23

if.then14:                                        ; preds = %if.end10
  %dev15 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %6 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8, !tbaa !44
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %6, i32 0, i32 15
  %7 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !159
  %shr = lshr i32 %index, 8
  %and16 = and i32 %index, 255
  %call = call %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config* %7, i32 %shr, i32 %and16)
  %tobool = icmp ne %struct.usb_host_interface* %call, null
  br i1 %tobool, label %land.lhs.true17, label %if.end23

land.lhs.true17:                                  ; preds = %if.then14
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %call, i32 0, i32 0
  %bInterfaceClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 5
  %8 = load i8, i8* %bInterfaceClass, align 1, !tbaa !199
  %conv = zext i8 %8 to i32
  %cmp18 = icmp eq i32 %conv, 7
  %shr21 = lshr i32 %index, 8
  %shr21.index = select i1 %cmp18, i32 %shr21, i32 %index
  br label %if.end23

if.end23:                                         ; preds = %land.lhs.true17, %if.then14, %if.end10
  %index.addr.1 = phi i32 [ %index, %if.end10 ], [ %index, %if.then14 ], [ %shr21.index, %land.lhs.true17 ]
  %and24 = and i32 %index.addr.1, 255
  %and25 = and i32 %requesttype, 31
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end23
  %Pivot = icmp slt i32 %and25, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and25, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and25, 1
  br i1 %SwitchLeaf, label %sw.bb38, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %and26 = and i32 %and24, -129
  %cmp27 = icmp eq i32 %and26, 0
  br i1 %cmp27, label %cleanup, label %if.end30

if.end30:                                         ; preds = %sw.bb
  %dev31 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %9 = load %struct.usb_device*, %struct.usb_device** %dev31, align 8, !tbaa !44
  %call32 = call i32 @findintfep(%struct.usb_device* %9, i32 %and24)
  %cmp33 = icmp sge i32 %call32, 0
  br i1 %cmp33, label %if.then35, label %cleanup

if.then35:                                        ; preds = %if.end30
  %call36 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call32)
  br label %cleanup

sw.bb38:                                          ; preds = %LeafBlock
  %call39 = call i32 @checkintf(%struct.dev_state* %ps, i32 %and24)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %cleanup

cleanup:                                          ; preds = %NewDefault, %sw.bb38, %if.then35, %if.end30, %sw.bb, %if.end, %land.lhs.true4
  %retval.0 = phi i32 [ -113, %land.lhs.true4 ], [ 0, %if.end ], [ 0, %sw.bb ], [ 0, %NewDefault ], [ %call39, %sw.bb38 ], [ %call36, %if.then35 ], [ %call32, %if.end30 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @usbfs_increase_memory_usage(i32 %amount) #1 {
entry:
  %0 = load volatile i32, i32* @usbfs_memory_mb, align 4, !tbaa !62
  %cmp = icmp eq i32 %0, 0
  %cmp1 = icmp ugt i32 %0, 2047
  %or.cond = or i1 %cmp, %cmp1
  %shl = shl i32 %0, 20
  %lim.0 = select i1 %or.cond, i32 2146483647, i32 %shl
  call void @atomic_add(i32 %amount, %struct.atomic_t* @usbfs_memory_usage)
  %call = call i32 @atomic_read(%struct.atomic_t* @usbfs_memory_usage)
  %cmp2 = icmp ule i32 %call, %lim.0
  br i1 %cmp2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %entry
  call void @atomic_sub(i32 %amount, %struct.atomic_t* @usbfs_memory_usage)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end4
  %retval.0 = phi i32 [ -12, %if.end4 ], [ 0, %entry ]
  ret i32 %retval.0
}

declare i64 @__get_free_pages(i32, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @__le16_to_cpup(i16* %p) #0 {
entry:
  %0 = load i16, i16* %p, align 2, !tbaa !76
  ret i16 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.thread_info* @current_thread_info() #0 {
entry:
  %0 = call i64 asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(i64* @kernel_stack) #5, !srcloc !200
  %add = add i64 %0, 40
  %sub = sub i64 %add, 8192
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.thread_info*
  ret %struct.thread_info* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__create_pipe(%struct.usb_device* %dev, i32 %endpoint) #0 {
entry:
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 0
  %0 = load i32, i32* %devnum, align 8, !tbaa !150
  %shl = shl i32 %0, 8
  %shl1 = shl i32 %endpoint, 15
  %or = or i32 %shl, %shl1
  ret i32 %or
}

; Function Attrs: nounwind uwtable
define internal void @snoop_urb(%struct.usb_device* %udev, i8* %userurb, i32 %pipe, i32 %length, i32 %timeout_or_status, i32 %when, i8* %data, i32 %data_len) #1 {
entry:
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %shr1 = ashr i32 %pipe, 30
  %and2 = and i32 %shr1, 3
  %idxprom = sext i32 %and2 to i64
  %arrayidx = getelementptr inbounds [4 x i8*], [4 x i8*]* @snoop_urb.types, i64 0, i64 %idxprom
  %1 = load i8*, i8** %arrayidx, align 8, !tbaa !56
  %and3 = and i32 %pipe, 128
  %tobool4 = icmp ne i32 %and3, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %idxprom6 = sext i32 %lnot.ext to i64
  %arrayidx7 = getelementptr inbounds [2 x i8*], [2 x i8*]* @snoop_urb.dirs, i64 0, i64 %idxprom6
  %2 = load i8*, i8** %arrayidx7, align 8, !tbaa !56
  %tobool8 = icmp ne i8* %userurb, null
  %cmp = icmp eq i32 %when, 0
  %dev = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 11
  br i1 %tobool8, label %if.then9, label %if.else14

if.then9:                                         ; preds = %if.end
  br i1 %cmp, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.then9
  %call = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.41, i32 0, i32 0), i8* %userurb, i32 %and, i8* %1, i8* %2, i32 %length)
  br label %if.end23

if.else:                                          ; preds = %if.then9
  %call12 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.42, i32 0, i32 0), i8* %userurb, i32 %and, i8* %1, i8* %2, i32 %length, i32 %timeout_or_status)
  br label %if.end23

if.else14:                                        ; preds = %if.end
  br i1 %cmp, label %if.then16, label %if.else19

if.then16:                                        ; preds = %if.else14
  %call18 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.43, i32 0, i32 0), i32 %and, i8* %1, i8* %2, i32 %length, i32 %timeout_or_status)
  br label %if.end23

if.else19:                                        ; preds = %if.else14
  %call21 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.44, i32 0, i32 0), i32 %and, i8* %1, i8* %2, i32 %length, i32 %timeout_or_status)
  br label %if.end23

if.end23:                                         ; preds = %if.then16, %if.else19, %if.then10, %if.else
  %tobool24 = icmp ne i8* %data, null
  %cmp25 = icmp ugt i32 %data_len, 0
  %or.cond = and i1 %tobool24, %cmp25
  br i1 %or.cond, label %if.then26, label %cleanup.cont

if.then26:                                        ; preds = %if.end23
  %conv = zext i32 %data_len to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %data, i64 %conv, i1 zeroext true)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %entry, %if.then26, %if.end23
  ret void
}

declare i32 @usb_control_msg(%struct.usb_device*, i32, i8 zeroext, i8 zeroext, i16 zeroext, i16 zeroext, i8*, i16 zeroext, i32) #3

declare i32 @dev_printk(i8*, %struct.device*, i8*, ...) #3

declare void @free_pages(i64, i32) #3

; Function Attrs: nounwind uwtable
define internal void @usbfs_decrease_memory_usage(i32 %amount) #1 {
entry:
  call void @atomic_sub(i32 %amount, %struct.atomic_t* @usbfs_memory_usage)
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

declare i64 @_copy_from_user(i8*, i8*, i32) #3

declare %struct.usb_host_interface* @usb_find_alt_setting(%struct.usb_host_config*, i32, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @findintfep(%struct.usb_device* %dev, i32 %ep) #1 {
entry:
  %and = and i32 %ep, -144
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %actconfig = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %0 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig, align 8, !tbaa !159
  %tobool1 = icmp ne %struct.usb_host_config* %0, null
  br i1 %tobool1, label %if.end3, label %cleanup

if.end3:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc32, %if.end3
  %i.0 = phi i32 [ 0, %if.end3 ], [ %inc33, %for.inc32 ]
  %actconfig4 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %1 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig4, align 8, !tbaa !159
  %desc = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %1, i32 0, i32 0
  %bNumInterfaces = getelementptr inbounds %struct.usb_config_descriptor, %struct.usb_config_descriptor* %desc, i32 0, i32 3
  %2 = load i8, i8* %bNumInterfaces, align 4, !tbaa !160
  %conv = zext i8 %2 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %actconfig6 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %dev, i32 0, i32 15
  %3 = load %struct.usb_host_config*, %struct.usb_host_config** %actconfig6, align 8, !tbaa !159
  %interface = getelementptr inbounds %struct.usb_host_config, %struct.usb_host_config* %3, i32 0, i32 3
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [32 x %struct.usb_interface*], [32 x %struct.usb_interface*]* %interface, i64 0, i64 %idxprom
  %4 = load %struct.usb_interface*, %struct.usb_interface** %arrayidx, align 8, !tbaa !56
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc29, %for.body
  %j.0 = phi i32 [ 0, %for.body ], [ %inc30, %for.inc29 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 2
  %5 = load i32, i32* %num_altsetting, align 8, !tbaa !201
  %cmp8 = icmp ult i32 %j.0, %5
  br i1 %cmp8, label %for.body10, label %for.inc32

for.body10:                                       ; preds = %for.cond7
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %4, i32 0, i32 0
  %6 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !12
  %idxprom11 = zext i32 %j.0 to i64
  %arrayidx12 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %6, i64 %idxprom11
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc, %for.body10
  %e.0 = phi i32 [ 0, %for.body10 ], [ %inc, %for.inc ]
  %desc14 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc14, i32 0, i32 4
  %7 = load i8, i8* %bNumEndpoints, align 4, !tbaa !202
  %conv15 = zext i8 %7 to i32
  %cmp16 = icmp ult i32 %e.0, %conv15
  br i1 %cmp16, label %for.body18, label %for.inc29

for.body18:                                       ; preds = %for.cond13
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 3
  %8 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !203
  %idxprom19 = zext i32 %e.0 to i64
  %arrayidx20 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %8, i64 %idxprom19
  %desc21 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx20, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc21, i32 0, i32 2
  %9 = load i8, i8* %bEndpointAddress, align 1, !tbaa !204
  %conv22 = zext i8 %9 to i32
  %cmp23 = icmp eq i32 %conv22, %ep
  br i1 %cmp23, label %if.then25, label %for.inc

if.then25:                                        ; preds = %for.body18
  %desc26 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx12, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc26, i32 0, i32 2
  %10 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !34
  %conv27 = zext i8 %10 to i32
  br label %cleanup

for.inc:                                          ; preds = %for.body18
  %inc = add i32 %e.0, 1
  br label %for.cond13

for.inc29:                                        ; preds = %for.cond13
  %inc30 = add i32 %j.0, 1
  br label %for.cond7

for.inc32:                                        ; preds = %for.cond7
  %inc33 = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.end, %entry, %if.then25
  %retval.0 = phi i32 [ %conv27, %if.then25 ], [ -22, %entry ], [ -3, %if.end ], [ -2, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @checkintf(%struct.dev_state* %ps, i32 %ifnum) #1 {
entry:
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 3
  %1 = load i32, i32* %state, align 8, !tbaa !72
  %cmp = icmp ne i32 %1, 7
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i32 %ifnum to i64
  %cmp1 = icmp uge i64 %conv, 64
  br i1 %cmp1, label %return, label %cond.false

cond.false:                                       ; preds = %if.end
  %ifclaimed5 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  %call6 = call i32 @variable_test_bit(i32 %ifnum, i64* %ifclaimed5)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %return, label %if.end9

if.end9:                                          ; preds = %cond.false
  %dev10 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev10, align 8, !tbaa !44
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  %call12 = call %struct.task_struct* @get_current()
  %call13 = call i32 @task_pid_nr(%struct.task_struct* %call12)
  %call14 = call %struct.task_struct* @get_current()
  %comm = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call14, i32 0, i32 64
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %comm, i32 0, i32 0
  %call15 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev11, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.34, i32 0, i32 0), i32 %call13, i8* %arraydecay, i32 %ifnum)
  %call16 = call i32 @claimintf(%struct.dev_state* %ps, i32 %ifnum)
  br label %return

return:                                           ; preds = %cond.false, %if.end, %entry, %if.end9
  %retval.0 = phi i32 [ %call16, %if.end9 ], [ -113, %entry ], [ -22, %if.end ], [ 0, %cond.false ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @constant_test_bit(i32 %nr, i64* %addr) #4 {
entry:
  %rem = urem i32 %nr, 64
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %div = udiv i32 %nr, 64
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds i64, i64* %addr, i64 %idxprom
  %0 = load volatile i64, i64* %arrayidx, align 8, !tbaa !113
  %and = and i64 %shl, %0
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !205
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @task_pid_nr(%struct.task_struct* %tsk) #0 {
entry:
  %pid = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 34
  %0 = load i32, i32* %pid, align 4, !tbaa !206
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @claimintf(%struct.dev_state* %ps, i32 %ifnum) #1 {
entry:
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %cond.false

cond.false:                                       ; preds = %entry
  %ifclaimed3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  %call4 = call i32 @variable_test_bit(i32 %ifnum, i64* %ifclaimed3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %cond.false
  %call8 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool9 = icmp ne %struct.usb_interface* %call8, null
  br i1 %tobool9, label %if.else, label %if.end12

if.else:                                          ; preds = %if.end7
  %1 = bitcast %struct.dev_state* %ps to i8*
  %call11 = call i32 @usb_driver_claim_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call8, i8* %1)
  br label %if.end12

if.end12:                                         ; preds = %if.end7, %if.else
  %err.0 = phi i32 [ %call11, %if.else ], [ -2, %if.end7 ]
  %cmp13 = icmp eq i32 %err.0, 0
  br i1 %cmp13, label %if.then15, label %cleanup

if.then15:                                        ; preds = %if.end12
  %ifclaimed16 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  call void @set_bit(i32 %ifnum, i64* %ifclaimed16)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then15, %cond.false, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ 0, %cond.false ], [ %err.0, %if.then15 ], [ %err.0, %if.end12 ]
  ret i32 %retval.0
}

declare %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device*, i32) #3

declare i32 @usb_driver_claim_interface(%struct.usb_driver*, %struct.usb_interface*, i8*) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal void @set_bit(i32 %nr, i64* %addr) #4 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !207
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_add(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; addl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !208
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !62
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_sub(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; subl $1,$0", "=*m,ir,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !209
  ret void
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) #3

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @usb_maxpacket(%struct.usb_device* %udev, i32 %pipe, i32 %is_out) #0 {
entry:
  %shr = ashr i32 %pipe, 15
  %and = and i32 %shr, 15
  %tobool = icmp ne i32 %is_out, 0
  %and1 = and i32 %pipe, 128
  %tobool2 = icmp ne i32 %and1, 0
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then10, label %if.end

if.then10:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.46, i32 0, i32 0), i32 1773)
  br label %if.end

if.end:                                           ; preds = %if.then10, %if.then
  %tobool11 = icmp ne i32 %lnot.ext, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 17
  br label %if.end47

if.else:                                          ; preds = %entry
  %lnot25 = xor i1 %lnot3, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.else
  call void @warn_slowpath_null(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.46, i32 0, i32 0), i32 1776)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.else
  %tobool38 = icmp ne i32 %lnot.ext26, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 16
  br label %if.end47

if.end47:                                         ; preds = %if.end36, %if.end
  %ep_in.sink = phi [16 x %struct.usb_host_endpoint*]* [ %ep_in, %if.end36 ], [ %ep_out, %if.end ]
  %idxprom45 = zext i32 %and to i64
  %arrayidx46 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_in.sink, i64 0, i64 %idxprom45
  %0 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx46, align 8, !tbaa !56
  %tobool48 = icmp ne %struct.usb_host_endpoint* %0, null
  br i1 %tobool48, label %if.end50, label %cleanup

if.end50:                                         ; preds = %if.end47
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %0, i32 0, i32 0
  %call = call i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %desc)
  %conv51 = trunc i32 %call to i16
  br label %cleanup

cleanup:                                          ; preds = %if.end47, %if.end50
  %retval.0 = phi i16 [ %conv51, %if.end50 ], [ 0, %if.end47 ]
  ret i16 %retval.0
}

declare i32 @usb_bulk_msg(%struct.usb_device*, i32, i8*, i32, i32*, i32) #3

declare void @kfree(i8*) #3

declare void @warn_slowpath_null(i8*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_maxp(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 4
  %0 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !210
  %conv = zext i16 %0 to i32
  ret i32 %conv
}

declare void @usb_reset_endpoint(%struct.usb_device*, i32) #3

declare i32 @usb_reset_device(%struct.usb_device*) #3

declare i32 @usb_clear_halt(%struct.usb_device*, i32) #3

declare i64 @strlcpy(i8*, i8*, i64) #3

declare i32 @usb_set_interface(%struct.usb_device*, i32, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_interface_claimed(%struct.usb_interface* %iface) #0 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %iface, i32 0, i32 7
  %driver = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 7
  %0 = load %struct.device_driver*, %struct.device_driver** %driver, align 8, !tbaa !147
  %cmp = icmp ne %struct.device_driver* %0, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i32 @usb_reset_configuration(%struct.usb_device*) #3

declare i32 @usb_set_configuration(%struct.usb_device*, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @proc_do_submiturb(%struct.dev_state* %ps, %struct.usbdevfs_urb* %uurb, %struct.usbdevfs_iso_packet_desc* %iso_frame_desc, i8* %arg) #1 {
entry:
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %flags = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %0 = load i32, i32* %flags, align 8, !tbaa !211
  %and = and i32 %0, -232
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %1 = load i32, i32* %buffer_length, align 8, !tbaa !213
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end3

land.lhs.true:                                    ; preds = %if.end
  %buffer = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %2 = load i8*, i8** %buffer, align 8, !tbaa !214
  %tobool1 = icmp ne i8* %2, null
  br i1 %tobool1, label %if.end3, label %cleanup

if.end3:                                          ; preds = %land.lhs.true, %if.end
  %type = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %3 = load i8, i8* %type, align 8, !tbaa !215
  %conv = zext i8 %3 to i32
  %cmp4 = icmp eq i32 %conv, 2
  br i1 %cmp4, label %land.lhs.true6, label %if.then11

land.lhs.true6:                                   ; preds = %if.end3
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %4 = load i8, i8* %endpoint, align 1, !tbaa !216
  %conv7 = zext i8 %4 to i32
  %and8 = and i32 %conv7, -129
  %cmp9 = icmp eq i32 %and8, 0
  br i1 %cmp9, label %if.end22, label %if.then11

if.then11:                                        ; preds = %land.lhs.true6, %if.end3
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %endpoint12 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %6 = load i8, i8* %endpoint12, align 1, !tbaa !216
  %conv13 = zext i8 %6 to i32
  %call = call i32 @findintfep(%struct.usb_device* %5, i32 %conv13)
  %cmp14 = icmp slt i32 %call, 0
  br i1 %cmp14, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.then11
  %call18 = call i32 @checkintf(%struct.dev_state* %ps, i32 %call)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end17, %land.lhs.true6
  %ifnum.0 = phi i32 [ -1, %land.lhs.true6 ], [ %call, %if.end17 ]
  %endpoint23 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %7 = load i8, i8* %endpoint23, align 1, !tbaa !216
  %conv24 = zext i8 %7 to i32
  %and25 = and i32 %conv24, 128
  %cmp26 = icmp ne i32 %and25, 0
  %dev29 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %8 = load %struct.usb_device*, %struct.usb_device** %dev29, align 8, !tbaa !44
  %ep_out = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 17
  %ep_in = getelementptr inbounds %struct.usb_device, %struct.usb_device* %8, i32 0, i32 16
  %ep_out.sink = select i1 %cmp26, [16 x %struct.usb_host_endpoint*]* %ep_in, [16 x %struct.usb_host_endpoint*]* %ep_out
  %is_in.0 = select i1 %cmp26, i32 1, i32 0
  %endpoint34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %9 = load i8, i8* %endpoint34, align 1, !tbaa !216
  %conv35 = zext i8 %9 to i32
  %and36 = and i32 %conv35, 15
  %idxprom37 = sext i32 %and36 to i64
  %arrayidx38 = getelementptr inbounds [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*]* %ep_out.sink, i64 0, i64 %idxprom37
  %10 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %arrayidx38, align 8, !tbaa !56
  %tobool40 = icmp ne %struct.usb_host_endpoint* %10, null
  br i1 %tobool40, label %if.end42, label %cleanup

if.end42:                                         ; preds = %if.end22
  %type43 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %11 = load i8, i8* %type43, align 8, !tbaa !215
  %conv44 = zext i8 %11 to i32
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end42
  %Pivot6 = icmp slt i32 %conv44, 2
  br i1 %Pivot6, label %NodeBlock, label %NodeBlock3

NodeBlock3:                                       ; preds = %NodeBlock5
  %Pivot4 = icmp slt i32 %conv44, 3
  br i1 %Pivot4, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock3
  %SwitchLeaf2 = icmp eq i32 %conv44, 3
  br i1 %SwitchLeaf2, label %sw.bb118, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv44, 1
  br i1 %Pivot, label %LeafBlock, label %sw.bb134

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv44, 0
  br i1 %SwitchLeaf, label %sw.bb141, label %NewDefault

sw.bb:                                            ; preds = %NodeBlock3
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call45 = call i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %desc)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.end48, label %cleanup

if.end48:                                         ; preds = %sw.bb
  %buffer_length49 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %12 = load i32, i32* %buffer_length49, align 8, !tbaa !213
  %cmp50 = icmp slt i32 %12, 8
  br i1 %cmp50, label %cleanup, label %if.end53

if.end53:                                         ; preds = %if.end48
  %call54 = call i8* @kmalloc(i64 8, i32 208)
  %13 = bitcast i8* %call54 to %struct.usb_ctrlrequest*
  %tobool55 = icmp ne %struct.usb_ctrlrequest* %13, null
  br i1 %tobool55, label %if.end57, label %cleanup

if.end57:                                         ; preds = %if.end53
  %14 = bitcast %struct.usb_ctrlrequest* %13 to i8*
  %buffer58 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %15 = load i8*, i8** %buffer58, align 8, !tbaa !214
  %call59 = call i64 @copy_from_user(i8* %14, i8* %15, i64 8)
  %tobool60 = icmp ne i64 %call59, 0
  br i1 %tobool60, label %error, label %if.end62

if.end62:                                         ; preds = %if.end57
  %buffer_length63 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %16 = load i32, i32* %buffer_length63, align 8, !tbaa !213
  %wLength = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 4
  %call64 = call zeroext i16 @__le16_to_cpup(i16* %wLength)
  %conv65 = zext i16 %call64 to i32
  %add = add nsw i32 %conv65, 8
  %cmp66 = icmp slt i32 %16, %add
  br i1 %cmp66, label %error, label %if.end69

if.end69:                                         ; preds = %if.end62
  %bRequestType = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 0
  %17 = load i8, i8* %bRequestType, align 1, !tbaa !217
  %conv70 = zext i8 %17 to i32
  %bRequest = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 1
  %18 = load i8, i8* %bRequest, align 1, !tbaa !219
  %conv71 = zext i8 %18 to i32
  %wIndex = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 3
  %call72 = call zeroext i16 @__le16_to_cpup(i16* %wIndex)
  %conv73 = zext i16 %call72 to i32
  %call74 = call i32 @check_ctrlrecip(%struct.dev_state* %ps, i32 %conv70, i32 %conv71, i32 %conv73)
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %error, label %if.end77

if.end77:                                         ; preds = %if.end69
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  store i32 0, i32* %number_of_packets, align 4, !tbaa !220
  %wLength78 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 4
  %call79 = call zeroext i16 @__le16_to_cpup(i16* %wLength78)
  %conv80 = zext i16 %call79 to i32
  %buffer_length81 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  store i32 %conv80, i32* %buffer_length81, align 8, !tbaa !213
  %buffer82 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %19 = load i8*, i8** %buffer82, align 8, !tbaa !214
  %add.ptr = getelementptr i8, i8* %19, i64 8
  store i8* %add.ptr, i8** %buffer82, align 8, !tbaa !214
  %bRequestType83 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 0
  %20 = load i8, i8* %bRequestType83, align 1, !tbaa !217
  %conv84 = zext i8 %20 to i32
  %and85 = and i32 %conv84, 128
  %tobool86 = icmp ne i32 %and85, 0
  br i1 %tobool86, label %land.lhs.true87, label %if.else94

land.lhs.true87:                                  ; preds = %if.end77
  %buffer_length88 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %21 = load i32, i32* %buffer_length88, align 8, !tbaa !213
  %tobool89 = icmp ne i32 %21, 0
  br i1 %tobool89, label %if.then90, label %if.else94

if.then90:                                        ; preds = %land.lhs.true87
  %endpoint91 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %22 = load i8, i8* %endpoint91, align 1, !tbaa !216
  %conv92 = zext i8 %22 to i32
  %or = or i32 %conv92, 128
  br label %if.end99

if.else94:                                        ; preds = %land.lhs.true87, %if.end77
  %endpoint95 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %23 = load i8, i8* %endpoint95, align 1, !tbaa !216
  %conv96 = zext i8 %23 to i32
  %and97 = and i32 %conv96, -129
  br label %if.end99

if.end99:                                         ; preds = %if.else94, %if.then90
  %and97.sink = phi i32 [ %and97, %if.else94 ], [ %or, %if.then90 ]
  %endpoint95.sink = phi i8* [ %endpoint95, %if.else94 ], [ %endpoint91, %if.then90 ]
  %is_in.1 = phi i32 [ 1, %if.then90 ], [ 0, %if.else94 ]
  %conv98 = trunc i32 %and97.sink to i8
  store i8 %conv98, i8* %endpoint95.sink, align 1, !tbaa !216
  %24 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool100 = trunc i8 %24 to i1
  br i1 %tobool100, label %if.then101, label %sw.epilog186

if.then101:                                       ; preds = %if.end99
  %dev102 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %25 = load %struct.usb_device*, %struct.usb_device** %dev102, align 8, !tbaa !44
  %dev103 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %25, i32 0, i32 11
  %bRequestType104 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 0
  %26 = load i8, i8* %bRequestType104, align 1, !tbaa !217
  %conv105 = zext i8 %26 to i32
  %bRequest106 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 1
  %27 = load i8, i8* %bRequest106, align 1, !tbaa !219
  %conv107 = zext i8 %27 to i32
  %wValue = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 2
  %call108 = call zeroext i16 @__le16_to_cpup(i16* %wValue)
  %conv109 = zext i16 %call108 to i32
  %wIndex110 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 3
  %call111 = call zeroext i16 @__le16_to_cpup(i16* %wIndex110)
  %conv112 = zext i16 %call111 to i32
  %wLength113 = getelementptr inbounds %struct.usb_ctrlrequest, %struct.usb_ctrlrequest* %13, i32 0, i32 4
  %call114 = call zeroext i16 @__le16_to_cpup(i16* %wLength113)
  %conv115 = zext i16 %call114 to i32
  %call116 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev103, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @.str.31, i32 0, i32 0), i32 %conv105, i32 %conv107, i32 %conv109, i32 %conv112, i32 %conv115)
  br label %sw.epilog186

sw.bb118:                                         ; preds = %LeafBlock1
  %desc119 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call120 = call i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %desc119)
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %sw.bb118
  %Pivot13 = icmp slt i32 %call120, 3
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %call120, 3
  br i1 %SwitchLeaf11, label %sw.bb122, label %NewDefault7

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp ule i32 %call120, 1
  br i1 %SwitchLeaf9, label %cleanup, label %NewDefault7

sw.bb122:                                         ; preds = %LeafBlock10
  %type123 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  store i8 1, i8* %type123, align 8, !tbaa !215
  br label %interrupt_urb

NewDefault7:                                      ; preds = %LeafBlock10, %LeafBlock8
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault7
  %number_of_packets124 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  store i32 0, i32* %number_of_packets124, align 4, !tbaa !220
  %buffer_length125 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %28 = load i32, i32* %buffer_length125, align 8, !tbaa !213
  %add126 = add nsw i32 %28, 16384
  %sub = sub nsw i32 %add126, 1
  %div = sdiv i32 %sub, 16384
  %cmp127 = icmp eq i32 %div, 1
  br i1 %cmp127, label %if.then132, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %dev129 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %29 = load %struct.usb_device*, %struct.usb_device** %dev129, align 8, !tbaa !44
  %bus = getelementptr inbounds %struct.usb_device, %struct.usb_device* %29, i32 0, i32 9
  %30 = load %struct.usb_bus*, %struct.usb_bus** %bus, align 8, !tbaa !191
  %sg_tablesize = getelementptr inbounds %struct.usb_bus, %struct.usb_bus* %30, i32 0, i32 7
  %31 = load i32, i32* %sg_tablesize, align 4, !tbaa !192
  %cmp130 = icmp ugt i32 %div, %31
  br i1 %cmp130, label %if.then132, label %sw.epilog186

if.then132:                                       ; preds = %lor.lhs.false, %sw.epilog
  br label %sw.epilog186

sw.bb134:                                         ; preds = %NodeBlock
  %desc135 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call136 = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %desc135)
  %tobool137 = icmp ne i32 %call136, 0
  br i1 %tobool137, label %interrupt_urb, label %cleanup

interrupt_urb:                                    ; preds = %sw.bb134, %sw.bb122
  %number_of_packets140 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  store i32 0, i32* %number_of_packets140, align 4, !tbaa !220
  br label %sw.epilog186

sw.bb141:                                         ; preds = %LeafBlock
  %number_of_packets142 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %32 = load i32, i32* %number_of_packets142, align 4, !tbaa !220
  %cmp143 = icmp slt i32 %32, 1
  br i1 %cmp143, label %cleanup, label %lor.lhs.false145

lor.lhs.false145:                                 ; preds = %sw.bb141
  %number_of_packets146 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %33 = load i32, i32* %number_of_packets146, align 4, !tbaa !220
  %cmp147 = icmp sgt i32 %33, 128
  br i1 %cmp147, label %cleanup, label %if.end150

if.end150:                                        ; preds = %lor.lhs.false145
  %desc151 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call152 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc151)
  %tobool153 = icmp ne i32 %call152, 0
  br i1 %tobool153, label %if.end155, label %cleanup

if.end155:                                        ; preds = %if.end150
  %number_of_packets156 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %34 = load i32, i32* %number_of_packets156, align 4, !tbaa !220
  %conv157 = sext i32 %34 to i64
  %mul = mul i64 12, %conv157
  %conv158 = trunc i64 %mul to i32
  %conv159 = zext i32 %conv158 to i64
  %call160 = call i8* @kmalloc(i64 %conv159, i32 208)
  %35 = bitcast i8* %call160 to %struct.usbdevfs_iso_packet_desc*
  %tobool161 = icmp ne %struct.usbdevfs_iso_packet_desc* %35, null
  br i1 %tobool161, label %if.end163, label %cleanup

if.end163:                                        ; preds = %if.end155
  %36 = bitcast %struct.usbdevfs_iso_packet_desc* %35 to i8*
  %37 = bitcast %struct.usbdevfs_iso_packet_desc* %iso_frame_desc to i8*
  %conv164 = zext i32 %conv158 to i64
  %call165 = call i64 @copy_from_user(i8* %36, i8* %37, i64 %conv164)
  %tobool166 = icmp ne i64 %call165, 0
  br i1 %tobool166, label %error, label %if.end168

if.end168:                                        ; preds = %if.end163
  br label %for.cond

for.cond:                                         ; preds = %if.end177, %if.end168
  %totlen.0 = phi i32 [ 0, %if.end168 ], [ %add181, %if.end177 ]
  %u.0 = phi i32 [ 0, %if.end168 ], [ %inc, %if.end177 ]
  %number_of_packets169 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %38 = load i32, i32* %number_of_packets169, align 4, !tbaa !220
  %cmp170 = icmp ult i32 %u.0, %38
  %idxprom172 = zext i32 %u.0 to i64
  br i1 %cmp170, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arrayidx173 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %35, i64 %idxprom172
  %length = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx173, i32 0, i32 0
  %39 = load i32, i32* %length, align 4, !tbaa !221
  %cmp174 = icmp ugt i32 %39, 49152
  br i1 %cmp174, label %error, label %if.end177

if.end177:                                        ; preds = %for.body
  %idxprom178 = zext i32 %u.0 to i64
  %arrayidx179 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %35, i64 %idxprom178
  %length180 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx179, i32 0, i32 0
  %40 = load i32, i32* %length180, align 4, !tbaa !221
  %add181 = add i32 %totlen.0, %40
  %inc = add i32 %u.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %mul183 = mul i64 %idxprom172, 16
  %conv184 = trunc i64 %mul183 to i32
  %buffer_length185 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  store i32 %totlen.0, i32* %buffer_length185, align 8, !tbaa !213
  br label %sw.epilog186

sw.epilog186:                                     ; preds = %lor.lhs.false, %if.then132, %if.end99, %if.then101, %for.end, %interrupt_urb
  %u.1 = phi i32 [ %conv184, %for.end ], [ 0, %interrupt_urb ], [ 8, %if.then101 ], [ 8, %if.end99 ], [ 0, %if.then132 ], [ 0, %lor.lhs.false ]
  %dr.0 = phi %struct.usb_ctrlrequest* [ null, %for.end ], [ null, %interrupt_urb ], [ %13, %if.then101 ], [ %13, %if.end99 ], [ null, %if.then132 ], [ null, %lor.lhs.false ]
  %isopkt.0 = phi %struct.usbdevfs_iso_packet_desc* [ %35, %for.end ], [ null, %interrupt_urb ], [ null, %if.then101 ], [ null, %if.end99 ], [ null, %if.then132 ], [ null, %lor.lhs.false ]
  %is_in.2 = phi i32 [ %is_in.0, %for.end ], [ %is_in.0, %interrupt_urb ], [ %is_in.1, %if.then101 ], [ %is_in.1, %if.end99 ], [ %is_in.0, %if.then132 ], [ %is_in.0, %lor.lhs.false ]
  %num_sgs.1 = phi i32 [ 0, %for.end ], [ 0, %interrupt_urb ], [ 0, %if.then101 ], [ 0, %if.end99 ], [ 0, %if.then132 ], [ %div, %lor.lhs.false ]
  %buffer_length187 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %41 = load i32, i32* %buffer_length187, align 8, !tbaa !213
  %cmp188 = icmp uge i32 %41, 2146483647
  br i1 %cmp188, label %error, label %if.end191

if.end191:                                        ; preds = %sw.epilog186
  %buffer_length192 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %42 = load i32, i32* %buffer_length192, align 8, !tbaa !213
  %cmp193 = icmp sgt i32 %42, 0
  br i1 %cmp193, label %land.lhs.true195, label %if.end207

land.lhs.true195:                                 ; preds = %if.end191
  %buffer196 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %43 = load i8*, i8** %buffer196, align 8, !tbaa !214
  %buffer_length197 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %44 = load i32, i32* %buffer_length197, align 8, !tbaa !213
  %conv198 = sext i32 %44 to i64
  %call199 = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call199, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %45 = load i64, i64* %seg, align 8, !tbaa !132
  %46 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(i8* %43, i64 %conv198, i64 %45) #8, !srcloc !223
  %asmresult = extractvalue { i64, i64 } %46, 0
  %asmresult200 = extractvalue { i64, i64 } %46, 1
  %cmp201 = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp201, true
  %lnot203 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot203 to i32
  %conv204 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv204, i64 1)
  %tobool205 = icmp ne i64 %expval, 0
  br i1 %tobool205, label %if.end207, label %error

if.end207:                                        ; preds = %land.lhs.true195, %if.end191
  %number_of_packets208 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %47 = load i32, i32* %number_of_packets208, align 4, !tbaa !220
  %call209 = call %struct.async* @alloc_async(i32 %47)
  %tobool210 = icmp ne %struct.async* %call209, null
  br i1 %tobool210, label %if.end212, label %error

if.end212:                                        ; preds = %if.end207
  %buffer_length213 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %48 = load i32, i32* %buffer_length213, align 8, !tbaa !213
  %conv214 = sext i32 %48 to i64
  %add215 = add i64 280, %conv214
  %conv216 = sext i32 %num_sgs.1 to i64
  %mul217 = mul i64 %conv216, 32
  %add218 = add i64 %add215, %mul217
  %conv219 = zext i32 %u.1 to i64
  %add220 = add i64 %conv219, %add218
  %conv221 = trunc i64 %add220 to i32
  %call222 = call i32 @usbfs_increase_memory_usage(i32 %conv221)
  %tobool223 = icmp ne i32 %call222, 0
  br i1 %tobool223, label %error, label %if.end225

if.end225:                                        ; preds = %if.end212
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 9
  store i32 %conv221, i32* %mem_usage, align 8, !tbaa !224
  %tobool226 = icmp ne i32 %num_sgs.1, 0
  br i1 %tobool226, label %if.then227, label %if.else275

if.then227:                                       ; preds = %if.end225
  %conv228 = sext i32 %num_sgs.1 to i64
  %mul229 = mul i64 %conv228, 32
  %call230 = call i8* @kmalloc(i64 %mul229, i32 208)
  %49 = bitcast i8* %call230 to %struct.scatterlist*
  %urb = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %50 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !120
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %50, i32 0, i32 16
  store %struct.scatterlist* %49, %struct.scatterlist** %sg, align 8, !tbaa !225
  %urb231 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %51 = load %struct.urb*, %struct.urb** %urb231, align 8, !tbaa !120
  %sg232 = getelementptr inbounds %struct.urb, %struct.urb* %51, i32 0, i32 16
  %52 = load %struct.scatterlist*, %struct.scatterlist** %sg232, align 8, !tbaa !225
  %tobool233 = icmp ne %struct.scatterlist* %52, null
  br i1 %tobool233, label %if.end235, label %error

if.end235:                                        ; preds = %if.then227
  %urb236 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %53 = load %struct.urb*, %struct.urb** %urb236, align 8, !tbaa !120
  %num_sgs237 = getelementptr inbounds %struct.urb, %struct.urb* %53, i32 0, i32 18
  store i32 %num_sgs.1, i32* %num_sgs237, align 4, !tbaa !227
  %urb238 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %54 = load %struct.urb*, %struct.urb** %urb238, align 8, !tbaa !120
  %sg239 = getelementptr inbounds %struct.urb, %struct.urb* %54, i32 0, i32 16
  %55 = load %struct.scatterlist*, %struct.scatterlist** %sg239, align 8, !tbaa !225
  %urb240 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %56 = load %struct.urb*, %struct.urb** %urb240, align 8, !tbaa !120
  %num_sgs241 = getelementptr inbounds %struct.urb, %struct.urb* %56, i32 0, i32 18
  %57 = load i32, i32* %num_sgs241, align 4, !tbaa !227
  call void @sg_init_table(%struct.scatterlist* %55, i32 %57)
  %buffer_length242 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %58 = load i32, i32* %buffer_length242, align 8, !tbaa !213
  br label %for.cond243

for.cond243:                                      ; preds = %if.end270, %if.end235
  %i.0 = phi i32 [ 0, %if.end235 ], [ %inc273, %if.end270 ]
  %totlen.1 = phi i32 [ %58, %if.end235 ], [ %sub271, %if.end270 ]
  %urb244 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %59 = load %struct.urb*, %struct.urb** %urb244, align 8, !tbaa !120
  %num_sgs245 = getelementptr inbounds %struct.urb, %struct.urb* %59, i32 0, i32 18
  %60 = load i32, i32* %num_sgs245, align 4, !tbaa !227
  %cmp246 = icmp slt i32 %i.0, %60
  br i1 %cmp246, label %for.body248, label %if.end313

for.body248:                                      ; preds = %for.cond243
  %cmp249 = icmp ugt i32 %totlen.1, 16384
  %.totlen.1 = select i1 %cmp249, i32 16384, i32 %totlen.1
  %conv251 = zext i32 %.totlen.1 to i64
  %call252 = call i8* @kmalloc(i64 %conv251, i32 208)
  %tobool253 = icmp ne i8* %call252, null
  br i1 %tobool253, label %if.end255, label %error

if.end255:                                        ; preds = %for.body248
  %urb256 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %61 = load %struct.urb*, %struct.urb** %urb256, align 8, !tbaa !120
  %sg257 = getelementptr inbounds %struct.urb, %struct.urb* %61, i32 0, i32 16
  %62 = load %struct.scatterlist*, %struct.scatterlist** %sg257, align 8, !tbaa !225
  %idxprom258 = sext i32 %i.0 to i64
  %arrayidx259 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %62, i64 %idxprom258
  call void @sg_set_buf(%struct.scatterlist* %arrayidx259, i8* %call252, i32 %.totlen.1)
  %tobool260 = icmp ne i32 %is_in.2, 0
  br i1 %tobool260, label %if.end270, label %if.then261

if.then261:                                       ; preds = %if.end255
  %buffer262 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %63 = load i8*, i8** %buffer262, align 8, !tbaa !214
  %conv263 = zext i32 %.totlen.1 to i64
  %call264 = call i64 @copy_from_user(i8* %call252, i8* %63, i64 %conv263)
  %tobool265 = icmp ne i64 %call264, 0
  br i1 %tobool265, label %error, label %if.end267

if.end267:                                        ; preds = %if.then261
  %buffer268 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %64 = load i8*, i8** %buffer268, align 8, !tbaa !214
  %idx.ext = zext i32 %.totlen.1 to i64
  %add.ptr269 = getelementptr i8, i8* %64, i64 %idx.ext
  store i8* %add.ptr269, i8** %buffer268, align 8, !tbaa !214
  br label %if.end270

if.end270:                                        ; preds = %if.end267, %if.end255
  %sub271 = sub i32 %totlen.1, %.totlen.1
  %inc273 = add nsw i32 %i.0, 1
  br label %for.cond243

if.else275:                                       ; preds = %if.end225
  %buffer_length276 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %65 = load i32, i32* %buffer_length276, align 8, !tbaa !213
  %cmp277 = icmp sgt i32 %65, 0
  br i1 %cmp277, label %if.then279, label %if.end313

if.then279:                                       ; preds = %if.else275
  %buffer_length280 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %66 = load i32, i32* %buffer_length280, align 8, !tbaa !213
  %conv281 = sext i32 %66 to i64
  %call282 = call i8* @kmalloc(i64 %conv281, i32 208)
  %urb283 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %67 = load %struct.urb*, %struct.urb** %urb283, align 8, !tbaa !120
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %67, i32 0, i32 14
  store i8* %call282, i8** %transfer_buffer, align 8, !tbaa !228
  %urb284 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %68 = load %struct.urb*, %struct.urb** %urb284, align 8, !tbaa !120
  %transfer_buffer285 = getelementptr inbounds %struct.urb, %struct.urb* %68, i32 0, i32 14
  %69 = load i8*, i8** %transfer_buffer285, align 8, !tbaa !228
  %tobool286 = icmp ne i8* %69, null
  br i1 %tobool286, label %if.end288, label %error

if.end288:                                        ; preds = %if.then279
  %tobool289 = icmp ne i32 %is_in.2, 0
  br i1 %tobool289, label %if.else300, label %if.then290

if.then290:                                       ; preds = %if.end288
  %urb291 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %70 = load %struct.urb*, %struct.urb** %urb291, align 8, !tbaa !120
  %transfer_buffer292 = getelementptr inbounds %struct.urb, %struct.urb* %70, i32 0, i32 14
  %71 = load i8*, i8** %transfer_buffer292, align 8, !tbaa !228
  %buffer293 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %72 = load i8*, i8** %buffer293, align 8, !tbaa !214
  %buffer_length294 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %73 = load i32, i32* %buffer_length294, align 8, !tbaa !213
  %conv295 = sext i32 %73 to i64
  %call296 = call i64 @copy_from_user(i8* %71, i8* %72, i64 %conv295)
  %tobool297 = icmp ne i64 %call296, 0
  br i1 %tobool297, label %error, label %if.end313

if.else300:                                       ; preds = %if.end288
  %type301 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %74 = load i8, i8* %type301, align 8, !tbaa !215
  %conv302 = zext i8 %74 to i32
  %cmp303 = icmp eq i32 %conv302, 0
  br i1 %cmp303, label %if.then305, label %if.end313

if.then305:                                       ; preds = %if.else300
  %urb306 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %75 = load %struct.urb*, %struct.urb** %urb306, align 8, !tbaa !120
  %transfer_buffer307 = getelementptr inbounds %struct.urb, %struct.urb* %75, i32 0, i32 14
  %76 = load i8*, i8** %transfer_buffer307, align 8, !tbaa !228
  %buffer_length308 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %77 = load i32, i32* %buffer_length308, align 8, !tbaa !213
  %conv309 = sext i32 %77 to i64
  call void @llvm.memset.p0i8.i64(i8* %76, i8 0, i64 %conv309, i32 1, i1 false)
  br label %if.end313

if.end313:                                        ; preds = %if.else275, %if.else300, %if.then305, %if.then290, %for.cond243
  %dev314 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %78 = load %struct.usb_device*, %struct.usb_device** %dev314, align 8, !tbaa !44
  %urb315 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %79 = load %struct.urb*, %struct.urb** %urb315, align 8, !tbaa !120
  %dev316 = getelementptr inbounds %struct.urb, %struct.urb* %79, i32 0, i32 8
  store %struct.usb_device* %78, %struct.usb_device** %dev316, align 8, !tbaa !229
  %type317 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %80 = load i8, i8* %type317, align 8, !tbaa !215
  %conv318 = zext i8 %80 to i32
  %shl = shl i32 %conv318, 30
  %dev319 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %81 = load %struct.usb_device*, %struct.usb_device** %dev319, align 8, !tbaa !44
  %endpoint320 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %82 = load i8, i8* %endpoint320, align 1, !tbaa !216
  %conv321 = zext i8 %82 to i32
  %and322 = and i32 %conv321, 15
  %call323 = call i32 @__create_pipe(%struct.usb_device* %81, i32 %and322)
  %or324 = or i32 %shl, %call323
  %endpoint325 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 1
  %83 = load i8, i8* %endpoint325, align 1, !tbaa !216
  %conv326 = zext i8 %83 to i32
  %and327 = and i32 %conv326, 128
  %or328 = or i32 %or324, %and327
  %urb329 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %84 = load %struct.urb*, %struct.urb** %urb329, align 8, !tbaa !120
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %84, i32 0, i32 10
  store i32 %or328, i32* %pipe, align 8, !tbaa !230
  %tobool330 = icmp ne i32 %is_in.2, 0
  %85 = zext i1 %tobool330 to i64
  %cond331 = select i1 %tobool330, i32 512, i32 0
  %flags332 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %86 = load i32, i32* %flags332, align 8, !tbaa !211
  %and333 = and i32 %86, 2
  %tobool334 = icmp ne i32 %and333, 0
  %or336 = or i32 %cond331, 2
  %or336.cond331 = select i1 %tobool334, i32 %or336, i32 %cond331
  %flags338 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %87 = load i32, i32* %flags338, align 8, !tbaa !211
  %and339 = and i32 %87, 1
  %tobool340 = icmp ne i32 %and339, 0
  %or342 = or i32 %or336.cond331, 1
  %u.3 = select i1 %tobool340, i32 %or342, i32 %or336.cond331
  %flags344 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %88 = load i32, i32* %flags344, align 8, !tbaa !211
  %and345 = and i32 %88, 32
  %tobool346 = icmp ne i32 %and345, 0
  %or348 = or i32 %u.3, 32
  %or348.u.3 = select i1 %tobool346, i32 %or348, i32 %u.3
  %flags350 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %89 = load i32, i32* %flags350, align 8, !tbaa !211
  %and351 = and i32 %89, 64
  %tobool352 = icmp ne i32 %and351, 0
  %or354 = or i32 %or348.u.3, 64
  %u.5 = select i1 %tobool352, i32 %or354, i32 %or348.u.3
  %flags356 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %90 = load i32, i32* %flags356, align 8, !tbaa !211
  %and357 = and i32 %90, 128
  %tobool358 = icmp ne i32 %and357, 0
  %or360 = or i32 %u.5, 128
  %or360.u.5 = select i1 %tobool358, i32 %or360, i32 %u.5
  %urb362 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %91 = load %struct.urb*, %struct.urb** %urb362, align 8, !tbaa !120
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %91, i32 0, i32 13
  store i32 %or360.u.5, i32* %transfer_flags, align 4, !tbaa !231
  %buffer_length363 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %92 = load i32, i32* %buffer_length363, align 8, !tbaa !213
  %urb364 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %93 = load %struct.urb*, %struct.urb** %urb364, align 8, !tbaa !120
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %93, i32 0, i32 19
  store i32 %92, i32* %transfer_buffer_length, align 8, !tbaa !232
  %94 = bitcast %struct.usb_ctrlrequest* %dr.0 to i8*
  %urb365 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %95 = load %struct.urb*, %struct.urb** %urb365, align 8, !tbaa !120
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %95, i32 0, i32 21
  store i8* %94, i8** %setup_packet, align 8, !tbaa !233
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 7
  %96 = load i32, i32* %start_frame, align 8, !tbaa !234
  %urb366 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %97 = load %struct.urb*, %struct.urb** %urb366, align 8, !tbaa !120
  %start_frame367 = getelementptr inbounds %struct.urb, %struct.urb* %97, i32 0, i32 23
  store i32 %96, i32* %start_frame367, align 8, !tbaa !235
  %number_of_packets368 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %98 = load i32, i32* %number_of_packets368, align 4, !tbaa !220
  %urb369 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %99 = load %struct.urb*, %struct.urb** %urb369, align 8, !tbaa !120
  %number_of_packets370 = getelementptr inbounds %struct.urb, %struct.urb* %99, i32 0, i32 24
  store i32 %98, i32* %number_of_packets370, align 4, !tbaa !236
  %type371 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 0
  %100 = load i8, i8* %type371, align 8, !tbaa !215
  %conv372 = zext i8 %100 to i32
  %cmp373 = icmp eq i32 %conv372, 0
  br i1 %cmp373, label %if.then379, label %lor.lhs.false375

lor.lhs.false375:                                 ; preds = %if.end313
  %dev376 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %101 = load %struct.usb_device*, %struct.usb_device** %dev376, align 8, !tbaa !44
  %speed = getelementptr inbounds %struct.usb_device, %struct.usb_device* %101, i32 0, i32 4
  %102 = load i32, i32* %speed, align 4, !tbaa !153
  %cmp377 = icmp eq i32 %102, 3
  br i1 %cmp377, label %if.then379, label %if.else394

if.then379:                                       ; preds = %lor.lhs.false375, %if.end313
  %103 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %103) #7
  store i32 15, i32* %_min1, align 4, !tbaa !62
  %104 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %104) #7
  %desc380 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc380, i32 0, i32 5
  %105 = load i8, i8* %bInterval, align 2, !tbaa !237
  %conv381 = zext i8 %105 to i32
  %sub382 = sub nsw i32 %conv381, 1
  store i32 %sub382, i32* %_min2, align 4, !tbaa !62
  %cmp383 = icmp eq i32* %_min1, %_min2
  %conv384 = zext i1 %cmp383 to i32
  %106 = load i32, i32* %_min1, align 4, !tbaa !62
  %107 = load i32, i32* %_min2, align 4, !tbaa !62
  %cmp386 = icmp slt i32 %106, %107
  %108 = load i32, i32* %_min1, align 4
  %109 = load i32, i32* %_min2, align 4
  %cond391 = select i1 %cmp386, i32 %108, i32 %109
  %110 = bitcast i32* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %110) #7
  %111 = bitcast i32* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %111) #7
  %shl392 = shl i32 1, %cond391
  br label %if.end400

if.else394:                                       ; preds = %lor.lhs.false375
  %desc395 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %bInterval396 = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc395, i32 0, i32 5
  %112 = load i8, i8* %bInterval396, align 2, !tbaa !237
  %conv397 = zext i8 %112 to i32
  br label %if.end400

if.end400:                                        ; preds = %if.else394, %if.then379
  %conv397.sink = phi i32 [ %conv397, %if.else394 ], [ %shl392, %if.then379 ]
  %urb398 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %113 = load %struct.urb*, %struct.urb** %urb398, align 8, !tbaa !120
  %interval399 = getelementptr inbounds %struct.urb, %struct.urb* %113, i32 0, i32 25
  store i32 %conv397.sink, i32* %interval399, align 8, !tbaa !238
  %114 = bitcast %struct.async* %call209 to i8*
  %urb401 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %115 = load %struct.urb*, %struct.urb** %urb401, align 8, !tbaa !120
  %context = getelementptr inbounds %struct.urb, %struct.urb* %115, i32 0, i32 27
  store i8* %114, i8** %context, align 8, !tbaa !239
  %urb402 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %116 = load %struct.urb*, %struct.urb** %urb402, align 8, !tbaa !120
  %complete = getelementptr inbounds %struct.urb, %struct.urb* %116, i32 0, i32 28
  store void (%struct.urb*)* @async_completed, void (%struct.urb*)** %complete, align 8, !tbaa !240
  br label %for.cond403

for.cond403:                                      ; preds = %for.body407, %if.end400
  %totlen.2 = phi i32 [ 0, %if.end400 ], [ %add423, %for.body407 ]
  %u.7 = phi i32 [ 0, %if.end400 ], [ %inc425, %for.body407 ]
  %number_of_packets404 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 8
  %117 = load i32, i32* %number_of_packets404, align 4, !tbaa !220
  %cmp405 = icmp ult i32 %u.7, %117
  br i1 %cmp405, label %for.body407, label %for.end426

for.body407:                                      ; preds = %for.cond403
  %urb408 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %118 = load %struct.urb*, %struct.urb** %urb408, align 8, !tbaa !120
  %iso_frame_desc409 = getelementptr inbounds %struct.urb, %struct.urb* %118, i32 0, i32 29
  %idxprom410 = zext i32 %u.7 to i64
  %arrayidx411 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc409, i64 0, i64 %idxprom410
  %offset = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx411, i32 0, i32 0
  store i32 %totlen.2, i32* %offset, align 8, !tbaa !241
  %idxprom412 = zext i32 %u.7 to i64
  %arrayidx413 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %isopkt.0, i64 %idxprom412
  %length414 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx413, i32 0, i32 0
  %119 = load i32, i32* %length414, align 4, !tbaa !221
  %urb415 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %120 = load %struct.urb*, %struct.urb** %urb415, align 8, !tbaa !120
  %iso_frame_desc416 = getelementptr inbounds %struct.urb, %struct.urb* %120, i32 0, i32 29
  %idxprom417 = zext i32 %u.7 to i64
  %arrayidx418 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc416, i64 0, i64 %idxprom417
  %length419 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx418, i32 0, i32 1
  store i32 %119, i32* %length419, align 4, !tbaa !243
  %idxprom420 = zext i32 %u.7 to i64
  %arrayidx421 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %isopkt.0, i64 %idxprom420
  %length422 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx421, i32 0, i32 0
  %121 = load i32, i32* %length422, align 4, !tbaa !221
  %add423 = add i32 %totlen.2, %121
  %inc425 = add i32 %u.7, 1
  br label %for.cond403

for.end426:                                       ; preds = %for.cond403
  %122 = bitcast %struct.usbdevfs_iso_packet_desc* %isopkt.0 to i8*
  call void @kfree(i8* %122)
  %ps427 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 1
  store %struct.dev_state* %ps, %struct.dev_state** %ps427, align 8, !tbaa !244
  %userurb = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 7
  store i8* %arg, i8** %userurb, align 8, !tbaa !245
  %tobool428 = icmp ne i32 %is_in.2, 0
  br i1 %tobool428, label %land.lhs.true429, label %if.end437

land.lhs.true429:                                 ; preds = %for.end426
  %buffer_length430 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 5
  %123 = load i32, i32* %buffer_length430, align 8, !tbaa !213
  %cmp431 = icmp sgt i32 %123, 0
  br i1 %cmp431, label %if.then433, label %if.end437

if.then433:                                       ; preds = %land.lhs.true429
  %buffer434 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 4
  %124 = load i8*, i8** %buffer434, align 8, !tbaa !214
  br label %if.end437

if.end437:                                        ; preds = %for.end426, %land.lhs.true429, %if.then433
  %.sink = phi i8* [ %124, %if.then433 ], [ null, %land.lhs.true429 ], [ null, %for.end426 ]
  %userbuffer436 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 6
  store i8* %.sink, i8** %userbuffer436, align 8, !tbaa !246
  %signr = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 10
  %125 = load i32, i32* %signr, align 4, !tbaa !247
  %signr438 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 4
  store i32 %125, i32* %signr438, align 8, !tbaa !248
  %ifnum439 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 5
  store i32 %ifnum.0, i32* %ifnum439, align 4, !tbaa !117
  %call440 = call %struct.task_struct* @get_current()
  %call441 = call %struct.pid* @task_pid(%struct.task_struct* %call440)
  %call442 = call %struct.pid* @get_pid(%struct.pid* %call441)
  %pid = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 2
  store %struct.pid* %call442, %struct.pid** %pid, align 8, !tbaa !249
  %call447 = call %struct.task_struct* @get_current()
  %cred = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call447, i32 0, i32 63
  %126 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !79
  %call448 = call %struct.cred* @get_cred(%struct.cred* %126)
  %cred449 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 3
  store %struct.cred* %call448, %struct.cred** %cred449, align 8, !tbaa !250
  %call450 = call %struct.task_struct* @get_current()
  %secid = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 11
  call void @security_task_getsecid(%struct.task_struct* %call450, i32* %secid)
  %dev451 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %127 = load %struct.usb_device*, %struct.usb_device** %dev451, align 8, !tbaa !44
  %userurb452 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 7
  %128 = load i8*, i8** %userurb452, align 8, !tbaa !245
  %urb453 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %129 = load %struct.urb*, %struct.urb** %urb453, align 8, !tbaa !120
  %pipe454 = getelementptr inbounds %struct.urb, %struct.urb* %129, i32 0, i32 10
  %130 = load i32, i32* %pipe454, align 8, !tbaa !230
  %urb455 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %131 = load %struct.urb*, %struct.urb** %urb455, align 8, !tbaa !120
  %transfer_buffer_length456 = getelementptr inbounds %struct.urb, %struct.urb* %131, i32 0, i32 19
  %132 = load i32, i32* %transfer_buffer_length456, align 8, !tbaa !232
  call void @snoop_urb(%struct.usb_device* %127, i8* %128, i32 %130, i32 %132, i32 0, i32 0, i8* null, i32 0)
  %tobool457 = icmp ne i32 %is_in.2, 0
  br i1 %tobool457, label %if.end462, label %if.then458

if.then458:                                       ; preds = %if.end437
  %urb459 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %133 = load %struct.urb*, %struct.urb** %urb459, align 8, !tbaa !120
  %urb460 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %134 = load %struct.urb*, %struct.urb** %urb460, align 8, !tbaa !120
  %transfer_buffer_length461 = getelementptr inbounds %struct.urb, %struct.urb* %134, i32 0, i32 19
  %135 = load i32, i32* %transfer_buffer_length461, align 8, !tbaa !232
  call void @snoop_urb_data(%struct.urb* %133, i32 %135)
  br label %if.end462

if.end462:                                        ; preds = %if.then458, %if.end437
  call void @async_newpending(%struct.async* %call209)
  %desc463 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call464 = call i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %desc463)
  %tobool465 = icmp ne i32 %call464, 0
  br i1 %tobool465, label %if.then466, label %if.else496

if.then466:                                       ; preds = %if.end462
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_lock_irq(%struct.spinlock* %lock)
  %desc467 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %call468 = call i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %desc467)
  %desc469 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %10, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc469, i32 0, i32 2
  %136 = load i8, i8* %bEndpointAddress, align 2, !tbaa !251
  %conv470 = zext i8 %136 to i32
  %and471 = and i32 %conv470, 128
  %shr = ashr i32 %and471, 3
  %or472 = or i32 %call468, %shr
  %conv473 = trunc i32 %or472 to i8
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 12
  store i8 %conv473, i8* %bulk_addr, align 4, !tbaa !252
  %flags474 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %uurb, i32 0, i32 3
  %137 = load i32, i32* %flags474, align 8, !tbaa !211
  %and475 = and i32 %137, 4
  %tobool476 = icmp ne i32 %and475, 0
  br i1 %tobool476, label %if.then477, label %if.else478

if.then477:                                       ; preds = %if.then466
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 13
  store i8 1, i8* %bulk_status, align 1, !tbaa !253
  br label %if.end483

if.else478:                                       ; preds = %if.then466
  %bulk_addr479 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 12
  %138 = load i8, i8* %bulk_addr479, align 4, !tbaa !252
  %conv480 = zext i8 %138 to i32
  %shl481 = shl i32 1, %conv480
  %neg = xor i32 %shl481, -1
  %disabled_bulk_eps = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 13
  %139 = load i32, i32* %disabled_bulk_eps, align 4, !tbaa !254
  %and482 = and i32 %139, %neg
  store i32 %and482, i32* %disabled_bulk_eps, align 4, !tbaa !254
  br label %if.end483

if.end483:                                        ; preds = %if.else478, %if.then477
  %disabled_bulk_eps484 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 13
  %140 = load i32, i32* %disabled_bulk_eps484, align 4, !tbaa !254
  %bulk_addr485 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 12
  %141 = load i8, i8* %bulk_addr485, align 4, !tbaa !252
  %conv486 = zext i8 %141 to i32
  %shl487 = shl i32 1, %conv486
  %and488 = and i32 %140, %shl487
  %tobool489 = icmp ne i32 %and488, 0
  br i1 %tobool489, label %if.end494, label %if.else491

if.else491:                                       ; preds = %if.end483
  %urb492 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %142 = load %struct.urb*, %struct.urb** %urb492, align 8, !tbaa !120
  %call493 = call i32 @usb_submit_urb(%struct.urb* %142, i32 32)
  br label %if.end494

if.end494:                                        ; preds = %if.end483, %if.else491
  %ret.0 = phi i32 [ %call493, %if.else491 ], [ -121, %if.end483 ]
  %lock495 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irq(%struct.spinlock* %lock495)
  br label %if.end499

if.else496:                                       ; preds = %if.end462
  %urb497 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %143 = load %struct.urb*, %struct.urb** %urb497, align 8, !tbaa !120
  %call498 = call i32 @usb_submit_urb(%struct.urb* %143, i32 208)
  br label %if.end499

if.end499:                                        ; preds = %if.else496, %if.end494
  %ret.1 = phi i32 [ %ret.0, %if.end494 ], [ %call498, %if.else496 ]
  %tobool500 = icmp ne i32 %ret.1, 0
  br i1 %tobool500, label %if.then501, label %cleanup

if.then501:                                       ; preds = %if.end499
  %dev502 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %144 = load %struct.usb_device*, %struct.usb_device** %dev502, align 8, !tbaa !44
  %dev503 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %144, i32 0, i32 11
  %call504 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev503, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.48, i32 0, i32 0), i32 %ret.1)
  %dev505 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %145 = load %struct.usb_device*, %struct.usb_device** %dev505, align 8, !tbaa !44
  %userurb506 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 7
  %146 = load i8*, i8** %userurb506, align 8, !tbaa !245
  %urb507 = getelementptr inbounds %struct.async, %struct.async* %call209, i32 0, i32 8
  %147 = load %struct.urb*, %struct.urb** %urb507, align 8, !tbaa !120
  %pipe508 = getelementptr inbounds %struct.urb, %struct.urb* %147, i32 0, i32 10
  %148 = load i32, i32* %pipe508, align 8, !tbaa !230
  call void @snoop_urb(%struct.usb_device* %145, i8* %146, i32 %148, i32 0, i32 %ret.1, i32 1, i8* null, i32 0)
  call void @async_removepending(%struct.async* %call209)
  br label %error

error:                                            ; preds = %if.then290, %if.then279, %if.then261, %for.body248, %if.then227, %if.end212, %if.end207, %land.lhs.true195, %sw.epilog186, %for.body, %if.end163, %if.end69, %if.end62, %if.end57, %if.then501
  %ret.2 = phi i32 [ %ret.1, %if.then501 ], [ -14, %if.end57 ], [ -22, %if.end62 ], [ %call74, %if.end69 ], [ -14, %if.end163 ], [ -22, %for.body ], [ -22, %sw.epilog186 ], [ -14, %land.lhs.true195 ], [ -12, %if.end207 ], [ %call222, %if.end212 ], [ -12, %if.then227 ], [ -12, %for.body248 ], [ -14, %if.then261 ], [ -12, %if.then279 ], [ -14, %if.then290 ]
  %dr.1 = phi %struct.usb_ctrlrequest* [ null, %if.then501 ], [ %13, %if.end57 ], [ %13, %if.end62 ], [ %13, %if.end69 ], [ null, %if.end163 ], [ null, %for.body ], [ %dr.0, %sw.epilog186 ], [ %dr.0, %land.lhs.true195 ], [ %dr.0, %if.end207 ], [ %dr.0, %if.end212 ], [ %dr.0, %if.then227 ], [ %dr.0, %for.body248 ], [ %dr.0, %if.then261 ], [ %dr.0, %if.then279 ], [ %dr.0, %if.then290 ]
  %as.0 = phi %struct.async* [ %call209, %if.then501 ], [ null, %if.end57 ], [ null, %if.end62 ], [ null, %if.end69 ], [ null, %if.end163 ], [ null, %for.body ], [ null, %sw.epilog186 ], [ null, %land.lhs.true195 ], [ %call209, %if.end207 ], [ %call209, %if.end212 ], [ %call209, %if.then227 ], [ %call209, %for.body248 ], [ %call209, %if.then261 ], [ %call209, %if.then279 ], [ %call209, %if.then290 ]
  %isopkt.1 = phi %struct.usbdevfs_iso_packet_desc* [ null, %if.then501 ], [ null, %if.end57 ], [ null, %if.end62 ], [ null, %if.end69 ], [ %35, %if.end163 ], [ %35, %for.body ], [ %isopkt.0, %sw.epilog186 ], [ %isopkt.0, %land.lhs.true195 ], [ %isopkt.0, %if.end207 ], [ %isopkt.0, %if.end212 ], [ %isopkt.0, %if.then227 ], [ %isopkt.0, %for.body248 ], [ %isopkt.0, %if.then261 ], [ %isopkt.0, %if.then279 ], [ %isopkt.0, %if.then290 ]
  %149 = bitcast %struct.usbdevfs_iso_packet_desc* %isopkt.1 to i8*
  call void @kfree(i8* %149)
  %150 = bitcast %struct.usb_ctrlrequest* %dr.1 to i8*
  call void @kfree(i8* %150)
  %tobool510 = icmp ne %struct.async* %as.0, null
  br i1 %tobool510, label %if.then511, label %cleanup

if.then511:                                       ; preds = %error
  call void @free_async(%struct.async* %as.0)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock8, %NewDefault, %error, %if.then511, %if.end499, %if.end155, %if.end150, %sw.bb141, %lor.lhs.false145, %sw.bb134, %if.end53, %if.end48, %sw.bb, %if.end22, %if.end17, %if.then11, %land.lhs.true, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -22, %land.lhs.true ], [ %call, %if.then11 ], [ %call18, %if.end17 ], [ -2, %if.end22 ], [ -22, %sw.bb ], [ -22, %if.end48 ], [ -12, %if.end53 ], [ -22, %LeafBlock8 ], [ -22, %sw.bb134 ], [ -22, %lor.lhs.false145 ], [ -22, %sw.bb141 ], [ -22, %if.end150 ], [ -12, %if.end155 ], [ -22, %NewDefault ], [ 0, %if.end499 ], [ %ret.2, %if.then511 ], [ %ret.2, %error ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_control(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !255
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 0
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_type(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !255
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !255
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !255
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @alloc_async(i32 %numisoframes) #1 {
entry:
  %call = call i8* @kzalloc(i64 88, i32 208)
  %0 = bitcast i8* %call to %struct.async*
  %tobool = icmp ne %struct.async* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call %struct.urb* @usb_alloc_urb(i32 %numisoframes, i32 208)
  %urb = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  store %struct.urb* %call1, %struct.urb** %urb, align 8, !tbaa !120
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %0, i32 0, i32 8
  %1 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !120
  %tobool3 = icmp ne %struct.urb* %1, null
  br i1 %tobool3, label %cleanup, label %if.then4

if.then4:                                         ; preds = %if.end
  %2 = bitcast %struct.async* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.then4
  %retval.0 = phi %struct.async* [ null, %if.then4 ], [ null, %entry ], [ %0, %if.end ]
  ret %struct.async* %retval.0
}

declare void @sg_init_table(%struct.scatterlist*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_buf(%struct.scatterlist* %sg, i8* %buf, i32 %buflen) #0 {
entry:
  %0 = ptrtoint i8* %buf to i64
  %call = call i64 @__phys_addr_nodebug(i64 %0)
  %shr = lshr i64 %call, 12
  %add.ptr = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %1 = ptrtoint i8* %buf to i64
  %and = and i64 %1, 4095
  %conv = trunc i64 %and to i32
  call void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %add.ptr, i32 %buflen, i32 %conv)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define internal void @async_completed(%struct.urb* %urb) #1 {
entry:
  %sinfo = alloca %struct.siginfo, align 8
  %context = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 27
  %0 = load i8*, i8** %context, align 8, !tbaa !239
  %1 = bitcast i8* %0 to %struct.async*
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 1
  %2 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8, !tbaa !244
  %3 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %3) #7
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %lock)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 0
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 5
  call void @list_move_tail(%struct.list_head* %asynclist, %struct.list_head* %async_completed)
  %status = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 12
  %4 = load i32, i32* %status, align 8, !tbaa !256
  %status2 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  store i32 %4, i32* %status2, align 4, !tbaa !257
  %signr3 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 4
  %5 = load i32, i32* %signr3, align 8, !tbaa !248
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %signr4 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 4
  %6 = load i32, i32* %signr4, align 8, !tbaa !248
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %6, i32* %si_signo, align 8, !tbaa !258
  %status5 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %7 = load i32, i32* %status5, align 4, !tbaa !257
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 %7, i32* %si_errno, align 4, !tbaa !260
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8, !tbaa !261
  %userurb = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 7
  %8 = load i8*, i8** %userurb, align 8, !tbaa !245
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.32* %_sifields to %struct.anon.37*
  %_addr = getelementptr inbounds %struct.anon.37, %struct.anon.37* %_sigfault, i32 0, i32 0
  store i8* %8, i8** %_addr, align 8, !tbaa !74
  %pid6 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 2
  %9 = load %struct.pid*, %struct.pid** %pid6, align 8, !tbaa !249
  %call = call %struct.pid* @get_pid(%struct.pid* %9)
  %cred7 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 3
  %10 = load %struct.cred*, %struct.cred** %cred7, align 8, !tbaa !250
  %call8 = call %struct.cred* @get_cred(%struct.cred* %10)
  %secid9 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 11
  %11 = load i32, i32* %secid9, align 8, !tbaa !262
  br label %do.body

do.body:                                          ; preds = %entry, %if.then
  %pid.0 = phi %struct.pid* [ %call, %if.then ], [ null, %entry ]
  %secid.0 = phi i32 [ %11, %if.then ], [ 0, %entry ]
  %cred.0 = phi %struct.cred* [ %call8, %if.then ], [ null, %entry ]
  %12 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool10 = trunc i8 %12 to i1
  br i1 %tobool10, label %if.then11, label %do.end

if.then11:                                        ; preds = %do.body
  %dev = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %13 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !229
  %dev12 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 11
  %call13 = call i32 (%struct.device*, i8*, ...) @_dev_info(%struct.device* %dev12, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.50, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then11, %do.body
  %dev15 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 8
  %14 = load %struct.usb_device*, %struct.usb_device** %dev15, align 8, !tbaa !229
  %userurb16 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 7
  %15 = load i8*, i8** %userurb16, align 8, !tbaa !245
  %pipe = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 10
  %16 = load i32, i32* %pipe, align 8, !tbaa !230
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %17 = load i32, i32* %actual_length, align 4, !tbaa !263
  %status17 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %18 = load i32, i32* %status17, align 4, !tbaa !257
  call void @snoop_urb(%struct.usb_device* %14, i8* %15, i32 %16, i32 %17, i32 %18, i32 1, i8* null, i32 0)
  %transfer_flags = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 13
  %19 = load i32, i32* %transfer_flags, align 4, !tbaa !231
  %and = and i32 %19, 512
  %cmp = icmp eq i32 %and, 128
  br i1 %cmp, label %if.then18, label %if.end20

if.then18:                                        ; preds = %do.end
  %actual_length19 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %20 = load i32, i32* %actual_length19, align 4, !tbaa !263
  call void @snoop_urb_data(%struct.urb* %urb, i32 %20)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %do.end
  %status21 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %21 = load i32, i32* %status21, align 4, !tbaa !257
  %cmp22 = icmp slt i32 %21, 0
  br i1 %cmp22, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.end20
  %bulk_addr = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 12
  %22 = load i8, i8* %bulk_addr, align 4, !tbaa !252
  %conv = zext i8 %22 to i32
  %tobool23 = icmp ne i32 %conv, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end35

land.lhs.true24:                                  ; preds = %land.lhs.true
  %status25 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %23 = load i32, i32* %status25, align 4, !tbaa !257
  %cmp26 = icmp ne i32 %23, -104
  br i1 %cmp26, label %land.lhs.true28, label %if.end35

land.lhs.true28:                                  ; preds = %land.lhs.true24
  %status29 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 10
  %24 = load i32, i32* %status29, align 4, !tbaa !257
  %cmp30 = icmp ne i32 %24, -2
  br i1 %cmp30, label %if.then32, label %if.end35

if.then32:                                        ; preds = %land.lhs.true28
  %bulk_addr33 = getelementptr inbounds %struct.async, %struct.async* %1, i32 0, i32 12
  %25 = load i8, i8* %bulk_addr33, align 4, !tbaa !252
  %conv34 = zext i8 %25 to i32
  call void @cancel_bulk_urbs(%struct.dev_state* %2, i32 %conv34)
  br label %if.end35

if.end35:                                         ; preds = %if.then32, %land.lhs.true28, %land.lhs.true24, %land.lhs.true, %if.end20
  %lock36 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %lock36)
  %tobool37 = icmp ne i32 %5, 0
  br i1 %tobool37, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end35
  %si_signo39 = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  %26 = load i32, i32* %si_signo39, align 8, !tbaa !258
  %call40 = call i32 @kill_pid_info_as_cred(i32 %26, %struct.siginfo* %sinfo, %struct.pid* %pid.0, %struct.cred* %cred.0, i32 %secid.0)
  call void @put_pid(%struct.pid* %pid.0)
  call void @put_cred(%struct.cred* %cred.0)
  br label %if.end41

if.end41:                                         ; preds = %if.then38, %if.end35
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %2, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 1, i8* null)
  %27 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %27) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @get_pid(%struct.pid* %pid) #0 {
entry:
  %tobool = icmp ne %struct.pid* %pid, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count = getelementptr inbounds %struct.pid, %struct.pid* %pid, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.pid* %pid
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.pid* @task_pid(%struct.task_struct* %task) #0 {
entry:
  %pids = getelementptr inbounds %struct.task_struct, %struct.task_struct* %task, i32 0, i32 43
  %arrayidx = getelementptr inbounds [3 x %struct.pid_link], [3 x %struct.pid_link]* %pids, i64 0, i64 0
  %pid = getelementptr inbounds %struct.pid_link, %struct.pid_link* %arrayidx, i32 0, i32 1
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !264
  ret %struct.pid* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cred* @get_cred(%struct.cred* %cred) #0 {
entry:
  call void @validate_creds(%struct.cred* %cred)
  %call = call %struct.cred* @get_new_cred(%struct.cred* %cred)
  ret %struct.cred* %call
}

declare void @security_task_getsecid(%struct.task_struct*, i32*) #3

; Function Attrs: nounwind uwtable
define internal void @snoop_urb_data(%struct.urb* %urb, i32 %len) #1 {
entry:
  %0 = load i8, i8* @usbfs_snoop, align 1, !tbaa !110, !range !111
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %1 = load i32, i32* %num_sgs, align 4, !tbaa !227
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %2 = load i8*, i8** %transfer_buffer, align 8, !tbaa !228
  %conv = zext i32 %len to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %2, i64 %conv, i1 zeroext true)
  br label %cleanup.cont

if.end2:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end2
  %i.0 = phi i32 [ 0, %if.end2 ], [ %inc, %for.body ]
  %len.addr.0 = phi i32 [ %len, %if.end2 ], [ %sub, %for.body ]
  %num_sgs3 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs3, align 4, !tbaa !227
  %cmp4 = icmp slt i32 %i.0, %3
  %tobool6 = icmp ne i32 %len.addr.0, 0
  %tobool6. = select i1 %cmp4, i1 %tobool6, i1 false
  br i1 %tobool6., label %for.body, label %cleanup.cont

for.body:                                         ; preds = %for.cond
  %cmp7 = icmp ugt i32 %len.addr.0, 16384
  %.len.addr.0 = select i1 %cmp7, i32 16384, i32 %len.addr.0
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %4 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !225
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %4, i64 %idxprom
  %call = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %conv9 = sext i32 %.len.addr.0 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), i32 0, i32 32, i32 1, i8* %call, i64 %conv9, i1 zeroext true)
  %sub = sub i32 %len.addr.0, %.len.addr.0
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

cleanup.cont:                                     ; preds = %if.then1, %entry, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @async_newpending(%struct.async* %as) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8, !tbaa !244
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 4
  call void @list_add_tail(%struct.list_head* %asynclist, %struct.list_head* %async_pending)
  %lock6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock6, i64 %call3)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_bulk(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !255
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 2
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_num(%struct.usb_endpoint_descriptor* %epd) #0 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !204
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  ret i32 %and
}

declare i32 @usb_submit_urb(%struct.urb*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @async_removepending(%struct.async* %as) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %ps1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 1
  %0 = load %struct.dev_state*, %struct.dev_state** %ps1, align 8, !tbaa !244
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  %lock6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %0, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock6, i64 %call3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @free_async(%struct.async* %as) #1 {
entry:
  %pid = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 2
  %0 = load %struct.pid*, %struct.pid** %pid, align 8, !tbaa !249
  call void @put_pid(%struct.pid* %0)
  %cred = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %1 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !250
  %tobool = icmp ne %struct.cred* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %cred1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 3
  %2 = load %struct.cred*, %struct.cred** %cred1, align 8, !tbaa !250
  call void @put_cred(%struct.cred* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %urb = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %3 = load %struct.urb*, %struct.urb** %urb, align 8, !tbaa !120
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %3, i32 0, i32 18
  %4 = load i32, i32* %num_sgs, align 4, !tbaa !227
  %cmp = icmp slt i32 %i.0, %4
  %urb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %5 = load %struct.urb*, %struct.urb** %urb2, align 8, !tbaa !120
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %5, i32 0, i32 16
  %6 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !225
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %6, i64 %idxprom
  %call = call %struct.page* @sg_page(%struct.scatterlist* %arrayidx)
  %tobool3 = icmp ne %struct.page* %call, null
  br i1 %tobool3, label %if.then4, label %for.inc

if.then4:                                         ; preds = %for.body
  %urb5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %7 = load %struct.urb*, %struct.urb** %urb5, align 8, !tbaa !120
  %sg6 = getelementptr inbounds %struct.urb, %struct.urb* %7, i32 0, i32 16
  %8 = load %struct.scatterlist*, %struct.scatterlist** %sg6, align 8, !tbaa !225
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %8, i64 %idxprom7
  %call9 = call i8* @sg_virt(%struct.scatterlist* %arrayidx8)
  call void @kfree(i8* %call9)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.then4
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = bitcast %struct.scatterlist* %6 to i8*
  call void @kfree(i8* %9)
  %urb13 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %10 = load %struct.urb*, %struct.urb** %urb13, align 8, !tbaa !120
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %10, i32 0, i32 14
  %11 = load i8*, i8** %transfer_buffer, align 8, !tbaa !228
  call void @kfree(i8* %11)
  %urb14 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %12 = load %struct.urb*, %struct.urb** %urb14, align 8, !tbaa !120
  %setup_packet = getelementptr inbounds %struct.urb, %struct.urb* %12, i32 0, i32 21
  %13 = load i8*, i8** %setup_packet, align 8, !tbaa !233
  call void @kfree(i8* %13)
  %urb15 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %14 = load %struct.urb*, %struct.urb** %urb15, align 8, !tbaa !120
  call void @usb_free_urb(%struct.urb* %14)
  %mem_usage = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 9
  %15 = load i32, i32* %mem_usage, align 8, !tbaa !224
  call void @usbfs_decrease_memory_usage(i32 %15)
  %16 = bitcast %struct.async* %as to i8*
  call void @kfree(i8* %16)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare %struct.urb* @usb_alloc_urb(i32, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_set_page(%struct.scatterlist* %sg, %struct.page* %page, i32 %len, i32 %offset) #0 {
entry:
  call void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page)
  %offset1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  store i32 %offset, i32* %offset1, align 8, !tbaa !266
  %length = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 2
  store i32 %len, i32* %length, align 4, !tbaa !268
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @__phys_addr_nodebug(i64 %x) #0 {
entry:
  %sub = sub i64 %x, -2147483648
  %cmp = icmp ugt i64 %x, %sub
  %0 = load i64, i64* @phys_base, align 8
  %cond = select i1 %cmp, i64 %0, i64 131939247849472
  %add = add i64 %sub, %cond
  ret i64 %add
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sg_assign_page(%struct.scatterlist* %sg, %struct.page* %page) #0 {
entry:
  %page_link1 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %page_link1, align 8, !tbaa !269
  %and = and i64 %0, 3
  %1 = ptrtoint %struct.page* %page to i64
  %and2 = and i64 %1, 3
  %tobool = icmp ne i64 %and2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.49, i32 0, i32 0), i32 65, i64 12) #7, !srcloc !270
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  %2 = ptrtoint %struct.page* %page to i64
  %or = or i64 %and, %2
  %page_link11 = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  store i64 %or, i64* %page_link11, align 8, !tbaa !269
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @cancel_bulk_urbs(%struct.dev_state* %ps, i32 %bulk_addr) #1 {
entry:
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist13.sink = phi %struct.list_head* [ %asynclist13, %for.inc ], [ %async_pending, %entry ]
  %next14 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist13.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next14, align 8, !tbaa !56
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr16 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr16 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %bulk_addr2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 12
  %3 = load i8, i8* %bulk_addr2, align 4, !tbaa !252
  %conv = zext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv, %bulk_addr
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %bulk_status = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  %4 = load i8, i8* %bulk_status, align 1, !tbaa !253
  %conv5 = zext i8 %4 to i32
  %cmp6 = icmp ne i32 %conv5, 1
  br i1 %cmp6, label %rescan.preheader, label %if.end

if.end:                                           ; preds = %if.then
  %bulk_status9 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 13
  store i8 2, i8* %bulk_status9, align 1, !tbaa !253
  %bulk_addr10 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 12
  store i8 0, i8* %bulk_addr10, align 4, !tbaa !252
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %asynclist13 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %shl = shl i32 1, %bulk_addr
  %disabled_bulk_eps = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 13
  %5 = load i32, i32* %disabled_bulk_eps, align 4, !tbaa !254
  %or = or i32 %5, %shl
  store i32 %or, i32* %disabled_bulk_eps, align 4, !tbaa !254
  br label %rescan.preheader

rescan.preheader:                                 ; preds = %if.then, %for.end
  br label %rescan

rescan:                                           ; preds = %rescan.preheader, %if.then32
  %async_pending18 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc38, %rescan
  %asynclist40.sink = phi %struct.list_head* [ %asynclist40, %for.inc38 ], [ %async_pending18, %rescan ]
  %next41 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist40.sink, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next41, align 8, !tbaa !56
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr43 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr43 to %struct.async*
  %asynclist23 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  %async_pending24 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp25 = icmp ne %struct.list_head* %asynclist23, %async_pending24
  br i1 %cmp25, label %for.body27, label %for.end44

for.body27:                                       ; preds = %for.cond22
  %bulk_status28 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 13
  %9 = load i8, i8* %bulk_status28, align 1, !tbaa !253
  %conv29 = zext i8 %9 to i32
  %cmp30 = icmp eq i32 %conv29, 2
  br i1 %cmp30, label %if.then32, label %for.inc38

if.then32:                                        ; preds = %for.body27
  %bulk_status33 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 13
  store i8 0, i8* %bulk_status33, align 1, !tbaa !253
  %urb34 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 8
  %10 = load %struct.urb*, %struct.urb** %urb34, align 8, !tbaa !120
  %call = call %struct.urb* @usb_get_urb(%struct.urb* %10)
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock(%struct.spinlock* %lock)
  %call35 = call i32 @usb_unlink_urb(%struct.urb* %10)
  call void @usb_free_urb(%struct.urb* %10)
  %lock36 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_lock(%struct.spinlock* %lock36)
  br label %rescan

for.inc38:                                        ; preds = %for.body27
  %asynclist40 = getelementptr inbounds %struct.async, %struct.async* %8, i32 0, i32 0
  br label %for.cond22

for.end44:                                        ; preds = %for.cond22
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare i32 @kill_pid_info_as_cred(i32, %struct.siginfo*, %struct.pid*, %struct.cred*, i32) #3

declare void @put_pid(%struct.pid*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @put_cred(%struct.cred* %_cred) #0 {
entry:
  call void @validate_creds(%struct.cred* %_cred)
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %_cred, i32 0, i32 0
  %call = call i32 @atomic_dec_and_test(%struct.atomic_t* %usage)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @__put_cred(%struct.cred* %_cred)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #3

declare void @_raw_spin_lock(%struct.raw_spinlock*) #3 section ".spinlock.text"

declare i32 @usb_unlink_urb(%struct.urb*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !271
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i32 0, i32 0
  call void @arch_spin_unlock(%struct.arch_spinlock* %raw_lock)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @arch_spin_unlock(%struct.arch_spinlock* %lock) #4 {
entry:
  call void @__ticket_spin_unlock(%struct.arch_spinlock* %lock)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__ticket_spin_unlock(%struct.arch_spinlock* %lock) #4 {
entry:
  %0 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %lock, i32 0, i32 0
  %tickets = bitcast %union.anon.1* %0 to %struct.__raw_tickets*
  %head = getelementptr inbounds %struct.__raw_tickets, %struct.__raw_tickets* %tickets, i32 0, i32 0
  call void asm sideeffect "addb ${1:b}, $0\0A", "=*m,qi,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i8* %head, i32 1, i8* %head) #7, !srcloc !272
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @validate_creds(%struct.cred* %cred) #0 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_dec_and_test(%struct.atomic_t* %v) #0 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #7
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0; sete $1", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #7, !srcloc !273
  %0 = load i8, i8* %c, align 1, !tbaa !74
  %conv = zext i8 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #7
  ret i32 %conv1
}

declare void @__put_cred(%struct.cred*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !274
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.cred* @get_new_cred(%struct.cred* %cred) #0 {
entry:
  %usage = getelementptr inbounds %struct.cred, %struct.cred* %cred, i32 0, i32 0
  call void @atomic_inc(%struct.atomic_t* %usage)
  ret %struct.cred* %cred
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @sg_virt(%struct.scatterlist* %sg) #0 {
entry:
  %call = call %struct.page* @sg_page(%struct.scatterlist* %sg)
  %call1 = call i8* @lowmem_page_address(%struct.page* %call)
  %offset = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 1
  %0 = load i32, i32* %offset, align 8, !tbaa !266
  %idx.ext = zext i32 %0 to i64
  %add.ptr = getelementptr i8, i8* %call1, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @lowmem_page_address(%struct.page* %page) #4 {
entry:
  %sub.ptr.lhs.cast = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, -24189255811072
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 64
  %shl = shl i64 %sub.ptr.div, 12
  %add = add i64 %shl, -131941395333120
  %0 = inttoptr i64 %add to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @sg_page(%struct.scatterlist* %sg) #0 {
entry:
  %page_link = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %sg, i32 0, i32 0
  %0 = load i64, i64* %page_link, align 8, !tbaa !269
  %and = and i64 %0, -4
  %1 = inttoptr i64 %and to %struct.page*
  ret %struct.page* %1
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock_irq(%struct.raw_spinlock* %lock) #0 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void @arch_local_irq_enable()
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !275
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @arch_local_irq_enable() #0 {
entry:
  call void @native_irq_enable()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @native_irq_enable() #0 {
entry:
  call void asm sideeffect "sti", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !276
  ret void
}

declare i8* @compat_alloc_user_space(i64) #3

declare i64 @copy_in_user(i8*, i8*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @compat_ptr(i32 %uptr) #0 {
entry:
  %conv = zext i32 %uptr to i64
  %0 = inttoptr i64 %conv to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_urb32(%struct.usbdevfs_urb* %kurb, %struct.usbdevfs_urb32* %uurb) #1 {
entry:
  %call = call %struct.thread_info* @current_thread_info()
  %addr_limit = getelementptr inbounds %struct.thread_info, %struct.thread_info* %call, i32 0, i32 6
  %seg = getelementptr inbounds %struct.mm_segment_t, %struct.mm_segment_t* %addr_limit, i32 0, i32 0
  %0 = load i64, i64* %seg, align 8, !tbaa !132
  %1 = call { i64, i64 } asm "add $3,$1 ; sbb $0,$0 ; cmp $1,$4 ; sbb $$0,$0", "=&r,=r,1,imr,rm,~{dirflag},~{fpsr},~{flags}"(%struct.usbdevfs_urb32* %uurb, i64 44, i64 %0) #8, !srcloc !277
  %asmresult = extractvalue { i64, i64 } %1, 0
  %asmresult1 = extractvalue { i64, i64 } %1, 1
  %cmp = icmp eq i64 %asmresult, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body, label %cleanup

do.body:                                          ; preds = %entry
  %type = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 0
  %2 = bitcast i8* %type to %struct.__large_struct*
  %3 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %2, i32 -14, i32 0) #7, !srcloc !278
  %asmresult3 = extractvalue { i32, i64 } %3, 0
  %asmresult4 = extractvalue { i32, i64 } %3, 1
  %conv5 = trunc i64 %asmresult4 to i8
  %type6 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 0
  store i8 %conv5, i8* %type6, align 8, !tbaa !215
  %tobool8 = icmp ne i32 %asmresult3, 0
  br i1 %tobool8, label %cleanup, label %do.body12

do.body12:                                        ; preds = %do.body
  %endpoint = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 1
  %4 = bitcast i8* %endpoint to %struct.__large_struct*
  %5 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movb $2,${1:b}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorb ${1:b},${1:b}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=q,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %4, i32 -14, i32 0) #7, !srcloc !279
  %asmresult13 = extractvalue { i32, i64 } %5, 0
  %asmresult14 = extractvalue { i32, i64 } %5, 1
  %conv17 = trunc i64 %asmresult14 to i8
  %endpoint18 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 1
  store i8 %conv17, i8* %endpoint18, align 1, !tbaa !216
  %tobool20 = icmp ne i32 %asmresult13, 0
  br i1 %tobool20, label %cleanup, label %do.body24

do.body24:                                        ; preds = %do.body12
  %status = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 2
  %6 = bitcast i32* %status to %struct.__large_struct*
  %7 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %6, i32 -14, i32 0) #7, !srcloc !280
  %asmresult25 = extractvalue { i32, i64 } %7, 0
  %asmresult26 = extractvalue { i32, i64 } %7, 1
  %conv29 = trunc i64 %asmresult26 to i32
  %status30 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 2
  store i32 %conv29, i32* %status30, align 4, !tbaa !281
  %tobool32 = icmp ne i32 %asmresult25, 0
  br i1 %tobool32, label %cleanup, label %do.body36

do.body36:                                        ; preds = %do.body24
  %flags = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 3
  %8 = bitcast i32* %flags to %struct.__large_struct*
  %9 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %8, i32 -14, i32 0) #7, !srcloc !282
  %asmresult37 = extractvalue { i32, i64 } %9, 0
  %asmresult38 = extractvalue { i32, i64 } %9, 1
  %conv41 = trunc i64 %asmresult38 to i32
  %flags42 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 3
  store i32 %conv41, i32* %flags42, align 8, !tbaa !211
  %tobool44 = icmp ne i32 %asmresult37, 0
  br i1 %tobool44, label %cleanup, label %do.body48

do.body48:                                        ; preds = %do.body36
  %buffer_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 5
  %10 = bitcast i32* %buffer_length to %struct.__large_struct*
  %11 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %10, i32 -14, i32 0) #7, !srcloc !283
  %asmresult49 = extractvalue { i32, i64 } %11, 0
  %asmresult50 = extractvalue { i32, i64 } %11, 1
  %conv53 = trunc i64 %asmresult50 to i32
  %buffer_length54 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 5
  store i32 %conv53, i32* %buffer_length54, align 8, !tbaa !213
  %tobool56 = icmp ne i32 %asmresult49, 0
  br i1 %tobool56, label %cleanup, label %do.body60

do.body60:                                        ; preds = %do.body48
  %actual_length = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 6
  %12 = bitcast i32* %actual_length to %struct.__large_struct*
  %13 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %12, i32 -14, i32 0) #7, !srcloc !284
  %asmresult61 = extractvalue { i32, i64 } %13, 0
  %asmresult62 = extractvalue { i32, i64 } %13, 1
  %conv65 = trunc i64 %asmresult62 to i32
  %actual_length66 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 6
  store i32 %conv65, i32* %actual_length66, align 4, !tbaa !285
  %tobool68 = icmp ne i32 %asmresult61, 0
  br i1 %tobool68, label %cleanup, label %do.body72

do.body72:                                        ; preds = %do.body60
  %start_frame = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 7
  %14 = bitcast i32* %start_frame to %struct.__large_struct*
  %15 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %14, i32 -14, i32 0) #7, !srcloc !286
  %asmresult73 = extractvalue { i32, i64 } %15, 0
  %asmresult74 = extractvalue { i32, i64 } %15, 1
  %conv77 = trunc i64 %asmresult74 to i32
  %start_frame78 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 7
  store i32 %conv77, i32* %start_frame78, align 8, !tbaa !234
  %tobool80 = icmp ne i32 %asmresult73, 0
  br i1 %tobool80, label %cleanup, label %do.body84

do.body84:                                        ; preds = %do.body72
  %number_of_packets = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 8
  %16 = bitcast i32* %number_of_packets to %struct.__large_struct*
  %17 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %16, i32 -14, i32 0) #7, !srcloc !287
  %asmresult85 = extractvalue { i32, i64 } %17, 0
  %asmresult86 = extractvalue { i32, i64 } %17, 1
  %conv89 = trunc i64 %asmresult86 to i32
  %number_of_packets90 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 8
  store i32 %conv89, i32* %number_of_packets90, align 4, !tbaa !220
  %tobool92 = icmp ne i32 %asmresult85, 0
  br i1 %tobool92, label %cleanup, label %do.body96

do.body96:                                        ; preds = %do.body84
  %error_count = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 9
  %18 = bitcast i32* %error_count to %struct.__large_struct*
  %19 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %18, i32 -14, i32 0) #7, !srcloc !288
  %asmresult97 = extractvalue { i32, i64 } %19, 0
  %asmresult98 = extractvalue { i32, i64 } %19, 1
  %conv101 = trunc i64 %asmresult98 to i32
  %error_count102 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 9
  store i32 %conv101, i32* %error_count102, align 8, !tbaa !289
  %tobool104 = icmp ne i32 %asmresult97, 0
  br i1 %tobool104, label %cleanup, label %do.body108

do.body108:                                       ; preds = %do.body96
  %signr = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 10
  %20 = bitcast i32* %signr to %struct.__large_struct*
  %21 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %20, i32 -14, i32 0) #7, !srcloc !290
  %asmresult109 = extractvalue { i32, i64 } %21, 0
  %asmresult110 = extractvalue { i32, i64 } %21, 1
  %conv113 = trunc i64 %asmresult110 to i32
  %signr114 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 10
  store i32 %conv113, i32* %signr114, align 4, !tbaa !247
  %tobool116 = icmp ne i32 %asmresult109, 0
  br i1 %tobool116, label %cleanup, label %do.body119

do.body119:                                       ; preds = %do.body108
  %buffer = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 4
  %22 = bitcast i32* %buffer to %struct.__large_struct*
  %23 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %22, i32 -14, i32 0) #7, !srcloc !291
  %asmresult120 = extractvalue { i32, i64 } %23, 0
  %asmresult121 = extractvalue { i32, i64 } %23, 1
  %conv124 = trunc i64 %asmresult121 to i32
  %tobool126 = icmp ne i32 %asmresult120, 0
  br i1 %tobool126, label %cleanup, label %if.end128

if.end128:                                        ; preds = %do.body119
  %call129 = call i8* @compat_ptr(i32 %conv124)
  %buffer130 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 4
  store i8* %call129, i8** %buffer130, align 8, !tbaa !214
  %usercontext = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %uurb, i32 0, i32 11
  %24 = bitcast i32* %usercontext to %struct.__large_struct*
  %25 = call { i32, i64 } asm sideeffect "661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xcb\0A6641:\0A\09.popsection\0A1:\09movl $2,${1:k}\0A2: 661:\0A\09.byte 0x66,0x66,0x90\0A\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word (9*32+20)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09.byte 0x0f,0x01,0xca\0A6641:\0A\09.popsection\0A.section .fixup,\22ax\22\0A3:\09mov $3,$0\0A\09xorl ${1:k},${1:k}\0A\09jmp 2b\0A.previous\0A .pushsection \22__ex_table\22,\22a\22\0A .balign 8\0A .long (1b) - .\0A .long (3b) - .\0A .popsection\0A", "=r,=r,*m,i,0,~{dirflag},~{fpsr},~{flags}"(%struct.__large_struct* %24, i32 -14, i32 0) #7, !srcloc !292
  %asmresult134 = extractvalue { i32, i64 } %25, 0
  %asmresult135 = extractvalue { i32, i64 } %25, 1
  %conv138 = trunc i64 %asmresult135 to i32
  %tobool140 = icmp ne i32 %asmresult134, 0
  br i1 %tobool140, label %cleanup, label %if.end142

if.end142:                                        ; preds = %if.end128
  %call143 = call i8* @compat_ptr(i32 %conv138)
  %usercontext144 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %kurb, i32 0, i32 11
  store i8* %call143, i8** %usercontext144, align 8, !tbaa !293
  br label %cleanup

cleanup:                                          ; preds = %if.end128, %do.body119, %entry, %do.body, %do.body12, %do.body24, %do.body36, %do.body48, %do.body60, %do.body72, %do.body84, %do.body96, %do.body108, %if.end142
  %retval.0 = phi i32 [ 0, %if.end142 ], [ -14, %do.body108 ], [ -14, %do.body96 ], [ -14, %do.body84 ], [ -14, %do.body72 ], [ -14, %do.body60 ], [ -14, %do.body48 ], [ -14, %do.body36 ], [ -14, %do.body24 ], [ -14, %do.body12 ], [ -14, %do.body ], [ -14, %entry ], [ -14, %do.body119 ], [ -14, %if.end128 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.async* @reap_as(%struct.dev_state* %ps) #1 {
entry:
  %wait = alloca %struct.__wait_queue, align 8
  %__ret = alloca i64, align 8
  %0 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0) #7
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !294
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 1
  %call = call %struct.task_struct* @get_current()
  %1 = bitcast %struct.task_struct* %call to i8*
  store i8* %1, i8** %private, align 8, !tbaa !296
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @default_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !297
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  store %struct.list_head* null, %struct.list_head** %next, align 8, !tbaa !116
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  store %struct.list_head* null, %struct.list_head** %prev, align 8, !tbaa !119
  %dev1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %2 = load %struct.usb_device*, %struct.usb_device** %dev1, align 8, !tbaa !44
  %wait2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 6
  call void @add_wait_queue(%struct.__wait_queue_head* %wait2, %struct.__wait_queue* %wait)
  br label %for.cond

for.cond:                                         ; preds = %if.end9, %entry
  %call3 = call %struct.task_struct* @get_current()
  %state = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call3, i32 0, i32 0
  store volatile i64 1, i64* %state, align 8, !tbaa !298
  %call4 = call %struct.async* @async_getcompleted(%struct.dev_state* %ps)
  %tobool = icmp ne %struct.async* %call4, null
  br i1 %tobool, label %for.end, label %if.end

if.end:                                           ; preds = %for.cond
  %call5 = call %struct.task_struct* @get_current()
  %call6 = call i32 @signal_pending(%struct.task_struct* %call5)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %for.end, label %if.end9

if.end9:                                          ; preds = %if.end
  %dev10 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_unlock(%struct.device* %dev10)
  call void @schedule()
  %dev11 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %2, i32 0, i32 11
  call void @device_lock(%struct.device* %dev11)
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  %wait12 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 6
  call void @remove_wait_queue(%struct.__wait_queue_head* %wait12, %struct.__wait_queue* %wait)
  %3 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  store volatile i64 0, i64* %__ret, align 8, !tbaa !113
  %4 = load volatile i64, i64* %__ret, align 8, !tbaa !113
  %call14 = call %struct.task_struct* @get_current()
  %state15 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call14, i32 0, i32 0
  %5 = call i64 asm sideeffect "xchgq ${0:q}, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64* %state15, i64 %4, i64* %state15) #7, !srcloc !299
  store volatile i64 %5, i64* %__ret, align 8, !tbaa !113
  %6 = load volatile i64, i64* %__ret, align 8, !tbaa !113
  %7 = bitcast i64* %__ret to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %8 = bitcast %struct.__wait_queue* %wait to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %8) #7
  ret %struct.async* %call4
}

; Function Attrs: nounwind uwtable
define internal i32 @processcompl_compat(%struct.async* %as, i8** %arg) #1 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !120
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !245
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb32*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !245
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !246
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !263
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !246
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @might_fault()
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 10
  %7 = load i32, i32* %status, align 4, !tbaa !257
  %status9 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #7, !srcloc !300
  %tobool10 = icmp ne i32 %8, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !263
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #7, !srcloc !301
  %tobool18 = icmp ne i32 %10, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end12
  call void @might_fault()
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !302
  %error_count23 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count23) #7, !srcloc !303
  %tobool25 = icmp ne i32 %12, 0
  br i1 %tobool25, label %cleanup, label %if.end27

if.end27:                                         ; preds = %if.end20
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !304
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call28 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end56

if.then30:                                        ; preds = %if.end27
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then30
  %i.0 = phi i32 [ 0, %if.then30 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !236
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end56

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length33 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length33, align 8, !tbaa !305
  %iso_frame_desc34 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom35 = zext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc34, i64 0, i64 %idxprom35
  %actual_length37 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx36, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length37) #7, !srcloc !306
  %tobool39 = icmp ne i32 %16, 0
  br i1 %tobool39, label %cleanup, label %if.end41

if.end41:                                         ; preds = %for.body
  call void @might_fault()
  %iso_frame_desc44 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom45 = zext i32 %i.0 to i64
  %arrayidx46 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc44, i64 0, i64 %idxprom45
  %status47 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx46, i32 0, i32 3
  %17 = load i32, i32* %status47, align 4, !tbaa !307
  %iso_frame_desc48 = getelementptr inbounds %struct.usbdevfs_urb32, %struct.usbdevfs_urb32* %2, i32 0, i32 12
  %idxprom49 = zext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx50, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status51) #7, !srcloc !308
  %tobool53 = icmp ne i32 %18, 0
  br i1 %tobool53, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end41
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end56:                                         ; preds = %for.cond, %if.end27
  call void @might_fault()
  %call59 = call i32 @ptr_to_compat(i8* %3)
  %19 = bitcast i8** %arg to i32*
  %20 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %call59, i32* %19) #7, !srcloc !309
  %tobool61 = icmp ne i32 %20, 0
  %. = select i1 %tobool61, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end56, %if.end41, %for.body, %if.end20, %if.end12, %if.end8, %if.then
  %retval.0 = phi i32 [ -14, %if.then ], [ -14, %if.end8 ], [ -14, %if.end12 ], [ -14, %if.end20 ], [ -14, %for.body ], [ -14, %if.end41 ], [ %., %if.end56 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #0 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare i32 @default_wake_function(%struct.__wait_queue*, i32, i32, i8*) #3

declare void @add_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #3

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getcompleted(%struct.dev_state* %ps) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %async_completed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 5
  %call5 = call i32 @list_empty(%struct.list_head* %async_completed)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %async_completed6 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %async_completed6, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !310
  %5 = bitcast %struct.list_head* %4 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %6, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %asynclist)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %as.0 = phi %struct.async* [ null, %entry ], [ %6, %if.then ]
  %lock8 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 3
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock8, i64 %call2)
  ret %struct.async* %as.0
}

declare void @schedule() #3

declare void @remove_wait_queue(%struct.__wait_queue_head*, %struct.__wait_queue*) #3

; Function Attrs: nounwind uwtable
define internal i32 @copy_urb_data_to_user(i8* %userbuffer, %struct.urb* %urb) #1 {
entry:
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 24
  %0 = load i32, i32* %number_of_packets, align 4, !tbaa !236
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %transfer_buffer_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 19
  %1 = load i32, i32* %transfer_buffer_length, align 8, !tbaa !232
  br label %if.end

if.else:                                          ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 20
  %2 = load i32, i32* %actual_length, align 4, !tbaa !263
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %len.0 = phi i32 [ %1, %if.then ], [ %2, %if.else ]
  %num_sgs = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %3 = load i32, i32* %num_sgs, align 4, !tbaa !227
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %transfer_buffer = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 14
  %4 = load i8*, i8** %transfer_buffer, align 8, !tbaa !228
  %call = call i32 @copy_to_user(i8* %userbuffer, i8* %4, i32 %len.0)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 -14, i32 0
  br label %cleanup

if.end5:                                          ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %if.end5
  %len.1 = phi i32 [ %len.0, %if.end5 ], [ %sub, %if.end14 ]
  %i.0 = phi i32 [ 0, %if.end5 ], [ %inc, %if.end14 ]
  %userbuffer.addr.0 = phi i8* [ %userbuffer, %if.end5 ], [ %add.ptr, %if.end14 ]
  %num_sgs6 = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 18
  %5 = load i32, i32* %num_sgs6, align 4, !tbaa !227
  %cmp7 = icmp ult i32 %i.0, %5
  %tobool8 = icmp ne i32 %len.1, 0
  %tobool8. = select i1 %cmp7, i1 %tobool8, i1 false
  br i1 %tobool8., label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %cmp9 = icmp ugt i32 %len.1, 16384
  %.len.1 = select i1 %cmp9, i32 16384, i32 %len.1
  %sg = getelementptr inbounds %struct.urb, %struct.urb* %urb, i32 0, i32 16
  %6 = load %struct.scatterlist*, %struct.scatterlist** %sg, align 8, !tbaa !225
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.scatterlist, %struct.scatterlist* %6, i64 %idxprom
  %call10 = call i8* @sg_virt(%struct.scatterlist* %arrayidx)
  %call11 = call i32 @copy_to_user(i8* %userbuffer.addr.0, i8* %call10, i32 %.len.1)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %cleanup, label %if.end14

if.end14:                                         ; preds = %for.body
  %idx.ext = zext i32 %.len.1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %userbuffer.addr.0, i64 %idx.ext
  %sub = sub i32 %len.1, %.len.1
  %inc = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %for.body, %if.then2
  %retval.0 = phi i32 [ %., %if.then2 ], [ -14, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #0 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !311
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #0 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @proc_ioctl(%struct.dev_state* %ps, %struct.usbdevfs_ioctl* %ctl) #1 {
entry:
  %ioctl_code = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %0 = load i32, i32* %ioctl_code, align 4, !tbaa !181
  %shr = ashr i32 %0, 16
  %and = and i32 %shr, 16383
  %cmp = icmp sgt i32 %and, 0
  br i1 %cmp, label %if.then, label %if.end17

if.then:                                          ; preds = %entry
  %conv = sext i32 %and to i64
  %call = call i8* @kmalloc(i64 %conv, i32 208)
  %cmp2 = icmp eq i8* %call, null
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then
  %ioctl_code5 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %1 = load i32, i32* %ioctl_code5, align 4, !tbaa !181
  %shr6 = ashr i32 %1, 30
  %and7 = and i32 %shr6, 3
  %and8 = and i32 %and7, 1
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.end
  %data = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %2 = load i8*, i8** %data, align 8, !tbaa !183
  %conv10 = sext i32 %and to i64
  %call11 = call i64 @copy_from_user(i8* %call, i8* %2, i64 %conv10)
  %tobool12 = icmp ne i64 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end17

if.then13:                                        ; preds = %if.then9
  call void @kfree(i8* %call)
  br label %cleanup

if.else:                                          ; preds = %if.end
  %conv15 = sext i32 %and to i64
  call void @llvm.memset.p0i8.i64(i8* %call, i8 0, i64 %conv15, i32 1, i1 false)
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then9, %entry
  %buf.0 = phi i8* [ null, %entry ], [ %call, %if.then9 ], [ %call, %if.else ]
  %call18 = call i32 @connected(%struct.dev_state* %ps)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end17
  call void @kfree(i8* %buf.0)
  br label %cleanup

if.end21:                                         ; preds = %if.end17
  %dev = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %3 = load %struct.usb_device*, %struct.usb_device** %dev, align 8, !tbaa !44
  %state = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 3
  %4 = load i32, i32* %state, align 8, !tbaa !72
  %cmp22 = icmp ne i32 %4, 7
  br i1 %cmp22, label %if.end76, label %if.else25

if.else25:                                        ; preds = %if.end21
  %dev26 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %5 = load %struct.usb_device*, %struct.usb_device** %dev26, align 8, !tbaa !44
  %ifno = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 0
  %6 = load i32, i32* %ifno, align 8, !tbaa !178
  %call27 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %5, i32 %6)
  %tobool28 = icmp ne %struct.usb_interface* %call27, null
  br i1 %tobool28, label %if.else30, label %if.end76

if.else30:                                        ; preds = %if.else25
  %ioctl_code31 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %7 = load i32, i32* %ioctl_code31, align 4, !tbaa !181
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.else30
  %Pivot = icmp slt i32 %7, 21783
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %7, 21783
  br i1 %SwitchLeaf2, label %sw.bb42, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %7, 21782
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %dev32 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver33 = getelementptr inbounds %struct.device, %struct.device* %dev32, i32 0, i32 7
  %8 = load %struct.device_driver*, %struct.device_driver** %driver33, align 8, !tbaa !147
  %tobool34 = icmp ne %struct.device_driver* %8, null
  br i1 %tobool34, label %if.then35, label %if.end76

if.then35:                                        ; preds = %sw.bb
  %dev36 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver37 = getelementptr inbounds %struct.device, %struct.device* %dev36, i32 0, i32 7
  %9 = load %struct.device_driver*, %struct.device_driver** %driver37, align 8, !tbaa !147
  %10 = bitcast %struct.device_driver* %9 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %10, i64 -104
  %11 = bitcast i8* %add.ptr to %struct.usb_driver*
  %dev38 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %call39 = call i32 (i8*, %struct.device*, i8*, ...) @dev_printk(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0), %struct.device* %dev38, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.51, i32 0, i32 0))
  call void @usb_driver_release_interface(%struct.usb_driver* %11, %struct.usb_interface* %call27)
  br label %if.end76

sw.bb42:                                          ; preds = %LeafBlock1
  %dev43 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver44 = getelementptr inbounds %struct.device, %struct.device* %dev43, i32 0, i32 7
  %12 = load %struct.device_driver*, %struct.device_driver** %driver44, align 8, !tbaa !147
  %tobool45 = icmp ne %struct.device_driver* %12, null
  br i1 %tobool45, label %if.end76, label %if.then46

if.then46:                                        ; preds = %sw.bb42
  %dev47 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %call48 = call i32 @device_attach(%struct.device* %dev47)
  br label %if.end76

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %dev51 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver52 = getelementptr inbounds %struct.device, %struct.device* %dev51, i32 0, i32 7
  %13 = load %struct.device_driver*, %struct.device_driver** %driver52, align 8, !tbaa !147
  %tobool53 = icmp ne %struct.device_driver* %13, null
  br i1 %tobool53, label %if.then54, label %if.end60

if.then54:                                        ; preds = %sw.default
  %dev56 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %call27, i32 0, i32 7
  %driver57 = getelementptr inbounds %struct.device, %struct.device* %dev56, i32 0, i32 7
  %14 = load %struct.device_driver*, %struct.device_driver** %driver57, align 8, !tbaa !147
  %15 = bitcast %struct.device_driver* %14 to i8*
  %add.ptr59 = getelementptr inbounds i8, i8* %15, i64 -104
  %16 = bitcast i8* %add.ptr59 to %struct.usb_driver*
  br label %if.end60

if.end60:                                         ; preds = %if.then54, %sw.default
  %driver.0 = phi %struct.usb_driver* [ %16, %if.then54 ], [ null, %sw.default ]
  %cmp61 = icmp eq %struct.usb_driver* %driver.0, null
  br i1 %cmp61, label %if.end76, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end60
  %unlocked_ioctl = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %17 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl, align 8, !tbaa !312
  %cmp63 = icmp eq i32 (%struct.usb_interface*, i32, i8*)* %17, null
  br i1 %cmp63, label %if.end76, label %if.else66

if.else66:                                        ; preds = %lor.lhs.false
  %unlocked_ioctl67 = getelementptr inbounds %struct.usb_driver, %struct.usb_driver* %driver.0, i32 0, i32 3
  %18 = load i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32, i8*)** %unlocked_ioctl67, align 8, !tbaa !312
  %ioctl_code68 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %19 = load i32, i32* %ioctl_code68, align 4, !tbaa !181
  %call69 = call i32 %18(%struct.usb_interface* %call27, i32 %19, i8* %buf.0)
  %cmp70 = icmp eq i32 %call69, -515
  %.call69 = select i1 %cmp70, i32 -25, i32 %call69
  br label %if.end76

if.end76:                                         ; preds = %if.else25, %if.else66, %lor.lhs.false, %if.end60, %if.then46, %sw.bb42, %if.then35, %sw.bb, %if.end21
  %retval1.6 = phi i32 [ -113, %if.end21 ], [ -22, %if.else25 ], [ 0, %if.then35 ], [ -61, %sw.bb ], [ %call48, %if.then46 ], [ -16, %sw.bb42 ], [ %.call69, %if.else66 ], [ -25, %lor.lhs.false ], [ -25, %if.end60 ]
  %cmp77 = icmp sge i32 %retval1.6, 0
  br i1 %cmp77, label %land.lhs.true, label %if.end94

land.lhs.true:                                    ; preds = %if.end76
  %ioctl_code79 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 1
  %20 = load i32, i32* %ioctl_code79, align 4, !tbaa !181
  %shr80 = ashr i32 %20, 30
  %and81 = and i32 %shr80, 3
  %and82 = and i32 %and81, 2
  %cmp83 = icmp ne i32 %and82, 0
  %cmp86 = icmp sgt i32 %and, 0
  %or.cond = and i1 %cmp83, %cmp86
  br i1 %or.cond, label %land.lhs.true88, label %if.end94

land.lhs.true88:                                  ; preds = %land.lhs.true
  %data89 = getelementptr inbounds %struct.usbdevfs_ioctl, %struct.usbdevfs_ioctl* %ctl, i32 0, i32 2
  %21 = load i8*, i8** %data89, align 8, !tbaa !183
  %call90 = call i32 @copy_to_user(i8* %21, i8* %buf.0, i32 %and)
  %cmp91 = icmp ne i32 %call90, 0
  %.retval1.6 = select i1 %cmp91, i32 -14, i32 %retval1.6
  br label %if.end94

if.end94:                                         ; preds = %land.lhs.true88, %land.lhs.true, %if.end76
  %retval1.7 = phi i32 [ %retval1.6, %land.lhs.true ], [ %retval1.6, %if.end76 ], [ %.retval1.6, %land.lhs.true88 ]
  call void @kfree(i8* %buf.0)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %if.end94, %if.then20, %if.then13
  %retval.0 = phi i32 [ -14, %if.then13 ], [ %retval1.7, %if.end94 ], [ -19, %if.then20 ], [ -12, %if.then ]
  ret i32 %retval.0
}

declare void @usb_driver_release_interface(%struct.usb_driver*, %struct.usb_interface*) #3

declare i32 @device_attach(%struct.device*) #3

; Function Attrs: nounwind uwtable
define internal %struct.async* @async_getpending(%struct.dev_state* %ps, i8* %userurb) #1 {
entry:
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %asynclist6.sink = phi %struct.list_head* [ %asynclist4, %for.inc ], [ %async_pending, %entry ]
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %asynclist6.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next7, align 8, !tbaa !56
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr9 to %struct.async*
  %asynclist = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  %async_pending1 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  %cmp = icmp ne %struct.list_head* %asynclist, %async_pending1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 7
  %3 = load i8*, i8** %userurb2, align 8, !tbaa !245
  %cmp3 = icmp eq i8* %3, %userurb
  %asynclist4 = getelementptr inbounds %struct.async, %struct.async* %2, i32 0, i32 0
  br i1 %cmp3, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  call void @list_del_init(%struct.list_head* %asynclist4)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.then
  %retval.0 = phi %struct.async* [ %2, %if.then ], [ null, %for.cond ]
  ret %struct.async* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @processcompl(%struct.async* %as, i8** %arg) #1 {
entry:
  %urb1 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 8
  %0 = load %struct.urb*, %struct.urb** %urb1, align 8, !tbaa !120
  %userurb2 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %1 = load i8*, i8** %userurb2, align 8, !tbaa !245
  %2 = bitcast i8* %1 to %struct.usbdevfs_urb*
  %userurb3 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 7
  %3 = load i8*, i8** %userurb3, align 8, !tbaa !245
  %userbuffer = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %4 = load i8*, i8** %userbuffer, align 8, !tbaa !246
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %entry
  %actual_length = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %5 = load i32, i32* %actual_length, align 4, !tbaa !263
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %if.then, label %if.end8

if.then:                                          ; preds = %land.lhs.true
  %userbuffer5 = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 6
  %6 = load i8*, i8** %userbuffer5, align 8, !tbaa !246
  %call = call i32 @copy_urb_data_to_user(i8* %6, %struct.urb* %0)
  %tobool6 = icmp ne i32 %call, 0
  br i1 %tobool6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.then, %land.lhs.true, %entry
  call void @might_fault()
  %status = getelementptr inbounds %struct.async, %struct.async* %as, i32 0, i32 10
  %7 = load i32, i32* %status, align 4, !tbaa !257
  %status9 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 2
  %8 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %7, i32* %status9) #7, !srcloc !316
  %tobool10 = icmp ne i32 %8, 0
  br i1 %tobool10, label %cleanup, label %if.end12

if.end12:                                         ; preds = %if.end8
  call void @might_fault()
  %actual_length15 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 20
  %9 = load i32, i32* %actual_length15, align 4, !tbaa !263
  %actual_length16 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 6
  %10 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %9, i32* %actual_length16) #7, !srcloc !317
  %tobool18 = icmp ne i32 %10, 0
  br i1 %tobool18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end12
  call void @might_fault()
  %error_count = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 26
  %11 = load i32, i32* %error_count, align 4, !tbaa !302
  %error_count23 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 9
  %12 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %11, i32* %error_count23) #7, !srcloc !318
  %tobool25 = icmp ne i32 %12, 0
  br i1 %tobool25, label %cleanup, label %if.end27

if.end27:                                         ; preds = %if.end20
  %ep = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 9
  %13 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %ep, align 8, !tbaa !304
  %desc = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %13, i32 0, i32 0
  %call28 = call i32 @usb_endpoint_xfer_isoc(%struct.usb_endpoint_descriptor* %desc)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.end56

if.then30:                                        ; preds = %if.end27
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then30
  %i.0 = phi i32 [ 0, %if.then30 ], [ %inc, %for.inc ]
  %number_of_packets = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 24
  %14 = load i32, i32* %number_of_packets, align 4, !tbaa !236
  %cmp = icmp ult i32 %i.0, %14
  br i1 %cmp, label %for.body, label %if.end56

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %iso_frame_desc = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc, i64 0, i64 %idxprom
  %actual_length33 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx, i32 0, i32 2
  %15 = load i32, i32* %actual_length33, align 8, !tbaa !305
  %iso_frame_desc34 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom35 = zext i32 %i.0 to i64
  %arrayidx36 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc34, i64 0, i64 %idxprom35
  %actual_length37 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx36, i32 0, i32 1
  %16 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %15, i32* %actual_length37) #7, !srcloc !319
  %tobool39 = icmp ne i32 %16, 0
  br i1 %tobool39, label %cleanup, label %if.end41

if.end41:                                         ; preds = %for.body
  call void @might_fault()
  %iso_frame_desc44 = getelementptr inbounds %struct.urb, %struct.urb* %0, i32 0, i32 29
  %idxprom45 = zext i32 %i.0 to i64
  %arrayidx46 = getelementptr inbounds [0 x %struct.usb_iso_packet_descriptor], [0 x %struct.usb_iso_packet_descriptor]* %iso_frame_desc44, i64 0, i64 %idxprom45
  %status47 = getelementptr inbounds %struct.usb_iso_packet_descriptor, %struct.usb_iso_packet_descriptor* %arrayidx46, i32 0, i32 3
  %17 = load i32, i32* %status47, align 4, !tbaa !307
  %iso_frame_desc48 = getelementptr inbounds %struct.usbdevfs_urb, %struct.usbdevfs_urb* %2, i32 0, i32 12
  %idxprom49 = zext i32 %i.0 to i64
  %arrayidx50 = getelementptr inbounds [0 x %struct.usbdevfs_iso_packet_desc], [0 x %struct.usbdevfs_iso_packet_desc]* %iso_frame_desc48, i64 0, i64 %idxprom49
  %status51 = getelementptr inbounds %struct.usbdevfs_iso_packet_desc, %struct.usbdevfs_iso_packet_desc* %arrayidx50, i32 0, i32 2
  %18 = call i32 asm sideeffect "call __put_user_4", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %17, i32* %status51) #7, !srcloc !320
  %tobool53 = icmp ne i32 %18, 0
  br i1 %tobool53, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end41
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end56:                                         ; preds = %for.cond, %if.end27
  call void @might_fault()
  %19 = call i8* asm sideeffect "call __put_user_8", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i8* %3, i8** %arg) #7, !srcloc !321
  %20 = ptrtoint i8* %19 to i64
  %21 = trunc i64 %20 to i32
  %tobool60 = icmp ne i32 %21, 0
  %. = select i1 %tobool60, i32 -14, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.then, %if.end8, %if.end12, %if.end20, %for.body, %if.end41, %if.end56
  %retval.0 = phi i32 [ %., %if.end56 ], [ -14, %if.end41 ], [ -14, %for.body ], [ -14, %if.end20 ], [ -14, %if.end12 ], [ -14, %if.end8 ], [ -14, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @releaseintf(%struct.dev_state* %ps, i32 %ifnum) #1 {
entry:
  %conv = zext i32 %ifnum to i64
  %cmp = icmp uge i64 %conv, 64
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 1
  %0 = load %struct.usb_device*, %struct.usb_device** %dev2, align 8, !tbaa !44
  %call = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %ifnum)
  %tobool = icmp ne %struct.usb_interface* %call, null
  br i1 %tobool, label %if.else, label %cleanup

if.else:                                          ; preds = %if.end
  %ifclaimed = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 11
  %call4 = call i32 @test_and_clear_bit(i32 %ifnum, i64* %ifclaimed)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.else
  call void @usb_driver_release_interface(%struct.usb_driver* @usbfs_driver, %struct.usb_interface* %call)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then6, %if.else, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -2, %if.end ], [ 0, %if.then6 ], [ -22, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !322
  ret i32 %0
}

declare i32 @usb_hub_claim_port(%struct.usb_device*, i32, %struct.dev_state*) #3

declare i32 @usb_hub_release_port(%struct.usb_device*, i32, %struct.dev_state*) #3

declare i32 @strncmp(i8*, i8*, i64) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @imajor(%struct.inode* %inode) #0 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !64
  %shr = lshr i32 %0, 20
  ret i32 %shr
}

; Function Attrs: nounwind uwtable
define internal %struct.usb_device* @usbdev_lookup_by_devt(i32 %devt) #1 {
entry:
  %conv = zext i32 %devt to i64
  %0 = inttoptr i64 %conv to i8*
  %call = call %struct.device* @bus_find_device(%struct.bus_type* @usb_bus_type, %struct.device* null, i8* %0, i32 (%struct.device*, i8*)* @match_devt)
  %tobool = icmp ne %struct.device* %call, null
  %1 = bitcast %struct.device* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -136
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  %retval.0 = select i1 %tobool, %struct.usb_device* %2, %struct.usb_device* null
  ret %struct.usb_device* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_autoresume_device(%struct.usb_device* %udev) #0 {
entry:
  ret i32 0
}

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #3

declare void @usb_put_dev(%struct.usb_device*) #3

declare %struct.device* @bus_find_device(%struct.bus_type*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) #3

; Function Attrs: nounwind uwtable
define internal i32 @match_devt(%struct.device* %dev, i8* %data) #1 {
entry:
  %devt = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 20
  %0 = load i32, i32* %devt, align 8, !tbaa !323
  %1 = ptrtoint i8* %data to i64
  %conv = trunc i64 %1 to i32
  %cmp = icmp eq i32 %0, %conv
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

declare void @usb_hub_release_all_ports(%struct.usb_device*, %struct.dev_state*) #3

; Function Attrs: nounwind uwtable
define internal void @destroy_all_async(%struct.dev_state* %ps) #1 {
entry:
  %async_pending = getelementptr inbounds %struct.dev_state, %struct.dev_state* %ps, i32 0, i32 4
  call void @destroy_async(%struct.dev_state* %ps, %struct.list_head* %async_pending)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @usbdev_notify(%struct.notifier_block* %self, i64 %action, i8* %dev) #1 {
entry:
  %cond = icmp eq i64 %action, 2
  br i1 %cond, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %entry
  %0 = bitcast i8* %dev to %struct.usb_device*
  call void @usbdev_remove(%struct.usb_device* %0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %sw.bb
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @usbdev_remove(%struct.usb_device* %udev) #1 {
entry:
  %sinfo = alloca %struct.siginfo, align 8
  %0 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %filelist = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %call = call i32 @list_empty(%struct.list_head* %filelist)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %filelist1 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %udev, i32 0, i32 27
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %filelist1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !324
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.dev_state*
  call void @destroy_all_async(%struct.dev_state* %3)
  %wait = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 6
  call void @__wake_up(%struct.__wait_queue_head* %wait, i32 3, i32 0, i8* null)
  %list = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 0
  call void @list_del_init(%struct.list_head* %list)
  %discsignr = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  %4 = load i32, i32* %discsignr, align 8, !tbaa !77
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %discsignr3 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  %5 = load i32, i32* %discsignr3, align 8, !tbaa !77
  %si_signo = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 0
  store i32 %5, i32* %si_signo, align 8, !tbaa !258
  %si_errno = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 1
  store i32 32, i32* %si_errno, align 4, !tbaa !260
  %si_code = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 2
  store i32 -4, i32* %si_code, align 8, !tbaa !261
  %disccontext = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 10
  %6 = load i8*, i8** %disccontext, align 8, !tbaa !107
  %_sifields = getelementptr inbounds %struct.siginfo, %struct.siginfo* %sinfo, i32 0, i32 3
  %_sigfault = bitcast %union.anon.32* %_sifields to %struct.anon.37*
  %_addr = getelementptr inbounds %struct.anon.37, %struct.anon.37* %_sigfault, i32 0, i32 0
  store i8* %6, i8** %_addr, align 8, !tbaa !74
  %discsignr4 = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 7
  %7 = load i32, i32* %discsignr4, align 8, !tbaa !77
  %disc_pid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 8
  %8 = load %struct.pid*, %struct.pid** %disc_pid, align 8, !tbaa !78
  %cred = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 9
  %9 = load %struct.cred*, %struct.cred** %cred, align 8, !tbaa !106
  %secid = getelementptr inbounds %struct.dev_state, %struct.dev_state* %3, i32 0, i32 12
  %10 = load i32, i32* %secid, align 8, !tbaa !325
  %call5 = call i32 @kill_pid_info_as_cred(i32 %7, %struct.siginfo* %sinfo, %struct.pid* %8, %struct.cred* %9, i32 %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %11 = bitcast %struct.siginfo* %sinfo to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %11) #7
  ret void
}

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }
attributes #8 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !4, i64 0}
!13 = !{!"usb_interface", !4, i64 0, !4, i64 8, !14, i64 16, !4, i64 24, !14, i64 32, !5, i64 36, !14, i64 40, !14, i64 40, !14, i64 40, !14, i64 40, !14, i64 40, !14, i64 40, !14, i64 40, !14, i64 40, !15, i64 48, !4, i64 488, !19, i64 496, !31, i64 504}
!14 = !{!"int", !5, i64 0}
!15 = !{!"device", !4, i64 0, !4, i64 8, !16, i64 16, !4, i64 80, !4, i64 88, !20, i64 96, !4, i64 136, !4, i64 144, !4, i64 152, !22, i64 160, !4, i64 248, !14, i64 256, !4, i64 264, !27, i64 272, !4, i64 280, !17, i64 288, !4, i64 304, !28, i64 312, !4, i64 328, !29, i64 336, !14, i64 344, !14, i64 348, !21, i64 352, !17, i64 360, !30, i64 376, !4, i64 408, !4, i64 416, !4, i64 424, !4, i64 432}
!16 = !{!"kobject", !4, i64 0, !17, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !18, i64 56, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60}
!17 = !{!"list_head", !4, i64 0, !4, i64 8}
!18 = !{!"kref", !19, i64 0}
!19 = !{!"", !14, i64 0}
!20 = !{!"mutex", !19, i64 0, !21, i64 4, !17, i64 8, !4, i64 24, !4, i64 32}
!21 = !{!"spinlock", !5, i64 0}
!22 = !{!"dev_pm_info", !23, i64 0, !14, i64 4, !14, i64 4, !24, i64 4, !24, i64 4, !24, i64 4, !24, i64 4, !21, i64 6, !17, i64 8, !25, i64 24, !4, i64 56, !24, i64 64, !24, i64 64, !4, i64 72, !4, i64 80}
!23 = !{!"pm_message", !14, i64 0}
!24 = !{!"_Bool", !5, i64 0}
!25 = !{!"completion", !14, i64 0, !26, i64 8}
!26 = !{!"__wait_queue_head", !21, i64 0, !17, i64 8}
!27 = !{!"long long", !5, i64 0}
!28 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!29 = !{!"acpi_dev_node", !4, i64 0}
!30 = !{!"klist_node", !4, i64 0, !17, i64 8, !18, i64 24}
!31 = !{!"work_struct", !32, i64 0, !17, i64 8, !4, i64 24}
!32 = !{!"", !33, i64 0}
!33 = !{!"long", !5, i64 0}
!34 = !{!35, !5, i64 2}
!35 = !{!"usb_host_interface", !36, i64 0, !14, i64 12, !4, i64 16, !4, i64 24, !4, i64 32}
!36 = !{!"usb_interface_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!37 = !{!38, !27, i64 72}
!38 = !{!"file", !5, i64 0, !39, i64 16, !4, i64 32, !4, i64 40, !21, i64 48, !14, i64 52, !32, i64 56, !14, i64 64, !14, i64 68, !27, i64 72, !40, i64 80, !4, i64 112, !42, i64 120, !27, i64 152, !4, i64 160, !4, i64 168, !17, i64 176, !17, i64 192, !4, i64 208}
!39 = !{!"path", !4, i64 0, !4, i64 8}
!40 = !{!"fown_struct", !41, i64 0, !4, i64 8, !5, i64 16, !14, i64 20, !14, i64 24, !14, i64 28}
!41 = !{!"", !5, i64 0}
!42 = !{!"file_ra_state", !33, i64 0, !14, i64 8, !14, i64 12, !14, i64 16, !14, i64 20, !27, i64 24}
!43 = !{!38, !4, i64 168}
!44 = !{!45, !4, i64 16}
!45 = !{!"dev_state", !17, i64 0, !4, i64 16, !4, i64 24, !21, i64 32, !17, i64 40, !17, i64 56, !26, i64 72, !14, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !33, i64 128, !14, i64 136, !14, i64 140}
!46 = !{!27, !27, i64 0}
!47 = !{!48, !5, i64 593}
!48 = !{!"usb_device", !14, i64 0, !5, i64 4, !14, i64 20, !5, i64 24, !5, i64 28, !4, i64 32, !14, i64 40, !5, i64 44, !4, i64 56, !4, i64 64, !49, i64 72, !15, i64 136, !53, i64 576, !4, i64 600, !4, i64 608, !4, i64 616, !5, i64 624, !5, i64 752, !4, i64 880, !51, i64 888, !5, i64 890, !5, i64 891, !14, i64 892, !14, i64 892, !14, i64 892, !14, i64 892, !14, i64 892, !14, i64 892, !14, i64 892, !14, i64 892, !14, i64 893, !14, i64 893, !14, i64 896, !4, i64 904, !4, i64 912, !4, i64 920, !17, i64 928, !14, i64 944, !14, i64 948, !19, i64 952, !33, i64 960, !33, i64 968, !14, i64 976, !14, i64 976, !14, i64 976, !4, i64 984, !14, i64 992, !5, i64 996, !54, i64 1000, !54, i64 1016, !14, i64 1032}
!49 = !{!"usb_host_endpoint", !50, i64 0, !52, i64 9, !17, i64 16, !4, i64 32, !4, i64 40, !4, i64 48, !14, i64 56, !14, i64 60}
!50 = !{!"usb_endpoint_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !51, i64 4, !5, i64 6, !5, i64 7, !5, i64 8}
!51 = !{!"short", !5, i64 0}
!52 = !{!"usb_ss_ep_comp_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !51, i64 4}
!53 = !{!"usb_device_descriptor", !5, i64 0, !5, i64 1, !51, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !51, i64 8, !51, i64 10, !51, i64 12, !5, i64 14, !5, i64 15, !5, i64 16, !5, i64 17}
!54 = !{!"usb3_lpm_parameters", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12}
!55 = !{!48, !4, i64 880}
!56 = !{!4, !4, i64 0}
!57 = !{!58, !51, i64 2}
!58 = !{!"usb_config_descriptor", !5, i64 0, !5, i64 1, !51, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!59 = !{!48, !4, i64 608}
!60 = !{!61, !51, i64 2}
!61 = !{!"usb_host_config", !58, i64 0, !4, i64 16, !5, i64 24, !5, i64 152, !5, i64 408, !4, i64 664, !14, i64 672}
!62 = !{!14, !14, i64 0}
!63 = !{!38, !14, i64 68}
!64 = !{!65, !14, i64 76}
!65 = !{!"inode", !51, i64 0, !51, i64 2, !14, i64 4, !14, i64 8, !14, i64 12, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !33, i64 64, !5, i64 72, !14, i64 76, !27, i64 80, !66, i64 88, !66, i64 104, !66, i64 120, !21, i64 136, !51, i64 138, !14, i64 140, !33, i64 144, !33, i64 152, !20, i64 160, !33, i64 200, !67, i64 208, !17, i64 224, !17, i64 240, !17, i64 256, !5, i64 272, !27, i64 288, !19, i64 296, !19, i64 300, !19, i64 304, !4, i64 312, !4, i64 320, !68, i64 328, !5, i64 496, !17, i64 512, !5, i64 528, !14, i64 536, !14, i64 540, !71, i64 544, !4, i64 552}
!66 = !{!"timespec", !33, i64 0, !33, i64 8}
!67 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!68 = !{!"address_space", !4, i64 0, !69, i64 8, !21, i64 24, !14, i64 28, !70, i64 32, !17, i64 40, !20, i64 56, !33, i64 96, !33, i64 104, !4, i64 112, !33, i64 120, !4, i64 128, !21, i64 136, !17, i64 144, !4, i64 160}
!69 = !{!"radix_tree_root", !14, i64 0, !14, i64 4, !4, i64 8}
!70 = !{!"rb_root", !4, i64 0}
!71 = !{!"hlist_head", !4, i64 0}
!72 = !{!48, !5, i64 24}
!73 = !{!45, !4, i64 24}
!74 = !{!5, !5, i64 0}
!75 = !{i64 0, i64 2, !76, i64 0, i64 1, !74, i64 1, i64 1, !74}
!76 = !{!51, !51, i64 0}
!77 = !{!45, !14, i64 96}
!78 = !{!45, !4, i64 104}
!79 = !{!80, !4, i64 1088}
!80 = !{!"task_struct", !33, i64 0, !4, i64 8, !19, i64 16, !14, i64 20, !14, i64 24, !81, i64 32, !14, i64 40, !14, i64 44, !14, i64 48, !14, i64 52, !14, i64 56, !14, i64 60, !4, i64 64, !82, i64 72, !87, i64 448, !4, i64 496, !5, i64 504, !14, i64 508, !14, i64 512, !14, i64 516, !88, i64 520, !89, i64 528, !17, i64 560, !90, i64 576, !4, i64 616, !4, i64 624, !91, i64 632, !14, i64 648, !14, i64 652, !14, i64 656, !14, i64 660, !14, i64 664, !14, i64 668, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 676, !14, i64 680, !4, i64 688, !4, i64 696, !17, i64 704, !17, i64 720, !4, i64 736, !17, i64 744, !17, i64 760, !5, i64 776, !17, i64 848, !4, i64 864, !4, i64 872, !4, i64 880, !33, i64 888, !33, i64 896, !33, i64 904, !33, i64 912, !33, i64 920, !92, i64 928, !33, i64 944, !33, i64 952, !66, i64 960, !66, i64 976, !33, i64 992, !33, i64 1000, !93, i64 1008, !5, i64 1032, !4, i64 1080, !4, i64 1088, !5, i64 1096, !14, i64 1112, !14, i64 1116, !94, i64 1120, !95, i64 1128, !4, i64 1312, !4, i64 1320, !4, i64 1328, !4, i64 1336, !4, i64 1344, !41, i64 1352, !41, i64 1360, !41, i64 1368, !97, i64 1376, !33, i64 1400, !33, i64 1408, !4, i64 1416, !4, i64 1424, !4, i64 1432, !4, i64 1440, !4, i64 1448, !14, i64 1456, !14, i64 1460, !98, i64 1464, !14, i64 1480, !14, i64 1484, !21, i64 1488, !99, i64 1490, !101, i64 1496, !4, i64 1512, !4, i64 1520, !4, i64 1528, !4, i64 1536, !4, i64 1544, !4, i64 1552, !4, i64 1560, !33, i64 1568, !4, i64 1576, !102, i64 1584, !27, i64 1640, !27, i64 1648, !33, i64 1656, !41, i64 1664, !103, i64 1672, !14, i64 1676, !14, i64 1680, !4, i64 1688, !17, i64 1696, !4, i64 1712, !4, i64 1720, !17, i64 1728, !4, i64 1744, !5, i64 1752, !20, i64 1768, !17, i64 1808, !4, i64 1824, !51, i64 1832, !51, i64 1834, !104, i64 1840, !4, i64 1856, !105, i64 1864, !4, i64 1880, !14, i64 1888, !14, i64 1892, !33, i64 1896, !33, i64 1904, !33, i64 1912, !33, i64 1920, !33, i64 1928, !19, i64 1936}
!81 = !{!"llist_node", !4, i64 0}
!82 = !{!"sched_entity", !83, i64 0, !84, i64 16, !17, i64 40, !14, i64 56, !27, i64 64, !27, i64 72, !27, i64 80, !27, i64 88, !27, i64 96, !85, i64 104, !4, i64 320, !4, i64 328, !4, i64 336, !86, i64 344}
!83 = !{!"load_weight", !33, i64 0, !33, i64 8}
!84 = !{!"rb_node", !33, i64 0, !4, i64 8, !4, i64 16}
!85 = !{!"sched_statistics", !27, i64 0, !27, i64 8, !27, i64 16, !27, i64 24, !27, i64 32, !27, i64 40, !27, i64 48, !27, i64 56, !27, i64 64, !27, i64 72, !27, i64 80, !27, i64 88, !27, i64 96, !27, i64 104, !27, i64 112, !27, i64 120, !27, i64 128, !27, i64 136, !27, i64 144, !27, i64 152, !27, i64 160, !27, i64 168, !27, i64 176, !27, i64 184, !27, i64 192, !27, i64 200, !27, i64 208}
!86 = !{!"sched_avg", !14, i64 0, !14, i64 4, !27, i64 8, !27, i64 16, !33, i64 24}
!87 = !{!"sched_rt_entity", !17, i64 0, !33, i64 16, !33, i64 24, !14, i64 32, !4, i64 40}
!88 = !{!"cpumask", !5, i64 0}
!89 = !{!"sched_info", !33, i64 0, !27, i64 8, !27, i64 16, !27, i64 24}
!90 = !{!"plist_node", !14, i64 0, !17, i64 8, !17, i64 24}
!91 = !{!"task_rss_stat", !14, i64 0, !5, i64 4}
!92 = !{!"cputime", !33, i64 0, !33, i64 8}
!93 = !{!"task_cputime", !33, i64 0, !33, i64 8, !27, i64 16}
!94 = !{!"sysv_sem", !4, i64 0}
!95 = !{!"thread_struct", !5, i64 0, !33, i64 24, !33, i64 32, !33, i64 40, !51, i64 48, !51, i64 50, !51, i64 52, !51, i64 54, !33, i64 56, !33, i64 64, !5, i64 72, !33, i64 104, !33, i64 112, !33, i64 120, !33, i64 128, !33, i64 136, !96, i64 144, !4, i64 160, !33, i64 168, !14, i64 176}
!96 = !{!"fpu", !14, i64 0, !14, i64 4, !4, i64 8}
!97 = !{!"sigpending", !17, i64 0, !41, i64 16}
!98 = !{!"seccomp", !14, i64 0, !4, i64 8}
!99 = !{!"raw_spinlock", !100, i64 0}
!100 = !{!"arch_spinlock", !5, i64 0}
!101 = !{!"plist_head", !17, i64 0}
!102 = !{!"task_io_accounting", !27, i64 0, !27, i64 8, !27, i64 16, !27, i64 24, !27, i64 32, !27, i64 40, !27, i64 48}
!103 = !{!"seqcount", !14, i64 0}
!104 = !{!"callback_head", !4, i64 0, !4, i64 8}
!105 = !{!"page_frag", !4, i64 0, !14, i64 8, !14, i64 12}
!106 = !{!45, !4, i64 112}
!107 = !{!45, !4, i64 120}
!108 = !{!45, !33, i64 128}
!109 = !{i32 -2143885651}
!110 = !{!24, !24, i64 0}
!111 = !{i8 0, i8 2}
!112 = !{i32 773302, i32 773323}
!113 = !{!33, !33, i64 0}
!114 = !{i32 -2146838774}
!115 = !{i32 -2147070008, i32 -2147069969, i32 -2147069948, i32 -2147069911, i32 -2147069888, i32 -2147070018}
!116 = !{!17, !4, i64 0}
!117 = !{!118, !14, i64 44}
!118 = !{!"async", !17, i64 0, !4, i64 16, !4, i64 24, !4, i64 32, !14, i64 40, !14, i64 44, !4, i64 48, !4, i64 56, !4, i64 64, !14, i64 72, !14, i64 76, !14, i64 80, !5, i64 84, !5, i64 85}
!119 = !{!17, !4, i64 8}
!120 = !{!118, !4, i64 64}
!121 = !{!38, !4, i64 32}
!122 = !{!123, !4, i64 0}
!123 = !{!"poll_table_struct", !4, i64 0, !33, i64 8}
!124 = !{i64 0, i64 8, !113, i64 8, i64 8, !113}
!125 = !{!126, !5, i64 0}
!126 = !{!"usbdevfs_ctrltransfer", !5, i64 0, !5, i64 1, !51, i64 2, !51, i64 4, !51, i64 6, !14, i64 8, !4, i64 16}
!127 = !{!126, !5, i64 1}
!128 = !{!126, !51, i64 4}
!129 = !{!126, !51, i64 6}
!130 = !{!126, !14, i64 8}
!131 = !{!126, !4, i64 16}
!132 = !{!133, !33, i64 32}
!133 = !{!"thread_info", !4, i64 0, !4, i64 8, !14, i64 16, !14, i64 20, !14, i64 24, !14, i64 28, !32, i64 32, !134, i64 40, !4, i64 88, !14, i64 96, !14, i64 96}
!134 = !{!"restart_block", !4, i64 0, !5, i64 8}
!135 = !{i32 -2143883508}
!136 = !{!126, !51, i64 2}
!137 = !{!138, !14, i64 0}
!138 = !{!"usbdevfs_bulktransfer", !14, i64 0, !14, i64 4, !14, i64 8, !4, i64 16}
!139 = !{!138, !14, i64 4}
!140 = !{!138, !14, i64 8}
!141 = !{!138, !4, i64 16}
!142 = !{i32 -2143881137}
!143 = !{i32 -2143880549}
!144 = !{i32 -2143879954}
!145 = !{!146, !14, i64 0}
!146 = !{!"usbdevfs_getdriver", !14, i64 0, !5, i64 4}
!147 = !{!13, !4, i64 192}
!148 = !{!149, !4, i64 0}
!149 = !{!"device_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !24, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112}
!150 = !{!48, !14, i64 0}
!151 = !{!152, !14, i64 0}
!152 = !{!"usbdevfs_connectinfo", !14, i64 0, !5, i64 4}
!153 = !{!48, !5, i64 28}
!154 = !{!152, !5, i64 4}
!155 = !{!156, !14, i64 0}
!156 = !{!"usbdevfs_setinterface", !14, i64 0, !14, i64 4}
!157 = !{!156, !14, i64 4}
!158 = !{i32 -2143879179}
!159 = !{!48, !4, i64 616}
!160 = !{!61, !5, i64 4}
!161 = !{!13, !4, i64 8}
!162 = !{!61, !5, i64 5}
!163 = !{i32 -2143861820}
!164 = !{i32 -2143860246}
!165 = !{i32 -2143859792}
!166 = !{i32 -2143858488}
!167 = !{i32 -2143857837}
!168 = !{i32 -2143856515}
!169 = !{i32 -2143855857}
!170 = !{i32 -2143854463}
!171 = !{i32 -2143853777}
!172 = !{i32 -2143852205}
!173 = !{!174, !14, i64 0}
!174 = !{!"usbdevfs_disconnectsignal32", !14, i64 0, !14, i64 4}
!175 = !{!174, !14, i64 4}
!176 = !{i32 -2143631443}
!177 = !{i32 -2143621363, i32 -2143621356, i32 -2143621342, i32 -2143621340, i32 -2143622013, i32 -2143621300, i32 -2143621252, i32 -2143621186, i32 -2143621124, i32 -2143621072, i32 -2143621933, i32 -2143621908, i32 -2143620867, i32 -2143621835, i32 -2143621810, i32 -2143620607, i32 -2143620683, i32 -2143620590, i32 -2143620639, i32 -2143622533, i32 -2143622492, i32 -2143619824, i32 -2143619810, i32 -2143619808, i32 -2143620481, i32 -2143619768, i32 -2143619720, i32 -2143619654, i32 -2143619592, i32 -2143619540, i32 -2143620401, i32 -2143620376, i32 -2143619335, i32 -2143620303, i32 -2143620278, i32 -2143619075, i32 -2143619151, i32 -2143619058, i32 -2143619107, i32 -2143622460, i32 -2143622421, i32 -2143622392, i32 -2143622346, i32 -2143622321, i32 -2143619041, i32 -2143618997, i32 -2143618974, i32 -2143618941, i32 -2143618910}
!178 = !{!179, !14, i64 0}
!179 = !{!"usbdevfs_ioctl", !14, i64 0, !14, i64 4, !4, i64 8}
!180 = !{i32 -2143605023, i32 -2143605016, i32 -2143605002, i32 -2143605000, i32 -2143605673, i32 -2143604960, i32 -2143604912, i32 -2143604846, i32 -2143604784, i32 -2143604732, i32 -2143605593, i32 -2143605568, i32 -2143604527, i32 -2143605495, i32 -2143605470, i32 -2143604267, i32 -2143604343, i32 -2143604250, i32 -2143604299, i32 -2143606199, i32 -2143606158, i32 -2143603484, i32 -2143603470, i32 -2143603468, i32 -2143604141, i32 -2143603428, i32 -2143603380, i32 -2143603314, i32 -2143603252, i32 -2143603200, i32 -2143604061, i32 -2143604036, i32 -2143602995, i32 -2143603963, i32 -2143603938, i32 -2143602735, i32 -2143602811, i32 -2143602718, i32 -2143602767, i32 -2143606126, i32 -2143606087, i32 -2143606058, i32 -2143606012, i32 -2143605987, i32 -2143602701, i32 -2143602657, i32 -2143602634, i32 -2143602601, i32 -2143602570}
!181 = !{!179, !14, i64 4}
!182 = !{i32 -2143584714, i32 -2143584707, i32 -2143584693, i32 -2143584691, i32 -2143585364, i32 -2143584651, i32 -2143584603, i32 -2143584537, i32 -2143584475, i32 -2143584423, i32 -2143585284, i32 -2143585259, i32 -2143584218, i32 -2143585186, i32 -2143585161, i32 -2143583958, i32 -2143584034, i32 -2143583941, i32 -2143583990, i32 -2143585884, i32 -2143585843, i32 -2143583175, i32 -2143583161, i32 -2143583159, i32 -2143583832, i32 -2143583119, i32 -2143583071, i32 -2143583005, i32 -2143582943, i32 -2143582891, i32 -2143583752, i32 -2143583727, i32 -2143582686, i32 -2143583654, i32 -2143583629, i32 -2143582426, i32 -2143582502, i32 -2143582409, i32 -2143582458, i32 -2143585811, i32 -2143585772, i32 -2143585743, i32 -2143585697, i32 -2143585672, i32 -2143582392, i32 -2143582348, i32 -2143582325, i32 -2143582292, i32 -2143582261}
!183 = !{!179, !4, i64 8}
!184 = !{!185, !14, i64 0}
!185 = !{!"usbdevfs_disconnectsignal", !14, i64 0, !4, i64 8}
!186 = !{!185, !4, i64 8}
!187 = !{i32 -2143635501}
!188 = !{i32 -2143634903}
!189 = !{i32 -2143578172}
!190 = !{i32 -2143577253}
!191 = !{!48, !4, i64 64}
!192 = !{!193, !14, i64 28}
!193 = !{!"usb_bus", !4, i64 0, !14, i64 8, !4, i64 16, !5, i64 24, !5, i64 25, !5, i64 26, !14, i64 27, !14, i64 27, !14, i64 27, !14, i64 28, !14, i64 32, !194, i64 40, !4, i64 56, !4, i64 64, !17, i64 72, !14, i64 88, !14, i64 92, !14, i64 96, !14, i64 100, !4, i64 104, !14, i64 112}
!194 = !{!"usb_devmap", !5, i64 0}
!195 = !{i32 -2143575671}
!196 = !{!197, !14, i64 0}
!197 = !{!"usbdevfs_disconnect_claim", !14, i64 0, !14, i64 4, !5, i64 8}
!198 = !{!197, !14, i64 4}
!199 = !{!35, !5, i64 5}
!200 = !{i32 -2146647981}
!201 = !{!13, !14, i64 16}
!202 = !{!35, !5, i64 4}
!203 = !{!35, !4, i64 24}
!204 = !{!50, !5, i64 2}
!205 = !{i32 369116, i32 369127}
!206 = !{!80, !14, i64 676}
!207 = !{i32 -2147070716, i32 -2147070677, i32 -2147070656, i32 -2147070619, i32 -2147070596, i32 -2147070726}
!208 = !{i32 -2146676596, i32 -2146676557, i32 -2146676536, i32 -2146676499, i32 -2146676476, i32 -2146676606}
!209 = !{i32 -2146676384, i32 -2146676345, i32 -2146676324, i32 -2146676287, i32 -2146676264, i32 -2146676394}
!210 = !{!50, !51, i64 4}
!211 = !{!212, !14, i64 8}
!212 = !{!"usbdevfs_urb", !5, i64 0, !5, i64 1, !14, i64 4, !14, i64 8, !4, i64 16, !14, i64 24, !14, i64 28, !14, i64 32, !14, i64 36, !14, i64 40, !14, i64 44, !4, i64 48, !5, i64 56}
!213 = !{!212, !14, i64 24}
!214 = !{!212, !4, i64 16}
!215 = !{!212, !5, i64 0}
!216 = !{!212, !5, i64 1}
!217 = !{!218, !5, i64 0}
!218 = !{!"usb_ctrlrequest", !5, i64 0, !5, i64 1, !51, i64 2, !51, i64 4, !51, i64 6}
!219 = !{!218, !5, i64 1}
!220 = !{!212, !14, i64 36}
!221 = !{!222, !14, i64 0}
!222 = !{!"usbdevfs_iso_packet_desc", !14, i64 0, !14, i64 4, !14, i64 8}
!223 = !{i32 -2143877019}
!224 = !{!118, !14, i64 72}
!225 = !{!226, !4, i64 120}
!226 = !{!"urb", !18, i64 0, !4, i64 8, !19, i64 16, !19, i64 20, !14, i64 24, !17, i64 32, !17, i64 48, !4, i64 64, !4, i64 72, !4, i64 80, !14, i64 88, !14, i64 92, !14, i64 96, !14, i64 100, !4, i64 104, !27, i64 112, !4, i64 120, !14, i64 128, !14, i64 132, !14, i64 136, !14, i64 140, !4, i64 144, !27, i64 152, !14, i64 160, !14, i64 164, !14, i64 168, !14, i64 172, !4, i64 176, !4, i64 184, !5, i64 192}
!227 = !{!226, !14, i64 132}
!228 = !{!226, !4, i64 104}
!229 = !{!226, !4, i64 72}
!230 = !{!226, !14, i64 88}
!231 = !{!226, !14, i64 100}
!232 = !{!226, !14, i64 136}
!233 = !{!226, !4, i64 144}
!234 = !{!212, !14, i64 32}
!235 = !{!226, !14, i64 160}
!236 = !{!226, !14, i64 164}
!237 = !{!49, !5, i64 6}
!238 = !{!226, !14, i64 168}
!239 = !{!226, !4, i64 176}
!240 = !{!226, !4, i64 184}
!241 = !{!242, !14, i64 0}
!242 = !{!"usb_iso_packet_descriptor", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12}
!243 = !{!242, !14, i64 4}
!244 = !{!118, !4, i64 16}
!245 = !{!118, !4, i64 56}
!246 = !{!118, !4, i64 48}
!247 = !{!212, !14, i64 44}
!248 = !{!118, !14, i64 40}
!249 = !{!118, !4, i64 24}
!250 = !{!118, !4, i64 32}
!251 = !{!49, !5, i64 2}
!252 = !{!118, !5, i64 84}
!253 = !{!118, !5, i64 85}
!254 = !{!45, !14, i64 140}
!255 = !{!50, !5, i64 3}
!256 = !{!226, !14, i64 96}
!257 = !{!118, !14, i64 76}
!258 = !{!259, !14, i64 0}
!259 = !{!"siginfo", !14, i64 0, !14, i64 4, !14, i64 8, !5, i64 16}
!260 = !{!259, !14, i64 4}
!261 = !{!259, !14, i64 8}
!262 = !{!118, !14, i64 80}
!263 = !{!226, !14, i64 140}
!264 = !{!265, !4, i64 16}
!265 = !{!"pid_link", !67, i64 0, !4, i64 16}
!266 = !{!267, !14, i64 8}
!267 = !{!"scatterlist", !33, i64 0, !14, i64 8, !14, i64 12, !27, i64 16, !14, i64 24}
!268 = !{!267, !14, i64 12}
!269 = !{!267, !33, i64 0}
!270 = !{i32 -2144243576, i32 -2144243551, i32 -2144243281, i32 -2144243484, i32 -2144243453, i32 -2144243423}
!271 = !{i32 -2146564839}
!272 = !{i32 -2146580014}
!273 = !{i32 -2146675536, i32 -2146675497, i32 -2146675476, i32 -2146675439, i32 -2146675416, i32 -2146675546}
!274 = !{i32 -2146675960, i32 -2146675921, i32 -2146675900, i32 -2146675863, i32 -2146675840, i32 -2146675970}
!275 = !{i32 -2146563583}
!276 = !{i32 773744}
!277 = !{i32 -2143851355}
!278 = !{i32 -2143848771, i32 -2143848764, i32 -2143848750, i32 -2143848748, i32 -2143849421, i32 -2143848708, i32 -2143848660, i32 -2143848594, i32 -2143848532, i32 -2143848480, i32 -2143849341, i32 -2143849316, i32 -2143848275, i32 -2143849243, i32 -2143849218, i32 -2143848015, i32 -2143848091, i32 -2143847998, i32 -2143848047, i32 -2143849941, i32 -2143849900, i32 -2143847232, i32 -2143847218, i32 -2143847216, i32 -2143847889, i32 -2143847176, i32 -2143847128, i32 -2143847062, i32 -2143847000, i32 -2143846948, i32 -2143847809, i32 -2143847784, i32 -2143846743, i32 -2143847711, i32 -2143847686, i32 -2143846483, i32 -2143846559, i32 -2143846466, i32 -2143846515, i32 -2143849868, i32 -2143849829, i32 -2143849800, i32 -2143849754, i32 -2143849729, i32 -2143846449, i32 -2143846405, i32 -2143846382, i32 -2143846349, i32 -2143846318}
!279 = !{i32 -2143832481, i32 -2143832474, i32 -2143832460, i32 -2143832458, i32 -2143833131, i32 -2143832418, i32 -2143832370, i32 -2143832304, i32 -2143832242, i32 -2143832190, i32 -2143833051, i32 -2143833026, i32 -2143831985, i32 -2143832953, i32 -2143832928, i32 -2143831725, i32 -2143831801, i32 -2143831708, i32 -2143831757, i32 -2143833655, i32 -2143833614, i32 -2143830942, i32 -2143830928, i32 -2143830926, i32 -2143831599, i32 -2143830886, i32 -2143830838, i32 -2143830772, i32 -2143830710, i32 -2143830658, i32 -2143831519, i32 -2143831494, i32 -2143830453, i32 -2143831421, i32 -2143831396, i32 -2143830193, i32 -2143830269, i32 -2143830176, i32 -2143830225, i32 -2143833582, i32 -2143833543, i32 -2143833514, i32 -2143833468, i32 -2143833443, i32 -2143830159, i32 -2143830115, i32 -2143830092, i32 -2143830059, i32 -2143830028}
!280 = !{i32 -2143808681, i32 -2143808674, i32 -2143808660, i32 -2143808658, i32 -2143809331, i32 -2143808618, i32 -2143808570, i32 -2143808504, i32 -2143808442, i32 -2143808390, i32 -2143809251, i32 -2143809226, i32 -2143808185, i32 -2143809153, i32 -2143809128, i32 -2143807925, i32 -2143808001, i32 -2143807908, i32 -2143807957, i32 -2143809853, i32 -2143809812, i32 -2143807142, i32 -2143807128, i32 -2143807126, i32 -2143807799, i32 -2143807086, i32 -2143807038, i32 -2143806972, i32 -2143806910, i32 -2143806858, i32 -2143807719, i32 -2143807694, i32 -2143806653, i32 -2143807621, i32 -2143807596, i32 -2143806393, i32 -2143806469, i32 -2143806376, i32 -2143806425, i32 -2143809780, i32 -2143809741, i32 -2143809712, i32 -2143809666, i32 -2143809641, i32 -2143806359, i32 -2143806315, i32 -2143806292, i32 -2143806259, i32 -2143806228}
!281 = !{!212, !14, i64 4}
!282 = !{i32 -2143788360, i32 -2143788353, i32 -2143788339, i32 -2143788337, i32 -2143789010, i32 -2143788297, i32 -2143788249, i32 -2143788183, i32 -2143788121, i32 -2143788069, i32 -2143788930, i32 -2143788905, i32 -2143787864, i32 -2143788832, i32 -2143788807, i32 -2143787604, i32 -2143787680, i32 -2143787587, i32 -2143787636, i32 -2143789531, i32 -2143789490, i32 -2143786821, i32 -2143786807, i32 -2143786805, i32 -2143787478, i32 -2143786765, i32 -2143786717, i32 -2143786651, i32 -2143786589, i32 -2143786537, i32 -2143787398, i32 -2143787373, i32 -2143786332, i32 -2143787300, i32 -2143787275, i32 -2143786072, i32 -2143786148, i32 -2143786055, i32 -2143786104, i32 -2143789458, i32 -2143789419, i32 -2143789390, i32 -2143789344, i32 -2143789319, i32 -2143786038, i32 -2143785994, i32 -2143785971, i32 -2143785938, i32 -2143785907}
!283 = !{i32 -2143771960, i32 -2143771953, i32 -2143771939, i32 -2143771937, i32 -2143772610, i32 -2143771897, i32 -2143771849, i32 -2143771783, i32 -2143771721, i32 -2143771669, i32 -2143772530, i32 -2143772505, i32 -2143771464, i32 -2143772432, i32 -2143772407, i32 -2143771204, i32 -2143771280, i32 -2143771187, i32 -2143771236, i32 -2143773139, i32 -2143773098, i32 -2143770421, i32 -2143770407, i32 -2143770405, i32 -2143771078, i32 -2143770365, i32 -2143770317, i32 -2143770251, i32 -2143770189, i32 -2143770137, i32 -2143770998, i32 -2143770973, i32 -2143769932, i32 -2143770900, i32 -2143770875, i32 -2143769672, i32 -2143769748, i32 -2143769655, i32 -2143769704, i32 -2143773066, i32 -2143773027, i32 -2143772998, i32 -2143772952, i32 -2143772927, i32 -2143769638, i32 -2143769594, i32 -2143769571, i32 -2143769538, i32 -2143769507}
!284 = !{i32 -2143755528, i32 -2143755521, i32 -2143755507, i32 -2143755505, i32 -2143756178, i32 -2143755465, i32 -2143755417, i32 -2143755351, i32 -2143755289, i32 -2143755237, i32 -2143756098, i32 -2143756073, i32 -2143755032, i32 -2143756000, i32 -2143755975, i32 -2143754772, i32 -2143754848, i32 -2143754755, i32 -2143754804, i32 -2143756707, i32 -2143756666, i32 -2143753989, i32 -2143753975, i32 -2143753973, i32 -2143754646, i32 -2143753933, i32 -2143753885, i32 -2143753819, i32 -2143753757, i32 -2143753705, i32 -2143754566, i32 -2143754541, i32 -2143753500, i32 -2143754468, i32 -2143754443, i32 -2143753240, i32 -2143753316, i32 -2143753223, i32 -2143753272, i32 -2143756634, i32 -2143756595, i32 -2143756566, i32 -2143756520, i32 -2143756495, i32 -2143753206, i32 -2143753162, i32 -2143753139, i32 -2143753106, i32 -2143753075}
!285 = !{!212, !14, i64 28}
!286 = !{i32 -2143739132, i32 -2143739125, i32 -2143739111, i32 -2143739109, i32 -2143739782, i32 -2143739069, i32 -2143739021, i32 -2143738955, i32 -2143738893, i32 -2143738841, i32 -2143739702, i32 -2143739677, i32 -2143738636, i32 -2143739604, i32 -2143739579, i32 -2143738376, i32 -2143738452, i32 -2143738359, i32 -2143738408, i32 -2143740309, i32 -2143740268, i32 -2143737593, i32 -2143737579, i32 -2143737577, i32 -2143738250, i32 -2143737537, i32 -2143737489, i32 -2143737423, i32 -2143737361, i32 -2143737309, i32 -2143738170, i32 -2143738145, i32 -2143737104, i32 -2143738072, i32 -2143738047, i32 -2143736844, i32 -2143736920, i32 -2143736827, i32 -2143736876, i32 -2143740236, i32 -2143740197, i32 -2143740168, i32 -2143740122, i32 -2143740097, i32 -2143736810, i32 -2143736766, i32 -2143736743, i32 -2143736710, i32 -2143736679}
!287 = !{i32 -2143722636, i32 -2143722629, i32 -2143722615, i32 -2143722613, i32 -2143723286, i32 -2143722573, i32 -2143722525, i32 -2143722459, i32 -2143722397, i32 -2143722345, i32 -2143723206, i32 -2143723181, i32 -2143722140, i32 -2143723108, i32 -2143723083, i32 -2143721880, i32 -2143721956, i32 -2143721863, i32 -2143721912, i32 -2143723819, i32 -2143723778, i32 -2143721097, i32 -2143721083, i32 -2143721081, i32 -2143721754, i32 -2143721041, i32 -2143720993, i32 -2143720927, i32 -2143720865, i32 -2143720813, i32 -2143721674, i32 -2143721649, i32 -2143720608, i32 -2143721576, i32 -2143721551, i32 -2143720348, i32 -2143720424, i32 -2143720331, i32 -2143720380, i32 -2143723746, i32 -2143723707, i32 -2143723678, i32 -2143723632, i32 -2143723607, i32 -2143720314, i32 -2143720270, i32 -2143720247, i32 -2143720214, i32 -2143720183}
!288 = !{i32 -2143706224, i32 -2143706217, i32 -2143706203, i32 -2143706201, i32 -2143706874, i32 -2143706161, i32 -2143706113, i32 -2143706047, i32 -2143705985, i32 -2143705933, i32 -2143706794, i32 -2143706769, i32 -2143705728, i32 -2143706696, i32 -2143706671, i32 -2143705468, i32 -2143705544, i32 -2143705451, i32 -2143705500, i32 -2143707401, i32 -2143707360, i32 -2143704685, i32 -2143704671, i32 -2143704669, i32 -2143705342, i32 -2143704629, i32 -2143704581, i32 -2143704515, i32 -2143704453, i32 -2143704401, i32 -2143705262, i32 -2143705237, i32 -2143704196, i32 -2143705164, i32 -2143705139, i32 -2143703936, i32 -2143704012, i32 -2143703919, i32 -2143703968, i32 -2143707328, i32 -2143707289, i32 -2143707260, i32 -2143707214, i32 -2143707189, i32 -2143703902, i32 -2143703858, i32 -2143703835, i32 -2143703802, i32 -2143703771}
!289 = !{!212, !14, i64 40}
!290 = !{i32 -2143685883, i32 -2143685876, i32 -2143685862, i32 -2143685860, i32 -2143686533, i32 -2143685820, i32 -2143685772, i32 -2143685706, i32 -2143685644, i32 -2143685592, i32 -2143686453, i32 -2143686428, i32 -2143685387, i32 -2143686355, i32 -2143686330, i32 -2143685127, i32 -2143685203, i32 -2143685110, i32 -2143685159, i32 -2143687054, i32 -2143687013, i32 -2143684344, i32 -2143684330, i32 -2143684328, i32 -2143685001, i32 -2143684288, i32 -2143684240, i32 -2143684174, i32 -2143684112, i32 -2143684060, i32 -2143684921, i32 -2143684896, i32 -2143683855, i32 -2143684823, i32 -2143684798, i32 -2143683595, i32 -2143683671, i32 -2143683578, i32 -2143683627, i32 -2143686981, i32 -2143686942, i32 -2143686913, i32 -2143686867, i32 -2143686842, i32 -2143683561, i32 -2143683517, i32 -2143683494, i32 -2143683461, i32 -2143683430}
!291 = !{i32 -2143669622, i32 -2143669615, i32 -2143669601, i32 -2143669599, i32 -2143670272, i32 -2143669559, i32 -2143669511, i32 -2143669445, i32 -2143669383, i32 -2143669331, i32 -2143670192, i32 -2143670167, i32 -2143669126, i32 -2143670094, i32 -2143670069, i32 -2143668866, i32 -2143668942, i32 -2143668849, i32 -2143668898, i32 -2143670794, i32 -2143670753, i32 -2143668083, i32 -2143668069, i32 -2143668067, i32 -2143668740, i32 -2143668027, i32 -2143667979, i32 -2143667913, i32 -2143667851, i32 -2143667799, i32 -2143668660, i32 -2143668635, i32 -2143667594, i32 -2143668562, i32 -2143668537, i32 -2143667334, i32 -2143667410, i32 -2143667317, i32 -2143667366, i32 -2143670721, i32 -2143670682, i32 -2143670653, i32 -2143670607, i32 -2143670582, i32 -2143667300, i32 -2143667256, i32 -2143667233, i32 -2143667200, i32 -2143667169}
!292 = !{i32 -2143653277, i32 -2143653270, i32 -2143653256, i32 -2143653254, i32 -2143653927, i32 -2143653214, i32 -2143653166, i32 -2143653100, i32 -2143653038, i32 -2143652986, i32 -2143653847, i32 -2143653822, i32 -2143652781, i32 -2143653749, i32 -2143653724, i32 -2143652521, i32 -2143652597, i32 -2143652504, i32 -2143652553, i32 -2143654454, i32 -2143654413, i32 -2143651738, i32 -2143651724, i32 -2143651722, i32 -2143652395, i32 -2143651682, i32 -2143651634, i32 -2143651568, i32 -2143651506, i32 -2143651454, i32 -2143652315, i32 -2143652290, i32 -2143651249, i32 -2143652217, i32 -2143652192, i32 -2143650989, i32 -2143651065, i32 -2143650972, i32 -2143651021, i32 -2143654381, i32 -2143654342, i32 -2143654313, i32 -2143654267, i32 -2143654242, i32 -2143650955, i32 -2143650911, i32 -2143650888, i32 -2143650855, i32 -2143650824}
!293 = !{!212, !4, i64 48}
!294 = !{!295, !14, i64 0}
!295 = !{!"__wait_queue", !14, i64 0, !4, i64 8, !4, i64 16, !17, i64 24}
!296 = !{!295, !4, i64 8}
!297 = !{!295, !4, i64 16}
!298 = !{!80, !33, i64 0}
!299 = !{i32 -2143862061}
!300 = !{i32 -2143645751}
!301 = !{i32 -2143643985}
!302 = !{!226, !14, i64 172}
!303 = !{i32 -2143642196}
!304 = !{!226, !4, i64 80}
!305 = !{!242, !14, i64 8}
!306 = !{i32 -2143640161}
!307 = !{!242, !14, i64 12}
!308 = !{i32 -2143638077}
!309 = !{i32 -2143636256}
!310 = !{!45, !4, i64 56}
!311 = !{!80, !4, i64 8}
!312 = !{!313, !4, i64 24}
!313 = !{!"usb_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !314, i64 80, !315, i64 104, !14, i64 232, !14, i64 232, !14, i64 232, !14, i64 232}
!314 = !{!"usb_dynids", !21, i64 0, !17, i64 8}
!315 = !{!"usbdrv_wrap", !149, i64 0, !14, i64 120}
!316 = !{i32 -2143873860}
!317 = !{i32 -2143872097}
!318 = !{i32 -2143870311}
!319 = !{i32 -2143868279}
!320 = !{i32 -2143866198}
!321 = !{i32 -2143864004}
!322 = !{i32 -2147068329, i32 -2147068290, i32 -2147068269, i32 -2147068232, i32 -2147068209, i32 -2147068339, i32 367117}
!323 = !{!15, !14, i64 344}
!324 = !{!48, !4, i64 928}
!325 = !{!45, !14, i64 136}
