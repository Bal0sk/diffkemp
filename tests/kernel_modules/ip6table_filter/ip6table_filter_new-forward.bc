; ModuleID = '/diffkemp/kernel/linux-4.11/net/ipv6/netfilter/ip6table_filter.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.88 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.uid_gid_extent*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.lock_class_key, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.raw_spinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.7 }
%union.anon.7 = type { %struct.raw_spinlock }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type { %struct.sock_common, %struct.socket_lock_t, %struct.atomic_t, i32, %struct.sk_buff_head, %struct.sk_buff_head, %struct.anon.76, i32, i32, i32, i32, %struct.sk_filter*, %union.anon.78, [2 x %struct.xfrm_policy*], %struct.dst_entry*, %struct.dst_entry*, %struct.atomic_t, i32, i32, %struct.atomic_t, i64, %struct.sk_buff*, %struct.sk_buff_head, i32, i32, i32, i64, %struct.timer_list, i32, i32, i32, i32, %struct.page_frag, i64, i64, i32, i32, i32, i32, [0 x i32], i32, i16, i64, %struct.proto*, %struct.rwlock_t, i32, i32, i32, i32, %struct.atomic_t, %struct.pid*, %struct.cred*, i64, i64, i16, i8, i32, %struct.socket*, i8*, i8*, %struct.lock_class_key, %struct.mem_cgroup*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, %struct.sock_reuseport*, %struct.callback_head }
%struct.sock_common = type { %union.anon, %struct.atomic_t, %struct.atomic_t, i16, i8, i8, i32, %union.anon.3, %struct.proto*, %struct.possible_net_t, %struct.in6_addr, %struct.in6_addr, %union.anon, %union.anon, [0 x i32], %union.anon.3, i32, %struct.atomic_t, %struct.atomic_t, [0 x i32], %struct.atomic_t }
%struct.possible_net_t = type { %struct.net* }
%struct.net = type { %struct.atomic_t, %struct.atomic_t, %struct.spinlock, %union.anon, %struct.list_head, %struct.list_head, %struct.list_head, %struct.user_namespace*, %struct.ucounts*, %struct.spinlock, %struct.idr, %struct.ns_common, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, i32, i32, i32, %struct.list_head, %struct.net_device*, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, [40 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_nf, %struct.netns_xt, %struct.netns_ct, [16 x i8], %struct.netns_nf_frag, %struct.sock*, %struct.sock*, %struct.net_generic*, [40 x i8], %struct.netns_xfrm, %struct.sock*, %struct.atomic_t, [52 x i8] }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, %struct.atomic_t, %struct.atomic_t, %struct.ns_common, i64, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [9 x i32] }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.work_struct = type { %union.anon, %struct.list_head, void (%struct.work_struct*)* }
%struct.ctl_table_header = type { %union.anon.18, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.list_head }
%union.anon.18 = type { %struct.anon.19 }
%struct.anon.19 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.atomic_t*, %struct.atomic_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.rb_root = type { %struct.rb_node* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.atomic_t, i32, [9 x %struct.atomic_t] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.idr = type { %struct.radix_tree_root, i32 }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.6, [64 x i8*], [3 x [1 x i64]] }
%union.anon.6 = type { %struct.list_head }
%struct.ns_common = type { %union.anon, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.proc_dir_entry = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.net_device = type { [16 x i8], %struct.hlist_node, i8*, i64, i64, i64, i32, %struct.atomic_t, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.81, i64, i64, i64, i64, i64, i64, i64, i32, i32, %struct.net_device_stats, %union.anon, %union.anon, %union.anon, %struct.net_device_ops*, %struct.ethtool_ops*, %struct.ndisc_ops*, %struct.header_ops*, i32, i32, i16, i16, i8, i8, i8, i8, i32, i32, i32, i16, i16, i16, i16, i16, [32 x i8], i8, i8, i16, i16, i16, %struct.spinlock, i8, i8, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i32, i32, i8*, %struct.in_device*, %struct.dn_dev*, %struct.inet6_dev*, i8*, %struct.wireless_dev*, %struct.wpan_dev*, i8*, %struct.netdev_rx_queue*, i32, i32, i64, i32 (%struct.sk_buff**)*, i8*, %struct.tcf_proto*, %struct.netdev_queue*, %struct.nf_hook_entry*, [32 x i8], %struct.cpu_rmap*, %struct.hlist_node, [24 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, [16 x %struct.hlist_head], i64, %struct.spinlock, i32, %struct.xps_dev_maps*, %struct.tcf_proto*, %struct.timer_list, i32*, %struct.list_head, %struct.list_head, i8, i8, i16, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.possible_net_t, %union.anon.88, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i16, i8, [16 x %struct.nlattr], [16 x i8], %struct.phy_device*, %struct.lock_class_key*, %struct.lock_class_key*, i8, [15 x i8] }
%struct.anon.81 = type { %struct.list_head, %struct.list_head }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.sk_buff*, %struct.net_device*, i64)*, i16 (%struct.net_device*, %struct.sk_buff*, i8*, i16 (%struct.net_device*, %struct.sk_buff*)*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*)*, void (%struct.net_device*, %struct.rtnl_link_stats64*)*, i1 (%struct.net_device*, i32)*, i32 (i32, %struct.net_device*, i8*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8, i16)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_stats*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i32, i64, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i16, %struct.tc_to_netdev*)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.net_device*, %struct.net_device*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.net_device*, %struct.neighbour*)*, void (%struct.net_device*, %struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, i16)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32*)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, i8*, i64)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.sk_buff*, %struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.netdev_xdp*)* }
%struct.ifreq = type { %union.anon.82, %union.anon.83 }
%union.anon.82 = type { [16 x i8] }
%union.anon.83 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.neigh_parms = type { %struct.possible_net_t, %struct.net_device*, %struct.list_head, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, %struct.neigh_table*, i8*, i32, %struct.atomic_t, %struct.callback_head, i32, [13 x i32], [1 x i64] }
%struct.neighbour = type { %struct.neighbour*, %struct.neigh_table*, %struct.neigh_parms*, i64, i64, %struct.rwlock_t, %struct.atomic_t, %struct.sk_buff_head, i32, %struct.timer_list, i64, %struct.atomic_t, i8, i8, i8, i8, %struct.seqlock_t, [32 x i8], %struct.hh_cache, i32 (%struct.neighbour*, %struct.sk_buff*)*, %struct.neigh_ops*, %struct.callback_head, %struct.net_device*, [0 x i8] }
%struct.seqlock_t = type { %struct.atomic_t, %struct.spinlock }
%struct.hh_cache = type { i16, i16, %struct.seqlock_t, [12 x i64] }
%struct.neigh_ops = type { i32, void (%struct.neighbour*, %struct.sk_buff*)*, void (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)* }
%struct.neigh_table = type { i32, i32, i32, i16, i32 (i8*, %struct.net_device*, i32*)*, i1 (%struct.neighbour*, i8*)*, i32 (%struct.neighbour*)*, i32 (%struct.pneigh_entry*)*, void (%struct.pneigh_entry*)*, void (%struct.sk_buff*)*, i8*, %struct.neigh_parms, %struct.list_head, i32, i32, i32, i32, i64, %struct.delayed_work, %struct.timer_list, %struct.sk_buff_head, %struct.atomic_t, %struct.rwlock_t, i64, %struct.neigh_statistics*, %struct.neigh_hash_table*, %struct.pneigh_entry** }
%struct.pneigh_entry = type { %struct.pneigh_entry*, %struct.possible_net_t, %struct.net_device*, i8, [0 x i8] }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.workqueue_struct = type opaque
%struct.neigh_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.neigh_hash_table = type { %struct.neighbour**, i32, [4 x i32], %struct.callback_head }
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.ifla_vf_stats = type { i64, i64, i64, i64, i64, i64 }
%struct.nlattr = type { i16, i16 }
%struct.tc_to_netdev = type { i32, %union.anon.85, i8 }
%union.anon.85 = type { %struct.tc_cls_u32_offload* }
%struct.tc_cls_u32_offload = type opaque
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.netlink_callback*)*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, i16, i16, i32, i32, [6 x i64] }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%struct.netdev_phys_item_id = type { [32 x i8], i8 }
%struct.udp_tunnel_info = type opaque
%struct.netdev_xdp = type { i32, %union.anon.86 }
%union.anon.86 = type { %struct.bpf_prog* }
%struct.bpf_prog = type { i16, i8, i32, i32, [8 x i8], %struct.bpf_prog_aux*, %struct.sock_fprog_kern*, i32 (i8*, %struct.bpf_insn*)*, %union.anon.77 }
%struct.bpf_prog_aux = type opaque
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%struct.bpf_insn = type { i8, i8, i16, i32 }
%union.anon.77 = type { [0 x %struct.sock_filter] }
%struct.ethtool_ops = type { i32 (%struct.net_device*, %struct.ethtool_cmd*)*, i32 (%struct.net_device*, %struct.ethtool_cmd*)*, void (%struct.net_device*, %struct.ethtool_drvinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, %struct.ethtool_regs*, i8*)*, void (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, void (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_test*, i64*)*, void (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*, i32*)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*)*, i32 (%struct.net_device*, %struct.ethtool_flash*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32*, i8*, i8*)*, i32 (%struct.net_device*, i32*, i8*, i8)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*)*, i32 (%struct.net_device*, %struct.ethtool_ts_info*)*, i32 (%struct.net_device*, %struct.ethtool_modinfo*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)* }
%struct.ethtool_cmd = type { i32, i32, i32, i16, i8, i8, i8, i8, i8, i8, i32, i32, i16, i8, i8, i32, [2 x i32] }
%struct.ethtool_drvinfo = type { i32, [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [12 x i8], i32, i32, i32, i32, i32 }
%struct.ethtool_regs = type { i32, i32, i32, [0 x i8] }
%struct.ethtool_wolinfo = type { i32, i32, i32, [6 x i8] }
%struct.ethtool_coalesce = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_pauseparam = type { i32, i32, i32, i32 }
%struct.ethtool_test = type { i32, i32, i32, i32, [0 x i64] }
%struct.ethtool_stats = type { i32, i32, [0 x i64] }
%struct.ethtool_rxnfc = type { i32, i32, i64, %struct.ethtool_rx_flow_spec, i32, [0 x i32] }
%struct.ethtool_rx_flow_spec = type { i32, %union.ethtool_flow_union, %struct.ethtool_flow_ext, %union.ethtool_flow_union, %struct.ethtool_flow_ext, i64, i32 }
%union.ethtool_flow_union = type { %struct.ethtool_tcpip6_spec, [12 x i8] }
%struct.ethtool_tcpip6_spec = type { [4 x i32], [4 x i32], i16, i16, i8 }
%struct.ethtool_flow_ext = type { [2 x i8], [6 x i8], i16, i16, [2 x i32] }
%struct.ethtool_flash = type { i32, i32, [128 x i8] }
%struct.ethtool_ringparam = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_eeprom = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_ts_info = type { i32, i32, i32, i32, [3 x i32], i32, [3 x i32] }
%struct.ethtool_modinfo = type { i32, i32, i32, [8 x i32] }
%struct.ethtool_eee = type { i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%struct.ethtool_tunable = type { i32, i32, i32, i32, [0 x i8*] }
%struct.ethtool_link_ksettings = type { %struct.ethtool_link_settings, %struct.anon.87 }
%struct.ethtool_link_settings = type { i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, [8 x i32], [0 x i32] }
%struct.anon.87 = type { [1 x i64], [1 x i64], [1 x i64] }
%struct.ndisc_ops = type { i32 (i8)*, i32 (%struct.net_device*, %struct.nd_opt_hdr*, %struct.ndisc_options*)*, void (%struct.net_device*, %struct.neighbour*, i32, i8, %struct.ndisc_options*)*, i32 (%struct.net_device*, i8, %struct.neighbour*, i8*, i8**)*, void (%struct.net_device*, %struct.sk_buff*, i8, i8*)*, void (%struct.net*, %struct.net_device*, %struct.prefix_info*, %struct.inet6_dev*, %struct.in6_addr*, i32, i32, i1, i1, i32, i32, i1)* }
%struct.nd_opt_hdr = type { i8, i8 }
%struct.ndisc_options = type { [15 x %struct.nd_opt_hdr*], %struct.nd_opt_hdr*, %struct.nd_opt_hdr* }
%struct.prefix_info = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)*, i1 (i8*, i32)* }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32 }
%struct.in_device = type opaque
%struct.dn_dev = type opaque
%struct.inet6_dev = type { %struct.net_device*, %struct.list_head, %struct.ifmcaddr6*, %struct.ifmcaddr6*, %struct.spinlock, i8, i8, i8, i8, i64, i64, i64, i64, %struct.timer_list, %struct.timer_list, %struct.timer_list, %struct.ifacaddr6*, %struct.rwlock_t, %struct.atomic_t, i32, i32, i32, [8 x i8], %struct.list_head, %struct.in6_addr, %struct.neigh_parms*, %struct.ipv6_devconf, %struct.ipv6_devstat, %struct.timer_list, i32, i8, i64, %struct.callback_head }
%struct.ifmcaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.ifmcaddr6*, %struct.ip6_sf_list*, %struct.ip6_sf_list*, i32, i8, [2 x i64], %struct.timer_list, i32, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.ip6_sf_list = type { %struct.ip6_sf_list*, %struct.in6_addr, [2 x i64], i8, i8, i8 }
%struct.ifacaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.rt6_info*, %struct.ifacaddr6*, i32, %struct.atomic_t, i64, i64 }
%struct.rt6_info = type opaque
%struct.ipv6_devconf = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.ipv6_stable_secret, i32, i32, i32, i32, i32, %struct.ctl_table_header* }
%struct.ipv6_stable_secret = type { i8, %struct.in6_addr }
%struct.ipv6_devstat = type { %struct.proc_dir_entry*, %struct.ipstats_mib*, %struct.icmpv6_mib_device*, %struct.icmpmsg_mib* }
%struct.ipstats_mib = type { [36 x i64], %struct.lock_class_key }
%struct.icmpv6_mib_device = type { [6 x %union.anon] }
%struct.icmpmsg_mib = type { [512 x %union.anon] }
%struct.wireless_dev = type opaque
%struct.wpan_dev = type opaque
%struct.netdev_rx_queue = type { %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8] }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.nf_hook_entry = type { %struct.nf_hook_entry*, i32 (i8*, %struct.sk_buff*, %struct.nf_hook_state*)*, i8*, %struct.nf_hook_ops* }
%struct.nf_hook_state = type { i32, i8, %struct.net_device*, %struct.net_device*, %struct.sock*, %struct.net*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)* }
%struct.nf_hook_ops = type { %struct.list_head, i32 (i8*, %struct.sk_buff*, %struct.nf_hook_state*)*, %struct.net_device*, i8*, i8, i32, i32 }
%struct.cpu_rmap = type opaque
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, i64, i64, [16 x i8], %struct.spinlock, i32, i64, i64, [40 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type { i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, i32, i32, %struct.Qdisc_ops*, %struct.qdisc_size_table*, %struct.hlist_node, i32, i32, i8*, %struct.netdev_queue*, %struct.net_rate_estimator*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, [24 x i8], %struct.sk_buff*, %struct.sk_buff_head, %struct.gnet_stats_basic_packed, %struct.atomic_t, %struct.gnet_stats_queue, i64, %struct.Qdisc*, %struct.sk_buff*, %struct.callback_head, i32, %struct.atomic_t, [8 x i8], %struct.spinlock, [60 x i8] }
%struct.Qdisc_ops = type { %struct.Qdisc_ops*, %struct.Qdisc_class_ops*, [16 x i8], i32, i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, %struct.sk_buff* (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*)*, void (%struct.Qdisc*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.sk_buff*)*, i32 (%struct.Qdisc*, %struct.gnet_dump*)*, %struct.module* }
%struct.Qdisc_class_ops = type { %struct.netdev_queue* (%struct.Qdisc*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.Qdisc*, %struct.Qdisc**)*, %struct.Qdisc* (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, i64)*, i64 (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i32, i32, %struct.nlattr**, i64*)*, i32 (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, %struct.qdisc_walker*)*, %struct.tcf_proto** (%struct.Qdisc*, i64)*, i1 (i32)*, i64 (%struct.Qdisc*, i64, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i64, %struct.sk_buff*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.gnet_dump*)* }
%struct.tcmsg = type { i8, i8, i16, i32, i32, i32, i32 }
%struct.qdisc_walker = type opaque
%struct.gnet_dump = type { %struct.spinlock*, %struct.sk_buff*, %struct.nlattr*, i32, i32, i32, i8*, i32, %struct.tc_stats }
%struct.tc_stats = type { i64, i32, i32, i32, i32, i32, i32, i32 }
%struct.qdisc_size_table = type { %struct.callback_head, %struct.list_head, %struct.tc_sizespec, i32, [0 x i16] }
%struct.tc_sizespec = type { i8, i8, i16, i32, i32, i32, i32, i32 }
%struct.net_rate_estimator = type opaque
%struct.gnet_stats_basic_cpu = type { %struct.gnet_stats_basic_packed, %struct.lock_class_key }
%struct.gnet_stats_basic_packed = type <{ i64, i32 }>
%struct.gnet_stats_queue = type { i32, i32, i32, i32, i32 }
%struct.xps_dev_maps = type { %struct.callback_head, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.tcf_proto = type { %struct.tcf_proto*, i8*, i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.load_weight*)*, i16, i32, i32, %struct.Qdisc*, i8*, %struct.tcf_proto_ops*, %struct.callback_head }
%struct.load_weight = type { i64, i32 }
%struct.tcf_proto_ops = type { %struct.list_head, [16 x i8], i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.load_weight*)*, i32 (%struct.tcf_proto*)*, i1 (%struct.tcf_proto*, i1)*, i64 (%struct.tcf_proto*, i32)*, i32 (%struct.net*, %struct.sk_buff*, %struct.tcf_proto*, i64, i32, %struct.nlattr**, i64*, i1)*, i32 (%struct.tcf_proto*, i64)*, void (%struct.tcf_proto*, %struct.tcf_walker*)*, i32 (%struct.net*, %struct.tcf_proto*, i64, %struct.sk_buff*, %struct.tcmsg*)*, %struct.module* }
%struct.tcf_walker = type opaque
%struct.netpoll_info = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %union.anon.88, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.atomic_t*, %struct.atomic_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.atomic_t, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %union.anon, i64, %struct.timerqueue_node, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.lock_class_key }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %union.anon*, %struct.atomic_t, %struct.atomic_t, %union.anon, %union.anon, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.lock_class_key, %union.anon, %struct.work_struct }
%struct.rw_semaphore = type { %union.anon, %struct.list_head, %struct.raw_spinlock, %struct.qspinlock, %struct.task_struct* }
%struct.qspinlock = type { %struct.atomic_t }
%struct.task_struct = type { %union.anon, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %union.anon.6, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.cpumask, %struct.cpumask, %struct.cpumask, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.atomic_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.cpumask, %struct.atomic_t, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.atomic_t, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.20 }
%union.anon.20 = type { %struct.anon.21 }
%struct.anon.21 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.pid_namespace = type opaque
%struct.cgroup_namespace = type { %struct.atomic_t, %struct.ns_common, %struct.user_namespace*, %struct.ucounts*, %struct.css_set* }
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigpending = type { %struct.list_head, %struct.cpumask }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type { %struct.list_head, i64, i64, i32 (i8*, i32)*, i8*, i8*, %struct.raw_spinlock, i32, i32, i32, i32, %union.anon, %struct.bdi_writeback, %struct.list_head, %struct.bdi_writeback_congested*, %struct.__wait_queue_head, %struct.device*, %struct.device*, %struct.timer_list, %struct.dentry*, %struct.dentry* }
%struct.bdi_writeback = type { %struct.backing_dev_info*, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock, [4 x %struct.percpu_counter], %struct.bdi_writeback_congested*, i64, i64, i64, i64, i64, i64, i64, %struct.fprop_local_percpu, i32, %struct.spinlock, %struct.list_head, %struct.delayed_work, i64, %struct.list_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.fprop_local_percpu = type { %struct.percpu_counter, i32, %struct.raw_spinlock }
%struct.bdi_writeback_congested = type { i64, %struct.atomic_t }
%struct.dentry = type { i32, %struct.atomic_t, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.6, %struct.list_head, %struct.list_head, %union.anon.3 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon, i8* }
%struct.inode = type { i16, i16, %struct.atomic_t, %struct.atomic_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.9, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.98, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.atomic_t, %struct.atomic_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.timespec = type { i64, i64 }
%union.anon.9 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type { i32, i64, i64, %union.anon.4, %union.anon }
%union.anon.4 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.page = type { i64, %union.anon.5, %union.anon, %union.anon, %union.anon.6, %union.anon, [8 x i8] }
%union.anon.5 = type { %struct.address_space* }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.16 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.16 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.writeback_control = type { i64, i64, i64, i64, i32, i8 }
%struct.swap_info_struct = type opaque
%union.anon.98 = type { %struct.pipe_inode_info* }
%struct.lockref = type { %union.anon }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %union.anon, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, [56 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %struct.qspinlock, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.atomic_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %union.anon* }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, [32 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.43 }
%union.anon.43 = type { %struct.anon.47, [80 x i8] }
%struct.anon.47 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.cpumask = type { [1 x i64] }
%struct.css_set = type { [4 x %struct.cgroup_subsys_state*], %struct.atomic_t, %struct.cgroup*, %struct.list_head, %struct.list_head, %struct.list_head, [4 x %struct.list_head], %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.cgroup*, %struct.css_set*, i8, %struct.callback_head }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.cgroup_subsys*, %struct.percpu_ref, %struct.cgroup_subsys_state*, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.callback_head, %struct.work_struct }
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void ()*, i32 (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.cgroup_subsys_state*)*, i8, i32, i8*, i8*, %struct.cgroup_root*, %struct.idr, %struct.list_head, %struct.cftype*, %struct.cftype*, i32 }
%struct.cgroup_taskset = type opaque
%struct.cgroup_root = type { %struct.kernfs_root*, i32, i32, %struct.cgroup, i32, %struct.atomic_t, %struct.list_head, i32, %struct.idr, [4096 x i8], [64 x i8] }
%struct.kernfs_root = type { %struct.kernfs_node*, i32, %struct.ida, %struct.kernfs_syscall_ops*, %struct.list_head, %struct.__wait_queue_head }
%struct.ida = type { %struct.radix_tree_root }
%struct.kernfs_syscall_ops = type { i32 (%struct.kernfs_root*, i32*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_root*)*, i32 (%struct.kernfs_node*, i8*, i16)*, i32 (%struct.kernfs_node*)*, i32 (%struct.kernfs_node*, %struct.kernfs_node*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_node*, %struct.kernfs_root*)* }
%struct.cgroup = type { %struct.cgroup_subsys_state, i64, i32, i32, i32, %struct.kernfs_node*, %struct.cgroup_file, %struct.cgroup_file, i16, i16, i16, i16, [4 x %struct.cgroup_subsys_state*], %struct.cgroup_root*, %struct.list_head, [4 x %struct.list_head], %struct.list_head, %struct.mutex, %struct.__wait_queue_head, %struct.work_struct, %struct.lock_class_key, [0 x i32] }
%struct.cgroup_file = type { %struct.kernfs_node* }
%struct.cftype = type { [64 x i8], i64, i64, i32, i32, %struct.cgroup_subsys*, %struct.list_head, %struct.kernfs_ops*, i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.percpu_ref = type { %union.anon, i64, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head }
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.atomic_t, i32, i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type { %struct.mutex, %struct.__wait_queue_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.page*, %struct.fasync_struct*, %struct.fasync_struct*, %struct.pipe_buffer*, %struct.user_struct* }
%struct.pipe_buffer = type { %struct.page*, i32, i32, %struct.pipe_buf_operations*, i32, i64 }
%struct.pipe_buf_operations = type { i32, i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)* }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %union.anon, i64, i64, i64, %union.anon, %struct.key*, %struct.key*, %struct.hlist_node, %struct.atomic_t, %union.anon }
%struct.key = type { %struct.atomic_t, i32, %union.anon.89, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon, i64, %struct.atomic_t, %struct.atomic_t, i32, i16, i16, i64, %union.anon.91, %union.anon.93, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.89 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.91 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.93 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.task_delay_info = type opaque
%struct.vm_struct = type { %struct.vm_struct*, i8*, i64, i64, %struct.page**, i32, i64, i8* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %union.anon, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.53 }
%union.anon.53 = type { %struct.anon.54 }
%struct.anon.54 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.56, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.59 }
%union.anon.56 = type { %struct.timespec }
%union.anon.59 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.mm_rss_stat = type { [4 x %union.anon] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %union.anon*, %union.anon*, %union.anon, %struct.page*, %struct.mem_cgroup*, %struct.page*, %union.anon*, %struct.spinlock*, %struct.page* }
%struct.file = type { %union.anon.9, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %union.anon, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.atomic_t, %struct.atomic_t, i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mempolicy = type opaque
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.raw_spinlock }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, void (%struct.net_device*)*, i32, %struct.nlattr*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nlattr*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)*, %struct.net* (%struct.net_device*)*, i64 (%struct.net_device*, i32)*, i32 (%struct.sk_buff*, %struct.net_device*, i32*, i32)* }
%struct.phy_device = type opaque
%struct.netns_core = type { %struct.ctl_table_header*, i32, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { %struct.tcp_mib*, %struct.ipstats_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib*, %struct.proc_dir_entry*, %struct.udp_mib*, %struct.udp_mib*, %struct.ipstats_mib*, %struct.icmpv6_mib*, %struct.icmpmsg_mib* }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [119 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.udp_mib = type { [9 x i64] }
%struct.icmpv6_mib = type { [6 x i64] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_ipv4 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.fib_rules_ops*, i8, %struct.fib_table*, %struct.fib_table*, %struct.hlist_head*, i8, %struct.sock*, %struct.sock**, %struct.sock*, %struct.inet_peer_base*, %struct.sock**, [48 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, i32, i32, i32, i32, i32, i32, %struct.local_ports, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [56 x i8], %struct.inet_timewait_death_row, i32, i32, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, i32, %struct.mr_table*, i32, i32, %struct.atomic_t, [52 x i8] }
%struct.ipv4_devconf = type opaque
%struct.fib_rules_ops = type { i32, %struct.list_head, i32, i32, i32, i32, i32 (%struct.fib_rule*, %struct.flowi*, i32, %struct.fib_lookup_arg*)*, i1 (%struct.fib_rule*, %struct.fib_lookup_arg*)*, i32 (%struct.fib_rule*, %struct.flowi*, i32)*, i32 (%struct.fib_rule*, %struct.sk_buff*, %struct.fib_rule_hdr*, %struct.nlattr**)*, i32 (%struct.fib_rule*)*, i32 (%struct.fib_rule*, %struct.fib_rule_hdr*, %struct.nlattr**)*, i32 (%struct.fib_rule*, %struct.sk_buff*, %struct.fib_rule_hdr*)*, i64 (%struct.fib_rule*)*, void (%struct.fib_rules_ops*)*, i32, %struct.nlattr*, %struct.list_head, %struct.module*, %struct.net*, %struct.callback_head }
%struct.fib_rule = type { %struct.list_head, i32, i32, i32, i32, i32, i32, i8, i8, i32, i64, %struct.fib_rule*, %struct.net*, %struct.atomic_t, i32, i32, i32, [16 x i8], [16 x i8], %struct.fib_kuid_range, %struct.callback_head }
%struct.fib_kuid_range = type { %struct.atomic_t, %struct.atomic_t }
%struct.flowi = type { %union.anon.24 }
%union.anon.24 = type { %struct.flowi6 }
%struct.flowi6 = type { %struct.flowi_common, %struct.in6_addr, %struct.in6_addr, i32, %struct.atomic_t }
%struct.flowi_common = type { i32, i32, i32, i8, i8, i8, i8, i32, %union.anon, %struct.atomic_t }
%struct.fib_lookup_arg = type { i8*, i8*, %struct.fib_rule*, i32, i32 }
%struct.fib_rule_hdr = type { i8, i8, i8, i8, i8, i8, i8, i8, i32 }
%struct.fib_table = type opaque
%struct.inet_peer_base = type opaque
%struct.netns_frags = type { %struct.percpu_counter, i32, i32, i32, i32, [8 x i8] }
%struct.xt_table = type { %struct.list_head, i32, %struct.xt_table_info*, %struct.module*, i8, i32, i32 (%struct.net*)*, [32 x i8] }
%struct.xt_table_info = type { i32, i32, i32, [5 x i32], [5 x i32], i32, i8***, [0 x i8] }
%struct.local_ports = type { %struct.seqlock_t, [2 x i32], i8 }
%struct.inet_timewait_death_row = type { %struct.atomic_t, [60 x i8], %struct.inet_hashinfo*, i32, i32, [48 x i8] }
%struct.inet_hashinfo = type opaque
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.atomic_t] }
%struct.mr_table = type opaque
%struct.netns_ipv6 = type { %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, [56 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, %struct.list_head, [56 x i8], %struct.dst_ops, %struct.rwlock_t, %struct.spinlock, i32, i64, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.sock*, %struct.atomic_t, %struct.atomic_t, %struct.seg6_pernet_data*, [48 x i8] }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.rt6_statistics = type opaque
%struct.fib6_table = type opaque
%struct.dst_ops = type { i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, void (%struct.dst_entry*, i8*)*, %struct.kmem_cache*, %struct.percpu_counter, [24 x i8] }
%struct.kmem_cache = type opaque
%struct.seg6_pernet_data = type opaque
%struct.netns_nf = type { %struct.proc_dir_entry*, %struct.nf_queue_handler*, [13 x %struct.nf_logger*], %struct.ctl_table_header*, [13 x [8 x %struct.nf_hook_entry*]], i8, i8 }
%struct.nf_queue_handler = type opaque
%struct.nf_logger = type { i8*, i32, void (%struct.net*, i8, i32, %struct.sk_buff*, %struct.net_device*, %struct.net_device*, %struct.nf_loginfo*, i8*)*, %struct.module* }
%struct.nf_loginfo = type { i8, %union.anon.42.455 }
%union.anon.42.455 = type { %struct.anon.43 }
%struct.anon.43 = type { i32, i16, i16, i16 }
%struct.netns_xt = type { [13 x %struct.list_head], i8, i8 }
%struct.netns_ct = type { %struct.atomic_t, i32, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i8, i32, i32, %struct.ct_pcpu*, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_exp_event_notifier*, %struct.nf_ip_net }
%struct.ct_pcpu = type { %struct.spinlock, %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.ip_conntrack_stat = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.nf_ct_event_notifier = type opaque
%struct.nf_exp_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.nf_generic_net, %struct.nf_tcp_net, %struct.nf_udp_net, %struct.nf_generic_net, %struct.nf_generic_net }
%struct.nf_tcp_net = type { %struct.nf_proto_net, [14 x i32], i32, i32, i32 }
%struct.nf_proto_net = type { %struct.ctl_table_header*, %struct.ctl_table*, i32 }
%struct.nf_udp_net = type { %struct.nf_proto_net, [2 x i32] }
%struct.nf_generic_net = type { %struct.nf_proto_net, i32 }
%struct.netns_nf_frag = type { %struct.netns_sysctl_ipv6, [16 x i8], %struct.netns_frags }
%struct.net_generic = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.list_head, %struct.hlist_head*, i32, [3 x %struct.hlist_head], [3 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.xfrm_policy_hthresh, %struct.sock*, %struct.sock*, i32, i32, i32, i32, %struct.ctl_table_header*, [56 x i8], %struct.dst_ops, %struct.dst_ops, %struct.spinlock, %struct.spinlock, %struct.mutex, %struct.flow_cache, %struct.atomic_t, %struct.list_head, %struct.atomic_t, %struct.spinlock, %struct.work_struct, %struct.work_struct, %struct.mutex }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32, i8, i8, i8, i8 }
%struct.xfrm_policy_hthresh = type { %struct.work_struct, %struct.seqlock_t, i8, i8, i8, i8 }
%struct.flow_cache = type { i32, %struct.flow_cache_percpu*, %struct.hlist_node, i32, i32, %struct.timer_list }
%struct.flow_cache_percpu = type { %struct.hlist_head*, i32, i32, i32, %struct.tasklet_struct }
%struct.tasklet_struct = type { %struct.tasklet_struct*, i64, %struct.atomic_t, void (i64)*, i64 }
%struct.in6_addr = type { %union.anon.29 }
%union.anon.29 = type { [4 x i32] }
%union.anon = type { i64 }
%union.anon.3 = type { %struct.hlist_node }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.__wait_queue_head }
%struct.anon.76 = type { %struct.atomic_t, i32, %struct.sk_buff*, %struct.sk_buff* }
%struct.sk_filter = type { %struct.atomic_t, %struct.callback_head, %struct.bpf_prog* }
%union.anon.78 = type { %struct.socket_wq* }
%struct.socket_wq = type { %struct.__wait_queue_head, %struct.fasync_struct*, i64, %struct.callback_head, [8 x i8] }
%struct.xfrm_policy = type opaque
%struct.dst_entry = type { %struct.callback_head, %struct.dst_entry*, %struct.net_device*, %struct.dst_ops*, i64, i64, %struct.dst_entry*, %struct.dst_entry*, %struct.xfrm_state*, i32 (%struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, i16, i16, i16, i16, i16, i16, i32, [2 x i64], %struct.atomic_t, i32, i64, %struct.lwtunnel_state*, %union.anon.41 }
%struct.xfrm_state = type opaque
%struct.lwtunnel_state = type opaque
%union.anon.41 = type { %struct.dst_entry* }
%struct.sk_buff = type { %union.anon.30, %struct.sock*, %union.anon.35, [48 x i8], i64, void (%struct.sk_buff*)*, %struct.sec_path*, i64, i32, i32, i16, i16, i16, [0 x i8], i8, [0 x i32], [0 x i8], i32, i16, %struct.atomic_t, i32, i32, i32, i16, i16, %struct.atomic_t, i32, %struct.atomic_t, %union.anon.40, i16, i16, i16, i16, i16, i16, i16, [0 x i32], i32, i32, i8*, i8*, i32, %struct.atomic_t }
%union.anon.30 = type { %struct.anon.31 }
%struct.anon.31 = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon }
%union.anon.35 = type { %struct.net_device* }
%struct.sec_path = type opaque
%union.anon.40 = type { i16 }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.proto = type { void (%struct.sock*, i64)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, i32)*, %struct.sock* (%struct.sock*, i32, i32*, i1)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.sock*, %struct.msghdr*, i64, i32, i32, i32*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, i16)*, i32, i1 (%struct.sock*)*, void (%struct.sock*)*, %union.anon*, %struct.percpu_counter*, i32*, i64*, i32*, i32*, i32, i8, %struct.kmem_cache*, i32, i32, %struct.percpu_counter*, %struct.request_sock_ops*, %struct.timewait_sock_ops*, %union.anon.71, %struct.module*, [32 x i8], %struct.list_head, i32 (%struct.sock*, i32)* }
%struct.msghdr = type { i8*, i32, %struct.iov_iter, i8*, i64, i32, %struct.kiocb* }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.request_sock_ops = type { i32, i32, %struct.kmem_cache*, i8*, i32 (%struct.sock*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*)*, void (%struct.request_sock*)*, void (%struct.request_sock*)* }
%struct.request_sock = type { %struct.sock_common, %struct.request_sock*, i16, i8, i8, i32, %struct.timer_list, %struct.request_sock_ops*, %struct.sock*, i32*, i32, i32 }
%struct.timewait_sock_ops = type { %struct.kmem_cache*, i8*, i32, i32 (%struct.sock*, %struct.sock*, i8*)*, void (%struct.sock*)* }
%union.anon.71 = type { %struct.inet_hashinfo* }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.atomic_t] }
%struct.socket = type { i32, i16, i64, %struct.socket_wq*, %struct.file*, %struct.sock*, %struct.proto_ops* }
%struct.proto_ops = type { i32, %struct.module*, i32 (%struct.socket*)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32, i32)*, i32 (%struct.socket*, %struct.socket*)*, i32 (%struct.socket*, %struct.socket*, i32, i1)*, i32 (%struct.socket*, %struct.sockaddr*, i32*, i32)*, i32 (%struct.file*, %struct.socket*, %struct.poll_table_struct*)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.socket*, %struct.msghdr*, i64)*, i32 (%struct.socket*, %struct.msghdr*, i64, i32)*, i32 (%struct.file*, %struct.socket*, %struct.vm_area_struct*)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.sock*, i32)*, i32 (%struct.socket*)*, i32 (%struct.sock*, %struct.read_descriptor_t*, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)*)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.88, i32 }
%struct.mem_cgroup = type opaque
%struct.sock_reuseport = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.42, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%union.anon.42 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %union.anon, %struct.spinlock, %struct.qspinlock, %struct.list_head }
%struct.kernel_symbol = type { i64, i8* }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.lock_class_key = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.qspinlock, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.88 = type { i8* }
%struct.pernet_operations = type { %struct.list_head, i32 (%struct.net*)*, void (%struct.net*)*, void (%struct.list_head*)*, i32*, i64 }
%struct.xt_target = type { %struct.list_head, [29 x i8], i8, i32 (%struct.sk_buff*, %struct.xt_action_param*)*, i32 (%struct.xt_tgchk_param*)*, void (%struct.xt_tgdtor_param*)*, void (i8*, i8*)*, i32 (i8*, i8*)*, %struct.module*, i8*, i32, i32, i32, i32, i16, i16 }
%struct.xt_action_param = type { %union.anon.102, %union.anon.88, %struct.nf_hook_state*, i32, i32, i8 }
%union.anon.102 = type { %struct.xt_match* }
%struct.xt_match = type { %struct.list_head, [29 x i8], i8, i1 (%struct.sk_buff*, %struct.xt_action_param*)*, i32 (%struct.xt_mtchk_param*)*, void (%struct.xt_mtdtor_param*)*, void (i8*, i8*)*, i32 (i8*, i8*)*, %struct.module*, i8*, i32, i32, i32, i32, i16, i16 }
%struct.xt_mtchk_param = type { %struct.net*, i8*, i8*, %struct.xt_match*, i8*, i32, i8, i8 }
%struct.xt_mtdtor_param = type { %struct.net*, %struct.xt_match*, i8*, i8 }
%struct.xt_tgchk_param = type { %struct.net*, i8*, i8*, %struct.xt_target*, i8*, i32, i8, i8 }
%struct.xt_tgdtor_param = type { %struct.net*, %struct.xt_target*, i8*, i8 }
%struct.nf_sockopt_ops = type { %struct.list_head, i8, i32, i32, i32 (%struct.sock*, i32, i8*, i32)*, i32 (%struct.sock*, i32, i8*, i32)*, i32, i32, i32 (%struct.sock*, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i8*, i32*)*, %struct.module* }
%struct.ip6t_ip6 = type { %struct.in6_addr, %struct.in6_addr, %struct.in6_addr, %struct.in6_addr, [16 x i8], [16 x i8], [16 x i8], [16 x i8], i16, i8, i8, i8 }
%struct.ip6t_replace = type { [32 x i8], i32, i32, i32, [5 x i32], [5 x i32], i32, %struct.timespec*, [0 x %struct.ip6t_entry] }
%struct.ip6t_entry = type { %struct.ip6t_ip6, i32, i16, i16, i32, %struct.timespec, [0 x i8] }
%struct.ip6t_standard = type { %struct.ip6t_entry, %struct.xt_standard_target }
%struct.xt_standard_target = type { %struct.xt_entry_target, i32 }
%struct.xt_entry_target = type { %union.anon.99, [0 x i8] }
%union.anon.99 = type { %struct.anon.101, [16 x i8] }
%struct.anon.101 = type { i16, %struct.xt_target* }
%struct.xt_get_revision = type { [29 x i8], i8 }
%struct.ip6t_get_entries = type { [32 x i8], i32, [0 x %struct.ip6t_entry] }
%struct.compat_ip6t_get_entries = type { [32 x i8], i32, [0 x %struct.compat_ip6t_entry] }
%struct.compat_ip6t_entry = type <{ %struct.ip6t_ip6, i32, i16, i16, i32, %struct.timespec, [0 x i8] }>
%struct.ip6t_getinfo = type { [32 x i8], i32, [5 x i32], [5 x i32], i32, i32 }
%struct.xt_entry_match = type { %union.anon.108, [0 x i8] }
%union.anon.108 = type { %struct.anon.110, [16 x i8] }
%struct.anon.110 = type { i16, %struct.xt_match* }
%struct.compat_ip6t_replace = type { [32 x i8], i32, i32, i32, [5 x i32], [5 x i32], i32, i32, [0 x %struct.compat_ip6t_entry] }
%struct.xt_counters_info = type { [32 x i8], i32, [0 x %struct.timespec] }
%struct.anon.104 = type { i16, [29 x i8], i8 }
%struct.xt_percpu_counter_alloc_state = type { i32, i8* }
%struct.icmp6hdr = type { i8, i8, i16, %union.anon.114 }
%union.anon.114 = type { [1 x i32] }
%struct.ip6t_icmp = type { i8, [2 x i8], i8 }
%struct.ipv6hdr = type { i8, [3 x i8], i16, i8, i8, %struct.in6_addr, %struct.in6_addr }
%union.anon.111 = type { %struct.xt_table* }
%struct.ip6t_error = type { %struct.ip6t_entry, %struct.xt_error_target }
%struct.xt_error_target = type { %struct.xt_entry_target, [30 x i8] }
%struct.anon.102 = type { %struct.ip6t_replace, [0 x %struct.ip6t_standard] }

@llvm.used = appending global [11 x i8*] [i8* bitcast (%struct.kernel_param* @__param_forward to i8*), i8* bitcast (void ()* @ip6table_filter_fini to i8*), i8* bitcast (i32 ()** @__initcall_ip6table_filter_init6 to i8*), i8* bitcast (void ()** @__exitcall_ip6table_filter_fini to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_ip6t_alloc_initial_table to i8*), i8* bitcast (void ()* @ip6_tables_fini to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_ip6t_register_table to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_ip6t_unregister_table to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_ip6t_do_table to i8*), i8* bitcast (i32 ()** @__initcall_ip6_tables_init6 to i8*), i8* bitcast (void ()** @__exitcall_ip6_tables_fini to i8*)], section "llvm.metadata"
@__param_forward = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_forward, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.88 { i8* @forward } }, section "__param", align 8
@__initcall_ip6table_filter_init6 = internal global i32 ()* @ip6table_filter_init, section ".initcall6.init", align 8
@__exitcall_ip6table_filter_fini = internal global void ()* @ip6table_filter_fini, section ".exitcall.exit", align 8
@packet_filter = internal constant %struct.xt_table { %struct.list_head zeroinitializer, i32 14, %struct.xt_table_info* null, %struct.module* null, i8 10, i32 0, i32 (%struct.net*)* @ip6table_filter_table_init, [32 x i8] c"filter\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@filter_ops = internal global %struct.nf_hook_ops* null, section ".data..read_mostly", align 8
@ip6table_filter_net_ops = internal global %struct.pernet_operations { %struct.list_head zeroinitializer, i32 (%struct.net*)* @ip6table_filter_net_init, void (%struct.net*)* @ip6table_filter_net_exit, void (%struct.list_head*)* null, i32* null, i64 0 }, align 8
@init_net = external global %struct.net, align 64
@forward = internal global i8 1, align 1
@__param_str_forward = internal constant [24 x i8] c"ip6table_filter.forward\00", align 16
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@__ksymtab_ip6t_alloc_initial_table = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.xt_table*)* @ip6t_alloc_initial_table to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_ip6t_alloc_initial_table, i32 0, i32 0) }, section "___ksymtab_gpl+ip6t_alloc_initial_table", align 8
@__ksymtab_ip6t_register_table = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.net*, %struct.xt_table*, %struct.ip6t_replace*, %struct.nf_hook_ops*, %struct.xt_table**)* @ip6t_register_table to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_ip6t_register_table, i32 0, i32 0) }, section "___ksymtab+ip6t_register_table", align 8
@__ksymtab_ip6t_unregister_table = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.net*, %struct.xt_table*, %struct.nf_hook_ops*)* @ip6t_unregister_table to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_ip6t_unregister_table, i32 0, i32 0) }, section "___ksymtab+ip6t_unregister_table", align 8
@__ksymtab_ip6t_do_table = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.sk_buff*, %struct.nf_hook_state*, %struct.xt_table*)* @ip6t_do_table to i64), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__kstrtab_ip6t_do_table, i32 0, i32 0) }, section "___ksymtab+ip6t_do_table", align 8
@__initcall_ip6_tables_init6 = internal global i32 ()* @ip6_tables_init, section ".initcall6.init", align 8
@__exitcall_ip6_tables_fini = internal global void ()* @ip6_tables_fini, section ".exitcall.exit", align 8
@ip6_tables_net_ops = internal global %struct.pernet_operations { %struct.list_head zeroinitializer, i32 (%struct.net*)* @ip6_tables_net_init, void (%struct.net*)* @ip6_tables_net_exit, void (%struct.list_head*)* null, i32* null, i64 0 }, align 8
@ip6t_builtin_tg = internal global [2 x %struct.xt_target] [%struct.xt_target { %struct.list_head zeroinitializer, [29 x i8] zeroinitializer, i8 0, i32 (%struct.sk_buff*, %struct.xt_action_param*)* null, i32 (%struct.xt_tgchk_param*)* null, void (%struct.xt_tgdtor_param*)* null, void (i8*, i8*)* @compat_standard_from_user, i32 (i8*, i8*)* @compat_standard_to_user, %struct.module* null, i8* null, i32 4, i32 0, i32 4, i32 0, i16 0, i16 10 }, %struct.xt_target { %struct.list_head zeroinitializer, [29 x i8] c"ERROR\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8 0, i32 (%struct.sk_buff*, %struct.xt_action_param*)* @ip6t_error, i32 (%struct.xt_tgchk_param*)* null, void (%struct.xt_tgdtor_param*)* null, void (i8*, i8*)* null, i32 (i8*, i8*)* null, %struct.module* null, i8* null, i32 30, i32 0, i32 0, i32 0, i16 0, i16 10 }], section ".data..read_mostly", align 16
@ip6t_builtin_mt = internal global [1 x %struct.xt_match] [%struct.xt_match { %struct.list_head zeroinitializer, [29 x i8] c"icmp6\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i8 0, i1 (%struct.sk_buff*, %struct.xt_action_param*)* @icmp6_match, i32 (%struct.xt_mtchk_param*)* @icmp6_checkentry, void (%struct.xt_mtdtor_param*)* null, void (i8*, i8*)* null, i32 (i8*, i8*)* null, %struct.module* null, i8* null, i32 4, i32 0, i32 0, i32 0, i16 58, i16 10 }], section ".data..read_mostly", align 16
@ip6t_sockopts = internal global %struct.nf_sockopt_ops { %struct.list_head zeroinitializer, i8 10, i32 64, i32 66, i32 (%struct.sock*, i32, i8*, i32)* @do_ip6t_set_ctl, i32 (%struct.sock*, i32, i8*, i32)* @compat_do_ip6t_set_ctl, i32 64, i32 70, i32 (%struct.sock*, i32, i8*, i32*)* @do_ip6t_get_ctl, i32 (%struct.sock*, i32, i8*, i32*)* @compat_do_ip6t_get_ctl, %struct.module* null }, align 8
@.str.13 = private unnamed_addr constant [49 x i8] c"\016ip6_tables: (C) 2000-2006 Netfilter Core Team\0A\00", align 1
@.str.7 = private unnamed_addr constant [33 x i8] c"./arch/x86/include/asm/uaccess.h\00", align 1
@.str.8 = private unnamed_addr constant [38 x i8] c"Buffer overflow detected (%d < %lu)!\0A\00", align 1
@__cpu_possible_mask = external global %struct.cpumask, align 8
@nr_cpu_ids = external global i32, align 4
@xt_recseq = external global %struct.atomic_t, align 4
@__per_cpu_offset = external global [64 x i64], align 16
@.str.9 = private unnamed_addr constant [12 x i8] c"ip6table_%s\00", align 1
@.str.11 = private unnamed_addr constant [8 x i8] c"ip6t_%s\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"add\00", align 1
@this_cpu_off = external global i64, align 8
@.str.3 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@__preempt_count = external global i32, align 4
@.str.10 = private unnamed_addr constant [77 x i8] c"\014ip6_tables: ip6tables: counters copy to user failed while replacing table\0A\00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"ERROR\00", align 1
@.str.6 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@unconditional.uncond = internal constant %struct.ip6t_ip6 zeroinitializer, align 4
@.str.12 = private unnamed_addr constant [27 x i8] c"\016ip6_tables: error: `%s'\0A\00", align 1
@__kstrtab_ip6t_do_table = internal constant [14 x i8] c"ip6t_do_table\00", section "__ksymtab_strings", align 1
@ip6t_do_table.nulldevname = internal constant [16 x i8] zeroinitializer, align 8
@cpu_number = external global i32, align 4
@xt_tee_enabled = external global %struct.qspinlock, align 4
@nf_skb_duplicated = external global i8, align 1
@__kstrtab_ip6t_unregister_table = internal constant [22 x i8] c"ip6t_unregister_table\00", section "__ksymtab_strings", align 1
@__kstrtab_ip6t_register_table = internal constant [20 x i8] c"ip6t_register_table\00", section "__ksymtab_strings", align 1
@__kstrtab_ip6t_alloc_initial_table = internal constant [25 x i8] c"ip6t_alloc_initial_table\00", section "__ksymtab_strings", align 1
@.str = private unnamed_addr constant [29 x i8] c"ERROR\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", align 1
@.str.1 = private unnamed_addr constant [30 x i8] c"ERROR\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", align 1
@.str.2 = private unnamed_addr constant [29 x i8] zeroinitializer, align 1

; Function Attrs: nounwind uwtable
define internal void @ip6table_filter_fini() #0 section ".exit.text" {
entry:
  call void @unregister_pernet_subsys(%struct.pernet_operations* @ip6table_filter_net_ops)
  %0 = load %struct.nf_hook_ops*, %struct.nf_hook_ops** @filter_ops, align 8, !tbaa !2
  %1 = bitcast %struct.nf_hook_ops* %0 to i8*
  call void @kfree(i8* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ip6table_filter_init() #0 section ".init.text" {
entry:
  %call = call %struct.nf_hook_ops* @xt_hook_ops_alloc(%struct.xt_table* @packet_filter, i32 (i8*, %struct.sk_buff*, %struct.nf_hook_state*)* @ip6table_filter_hook)
  store %struct.nf_hook_ops* %call, %struct.nf_hook_ops** @filter_ops, align 8, !tbaa !2
  %0 = load %struct.nf_hook_ops*, %struct.nf_hook_ops** @filter_ops, align 8, !tbaa !2
  %1 = bitcast %struct.nf_hook_ops* %0 to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %1)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.nf_hook_ops*, %struct.nf_hook_ops** @filter_ops, align 8, !tbaa !2
  %3 = bitcast %struct.nf_hook_ops* %2 to i8*
  %call2 = call i64 @PTR_ERR(i8* %3)
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %call3 = call i32 @register_pernet_subsys(%struct.pernet_operations* @ip6table_filter_net_ops)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end
  %4 = load %struct.nf_hook_ops*, %struct.nf_hook_ops** @filter_ops, align 8, !tbaa !2
  %5 = bitcast %struct.nf_hook_ops* %4 to i8*
  call void @kfree(i8* %5)
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %if.end, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %call3, %if.then5 ], [ %call3, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @ip6table_filter_hook(i8* %priv, %struct.sk_buff* %skb, %struct.nf_hook_state* %state) #0 {
entry:
  %net = getelementptr inbounds %struct.nf_hook_state, %struct.nf_hook_state* %state, i32 0, i32 5
  %0 = load %struct.net*, %struct.net** %net, align 8, !tbaa !6
  %ipv6 = getelementptr inbounds %struct.net, %struct.net* %0, i32 0, i32 31
  %ip6table_filter = getelementptr inbounds %struct.netns_ipv6, %struct.netns_ipv6* %ipv6, i32 0, i32 6
  %1 = load %struct.xt_table*, %struct.xt_table** %ip6table_filter, align 64, !tbaa !9
  %call = call i32 @ip6t_do_table(%struct.sk_buff* %skb, %struct.nf_hook_state* %state, %struct.xt_table* %1)
  ret i32 %call
}

declare %struct.nf_hook_ops* @xt_hook_ops_alloc(%struct.xt_table*, i32 (i8*, %struct.sk_buff*, %struct.nf_hook_state*)*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare i32 @register_pernet_subsys(%struct.pernet_operations*) #1

declare void @kfree(i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @ip6table_filter_net_init(%struct.net* %net) #0 {
entry:
  %cmp = icmp eq %struct.net* %net, @init_net
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %0 = load i8, i8* @forward, align 1, !tbaa !64, !range !65
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call i32 @ip6table_filter_table_init(%struct.net* %net)
  br label %return

return:                                           ; preds = %if.then, %lor.lhs.false
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %lor.lhs.false ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @ip6table_filter_net_exit(%struct.net* %net) #0 {
entry:
  %ipv6 = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 31
  %ip6table_filter = getelementptr inbounds %struct.netns_ipv6, %struct.netns_ipv6* %ipv6, i32 0, i32 6
  %0 = load %struct.xt_table*, %struct.xt_table** %ip6table_filter, align 64, !tbaa !9
  %tobool = icmp ne %struct.xt_table* %0, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %ipv61 = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 31
  %ip6table_filter2 = getelementptr inbounds %struct.netns_ipv6, %struct.netns_ipv6* %ipv61, i32 0, i32 6
  %1 = load %struct.xt_table*, %struct.xt_table** %ip6table_filter2, align 64, !tbaa !9
  %2 = load %struct.nf_hook_ops*, %struct.nf_hook_ops** @filter_ops, align 8, !tbaa !2
  call void @ip6t_unregister_table(%struct.net* %net, %struct.xt_table* %1, %struct.nf_hook_ops* %2)
  %ipv63 = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 31
  %ip6table_filter4 = getelementptr inbounds %struct.netns_ipv6, %struct.netns_ipv6* %ipv63, i32 0, i32 6
  store %struct.xt_table* null, %struct.xt_table** %ip6table_filter4, align 64, !tbaa !9
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ip6table_filter_table_init(%struct.net* %net) #0 {
entry:
  %ipv6 = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 31
  %ip6table_filter = getelementptr inbounds %struct.netns_ipv6, %struct.netns_ipv6* %ipv6, i32 0, i32 6
  %0 = load %struct.xt_table*, %struct.xt_table** %ip6table_filter, align 64, !tbaa !9
  %tobool = icmp ne %struct.xt_table* %0, null
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i8* @ip6t_alloc_initial_table(%struct.xt_table* @packet_filter)
  %1 = bitcast i8* %call to %struct.ip6t_replace*
  %cmp = icmp eq %struct.ip6t_replace* %1, null
  br i1 %cmp, label %cleanup, label %if.end2

if.end2:                                          ; preds = %if.end
  %2 = load i8, i8* @forward, align 1, !tbaa !64, !range !65
  %tobool3 = trunc i8 %2 to i1
  %3 = zext i1 %tobool3 to i64
  %cond = select i1 %tobool3, i32 -2, i32 -1
  %entries = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %1, i32 0, i32 8
  %arraydecay = getelementptr inbounds [0 x %struct.ip6t_entry], [0 x %struct.ip6t_entry]* %entries, i32 0, i32 0
  %4 = bitcast %struct.ip6t_entry* %arraydecay to %struct.ip6t_standard*
  %arrayidx = getelementptr inbounds %struct.ip6t_standard, %struct.ip6t_standard* %4, i64 1
  %target = getelementptr inbounds %struct.ip6t_standard, %struct.ip6t_standard* %arrayidx, i32 0, i32 1
  %verdict = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %target, i32 0, i32 1
  store i32 %cond, i32* %verdict, align 8, !tbaa !66
  %5 = load %struct.nf_hook_ops*, %struct.nf_hook_ops** @filter_ops, align 8, !tbaa !2
  %ipv64 = getelementptr inbounds %struct.net, %struct.net* %net, i32 0, i32 31
  %ip6table_filter5 = getelementptr inbounds %struct.netns_ipv6, %struct.netns_ipv6* %ipv64, i32 0, i32 6
  %call6 = call i32 @ip6t_register_table(%struct.net* %net, %struct.xt_table* @packet_filter, %struct.ip6t_replace* %1, %struct.nf_hook_ops* %5, %struct.xt_table** %ip6table_filter5)
  %6 = bitcast %struct.ip6t_replace* %1 to i8*
  call void @kfree(i8* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %if.end, %entry
  %retval.0 = phi i32 [ %call6, %if.end2 ], [ 0, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #3

declare void @unregister_pernet_subsys(%struct.pernet_operations*) #1

; Function Attrs: nounwind uwtable
define internal void @ip6_tables_fini() #0 section ".exit.text" {
entry:
  call void @nf_unregister_sockopt(%struct.nf_sockopt_ops* @ip6t_sockopts)
  call void @xt_unregister_matches(%struct.xt_match* getelementptr inbounds ([1 x %struct.xt_match], [1 x %struct.xt_match]* @ip6t_builtin_mt, i32 0, i32 0), i32 1)
  call void @xt_unregister_targets(%struct.xt_target* getelementptr inbounds ([2 x %struct.xt_target], [2 x %struct.xt_target]* @ip6t_builtin_tg, i32 0, i32 0), i32 2)
  call void @unregister_pernet_subsys(%struct.pernet_operations* @ip6_tables_net_ops)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ip6_tables_init() #0 section ".init.text" {
entry:
  %call = call i32 @register_pernet_subsys(%struct.pernet_operations* @ip6_tables_net_ops)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @xt_register_targets(%struct.xt_target* getelementptr inbounds ([2 x %struct.xt_target], [2 x %struct.xt_target]* @ip6t_builtin_tg, i32 0, i32 0), i32 2)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %err2, label %if.end4

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @xt_register_matches(%struct.xt_match* getelementptr inbounds ([1 x %struct.xt_match], [1 x %struct.xt_match]* @ip6t_builtin_mt, i32 0, i32 0), i32 1)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %err4, label %if.end8

if.end8:                                          ; preds = %if.end4
  %call9 = call i32 @nf_register_sockopt(%struct.nf_sockopt_ops* @ip6t_sockopts)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %err5, label %if.end12

if.end12:                                         ; preds = %if.end8
  %call13 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.13, i32 0, i32 0))
  br label %cleanup

err5:                                             ; preds = %if.end8
  call void @xt_unregister_matches(%struct.xt_match* getelementptr inbounds ([1 x %struct.xt_match], [1 x %struct.xt_match]* @ip6t_builtin_mt, i32 0, i32 0), i32 1)
  br label %err4

err4:                                             ; preds = %err5, %if.end4
  %ret.0 = phi i32 [ %call9, %err5 ], [ %call5, %if.end4 ]
  call void @xt_unregister_targets(%struct.xt_target* getelementptr inbounds ([2 x %struct.xt_target], [2 x %struct.xt_target]* @ip6t_builtin_tg, i32 0, i32 0), i32 2)
  br label %err2

err2:                                             ; preds = %err4, %if.end
  %ret.1 = phi i32 [ %ret.0, %err4 ], [ %call1, %if.end ]
  call void @unregister_pernet_subsys(%struct.pernet_operations* @ip6_tables_net_ops)
  br label %cleanup

cleanup:                                          ; preds = %err2, %if.end12, %entry
  %retval.0 = phi i32 [ 0, %if.end12 ], [ %ret.1, %err2 ], [ %call, %entry ]
  ret i32 %retval.0
}

declare i32 @xt_register_targets(%struct.xt_target*, i32) #1

declare i32 @xt_register_matches(%struct.xt_match*, i32) #1

declare i32 @nf_register_sockopt(%struct.nf_sockopt_ops*) #1

declare i32 @printk(i8*, ...) #1

declare void @xt_unregister_matches(%struct.xt_match*, i32) #1

declare void @xt_unregister_targets(%struct.xt_target*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @do_ip6t_set_ctl(%struct.sock* %sk, i32 %cmd, i8* %user, i32 %len) #0 {
entry:
  %call = call %struct.net* @sock_net(%struct.sock* %sk)
  %user_ns = getelementptr inbounds %struct.net, %struct.net* %call, i32 0, i32 7
  %0 = load %struct.user_namespace*, %struct.user_namespace** %user_ns, align 8, !tbaa !74
  %call1 = call zeroext i1 @ns_capable(%struct.user_namespace* %0, i32 12)
  br i1 %call1, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %cmd, 65
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 65
  br i1 %SwitchLeaf2, label %sw.bb4, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, 64
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call2 = call %struct.net* @sock_net(%struct.sock* %sk)
  %call3 = call i32 @do_replace(%struct.net* %call2, i8* %user, i32 %len)
  br label %cleanup

sw.bb4:                                           ; preds = %LeafBlock1
  %call5 = call %struct.net* @sock_net(%struct.sock* %sk)
  %call6 = call i32 @do_add_counters(%struct.net* %call5, i8* %user, i32 %len, i32 0)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %cleanup

cleanup:                                          ; preds = %NewDefault, %sw.bb4, %sw.bb, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ %call6, %sw.bb4 ], [ %call3, %sw.bb ], [ -22, %NewDefault ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @compat_do_ip6t_set_ctl(%struct.sock* %sk, i32 %cmd, i8* %user, i32 %len) #0 {
entry:
  %call = call %struct.net* @sock_net(%struct.sock* %sk)
  %user_ns = getelementptr inbounds %struct.net, %struct.net* %call, i32 0, i32 7
  %0 = load %struct.user_namespace*, %struct.user_namespace** %user_ns, align 8, !tbaa !74
  %call1 = call zeroext i1 @ns_capable(%struct.user_namespace* %0, i32 12)
  br i1 %call1, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %cmd, 65
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 65
  br i1 %SwitchLeaf2, label %sw.bb4, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, 64
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call2 = call %struct.net* @sock_net(%struct.sock* %sk)
  %call3 = call i32 @compat_do_replace(%struct.net* %call2, i8* %user, i32 %len)
  br label %cleanup

sw.bb4:                                           ; preds = %LeafBlock1
  %call5 = call %struct.net* @sock_net(%struct.sock* %sk)
  %call6 = call i32 @do_add_counters(%struct.net* %call5, i8* %user, i32 %len, i32 1)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %cleanup

cleanup:                                          ; preds = %NewDefault, %sw.bb4, %sw.bb, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ %call6, %sw.bb4 ], [ %call3, %sw.bb ], [ -22, %NewDefault ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @do_ip6t_get_ctl(%struct.sock* %sk, i32 %cmd, i8* %user, i32* %len) #0 {
entry:
  %ret = alloca i32, align 4
  %rev = alloca %struct.xt_get_revision, align 1
  %0 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %call = call %struct.net* @sock_net(%struct.sock* %sk)
  %user_ns = getelementptr inbounds %struct.net, %struct.net* %call, i32 0, i32 7
  %1 = load %struct.user_namespace*, %struct.user_namespace** %user_ns, align 8, !tbaa !74
  %call1 = call zeroext i1 @ns_capable(%struct.user_namespace* %1, i32 12)
  br i1 %call1, label %if.end, label %cleanup30

if.end:                                           ; preds = %entry
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %cmd, 65
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %cmd, 68
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %cmd.off = add i32 %cmd, -68
  %SwitchLeaf4 = icmp ule i32 %cmd.off, 1
  br i1 %SwitchLeaf4, label %sw.bb7, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 65
  br i1 %SwitchLeaf2, label %sw.bb4, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %cmd, 64
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call2 = call %struct.net* @sock_net(%struct.sock* %sk)
  %call3 = call i32 @get_info(%struct.net* %call2, i8* %user, i32* %len, i32 0)
  store i32 %call3, i32* %ret, align 4, !tbaa !75
  br label %sw.epilog

sw.bb4:                                           ; preds = %LeafBlock1
  %call5 = call %struct.net* @sock_net(%struct.sock* %sk)
  %2 = bitcast i8* %user to %struct.ip6t_get_entries*
  %call6 = call i32 @get_entries(%struct.net* %call5, %struct.ip6t_get_entries* %2, i32* %len)
  store i32 %call6, i32* %ret, align 4, !tbaa !75
  br label %sw.epilog

sw.bb7:                                           ; preds = %LeafBlock3
  %3 = bitcast %struct.xt_get_revision* %rev to i8*
  call void @llvm.lifetime.start.p0i8(i64 30, i8* %3) #7
  %4 = load i32, i32* %len, align 4, !tbaa !75
  %conv = sext i32 %4 to i64
  %cmp = icmp ne i64 %conv, 30
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %sw.bb7
  store i32 -22, i32* %ret, align 4, !tbaa !75
  br label %cleanup

if.end10:                                         ; preds = %sw.bb7
  %5 = bitcast %struct.xt_get_revision* %rev to i8*
  %call11 = call i64 @copy_from_user(i8* %5, i8* %user, i64 30)
  %cmp12 = icmp ne i64 %call11, 0
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end10
  store i32 -14, i32* %ret, align 4, !tbaa !75
  br label %cleanup

if.end15:                                         ; preds = %if.end10
  %name = getelementptr inbounds %struct.xt_get_revision, %struct.xt_get_revision* %rev, i32 0, i32 0
  %arrayidx = getelementptr inbounds [29 x i8], [29 x i8]* %name, i64 0, i64 28
  store i8 0, i8* %arrayidx, align 1, !tbaa !76
  %cmp16 = icmp eq i32 %cmd, 69
  %. = select i1 %cmp16, i32 1, i32 0
  %name20 = getelementptr inbounds %struct.xt_get_revision, %struct.xt_get_revision* %rev, i32 0, i32 0
  %arraydecay = getelementptr inbounds [29 x i8], [29 x i8]* %name20, i32 0, i32 0
  %revision = getelementptr inbounds %struct.xt_get_revision, %struct.xt_get_revision* %rev, i32 0, i32 1
  %6 = load i8, i8* %revision, align 1, !tbaa !77
  %call21 = call i32 @xt_find_revision(i8 zeroext 10, i8* %arraydecay, i8 zeroext %6, i32 %., i32* %ret)
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %cleanup, label %cond.false

cond.false:                                       ; preds = %if.end15
  %name22 = getelementptr inbounds %struct.xt_get_revision, %struct.xt_get_revision* %rev, i32 0, i32 0
  %arraydecay23 = getelementptr inbounds [29 x i8], [29 x i8]* %name22, i32 0, i32 0
  %call24 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.11, i32 0, i32 0), i8* %arraydecay23)
  %name25 = getelementptr inbounds %struct.xt_get_revision, %struct.xt_get_revision* %rev, i32 0, i32 0
  %arraydecay26 = getelementptr inbounds [29 x i8], [29 x i8]* %name25, i32 0, i32 0
  %revision27 = getelementptr inbounds %struct.xt_get_revision, %struct.xt_get_revision* %rev, i32 0, i32 1
  %7 = load i8, i8* %revision27, align 1, !tbaa !77
  %call28 = call i32 @xt_find_revision(i8 zeroext 10, i8* %arraydecay26, i8 zeroext %7, i32 %., i32* %ret)
  br label %cleanup

cleanup:                                          ; preds = %cond.false, %if.end15, %if.then14, %if.then9
  %8 = bitcast %struct.xt_get_revision* %rev to i8*
  call void @llvm.lifetime.end.p0i8(i64 30, i8* %8) #7
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  store i32 -22, i32* %ret, align 4, !tbaa !75
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %cleanup, %sw.bb4, %sw.bb
  %9 = load i32, i32* %ret, align 4, !tbaa !75
  br label %cleanup30

cleanup30:                                        ; preds = %sw.epilog, %entry
  %retval.0 = phi i32 [ %9, %sw.epilog ], [ -1, %entry ]
  %10 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @compat_do_ip6t_get_ctl(%struct.sock* %sk, i32 %cmd, i8* %user, i32* %len) #0 {
entry:
  %call = call %struct.net* @sock_net(%struct.sock* %sk)
  %user_ns = getelementptr inbounds %struct.net, %struct.net* %call, i32 0, i32 7
  %0 = load %struct.user_namespace*, %struct.user_namespace** %user_ns, align 8, !tbaa !74
  %call1 = call zeroext i1 @ns_capable(%struct.user_namespace* %0, i32 12)
  br i1 %call1, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %cmd, 65
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 65
  br i1 %SwitchLeaf2, label %sw.bb4, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cmd, 64
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call2 = call %struct.net* @sock_net(%struct.sock* %sk)
  %call3 = call i32 @get_info(%struct.net* %call2, i8* %user, i32* %len, i32 1)
  br label %cleanup

sw.bb4:                                           ; preds = %LeafBlock1
  %call5 = call %struct.net* @sock_net(%struct.sock* %sk)
  %1 = bitcast i8* %user to %struct.compat_ip6t_get_entries*
  %call6 = call i32 @compat_get_entries(%struct.net* %call5, %struct.compat_ip6t_get_entries* %1, i32* %len)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %call7 = call i32 @do_ip6t_get_ctl(%struct.sock* %sk, i32 %cmd, i8* %user, i32* %len)
  br label %cleanup

cleanup:                                          ; preds = %sw.default, %sw.bb4, %sw.bb, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ %call7, %sw.default ], [ %call6, %sw.bb4 ], [ %call3, %sw.bb ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @sock_net(%struct.sock* %sk) #2 {
entry:
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_net = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 9
  %call = call %struct.net* @read_pnet(%struct.possible_net_t* %skc_net)
  ret %struct.net* %call
}

declare zeroext i1 @ns_capable(%struct.user_namespace*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @get_info(%struct.net* %net, i8* %user, i32* %len, i32 %compat) #0 {
entry:
  %name = alloca [32 x i8], align 16
  %info = alloca %struct.ip6t_getinfo, align 4
  %tmp = alloca %struct.xt_table_info, align 8
  %0 = bitcast [32 x i8]* %name to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %1 = load i32, i32* %len, align 4, !tbaa !75
  %conv = sext i32 %1 to i64
  %cmp = icmp ne i64 %conv, 84
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %call = call i64 @copy_from_user(i8* %arraydecay, i8* %user, i64 32)
  %cmp2 = icmp ne i64 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %name, i64 0, i64 31
  store i8 0, i8* %arrayidx, align 1, !tbaa !76
  %tobool = icmp ne i32 %compat, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end5
  call void @xt_compat_lock(i8 zeroext 10)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end5
  %arraydecay8 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %call9 = call %struct.xt_table* @xt_find_table_lock(%struct.net* %net, i8 zeroext 10, i8* %arraydecay8)
  %tobool10 = icmp ne %struct.xt_table* %call9, null
  br i1 %tobool10, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end7
  %arraydecay11 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %call12 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.9, i32 0, i32 0), i8* %arraydecay11)
  %arraydecay13 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %call14 = call %struct.xt_table* @xt_find_table_lock(%struct.net* %net, i8 zeroext 10, i8* %arraydecay13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end7
  %cond = phi %struct.xt_table* [ %call14, %cond.false ], [ %call9, %if.end7 ]
  %tobool15 = icmp ne %struct.xt_table* %cond, null
  br i1 %tobool15, label %if.then16, label %if.end65

if.then16:                                        ; preds = %cond.end
  %2 = bitcast %struct.ip6t_getinfo* %info to i8*
  call void @llvm.lifetime.start.p0i8(i64 84, i8* %2) #7
  %private17 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %cond, i32 0, i32 2
  %3 = load %struct.xt_table_info*, %struct.xt_table_info** %private17, align 8, !tbaa !79
  %4 = bitcast %struct.xt_table_info* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %4) #7
  %tobool18 = icmp ne i32 %compat, 0
  br i1 %tobool18, label %if.then19, label %if.end21

if.then19:                                        ; preds = %if.then16
  %call20 = call i32 @compat_table_info(%struct.xt_table_info* %3, %struct.xt_table_info* %tmp)
  call void @xt_compat_flush_offsets(i8 zeroext 10)
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %if.then16
  %private.0 = phi %struct.xt_table_info* [ %tmp, %if.then19 ], [ %3, %if.then16 ]
  %5 = bitcast %struct.ip6t_getinfo* %info to i8*
  call void @llvm.memset.p0i8.i64(i8* %5, i8 0, i64 84, i32 4, i1 false)
  %valid_hooks = getelementptr inbounds %struct.xt_table, %struct.xt_table* %cond, i32 0, i32 1
  %6 = load i32, i32* %valid_hooks, align 8, !tbaa !81
  %valid_hooks22 = getelementptr inbounds %struct.ip6t_getinfo, %struct.ip6t_getinfo* %info, i32 0, i32 1
  store i32 %6, i32* %valid_hooks22, align 4, !tbaa !82
  %cmp23 = icmp uge i64 20, 64
  %hook_entry = getelementptr inbounds %struct.ip6t_getinfo, %struct.ip6t_getinfo* %info, i32 0, i32 2
  %arraydecay26 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i32 0, i32 0
  %7 = bitcast i32* %arraydecay26 to i8*
  %hook_entry27 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %private.0, i32 0, i32 3
  %arraydecay28 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry27, i32 0, i32 0
  %8 = bitcast i32* %arraydecay28 to i8*
  br i1 %cmp23, label %if.then25, label %if.else

if.then25:                                        ; preds = %if.end21
  %call29 = call i8* @__memcpy(i8* %7, i8* %8, i64 20)
  br label %if.end34

if.else:                                          ; preds = %if.end21
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 20, i32 4, i1 false)
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then25
  %__ret.0 = phi i8* [ %call29, %if.then25 ], [ %7, %if.else ]
  %cmp38 = icmp uge i64 20, 64
  %underflow = getelementptr inbounds %struct.ip6t_getinfo, %struct.ip6t_getinfo* %info, i32 0, i32 3
  %arraydecay41 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i32 0, i32 0
  %9 = bitcast i32* %arraydecay41 to i8*
  %underflow42 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %private.0, i32 0, i32 4
  %arraydecay43 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow42, i32 0, i32 0
  %10 = bitcast i32* %arraydecay43 to i8*
  br i1 %cmp38, label %if.then40, label %if.else45

if.then40:                                        ; preds = %if.end34
  %call44 = call i8* @__memcpy(i8* %9, i8* %10, i64 20)
  br label %if.end50

if.else45:                                        ; preds = %if.end34
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 20, i32 4, i1 false)
  br label %if.end50

if.end50:                                         ; preds = %if.else45, %if.then40
  %__ret37.0 = phi i8* [ %call44, %if.then40 ], [ %9, %if.else45 ]
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %private.0, i32 0, i32 1
  %11 = load i32, i32* %number, align 4, !tbaa !84
  %num_entries = getelementptr inbounds %struct.ip6t_getinfo, %struct.ip6t_getinfo* %info, i32 0, i32 4
  store i32 %11, i32* %num_entries, align 4, !tbaa !86
  %size = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %private.0, i32 0, i32 0
  %12 = load i32, i32* %size, align 8, !tbaa !87
  %size52 = getelementptr inbounds %struct.ip6t_getinfo, %struct.ip6t_getinfo* %info, i32 0, i32 5
  store i32 %12, i32* %size52, align 4, !tbaa !88
  %name53 = getelementptr inbounds %struct.ip6t_getinfo, %struct.ip6t_getinfo* %info, i32 0, i32 0
  %arraydecay54 = getelementptr inbounds [32 x i8], [32 x i8]* %name53, i32 0, i32 0
  %arraydecay55 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %call56 = call i8* @strcpy(i8* %arraydecay54, i8* %arraydecay55)
  %13 = bitcast %struct.ip6t_getinfo* %info to i8*
  %14 = load i32, i32* %len, align 4, !tbaa !75
  %conv57 = sext i32 %14 to i64
  %call58 = call i64 @copy_to_user(i8* %user, i8* %13, i64 %conv57)
  %cmp59 = icmp ne i64 %call58, 0
  %. = select i1 %cmp59, i32 -14, i32 0
  call void @xt_table_unlock(%struct.xt_table* %cond)
  %me = getelementptr inbounds %struct.xt_table, %struct.xt_table* %cond, i32 0, i32 3
  %15 = load %struct.module*, %struct.module** %me, align 8, !tbaa !89
  call void @module_put(%struct.module* %15)
  %16 = bitcast %struct.xt_table_info* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %16) #7
  %17 = bitcast %struct.ip6t_getinfo* %info to i8*
  call void @llvm.lifetime.end.p0i8(i64 84, i8* %17) #7
  br label %if.end65

if.end65:                                         ; preds = %if.end50, %cond.end
  %ret.1 = phi i32 [ %., %if.end50 ], [ -2, %cond.end ]
  %tobool66 = icmp ne i32 %compat, 0
  br i1 %tobool66, label %if.then67, label %cleanup

if.then67:                                        ; preds = %if.end65
  call void @xt_compat_unlock(i8 zeroext 10)
  br label %cleanup

cleanup:                                          ; preds = %if.then67, %if.end65, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -14, %if.end ], [ %ret.1, %if.then67 ], [ %ret.1, %if.end65 ]
  %18 = bitcast [32 x i8]* %name to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %18) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @compat_get_entries(%struct.net* %net, %struct.compat_ip6t_get_entries* %uptr, i32* %len) #0 {
entry:
  %get = alloca %struct.compat_ip6t_get_entries, align 4
  %info = alloca %struct.xt_table_info, align 8
  %0 = bitcast %struct.compat_ip6t_get_entries* %get to i8*
  call void @llvm.lifetime.start.p0i8(i64 36, i8* %0) #7
  %1 = load i32, i32* %len, align 4, !tbaa !75
  %conv = sext i32 %1 to i64
  %cmp = icmp ult i64 %conv, 36
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast %struct.compat_ip6t_get_entries* %get to i8*
  %3 = bitcast %struct.compat_ip6t_get_entries* %uptr to i8*
  %call = call i64 @copy_from_user(i8* %2, i8* %3, i64 36)
  %cmp2 = icmp ne i64 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %4 = load i32, i32* %len, align 4, !tbaa !75
  %conv6 = sext i32 %4 to i64
  %size = getelementptr inbounds %struct.compat_ip6t_get_entries, %struct.compat_ip6t_get_entries* %get, i32 0, i32 1
  %5 = load i32, i32* %size, align 4, !tbaa !90
  %conv7 = zext i32 %5 to i64
  %add = add i64 36, %conv7
  %cmp8 = icmp ne i64 %conv6, %add
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end5
  %name = getelementptr inbounds %struct.compat_ip6t_get_entries, %struct.compat_ip6t_get_entries* %get, i32 0, i32 0
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %name, i64 0, i64 31
  store i8 0, i8* %arrayidx, align 1, !tbaa !76
  call void @xt_compat_lock(i8 zeroext 10)
  %name12 = getelementptr inbounds %struct.compat_ip6t_get_entries, %struct.compat_ip6t_get_entries* %get, i32 0, i32 0
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name12, i32 0, i32 0
  %call13 = call %struct.xt_table* @xt_find_table_lock(%struct.net* %net, i8 zeroext 10, i8* %arraydecay)
  %tobool = icmp ne %struct.xt_table* %call13, null
  br i1 %tobool, label %if.then14, label %if.end31

if.then14:                                        ; preds = %if.end11
  %private15 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %call13, i32 0, i32 2
  %6 = load %struct.xt_table_info*, %struct.xt_table_info** %private15, align 8, !tbaa !79
  %7 = bitcast %struct.xt_table_info* %info to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %7) #7
  %call16 = call i32 @compat_table_info(%struct.xt_table_info* %6, %struct.xt_table_info* %info)
  %cond = icmp eq i32 %call16, 0
  br i1 %cond, label %land.lhs.true, label %if.end29

land.lhs.true:                                    ; preds = %if.then14
  %size18 = getelementptr inbounds %struct.compat_ip6t_get_entries, %struct.compat_ip6t_get_entries* %get, i32 0, i32 1
  %8 = load i32, i32* %size18, align 4, !tbaa !90
  %size19 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 0
  %9 = load i32, i32* %size19, align 8, !tbaa !87
  %cmp20 = icmp eq i32 %8, %9
  br i1 %cmp20, label %if.then22, label %if.else

if.then22:                                        ; preds = %land.lhs.true
  %size23 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 0
  %10 = load i32, i32* %size23, align 8, !tbaa !87
  %entrytable = getelementptr inbounds %struct.compat_ip6t_get_entries, %struct.compat_ip6t_get_entries* %uptr, i32 0, i32 2
  %arraydecay24 = getelementptr inbounds [0 x %struct.compat_ip6t_entry], [0 x %struct.compat_ip6t_entry]* %entrytable, i32 0, i32 0
  %11 = bitcast %struct.compat_ip6t_entry* %arraydecay24 to i8*
  %call25 = call i32 @compat_copy_entries_to_user(i32 %10, %struct.xt_table* %call13, i8* %11)
  br label %if.end29

if.else:                                          ; preds = %land.lhs.true
  %tobool26 = icmp ne i32 %call16, 0
  %call16. = select i1 %tobool26, i32 %call16, i32 -11
  br label %if.end29

if.end29:                                         ; preds = %if.else, %if.then22, %if.then14
  %ret.1 = phi i32 [ %call25, %if.then22 ], [ %call16, %if.then14 ], [ %call16., %if.else ]
  call void @xt_compat_flush_offsets(i8 zeroext 10)
  %me = getelementptr inbounds %struct.xt_table, %struct.xt_table* %call13, i32 0, i32 3
  %12 = load %struct.module*, %struct.module** %me, align 8, !tbaa !89
  call void @module_put(%struct.module* %12)
  call void @xt_table_unlock(%struct.xt_table* %call13)
  %13 = bitcast %struct.xt_table_info* %info to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %13) #7
  br label %if.end31

if.end31:                                         ; preds = %if.end29, %if.end11
  %ret.2 = phi i32 [ %ret.1, %if.end29 ], [ -2, %if.end11 ]
  call void @xt_compat_unlock(i8 zeroext 10)
  br label %cleanup

cleanup:                                          ; preds = %if.end31, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ %ret.2, %if.end31 ], [ -22, %entry ], [ -14, %if.end ], [ -22, %if.end5 ]
  %14 = bitcast %struct.compat_ip6t_get_entries* %get to i8*
  call void @llvm.lifetime.end.p0i8(i64 36, i8* %14) #7
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #5 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_write(i8* %to, i32 %conv1)
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size(i8* %to, i64 %n, i1 zeroext false)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

declare void @xt_compat_lock(i8 zeroext) #1

declare %struct.xt_table* @xt_find_table_lock(%struct.net*, i8 zeroext, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @compat_table_info(%struct.xt_table_info* %info, %struct.xt_table_info* %newinfo) #0 {
entry:
  %tobool = icmp ne %struct.xt_table_info* %newinfo, null
  %tobool1 = icmp ne %struct.xt_table_info* %info, null
  %or.cond = and i1 %tobool, %tobool1
  br i1 %or.cond, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %cmp = icmp uge i64 64, 64
  %0 = bitcast %struct.xt_table_info* %newinfo to i8*
  %1 = bitcast %struct.xt_table_info* %info to i8*
  br i1 %cmp, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %call = call i8* @__memcpy(i8* %0, i8* %1, i64 64)
  br label %if.end3

if.else:                                          ; preds = %if.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 64, i32 8, i1 false)
  br label %if.end3

if.end3:                                          ; preds = %if.else, %if.then2
  %__ret.0 = phi i8* [ %call, %if.then2 ], [ %0, %if.else ]
  %initial_entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 2
  store i32 0, i32* %initial_entries, align 8, !tbaa !92
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 1
  %2 = load i32, i32* %number, align 4, !tbaa !84
  call void @xt_compat_init_offsets(i8 zeroext 10, i32 %2)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %add.ptr10.sink = phi i8* [ %add.ptr10, %for.inc ], [ %arraydecay, %if.end3 ]
  %3 = bitcast i8* %add.ptr10.sink to %struct.ip6t_entry*
  %size = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 0
  %4 = load i32, i32* %size, align 8, !tbaa !87
  %idx.ext = zext i32 %4 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 %idx.ext
  %5 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %cmp4 = icmp ult %struct.ip6t_entry* %3, %5
  br i1 %cmp4, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call5 = call i32 @compat_calc_entry(%struct.ip6t_entry* %3, %struct.xt_table_info* %info, i8* %arraydecay, %struct.xt_table_info* %newinfo)
  %cmp6 = icmp ne i32 %call5, 0
  br i1 %cmp6, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = bitcast %struct.ip6t_entry* %3 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %3, i32 0, i32 3
  %7 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv = zext i16 %7 to i32
  %idx.ext9 = sext i32 %conv to i64
  %add.ptr10 = getelementptr inbounds i8, i8* %6, i64 %idx.ext9
  br label %for.cond

cleanup:                                          ; preds = %for.body, %for.cond, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ %call5, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @compat_copy_entries_to_user(i32 %total_size, %struct.xt_table* %table, i8* %userptr) #0 {
entry:
  %pos = alloca i8*, align 8
  %size = alloca i32, align 4
  %private1 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %table, i32 0, i32 2
  %0 = load %struct.xt_table_info*, %struct.xt_table_info** %private1, align 8, !tbaa !79
  %1 = bitcast i8** %pos to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i32* %size to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %call = call %struct.timespec* @alloc_counters(%struct.xt_table* %table)
  %3 = bitcast %struct.timespec* %call to i8*
  %call2 = call zeroext i1 @IS_ERR.2(i8* %3)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = bitcast %struct.timespec* %call to i8*
  %call3 = call i64 @PTR_ERR.3(i8* %4)
  %conv = trunc i64 %call3 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  store i8* %userptr, i8** %pos, align 8, !tbaa !2
  store i32 %total_size, i32* %size, align 4, !tbaa !75
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %0, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %add.ptr14.sink = phi i8* [ %add.ptr14, %for.inc ], [ %arraydecay, %if.end ]
  %ret.0 = phi i32 [ 0, %if.end ], [ %call7, %for.inc ]
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %5 = bitcast i8* %add.ptr14.sink to %struct.ip6t_entry*
  %entries4 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %0, i32 0, i32 7
  %arraydecay5 = getelementptr inbounds [0 x i8], [0 x i8]* %entries4, i32 0, i32 0
  %idx.ext = zext i32 %total_size to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay5, i64 %idx.ext
  %6 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %cmp = icmp ult %struct.ip6t_entry* %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %inc = add i32 %i.0, 1
  %call7 = call i32 @compat_copy_entry_to_user(%struct.ip6t_entry* %5, i8** %pos, i32* %size, %struct.timespec* %call, i32 %i.0)
  %cmp8 = icmp ne i32 %call7, 0
  br i1 %cmp8, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = bitcast %struct.ip6t_entry* %5 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %5, i32 0, i32 3
  %8 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv12 = zext i16 %8 to i32
  %idx.ext13 = sext i32 %conv12 to i64
  %add.ptr14 = getelementptr inbounds i8, i8* %7, i64 %idx.ext13
  br label %for.cond

for.end:                                          ; preds = %for.body, %for.cond
  %ret.1 = phi i32 [ %call7, %for.body ], [ %ret.0, %for.cond ]
  %9 = bitcast %struct.timespec* %call to i8*
  call void @vfree(i8* %9)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %ret.1, %for.end ]
  %10 = bitcast i32* %size to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #7
  %11 = bitcast i8** %pos to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  ret i32 %retval.0
}

declare void @xt_compat_flush_offsets(i8 zeroext) #1

declare void @module_put(%struct.module*) #1

declare void @xt_table_unlock(%struct.xt_table*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

declare void @xt_compat_unlock(i8 zeroext) #1

; Function Attrs: nounwind uwtable
define internal %struct.timespec* @alloc_counters(%struct.xt_table* %table) #0 {
entry:
  %private1 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %table, i32 0, i32 2
  %0 = load %struct.xt_table_info*, %struct.xt_table_info** %private1, align 8, !tbaa !79
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %0, i32 0, i32 1
  %1 = load i32, i32* %number, align 4, !tbaa !84
  %conv = zext i32 %1 to i64
  %mul = mul i64 16, %conv
  %conv2 = trunc i64 %mul to i32
  %conv3 = zext i32 %conv2 to i64
  %call = call i8* @vzalloc(i64 %conv3)
  %2 = bitcast i8* %call to %struct.timespec*
  %cmp = icmp eq %struct.timespec* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call5 = call i8* @ERR_PTR(i64 -12)
  %3 = bitcast i8* %call5 to %struct.timespec*
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @get_counters(%struct.xt_table_info* %0, %struct.timespec* %2)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi %struct.timespec* [ %3, %if.then ], [ %2, %if.end ]
  ret %struct.timespec* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR.2(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR.3(i8* %ptr) #2 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @compat_copy_entry_to_user(%struct.ip6t_entry* %e, i8** %dstptr, i32* %size, %struct.timespec* %counters, i32 %i) #0 {
entry:
  %0 = load i32, i32* %size, align 4, !tbaa !75
  %1 = load i8*, i8** %dstptr, align 8, !tbaa !2
  %2 = bitcast i8* %1 to %struct.compat_ip6t_entry*
  %3 = bitcast %struct.compat_ip6t_entry* %2 to i8*
  %4 = bitcast %struct.ip6t_entry* %e to i8*
  %call = call i64 @copy_to_user(i8* %3, i8* %4, i64 168)
  %cmp = icmp ne i64 %call, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %counters1 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %2, i32 0, i32 5
  %5 = bitcast %struct.timespec* %counters1 to i8*
  %idxprom = zext i32 %i to i64
  %arrayidx = getelementptr inbounds %struct.timespec, %struct.timespec* %counters, i64 %idxprom
  %6 = bitcast %struct.timespec* %arrayidx to i8*
  %call2 = call i64 @copy_to_user(i8* %5, i8* %6, i64 16)
  %cmp3 = icmp ne i64 %call2, 0
  br i1 %cmp3, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %7 = load i8*, i8** %dstptr, align 8, !tbaa !2
  %add.ptr = getelementptr i8, i8* %7, i64 164
  store i8* %add.ptr, i8** %dstptr, align 8, !tbaa !2
  %8 = load i32, i32* %size, align 4, !tbaa !75
  %conv = zext i32 %8 to i64
  %sub = sub i64 %conv, 4
  %conv4 = trunc i64 %sub to i32
  store i32 %conv4, i32* %size, align 4, !tbaa !75
  %elems = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %add.ptr17.sink = phi i8* [ %add.ptr17, %for.inc ], [ %arraydecay, %if.end ]
  %9 = bitcast i8* %add.ptr17.sink to %struct.xt_entry_match*
  %10 = bitcast %struct.ip6t_entry* %e to i8*
  %target_offset5 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %11 = load i16, i16* %target_offset5, align 4, !tbaa !94
  %conv6 = zext i16 %11 to i32
  %idx.ext = sext i32 %conv6 to i64
  %add.ptr7 = getelementptr inbounds i8, i8* %10, i64 %idx.ext
  %12 = bitcast i8* %add.ptr7 to %struct.xt_entry_match*
  %cmp8 = icmp ult %struct.xt_entry_match* %9, %12
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call10 = call i32 @xt_compat_match_to_user(%struct.xt_entry_match* %9, i8** %dstptr, i32* %size)
  %cmp11 = icmp ne i32 %call10, 0
  br i1 %cmp11, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = bitcast %struct.xt_entry_match* %9 to i8*
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %9, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u to i16*
  %14 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv15 = zext i16 %14 to i32
  %idx.ext16 = sext i32 %conv15 to i64
  %add.ptr17 = getelementptr inbounds i8, i8* %13, i64 %idx.ext16
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %target_offset18 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %15 = load i16, i16* %target_offset18, align 4, !tbaa !94
  %conv19 = zext i16 %15 to i32
  %16 = load i32, i32* %size, align 4, !tbaa !75
  %sub20 = sub i32 %0, %16
  %sub21 = sub i32 %conv19, %sub20
  %conv22 = trunc i32 %sub21 to i16
  %call23 = call %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %e)
  %call24 = call i32 @xt_compat_target_to_user(%struct.xt_entry_target* %call23, i8** %dstptr, i32* %size)
  %tobool = icmp ne i32 %call24, 0
  br i1 %tobool, label %cleanup, label %if.end26

if.end26:                                         ; preds = %for.end
  %next_offset27 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 3
  %17 = load i16, i16* %next_offset27, align 2, !tbaa !93
  %conv28 = zext i16 %17 to i32
  %18 = load i32, i32* %size, align 4, !tbaa !75
  %sub29 = sub i32 %0, %18
  %sub30 = sub i32 %conv28, %sub29
  %conv31 = trunc i32 %sub30 to i16
  call void @might_fault()
  %19 = zext i16 %conv22 to i32
  %target_offset32 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %2, i32 0, i32 2
  %20 = call i32 asm sideeffect "call __put_user_2", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %19, i16* %target_offset32) #7, !srcloc !95
  %conv33 = sext i32 %20 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %cmp34 = icmp ne i64 %expval, 0
  br i1 %cmp34, label %cleanup, label %lor.lhs.false36

lor.lhs.false36:                                  ; preds = %if.end26
  call void @might_fault()
  %21 = zext i16 %conv31 to i32
  %next_offset39 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %2, i32 0, i32 3
  %22 = call i32 asm sideeffect "call __put_user_2", "={ax},0,{cx},~{ebx},~{dirflag},~{fpsr},~{flags}"(i32 %21, i16* %next_offset39) #7, !srcloc !96
  %conv41 = sext i32 %22 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %cmp43 = icmp ne i64 %expval42, 0
  %. = select i1 %cmp43, i32 -14, i32 0
  ret i32 %.

cleanup:                                          ; preds = %if.end26, %for.end, %for.body, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -14, %lor.lhs.false ], [ -14, %entry ], [ %call10, %for.body ], [ %call24, %for.end ], [ -14, %if.end26 ]
  ret i32 %retval.0
}

declare void @vfree(i8*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i64 @copy_to_user(i8* %to, i8* %from, i64 %n) #5 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %from, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  %conv1 = trunc i64 %n to i32
  call void @kasan_check_read(i8* %from, i32 %conv1)
  call void @might_fault()
  %cmp = icmp slt i32 %conv, 0
  %conv3 = sext i32 %conv to i64
  %cmp4 = icmp uge i64 %conv3, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp4
  %lnot = xor i1 %1, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @check_object_size(i8* %from, i64 %n, i1 zeroext true)
  %conv8 = trunc i64 %n to i32
  %call = call i64 @_copy_to_user(i8* %to, i8* %from, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @copy_user_overflow(i32 %conv, i64 %n)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.else ]
  ret i64 %n.addr.0
}

declare i32 @xt_compat_match_to_user(%struct.xt_entry_match*, i8**, i32*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %e) #2 {
entry:
  %0 = bitcast %struct.ip6t_entry* %e to i8*
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %1 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv = zext i16 %1 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %2 = bitcast i8* %add.ptr to %struct.xt_entry_target*
  ret %struct.xt_entry_target* %2
}

declare i32 @xt_compat_target_to_user(%struct.xt_entry_target*, i8**, i32*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @might_fault() #2 {
entry:
  ret void
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

; Function Attrs: inlinehint nounwind uwtable
define internal void @kasan_check_read(i8* %p, i32 %size) #2 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @check_object_size(i8* %ptr, i64 %n, i1 zeroext %to_user) #2 {
entry:
  %frombool = zext i1 %to_user to i8
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @copy_user_overflow(i32 %size, i64 %count) #2 {
entry:
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.7, i32 0, i32 0), i32 688, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.8, i32 0, i32 0), i32 %size, i64 %count)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool3 = icmp ne i32 1, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv8 = sext i32 %lnot.ext7 to i64
  %expval9 = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  ret void
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

declare i8* @vzalloc(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR(i64 %error) #2 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal void @get_counters(%struct.xt_table_info* %t, %struct.timespec* %counters) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %cpu.0 = phi i32 [ -1, %entry ], [ %call, %for.end ]
  %call = call i32 @cpumask_next(i32 %cpu.0, %struct.cpumask* @__cpu_possible_mask)
  %0 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !75
  %cmp = icmp ult i32 %call, %0
  br i1 %cmp, label %do.end, label %for.end30

do.end:                                           ; preds = %for.cond
  %1 = call i64 asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(%struct.atomic_t* @xt_recseq) #3, !srcloc !97
  %idxprom = zext i32 %call to i64
  %arrayidx = getelementptr inbounds [64 x i64], [64 x i64]* @__per_cpu_offset, i64 0, i64 %idxprom
  %2 = load i64, i64* %arrayidx, align 8, !tbaa !98
  %add = add i64 %1, %2
  %3 = inttoptr i64 %add to %struct.atomic_t*
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %t, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  br label %for.cond2

for.cond2:                                        ; preds = %do.body17, %do.end
  %add.ptr29.sink = phi i8* [ %add.ptr29, %do.body17 ], [ %arraydecay, %do.end ]
  %i.0 = phi i32 [ 0, %do.end ], [ %inc, %do.body17 ]
  %4 = bitcast i8* %add.ptr29.sink to %struct.ip6t_entry*
  %entries3 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %t, i32 0, i32 7
  %arraydecay4 = getelementptr inbounds [0 x i8], [0 x i8]* %entries3, i32 0, i32 0
  %size = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %t, i32 0, i32 0
  %5 = load i32, i32* %size, align 8, !tbaa !87
  %idx.ext = zext i32 %5 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay4, i64 %idx.ext
  %6 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %cmp5 = icmp ult %struct.ip6t_entry* %4, %6
  br i1 %cmp5, label %for.body6, label %for.end

for.body6:                                        ; preds = %for.cond2
  %counters8 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %4, i32 0, i32 5
  %call9 = call %struct.timespec* @xt_get_per_cpu_counter(%struct.timespec* %counters8, i32 %call)
  br label %do.body10

do.body10:                                        ; preds = %do.body10, %for.body6
  %call11 = call i32 @read_seqcount_begin(%struct.atomic_t* %3)
  %bcnt12 = getelementptr inbounds %struct.timespec, %struct.timespec* %call9, i32 0, i32 1
  %7 = load i64, i64* %bcnt12, align 8, !tbaa !99
  %pcnt13 = getelementptr inbounds %struct.timespec, %struct.timespec* %call9, i32 0, i32 0
  %8 = load i64, i64* %pcnt13, align 8, !tbaa !100
  %call15 = call i32 @read_seqcount_retry(%struct.atomic_t* %3, i32 %call11)
  %tobool = icmp ne i32 %call15, 0
  br i1 %tobool, label %do.body10, label %do.body17

do.body17:                                        ; preds = %do.body10
  %idxprom18 = zext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds %struct.timespec, %struct.timespec* %counters, i64 %idxprom18
  %bcnt20 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx19, i32 0, i32 1
  %9 = load i64, i64* %bcnt20, align 8, !tbaa !99
  %add21 = add i64 %9, %7
  store i64 %add21, i64* %bcnt20, align 8, !tbaa !99
  %idxprom22 = zext i32 %i.0 to i64
  %arrayidx23 = getelementptr inbounds %struct.timespec, %struct.timespec* %counters, i64 %idxprom22
  %pcnt24 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx23, i32 0, i32 0
  %10 = load i64, i64* %pcnt24, align 8, !tbaa !100
  %add25 = add i64 %10, %8
  store i64 %add25, i64* %pcnt24, align 8, !tbaa !100
  %inc = add i32 %i.0, 1
  %11 = bitcast %struct.ip6t_entry* %4 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %4, i32 0, i32 3
  %12 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv = zext i16 %12 to i32
  %idx.ext28 = sext i32 %conv to i64
  %add.ptr29 = getelementptr inbounds i8, i8* %11, i64 %idx.ext28
  br label %for.cond2

for.end:                                          ; preds = %for.cond2
  br label %for.cond

for.end30:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cpumask_next(i32 %n, %struct.cpumask* %srcp) #2 {
entry:
  %cmp = icmp ne i32 %n, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @cpumask_check(i32 %n)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %bits = getelementptr inbounds %struct.cpumask, %struct.cpumask* %srcp, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %bits, i32 0, i32 0
  %add = add nsw i32 %n, 1
  %conv = sext i32 %add to i64
  %call1 = call i64 @find_next_bit(i64* %arraydecay, i64 64, i64 %conv)
  %conv2 = trunc i64 %call1 to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.timespec* @xt_get_per_cpu_counter(%struct.timespec* %cnt, i32 %cpu) #2 {
entry:
  %0 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !75
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %do.end, label %return

do.end:                                           ; preds = %entry
  %pcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %cnt, i32 0, i32 0
  %1 = load i64, i64* %pcnt, align 8, !tbaa !100
  %2 = inttoptr i64 %1 to i8*
  %3 = call i64 asm "", "=r,0,~{dirflag},~{fpsr},~{flags}"(i8* %2) #3, !srcloc !101
  %idxprom = zext i32 %cpu to i64
  %arrayidx = getelementptr inbounds [64 x i64], [64 x i64]* @__per_cpu_offset, i64 0, i64 %idxprom
  %4 = load i64, i64* %arrayidx, align 8, !tbaa !98
  %add = add i64 %3, %4
  %5 = inttoptr i64 %add to i8*
  %6 = bitcast i8* %5 to %struct.timespec*
  br label %return

return:                                           ; preds = %do.end, %entry
  %retval.0 = phi %struct.timespec* [ %6, %do.end ], [ %cnt, %entry ]
  ret %struct.timespec* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @read_seqcount_begin(%struct.atomic_t* %s) #2 {
entry:
  %call = call i32 @raw_read_seqcount_begin(%struct.atomic_t* %s)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @read_seqcount_retry(%struct.atomic_t* %s, i32 %start) #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !102
  %call = call i32 @__read_seqcount_retry(%struct.atomic_t* %s, i32 %start)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__read_seqcount_retry(%struct.atomic_t* %s, i32 %start) #2 {
entry:
  %sequence = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %s, i32 0, i32 0
  %0 = load i32, i32* %sequence, align 4, !tbaa !103
  %cmp = icmp ne i32 %0, %start
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @raw_read_seqcount_begin(%struct.atomic_t* %s) #2 {
entry:
  %call = call i32 @__read_seqcount_begin(%struct.atomic_t* %s)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !104
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__read_seqcount_begin(%struct.atomic_t* %s) #2 {
entry:
  %__u = alloca %struct.atomic_t, align 4
  br label %repeat

repeat:                                           ; preds = %if.then, %entry
  %0 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %sequence = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %s, i32 0, i32 0
  %1 = bitcast i32* %sequence to i8*
  %__c = bitcast %struct.atomic_t* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val = bitcast %struct.atomic_t* %__u to i32*
  %2 = load i32, i32* %__val, align 4, !tbaa !76
  %3 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #7
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %repeat
  call void @cpu_relax()
  br label %repeat

if.end:                                           ; preds = %repeat
  ret i32 %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__read_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load volatile i8, i8* %p, align 1, !tbaa !76
  store i8 %0, i8* %res, align 1, !tbaa !76
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %p to i16*
  %2 = load volatile i16, i16* %1, align 2, !tbaa !105
  %3 = bitcast i8* %res to i16*
  store i16 %2, i16* %3, align 2, !tbaa !105
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %p to i32*
  %5 = load volatile i32, i32* %4, align 4, !tbaa !75
  %6 = bitcast i8* %res to i32*
  store i32 %5, i32* %6, align 4, !tbaa !75
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %p to i64*
  %8 = load volatile i64, i64* %7, align 8, !tbaa !106
  %9 = bitcast i8* %res to i64*
  store i64 %8, i64* %9, align 8, !tbaa !106
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !107
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %res, i8* %p, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !108
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @cpu_relax() #5 {
entry:
  call void @rep_nop()
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @rep_nop() #5 {
entry:
  call void asm sideeffect "rep; nop", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !109
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cpumask_check(i32 %cpu) #2 {
entry:
  ret i32 %cpu
}

declare i64 @find_next_bit(i64*, i64, i64) #1

declare i8* @__memcpy(i8*, i8*, i64) #1

declare void @xt_compat_init_offsets(i8 zeroext, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @compat_calc_entry(%struct.ip6t_entry* %e, %struct.xt_table_info* %info, i8* %base, %struct.xt_table_info* %newinfo) #0 {
entry:
  %0 = bitcast %struct.ip6t_entry* %e to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %0 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %base to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %elems = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %add.ptr6.sink = phi i8* [ %add.ptr6, %for.body ], [ %arraydecay, %entry ]
  %off.0 = phi i32 [ 4, %entry ], [ %add, %for.body ]
  %1 = bitcast i8* %add.ptr6.sink to %struct.xt_entry_match*
  %2 = bitcast %struct.ip6t_entry* %e to i8*
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %3 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv1 = zext i16 %3 to i32
  %idx.ext = sext i32 %conv1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  %4 = bitcast i8* %add.ptr to %struct.xt_entry_match*
  %cmp = icmp ult %struct.xt_entry_match* %1, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %1, i32 0, i32 0
  %kernel = bitcast %union.anon.108* %u to %struct.anon.110*
  %match = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel, i32 0, i32 1
  %5 = load %struct.xt_match*, %struct.xt_match** %match, align 8, !tbaa !76
  %call = call i32 @xt_compat_match_offset(%struct.xt_match* %5)
  %add = add nsw i32 %off.0, %call
  %6 = bitcast %struct.xt_entry_match* %1 to i8*
  %u3 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %1, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u3 to i16*
  %7 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv4 = zext i16 %7 to i32
  %idx.ext5 = sext i32 %conv4 to i64
  %add.ptr6 = getelementptr inbounds i8, i8* %6, i64 %idx.ext5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call7 = call %struct.xt_entry_target* @ip6t_get_target_c(%struct.ip6t_entry* %e)
  %u8 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call7, i32 0, i32 0
  %kernel9 = bitcast %union.anon.99* %u8 to %struct.anon.101*
  %target = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel9, i32 0, i32 1
  %8 = load %struct.xt_target*, %struct.xt_target** %target, align 8, !tbaa !76
  %call10 = call i32 @xt_compat_target_offset(%struct.xt_target* %8)
  %add11 = add nsw i32 %off.0, %call10
  %size = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 0
  %9 = load i32, i32* %size, align 8, !tbaa !87
  %sub = sub i32 %9, %add11
  store i32 %sub, i32* %size, align 8, !tbaa !87
  %call12 = call i32 @xt_compat_add_offset(i8 zeroext 10, i32 %conv, i32 %add11)
  %tobool = icmp ne i32 %call12, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %for.end
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc48, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc48 ]
  %cmp14 = icmp slt i32 %i.0, 5
  br i1 %cmp14, label %for.body16, label %cleanup

for.body16:                                       ; preds = %for.cond13
  %hook_entry = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 3
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom
  %10 = load i32, i32* %arrayidx, align 4, !tbaa !75
  %tobool17 = icmp ne i32 %10, 0
  br i1 %tobool17, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %for.body16
  %hook_entry18 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 3
  %idxprom19 = sext i32 %i.0 to i64
  %arrayidx20 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry18, i64 0, i64 %idxprom19
  %11 = load i32, i32* %arrayidx20, align 4, !tbaa !75
  %idx.ext21 = zext i32 %11 to i64
  %add.ptr22 = getelementptr i8, i8* %base, i64 %idx.ext21
  %12 = bitcast i8* %add.ptr22 to %struct.ip6t_entry*
  %cmp23 = icmp ult %struct.ip6t_entry* %e, %12
  br i1 %cmp23, label %if.then25, label %if.end30

if.then25:                                        ; preds = %land.lhs.true
  %hook_entry26 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 3
  %idxprom27 = sext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry26, i64 0, i64 %idxprom27
  %13 = load i32, i32* %arrayidx28, align 4, !tbaa !75
  %sub29 = sub i32 %13, %add11
  store i32 %sub29, i32* %arrayidx28, align 4, !tbaa !75
  br label %if.end30

if.end30:                                         ; preds = %if.then25, %land.lhs.true, %for.body16
  %underflow = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 4
  %idxprom31 = sext i32 %i.0 to i64
  %arrayidx32 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i64 0, i64 %idxprom31
  %14 = load i32, i32* %arrayidx32, align 4, !tbaa !75
  %tobool33 = icmp ne i32 %14, 0
  br i1 %tobool33, label %land.lhs.true34, label %for.inc48

land.lhs.true34:                                  ; preds = %if.end30
  %underflow35 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %info, i32 0, i32 4
  %idxprom36 = sext i32 %i.0 to i64
  %arrayidx37 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow35, i64 0, i64 %idxprom36
  %15 = load i32, i32* %arrayidx37, align 4, !tbaa !75
  %idx.ext38 = zext i32 %15 to i64
  %add.ptr39 = getelementptr i8, i8* %base, i64 %idx.ext38
  %16 = bitcast i8* %add.ptr39 to %struct.ip6t_entry*
  %cmp40 = icmp ult %struct.ip6t_entry* %e, %16
  br i1 %cmp40, label %if.then42, label %for.inc48

if.then42:                                        ; preds = %land.lhs.true34
  %underflow43 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 4
  %idxprom44 = sext i32 %i.0 to i64
  %arrayidx45 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow43, i64 0, i64 %idxprom44
  %17 = load i32, i32* %arrayidx45, align 4, !tbaa !75
  %sub46 = sub i32 %17, %add11
  store i32 %sub46, i32* %arrayidx45, align 4, !tbaa !75
  br label %for.inc48

for.inc48:                                        ; preds = %if.then42, %land.lhs.true34, %if.end30
  %inc = add nsw i32 %i.0, 1
  br label %for.cond13

cleanup:                                          ; preds = %for.cond13, %for.end
  %retval.0 = phi i32 [ %call12, %for.end ], [ 0, %for.cond13 ]
  ret i32 %retval.0
}

declare i32 @xt_compat_match_offset(%struct.xt_match*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.xt_entry_target* @ip6t_get_target_c(%struct.ip6t_entry* %e) #2 {
entry:
  %call = call %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %e)
  ret %struct.xt_entry_target* %call
}

declare i32 @xt_compat_target_offset(%struct.xt_target*) #1

declare i32 @xt_compat_add_offset(i8 zeroext, i32, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @kasan_check_write(i8* %p, i32 %size) #2 {
entry:
  ret void
}

declare i64 @_copy_from_user(i8*, i8*, i32) #1

declare i32 @__request_module(i1 zeroext, i8*, ...) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #4

declare i8* @strcpy(i8*, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @read_pnet(%struct.possible_net_t* %pnet) #2 {
entry:
  %net = getelementptr inbounds %struct.possible_net_t, %struct.possible_net_t* %pnet, i32 0, i32 0
  %0 = load %struct.net*, %struct.net** %net, align 8, !tbaa !110
  ret %struct.net* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @get_entries(%struct.net* %net, %struct.ip6t_get_entries* %uptr, i32* %len) #0 {
entry:
  %get = alloca %struct.ip6t_get_entries, align 8
  %0 = bitcast %struct.ip6t_get_entries* %get to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0) #7
  %1 = load i32, i32* %len, align 4, !tbaa !75
  %conv = sext i32 %1 to i64
  %cmp = icmp ult i64 %conv, 40
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast %struct.ip6t_get_entries* %get to i8*
  %3 = bitcast %struct.ip6t_get_entries* %uptr to i8*
  %call = call i64 @copy_from_user(i8* %2, i8* %3, i64 40)
  %cmp2 = icmp ne i64 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %4 = load i32, i32* %len, align 4, !tbaa !75
  %conv6 = sext i32 %4 to i64
  %size = getelementptr inbounds %struct.ip6t_get_entries, %struct.ip6t_get_entries* %get, i32 0, i32 1
  %5 = load i32, i32* %size, align 8, !tbaa !112
  %conv7 = zext i32 %5 to i64
  %add = add i64 40, %conv7
  %cmp8 = icmp ne i64 %conv6, %add
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end5
  %name = getelementptr inbounds %struct.ip6t_get_entries, %struct.ip6t_get_entries* %get, i32 0, i32 0
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %name, i64 0, i64 31
  store i8 0, i8* %arrayidx, align 1, !tbaa !76
  %name12 = getelementptr inbounds %struct.ip6t_get_entries, %struct.ip6t_get_entries* %get, i32 0, i32 0
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name12, i32 0, i32 0
  %call13 = call %struct.xt_table* @xt_find_table_lock(%struct.net* %net, i8 zeroext 10, i8* %arraydecay)
  %tobool = icmp ne %struct.xt_table* %call13, null
  br i1 %tobool, label %if.then14, label %cleanup

if.then14:                                        ; preds = %if.end11
  %private15 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %call13, i32 0, i32 2
  %6 = load %struct.xt_table_info*, %struct.xt_table_info** %private15, align 8, !tbaa !79
  %size16 = getelementptr inbounds %struct.ip6t_get_entries, %struct.ip6t_get_entries* %get, i32 0, i32 1
  %7 = load i32, i32* %size16, align 8, !tbaa !112
  %size17 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 0
  %8 = load i32, i32* %size17, align 8, !tbaa !87
  %cmp18 = icmp eq i32 %7, %8
  br i1 %cmp18, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.then14
  %size21 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 0
  %9 = load i32, i32* %size21, align 8, !tbaa !87
  %entrytable = getelementptr inbounds %struct.ip6t_get_entries, %struct.ip6t_get_entries* %uptr, i32 0, i32 2
  %arraydecay22 = getelementptr inbounds [0 x %struct.ip6t_entry], [0 x %struct.ip6t_entry]* %entrytable, i32 0, i32 0
  %10 = bitcast %struct.ip6t_entry* %arraydecay22 to i8*
  %call23 = call i32 @copy_entries_to_user(i32 %9, %struct.xt_table* %call13, i8* %10)
  br label %if.end24

if.end24:                                         ; preds = %if.then20, %if.then14
  %ret.0 = phi i32 [ %call23, %if.then20 ], [ -11, %if.then14 ]
  %me = getelementptr inbounds %struct.xt_table, %struct.xt_table* %call13, i32 0, i32 3
  %11 = load %struct.module*, %struct.module** %me, align 8, !tbaa !89
  call void @module_put(%struct.module* %11)
  call void @xt_table_unlock(%struct.xt_table* %call13)
  br label %cleanup

cleanup:                                          ; preds = %if.end24, %if.end11, %if.end5, %if.end, %entry
  %retval.0 = phi i32 [ -22, %entry ], [ -14, %if.end ], [ -22, %if.end5 ], [ %ret.0, %if.end24 ], [ -2, %if.end11 ]
  %12 = bitcast %struct.ip6t_get_entries* %get to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %12) #7
  ret i32 %retval.0
}

declare i32 @xt_find_revision(i8 zeroext, i8*, i8 zeroext, i32, i32*) #1

; Function Attrs: nounwind uwtable
define internal i32 @copy_entries_to_user(i32 %total_size, %struct.xt_table* %table, i8* %userptr) #0 {
entry:
  %private1 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %table, i32 0, i32 2
  %0 = load %struct.xt_table_info*, %struct.xt_table_info** %private1, align 8, !tbaa !79
  %call = call %struct.timespec* @alloc_counters(%struct.xt_table* %table)
  %1 = bitcast %struct.timespec* %call to i8*
  %call2 = call zeroext i1 @IS_ERR.2(i8* %1)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.timespec* %call to i8*
  %call3 = call i64 @PTR_ERR.3(i8* %2)
  %conv = trunc i64 %call3 to i32
  br label %cleanup51

if.end:                                           ; preds = %entry
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %0, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc47, %if.end
  %num.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc47 ]
  %off.0 = phi i32 [ 0, %if.end ], [ %add49, %for.inc47 ]
  %ret.0 = phi i32 [ 0, %if.end ], [ %ret.1, %for.inc47 ]
  %cmp = icmp ult i32 %off.0, %total_size
  br i1 %cmp, label %for.body, label %free_counters

for.body:                                         ; preds = %for.cond
  %idx.ext = zext i32 %off.0 to i64
  %add.ptr = getelementptr i8, i8* %arraydecay, i64 %idx.ext
  %3 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %idx.ext5 = zext i32 %off.0 to i64
  %add.ptr6 = getelementptr i8, i8* %userptr, i64 %idx.ext5
  %4 = bitcast %struct.ip6t_entry* %3 to i8*
  %call7 = call i64 @copy_to_user(i8* %add.ptr6, i8* %4, i64 168)
  %tobool = icmp ne i64 %call7, 0
  br i1 %tobool, label %cleanup, label %if.end9

if.end9:                                          ; preds = %for.body
  %idx.ext10 = zext i32 %off.0 to i64
  %add.ptr11 = getelementptr i8, i8* %userptr, i64 %idx.ext10
  %add.ptr12 = getelementptr i8, i8* %add.ptr11, i64 152
  %idxprom = zext i32 %num.0 to i64
  %arrayidx = getelementptr inbounds %struct.timespec, %struct.timespec* %call, i64 %idxprom
  %5 = bitcast %struct.timespec* %arrayidx to i8*
  %call13 = call i64 @copy_to_user(i8* %add.ptr12, i8* %5, i64 16)
  %cmp14 = icmp ne i64 %call13, 0
  br i1 %cmp14, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end9
  br label %for.cond18

for.cond18:                                       ; preds = %for.inc, %if.end17
  %i.0 = phi i32 [ 168, %if.end17 ], [ %add, %for.inc ]
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %3, i32 0, i32 2
  %6 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv19 = zext i16 %6 to i32
  %cmp20 = icmp ult i32 %i.0, %conv19
  br i1 %cmp20, label %for.body22, label %for.end

for.body22:                                       ; preds = %for.cond18
  %7 = bitcast %struct.ip6t_entry* %3 to i8*
  %idx.ext23 = zext i32 %i.0 to i64
  %add.ptr24 = getelementptr i8, i8* %7, i64 %idx.ext23
  %8 = bitcast i8* %add.ptr24 to %struct.xt_entry_match*
  %idx.ext25 = zext i32 %off.0 to i64
  %add.ptr26 = getelementptr i8, i8* %userptr, i64 %idx.ext25
  %idx.ext27 = zext i32 %i.0 to i64
  %add.ptr28 = getelementptr i8, i8* %add.ptr26, i64 %idx.ext27
  %9 = bitcast i8* %add.ptr28 to %struct.xt_entry_match*
  %call29 = call i32 @xt_match_to_user(%struct.xt_entry_match* %8, %struct.xt_entry_match* %9)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body22
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %8, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u to i16*
  %10 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv33 = zext i16 %10 to i32
  %add = add i32 %i.0, %conv33
  br label %for.cond18

for.end:                                          ; preds = %for.cond18
  %call34 = call %struct.xt_entry_target* @ip6t_get_target_c(%struct.ip6t_entry* %3)
  %idx.ext35 = zext i32 %off.0 to i64
  %add.ptr36 = getelementptr i8, i8* %userptr, i64 %idx.ext35
  %target_offset37 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %3, i32 0, i32 2
  %11 = load i16, i16* %target_offset37, align 4, !tbaa !94
  %conv38 = zext i16 %11 to i32
  %idx.ext39 = sext i32 %conv38 to i64
  %add.ptr40 = getelementptr i8, i8* %add.ptr36, i64 %idx.ext39
  %12 = bitcast i8* %add.ptr40 to %struct.xt_entry_target*
  %call41 = call i32 @xt_target_to_user(%struct.xt_entry_target* %call34, %struct.xt_entry_target* %12)
  %tobool42 = icmp ne i32 %call41, 0
  %.ret.0 = select i1 %tobool42, i32 -14, i32 %ret.0
  %. = select i1 %tobool42, i32 5, i32 0
  br label %cleanup

cleanup:                                          ; preds = %for.end, %for.body22, %if.end9, %for.body
  %ret.1 = phi i32 [ -14, %for.body ], [ -14, %if.end9 ], [ -14, %for.body22 ], [ %.ret.0, %for.end ]
  %cleanup.dest.slot.0 = phi i32 [ 5, %for.body ], [ 5, %if.end9 ], [ 5, %for.body22 ], [ %., %for.end ]
  br label %NodeBlock

NodeBlock:                                        ; preds = %cleanup
  %Pivot = icmp slt i32 %cleanup.dest.slot.0, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cleanup.dest.slot.0, 5
  br i1 %SwitchLeaf2, label %free_counters, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %SwitchLeaf, label %for.inc47, label %NewDefault

for.inc47:                                        ; preds = %LeafBlock
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %3, i32 0, i32 3
  %13 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv48 = zext i16 %13 to i32
  %add49 = add i32 %off.0, %conv48
  %inc = add i32 %num.0, 1
  br label %for.cond

free_counters:                                    ; preds = %LeafBlock1, %for.cond
  %ret.2 = phi i32 [ %ret.0, %for.cond ], [ %ret.1, %LeafBlock1 ]
  %14 = bitcast %struct.timespec* %call to i8*
  call void @vfree(i8* %14)
  br label %cleanup51

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %cleanup51

cleanup51:                                        ; preds = %NewDefault, %free_counters, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %ret.2, %free_counters ], [ undef, %NewDefault ]
  ret i32 %retval.0
}

declare i32 @xt_match_to_user(%struct.xt_entry_match*, %struct.xt_entry_match*) #1

declare i32 @xt_target_to_user(%struct.xt_entry_target*, %struct.xt_entry_target*) #1

; Function Attrs: nounwind uwtable
define internal i32 @compat_do_replace(%struct.net* %net, i8* %user, i32 %len) #0 {
entry:
  %tmp = alloca %struct.compat_ip6t_replace, align 4
  %newinfo = alloca %struct.xt_table_info*, align 8
  %loc_cpu_entry = alloca i8*, align 8
  %0 = bitcast %struct.compat_ip6t_replace* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 92, i8* %0) #7
  %1 = bitcast %struct.xt_table_info** %newinfo to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i8** %loc_cpu_entry to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast %struct.compat_ip6t_replace* %tmp to i8*
  %call = call i64 @copy_from_user(i8* %3, i8* %user, i64 92)
  %cmp = icmp ne i64 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %num_counters = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 6
  %4 = load i32, i32* %num_counters, align 4, !tbaa !114
  %conv = zext i32 %4 to i64
  %cmp1 = icmp uge i64 %conv, 134217727
  br i1 %cmp1, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %num_counters5 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 6
  %5 = load i32, i32* %num_counters5, align 4, !tbaa !114
  %cmp6 = icmp eq i32 %5, 0
  br i1 %cmp6, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end4
  %name = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 0
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %name, i64 0, i64 31
  store i8 0, i8* %arrayidx, align 1, !tbaa !76
  %size = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 3
  %6 = load i32, i32* %size, align 4, !tbaa !116
  %call10 = call %struct.xt_table_info* @xt_alloc_table_info(i32 %6)
  store %struct.xt_table_info* %call10, %struct.xt_table_info** %newinfo, align 8, !tbaa !2
  %7 = load %struct.xt_table_info*, %struct.xt_table_info** %newinfo, align 8, !tbaa !2
  %tobool = icmp ne %struct.xt_table_info* %7, null
  br i1 %tobool, label %if.end12, label %cleanup

if.end12:                                         ; preds = %if.end9
  %8 = load %struct.xt_table_info*, %struct.xt_table_info** %newinfo, align 8, !tbaa !2
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %8, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  store i8* %arraydecay, i8** %loc_cpu_entry, align 8, !tbaa !2
  %9 = load i8*, i8** %loc_cpu_entry, align 8, !tbaa !2
  %add.ptr = getelementptr i8, i8* %user, i64 92
  %size13 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 3
  %10 = load i32, i32* %size13, align 4, !tbaa !116
  %conv14 = zext i32 %10 to i64
  %call15 = call i64 @copy_from_user(i8* %9, i8* %add.ptr, i64 %conv14)
  %cmp16 = icmp ne i64 %call15, 0
  br i1 %cmp16, label %free_newinfo, label %if.end19

if.end19:                                         ; preds = %if.end12
  %call20 = call i32 @translate_compat_table(%struct.net* %net, %struct.xt_table_info** %newinfo, i8** %loc_cpu_entry, %struct.compat_ip6t_replace* %tmp)
  %cmp21 = icmp ne i32 %call20, 0
  br i1 %cmp21, label %free_newinfo, label %if.end24

if.end24:                                         ; preds = %if.end19
  %name25 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 0
  %arraydecay26 = getelementptr inbounds [32 x i8], [32 x i8]* %name25, i32 0, i32 0
  %valid_hooks = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 1
  %11 = load i32, i32* %valid_hooks, align 4, !tbaa !117
  %12 = load %struct.xt_table_info*, %struct.xt_table_info** %newinfo, align 8, !tbaa !2
  %num_counters27 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 6
  %13 = load i32, i32* %num_counters27, align 4, !tbaa !114
  %counters = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %tmp, i32 0, i32 7
  %14 = load i32, i32* %counters, align 4, !tbaa !118
  %call28 = call i8* @compat_ptr(i32 %14)
  %call29 = call i32 @__do_replace(%struct.net* %net, i8* %arraydecay26, i32 %11, %struct.xt_table_info* %12, i32 %13, i8* %call28)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %free_newinfo_untrans, label %cleanup

free_newinfo_untrans:                             ; preds = %if.end24
  %15 = load i8*, i8** %loc_cpu_entry, align 8, !tbaa !2
  br label %for.cond

for.cond:                                         ; preds = %for.body, %free_newinfo_untrans
  %add.ptr39.sink = phi i8* [ %add.ptr39, %for.body ], [ %15, %free_newinfo_untrans ]
  %16 = bitcast i8* %add.ptr39.sink to %struct.ip6t_entry*
  %17 = load i8*, i8** %loc_cpu_entry, align 8, !tbaa !2
  %18 = load %struct.xt_table_info*, %struct.xt_table_info** %newinfo, align 8, !tbaa !2
  %size33 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %18, i32 0, i32 0
  %19 = load i32, i32* %size33, align 8, !tbaa !87
  %idx.ext = zext i32 %19 to i64
  %add.ptr34 = getelementptr inbounds i8, i8* %17, i64 %idx.ext
  %20 = bitcast i8* %add.ptr34 to %struct.ip6t_entry*
  %cmp35 = icmp ult %struct.ip6t_entry* %16, %20
  br i1 %cmp35, label %for.body, label %free_newinfo

for.body:                                         ; preds = %for.cond
  call void @cleanup_entry(%struct.ip6t_entry* %16, %struct.net* %net)
  %21 = bitcast %struct.ip6t_entry* %16 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %16, i32 0, i32 3
  %22 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv37 = zext i16 %22 to i32
  %idx.ext38 = sext i32 %conv37 to i64
  %add.ptr39 = getelementptr inbounds i8, i8* %21, i64 %idx.ext38
  br label %for.cond

free_newinfo:                                     ; preds = %for.cond, %if.end19, %if.end12
  %ret.0 = phi i32 [ -14, %if.end12 ], [ %call20, %if.end19 ], [ %call29, %for.cond ]
  %23 = load %struct.xt_table_info*, %struct.xt_table_info** %newinfo, align 8, !tbaa !2
  call void @xt_free_table_info(%struct.xt_table_info* %23)
  br label %cleanup

cleanup:                                          ; preds = %free_newinfo, %if.end24, %if.end9, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %ret.0, %free_newinfo ], [ -14, %entry ], [ -12, %if.end ], [ -22, %if.end4 ], [ -12, %if.end9 ], [ 0, %if.end24 ]
  %24 = bitcast i8** %loc_cpu_entry to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #7
  %25 = bitcast %struct.xt_table_info** %newinfo to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %25) #7
  %26 = bitcast %struct.compat_ip6t_replace* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 92, i8* %26) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @do_add_counters(%struct.net* %net, i8* %user, i32 %len, i32 %compat) #0 {
entry:
  %tmp = alloca %struct.xt_counters_info, align 8
  %0 = bitcast %struct.xt_counters_info* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %0) #7
  %tobool = icmp ne i32 %compat, 0
  %call = call i8* @xt_copy_counters_from_user(i8* %user, i32 %len, %struct.xt_counters_info* %tmp, i1 zeroext %tobool)
  %1 = bitcast i8* %call to %struct.timespec*
  %2 = bitcast %struct.timespec* %1 to i8*
  %call1 = call zeroext i1 @IS_ERR.2(i8* %2)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = bitcast %struct.timespec* %1 to i8*
  %call2 = call i64 @PTR_ERR.3(i8* %3)
  %conv = trunc i64 %call2 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %name = getelementptr inbounds %struct.xt_counters_info, %struct.xt_counters_info* %tmp, i32 0, i32 0
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %call3 = call %struct.xt_table* @xt_find_table_lock(%struct.net* %net, i8 zeroext 10, i8* %arraydecay)
  %tobool4 = icmp ne %struct.xt_table* %call3, null
  br i1 %tobool4, label %if.end6, label %free

if.end6:                                          ; preds = %if.end
  call void @local_bh_disable()
  %private7 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %call3, i32 0, i32 2
  %4 = load %struct.xt_table_info*, %struct.xt_table_info** %private7, align 8, !tbaa !79
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %4, i32 0, i32 1
  %5 = load i32, i32* %number, align 4, !tbaa !84
  %num_counters = getelementptr inbounds %struct.xt_counters_info, %struct.xt_counters_info* %tmp, i32 0, i32 1
  %6 = load i32, i32* %num_counters, align 8, !tbaa !119
  %cmp = icmp ne i32 %5, %6
  br i1 %cmp, label %unlock_up_free, label %if.end10

if.end10:                                         ; preds = %if.end6
  %call11 = call i32 @xt_write_recseq_begin()
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %4, i32 0, i32 7
  %arraydecay12 = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end10
  %add.ptr26.sink = phi i8* [ %add.ptr26, %for.body ], [ %arraydecay12, %if.end10 ]
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.body ]
  %7 = bitcast i8* %add.ptr26.sink to %struct.ip6t_entry*
  %entries13 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %4, i32 0, i32 7
  %arraydecay14 = getelementptr inbounds [0 x i8], [0 x i8]* %entries13, i32 0, i32 0
  %size = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %4, i32 0, i32 0
  %8 = load i32, i32* %size, align 8, !tbaa !87
  %idx.ext = zext i32 %8 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay14, i64 %idx.ext
  %9 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %cmp15 = icmp ult %struct.ip6t_entry* %7, %9
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %counters = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %7, i32 0, i32 5
  %call18 = call %struct.timespec* @xt_get_this_cpu_counter(%struct.timespec* %counters)
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.timespec, %struct.timespec* %1, i64 %idxprom
  %bcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx, i32 0, i32 1
  %10 = load i64, i64* %bcnt, align 8, !tbaa !99
  %bcnt19 = getelementptr inbounds %struct.timespec, %struct.timespec* %call18, i32 0, i32 1
  %11 = load i64, i64* %bcnt19, align 8, !tbaa !99
  %add = add i64 %11, %10
  store i64 %add, i64* %bcnt19, align 8, !tbaa !99
  %idxprom20 = zext i32 %i.0 to i64
  %arrayidx21 = getelementptr inbounds %struct.timespec, %struct.timespec* %1, i64 %idxprom20
  %pcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx21, i32 0, i32 0
  %12 = load i64, i64* %pcnt, align 8, !tbaa !100
  %pcnt22 = getelementptr inbounds %struct.timespec, %struct.timespec* %call18, i32 0, i32 0
  %13 = load i64, i64* %pcnt22, align 8, !tbaa !100
  %add23 = add i64 %13, %12
  store i64 %add23, i64* %pcnt22, align 8, !tbaa !100
  %inc = add i32 %i.0, 1
  %14 = bitcast %struct.ip6t_entry* %7 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %7, i32 0, i32 3
  %15 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv24 = zext i16 %15 to i32
  %idx.ext25 = sext i32 %conv24 to i64
  %add.ptr26 = getelementptr inbounds i8, i8* %14, i64 %idx.ext25
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @xt_write_recseq_end(i32 %call11)
  br label %unlock_up_free

unlock_up_free:                                   ; preds = %for.end, %if.end6
  %ret.0 = phi i32 [ 0, %for.end ], [ -22, %if.end6 ]
  call void @local_bh_enable()
  call void @xt_table_unlock(%struct.xt_table* %call3)
  %me = getelementptr inbounds %struct.xt_table, %struct.xt_table* %call3, i32 0, i32 3
  %16 = load %struct.module*, %struct.module** %me, align 8, !tbaa !89
  call void @module_put(%struct.module* %16)
  br label %free

free:                                             ; preds = %unlock_up_free, %if.end
  %ret.1 = phi i32 [ %ret.0, %unlock_up_free ], [ -2, %if.end ]
  %17 = bitcast %struct.timespec* %1 to i8*
  call void @vfree(i8* %17)
  br label %cleanup

cleanup:                                          ; preds = %free, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %ret.1, %free ]
  %18 = bitcast %struct.xt_counters_info* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %18) #7
  ret i32 %retval.0
}

declare i8* @xt_copy_counters_from_user(i8*, i32, %struct.xt_counters_info*, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @local_bh_disable() #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @__local_bh_disable_ip(i64 ptrtoint (i8* blockaddress(@local_bh_disable, %__here) to i64), i32 512)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xt_write_recseq_begin() #2 {
entry:
  call void @__this_cpu_preempt_check(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0))
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @xt_recseq, i32 0, i32 0)) #8, !srcloc !121
  %add = add i32 %0, 1
  %and = and i32 %add, 1
  call void @__this_cpu_preempt_check(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0))
  call void asm "addl $1, %gs:$0", "=*m,ri,*m,~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @xt_recseq, i32 0, i32 0), i32 %and, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @xt_recseq, i32 0, i32 0)) #7, !srcloc !122
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !123
  ret i32 %and
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.timespec* @xt_get_this_cpu_counter(%struct.timespec* %cnt) #2 {
entry:
  %0 = load i32, i32* @nr_cpu_ids, align 4, !tbaa !75
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %do.end, label %return

do.end:                                           ; preds = %entry
  %pcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %cnt, i32 0, i32 0
  %1 = load i64, i64* %pcnt, align 8, !tbaa !100
  %2 = inttoptr i64 %1 to i8*
  %3 = call i64 asm sideeffect "add %gs:$1, $0", "=r,*m,0,~{dirflag},~{fpsr},~{flags}"(i64* @this_cpu_off, i8* %2) #7, !srcloc !124
  %4 = inttoptr i64 %3 to i8*
  %5 = bitcast i8* %4 to %struct.timespec*
  br label %return

return:                                           ; preds = %do.end, %entry
  %retval.0 = phi %struct.timespec* [ %5, %do.end ], [ %cnt, %entry ]
  ret %struct.timespec* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xt_write_recseq_end(i32 %addend) #2 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !125
  call void @__this_cpu_preempt_check(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0))
  call void asm "addl $1, %gs:$0", "=*m,ri,*m,~{dirflag},~{fpsr},~{flags}"(i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @xt_recseq, i32 0, i32 0), i32 %addend, i32* getelementptr inbounds (%struct.atomic_t, %struct.atomic_t* @xt_recseq, i32 0, i32 0)) #7, !srcloc !126
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @local_bh_enable() #2 {
entry:
  br label %__here

__here:                                           ; preds = %entry
  call void @__local_bh_enable_ip(i64 ptrtoint (i8* blockaddress(@local_bh_enable, %__here) to i64), i32 512)
  ret void
}

declare void @__local_bh_enable_ip(i64, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__this_cpu_preempt_check(i8* %op) #2 {
entry:
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__local_bh_disable_ip(i64 %ip, i32 %cnt) #5 {
entry:
  call void @__preempt_count_add(i32 %cnt)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !127
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__preempt_count_add(i32 %val) #5 {
entry:
  call void asm "addl $1, %gs:$0", "=*m,ri,*m,~{dirflag},~{fpsr},~{flags}"(i32* @__preempt_count, i32 %val, i32* @__preempt_count) #7, !srcloc !128
  ret void
}

declare %struct.xt_table_info* @xt_alloc_table_info(i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @translate_compat_table(%struct.net* %net, %struct.xt_table_info** %pinfo, i8** %pentry0, %struct.compat_ip6t_replace* %compatr) #0 {
entry:
  %pos = alloca i8*, align 8
  %repl = alloca %struct.ip6t_replace, align 8
  %size = alloca i32, align 4
  %0 = bitcast i8** %pos to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.ip6t_replace* %repl to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* %1) #7
  %2 = bitcast i32* %size to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %3 = load %struct.xt_table_info*, %struct.xt_table_info** %pinfo, align 8, !tbaa !2
  %4 = load i8*, i8** %pentry0, align 8, !tbaa !2
  %size1 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 3
  %5 = load i32, i32* %size1, align 4, !tbaa !116
  store i32 %5, i32* %size, align 4, !tbaa !75
  %num_entries = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 2
  %6 = load i32, i32* %num_entries, align 4, !tbaa !129
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %3, i32 0, i32 1
  store i32 %6, i32* %number, align 4, !tbaa !84
  call void @xt_compat_lock(i8 zeroext 10)
  %num_entries2 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 2
  %7 = load i32, i32* %num_entries2, align 4, !tbaa !129
  call void @xt_compat_init_offsets(i8 zeroext 10, i32 %7)
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %add.ptr9.sink = phi i8* [ %add.ptr9, %if.end ], [ %4, %entry ]
  %j.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %8 = bitcast i8* %add.ptr9.sink to %struct.compat_ip6t_entry*
  %size3 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 3
  %9 = load i32, i32* %size3, align 4, !tbaa !116
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %10 = bitcast i8* %add.ptr to %struct.compat_ip6t_entry*
  %cmp = icmp ult %struct.compat_ip6t_entry* %8, %10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %size4 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 3
  %11 = load i32, i32* %size4, align 4, !tbaa !116
  %idx.ext5 = zext i32 %11 to i64
  %add.ptr6 = getelementptr i8, i8* %4, i64 %idx.ext5
  %call = call i32 @check_compat_entry_size_and_hooks(%struct.compat_ip6t_entry* %8, %struct.xt_table_info* %3, i32* %size, i8* %4, i8* %add.ptr6)
  %cmp7 = icmp ne i32 %call, 0
  br i1 %cmp7, label %out_unlock, label %if.end

if.end:                                           ; preds = %for.body
  %inc = add i32 %j.0, 1
  %12 = bitcast %struct.compat_ip6t_entry* %8 to i8*
  %next_offset = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %8, i32 0, i32 3
  %13 = load i16, i16* %next_offset, align 2, !tbaa !130
  %conv = zext i16 %13 to i32
  %idx.ext8 = sext i32 %conv to i64
  %add.ptr9 = getelementptr inbounds i8, i8* %12, i64 %idx.ext8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %num_entries10 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 2
  %14 = load i32, i32* %num_entries10, align 4, !tbaa !129
  %cmp11 = icmp ne i32 %j.0, %14
  br i1 %cmp11, label %out_unlock, label %if.end14

if.end14:                                         ; preds = %for.end
  %15 = load i32, i32* %size, align 4, !tbaa !75
  %call15 = call %struct.xt_table_info* @xt_alloc_table_info(i32 %15)
  %tobool = icmp ne %struct.xt_table_info* %call15, null
  br i1 %tobool, label %if.end17, label %out_unlock

if.end17:                                         ; preds = %if.end14
  %num_entries18 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 2
  %16 = load i32, i32* %num_entries18, align 4, !tbaa !129
  %number19 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call15, i32 0, i32 1
  store i32 %16, i32* %number19, align 4, !tbaa !84
  br label %for.cond20

for.cond20:                                       ; preds = %for.body23, %if.end17
  %i.0 = phi i32 [ 0, %if.end17 ], [ %inc33, %for.body23 ]
  %cmp21 = icmp ult i32 %i.0, 5
  br i1 %cmp21, label %for.body23, label %for.end34

for.body23:                                       ; preds = %for.cond20
  %hook_entry = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 4
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom
  %17 = load i32, i32* %arrayidx, align 4, !tbaa !75
  %hook_entry24 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call15, i32 0, i32 3
  %idxprom25 = zext i32 %i.0 to i64
  %arrayidx26 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry24, i64 0, i64 %idxprom25
  store i32 %17, i32* %arrayidx26, align 4, !tbaa !75
  %underflow = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 5
  %idxprom27 = zext i32 %i.0 to i64
  %arrayidx28 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i64 0, i64 %idxprom27
  %18 = load i32, i32* %arrayidx28, align 4, !tbaa !75
  %underflow29 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call15, i32 0, i32 4
  %idxprom30 = zext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow29, i64 0, i64 %idxprom30
  store i32 %18, i32* %arrayidx31, align 4, !tbaa !75
  %inc33 = add i32 %i.0, 1
  br label %for.cond20

for.end34:                                        ; preds = %for.cond20
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call15, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  store i8* %arraydecay, i8** %pos, align 8, !tbaa !2
  %size35 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 3
  %19 = load i32, i32* %size35, align 4, !tbaa !116
  store i32 %19, i32* %size, align 4, !tbaa !75
  br label %for.cond36

for.cond36:                                       ; preds = %for.body42, %for.end34
  %add.ptr47.sink = phi i8* [ %add.ptr47, %for.body42 ], [ %4, %for.end34 ]
  %20 = bitcast i8* %add.ptr47.sink to %struct.compat_ip6t_entry*
  %size37 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 3
  %21 = load i32, i32* %size37, align 4, !tbaa !116
  %idx.ext38 = zext i32 %21 to i64
  %add.ptr39 = getelementptr inbounds i8, i8* %4, i64 %idx.ext38
  %22 = bitcast i8* %add.ptr39 to %struct.compat_ip6t_entry*
  %cmp40 = icmp ult %struct.compat_ip6t_entry* %20, %22
  br i1 %cmp40, label %for.body42, label %for.end48

for.body42:                                       ; preds = %for.cond36
  call void @compat_copy_entry_from_user(%struct.compat_ip6t_entry* %20, i8** %pos, i32* %size, %struct.xt_table_info* %call15, i8* %arraydecay)
  %23 = bitcast %struct.compat_ip6t_entry* %20 to i8*
  %next_offset44 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %20, i32 0, i32 3
  %24 = load i16, i16* %next_offset44, align 2, !tbaa !130
  %conv45 = zext i16 %24 to i32
  %idx.ext46 = sext i32 %conv45 to i64
  %add.ptr47 = getelementptr inbounds i8, i8* %23, i64 %idx.ext46
  br label %for.cond36

for.end48:                                        ; preds = %for.cond36
  call void @xt_compat_flush_offsets(i8 zeroext 10)
  call void @xt_compat_unlock(i8 zeroext 10)
  %cmp49 = icmp uge i64 92, 64
  %25 = bitcast %struct.ip6t_replace* %repl to i8*
  %26 = bitcast %struct.compat_ip6t_replace* %compatr to i8*
  br i1 %cmp49, label %if.then51, label %if.else

if.then51:                                        ; preds = %for.end48
  %call52 = call i8* @__memcpy(i8* %25, i8* %26, i64 92)
  br label %if.end53

if.else:                                          ; preds = %for.end48
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %25, i8* %26, i64 92, i32 4, i1 false)
  br label %if.end53

if.end53:                                         ; preds = %if.else, %if.then51
  %__ret.0 = phi i8* [ %call52, %if.then51 ], [ %25, %if.else ]
  br label %for.cond54

for.cond54:                                       ; preds = %for.body57, %if.end53
  %i.1 = phi i32 [ 0, %if.end53 ], [ %inc71, %for.body57 ]
  %cmp55 = icmp ult i32 %i.1, 5
  br i1 %cmp55, label %for.body57, label %for.end72

for.body57:                                       ; preds = %for.cond54
  %hook_entry58 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call15, i32 0, i32 3
  %idxprom59 = zext i32 %i.1 to i64
  %arrayidx60 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry58, i64 0, i64 %idxprom59
  %27 = load i32, i32* %arrayidx60, align 4, !tbaa !75
  %hook_entry61 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 4
  %idxprom62 = zext i32 %i.1 to i64
  %arrayidx63 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry61, i64 0, i64 %idxprom62
  store i32 %27, i32* %arrayidx63, align 4, !tbaa !75
  %underflow64 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call15, i32 0, i32 4
  %idxprom65 = zext i32 %i.1 to i64
  %arrayidx66 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow64, i64 0, i64 %idxprom65
  %28 = load i32, i32* %arrayidx66, align 4, !tbaa !75
  %underflow67 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 5
  %idxprom68 = zext i32 %i.1 to i64
  %arrayidx69 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow67, i64 0, i64 %idxprom68
  store i32 %28, i32* %arrayidx69, align 4, !tbaa !75
  %inc71 = add i32 %i.1, 1
  br label %for.cond54

for.end72:                                        ; preds = %for.cond54
  %num_counters = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 6
  store i32 0, i32* %num_counters, align 4, !tbaa !133
  %counters = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 7
  store %struct.timespec* null, %struct.timespec** %counters, align 8, !tbaa !135
  %size73 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call15, i32 0, i32 0
  %29 = load i32, i32* %size73, align 8, !tbaa !87
  %size74 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 3
  store i32 %29, i32* %size74, align 8, !tbaa !136
  %call75 = call i32 @translate_table(%struct.net* %net, %struct.xt_table_info* %call15, i8* %arraydecay, %struct.ip6t_replace* %repl)
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %free_newinfo, label %if.end78

if.end78:                                         ; preds = %for.end72
  store %struct.xt_table_info* %call15, %struct.xt_table_info** %pinfo, align 8, !tbaa !2
  store i8* %arraydecay, i8** %pentry0, align 8, !tbaa !2
  call void @xt_free_table_info(%struct.xt_table_info* %3)
  br label %cleanup

free_newinfo:                                     ; preds = %for.end72
  call void @xt_free_table_info(%struct.xt_table_info* %call15)
  br label %cleanup

out_unlock:                                       ; preds = %if.end14, %for.end, %for.body
  %ret.0 = phi i32 [ %call, %for.body ], [ -22, %for.end ], [ -12, %if.end14 ]
  call void @xt_compat_flush_offsets(i8 zeroext 10)
  call void @xt_compat_unlock(i8 zeroext 10)
  br label %for.cond79

for.cond79:                                       ; preds = %if.end89, %out_unlock
  %add.ptr94.sink = phi i8* [ %add.ptr94, %if.end89 ], [ %4, %out_unlock ]
  %j.1 = phi i32 [ %j.0, %out_unlock ], [ %dec, %if.end89 ]
  %30 = bitcast i8* %add.ptr94.sink to %struct.compat_ip6t_entry*
  %size80 = getelementptr inbounds %struct.compat_ip6t_replace, %struct.compat_ip6t_replace* %compatr, i32 0, i32 3
  %31 = load i32, i32* %size80, align 4, !tbaa !116
  %idx.ext81 = zext i32 %31 to i64
  %add.ptr82 = getelementptr inbounds i8, i8* %4, i64 %idx.ext81
  %32 = bitcast i8* %add.ptr82 to %struct.compat_ip6t_entry*
  %cmp83 = icmp ult %struct.compat_ip6t_entry* %30, %32
  br i1 %cmp83, label %for.body85, label %cleanup

for.body85:                                       ; preds = %for.cond79
  %dec = add i32 %j.1, -1
  %cmp86 = icmp eq i32 %j.1, 0
  br i1 %cmp86, label %cleanup, label %if.end89

if.end89:                                         ; preds = %for.body85
  call void @compat_release_entry(%struct.compat_ip6t_entry* %30)
  %33 = bitcast %struct.compat_ip6t_entry* %30 to i8*
  %next_offset91 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %30, i32 0, i32 3
  %34 = load i16, i16* %next_offset91, align 2, !tbaa !130
  %conv92 = zext i16 %34 to i32
  %idx.ext93 = sext i32 %conv92 to i64
  %add.ptr94 = getelementptr inbounds i8, i8* %33, i64 %idx.ext93
  br label %for.cond79

cleanup:                                          ; preds = %for.body85, %for.cond79, %free_newinfo, %if.end78
  %retval.0 = phi i32 [ %call75, %free_newinfo ], [ 0, %if.end78 ], [ %ret.0, %for.cond79 ], [ %ret.0, %for.body85 ]
  %35 = bitcast i32* %size to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %35) #7
  %36 = bitcast %struct.ip6t_replace* %repl to i8*
  call void @llvm.lifetime.end.p0i8(i64 96, i8* %36) #7
  %37 = bitcast i8** %pos to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %37) #7
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @compat_ptr(i32 %uptr) #2 {
entry:
  %conv = zext i32 %uptr to i64
  %0 = inttoptr i64 %conv to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @__do_replace(%struct.net* %net, i8* %name, i32 %valid_hooks, %struct.xt_table_info* %newinfo, i32 %num_counters, i8* %counters_ptr) #0 {
entry:
  %ret = alloca i32, align 4
  %0 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 0, i32* %ret, align 4, !tbaa !75
  %conv = zext i32 %num_counters to i64
  %mul = mul i64 %conv, 16
  %call = call i8* @vzalloc(i64 %mul)
  %1 = bitcast i8* %call to %struct.timespec*
  %tobool = icmp ne %struct.timespec* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -12, i32* %ret, align 4, !tbaa !75
  br label %out

if.end:                                           ; preds = %entry
  %call1 = call %struct.xt_table* @xt_find_table_lock(%struct.net* %net, i8 zeroext 10, i8* %name)
  %tobool2 = icmp ne %struct.xt_table* %call1, null
  br i1 %tobool2, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  %call3 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.9, i32 0, i32 0), i8* %name)
  %call4 = call %struct.xt_table* @xt_find_table_lock(%struct.net* %net, i8 zeroext 10, i8* %name)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end
  %cond = phi %struct.xt_table* [ %call4, %cond.false ], [ %call1, %if.end ]
  %tobool5 = icmp ne %struct.xt_table* %cond, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %cond.end
  store i32 -2, i32* %ret, align 4, !tbaa !75
  br label %free_newinfo_counters_untrans

if.end7:                                          ; preds = %cond.end
  %valid_hooks8 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %cond, i32 0, i32 1
  %2 = load i32, i32* %valid_hooks8, align 8, !tbaa !81
  %cmp = icmp ne i32 %valid_hooks, %2
  br i1 %cmp, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  store i32 -22, i32* %ret, align 4, !tbaa !75
  br label %put_module

if.end11:                                         ; preds = %if.end7
  %call12 = call %struct.xt_table_info* @xt_replace_table(%struct.xt_table* %cond, i32 %num_counters, %struct.xt_table_info* %newinfo, i32* %ret)
  %tobool13 = icmp ne %struct.xt_table_info* %call12, null
  br i1 %tobool13, label %if.end15, label %put_module

if.end15:                                         ; preds = %if.end11
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 1
  %3 = load i32, i32* %number, align 4, !tbaa !84
  %initial_entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 2
  %4 = load i32, i32* %initial_entries, align 8, !tbaa !92
  %cmp16 = icmp ugt i32 %3, %4
  br i1 %cmp16, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end15
  %number18 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 1
  %5 = load i32, i32* %number18, align 4, !tbaa !84
  %initial_entries19 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 2
  %6 = load i32, i32* %initial_entries19, align 8, !tbaa !92
  %cmp20 = icmp ule i32 %5, %6
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %lor.lhs.false, %if.end15
  %me = getelementptr inbounds %struct.xt_table, %struct.xt_table* %cond, i32 0, i32 3
  %7 = load %struct.module*, %struct.module** %me, align 8, !tbaa !89
  call void @module_put(%struct.module* %7)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %lor.lhs.false
  %number24 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 1
  %8 = load i32, i32* %number24, align 4, !tbaa !84
  %initial_entries25 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 2
  %9 = load i32, i32* %initial_entries25, align 8, !tbaa !92
  %cmp26 = icmp ugt i32 %8, %9
  br i1 %cmp26, label %land.lhs.true, label %if.end34

land.lhs.true:                                    ; preds = %if.end23
  %number28 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 1
  %10 = load i32, i32* %number28, align 4, !tbaa !84
  %initial_entries29 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 2
  %11 = load i32, i32* %initial_entries29, align 8, !tbaa !92
  %cmp30 = icmp ule i32 %10, %11
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %land.lhs.true
  %me33 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %cond, i32 0, i32 3
  %12 = load %struct.module*, %struct.module** %me33, align 8, !tbaa !89
  call void @module_put(%struct.module* %12)
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %land.lhs.true, %if.end23
  call void @get_counters(%struct.xt_table_info* %call12, %struct.timespec* %1)
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end34
  %add.ptr41.sink = phi i8* [ %add.ptr41, %for.body ], [ %arraydecay, %if.end34 ]
  %13 = bitcast i8* %add.ptr41.sink to %struct.ip6t_entry*
  %entries35 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 7
  %arraydecay36 = getelementptr inbounds [0 x i8], [0 x i8]* %entries35, i32 0, i32 0
  %size = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call12, i32 0, i32 0
  %14 = load i32, i32* %size, align 8, !tbaa !87
  %idx.ext = zext i32 %14 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay36, i64 %idx.ext
  %15 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %cmp37 = icmp ult %struct.ip6t_entry* %13, %15
  br i1 %cmp37, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @cleanup_entry(%struct.ip6t_entry* %13, %struct.net* %net)
  %16 = bitcast %struct.ip6t_entry* %13 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %13, i32 0, i32 3
  %17 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv39 = zext i16 %17 to i32
  %idx.ext40 = sext i32 %conv39 to i64
  %add.ptr41 = getelementptr inbounds i8, i8* %16, i64 %idx.ext40
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @xt_free_table_info(%struct.xt_table_info* %call12)
  %18 = bitcast %struct.timespec* %1 to i8*
  %conv42 = zext i32 %num_counters to i64
  %mul43 = mul i64 16, %conv42
  %call44 = call i64 @copy_to_user(i8* %counters_ptr, i8* %18, i64 %mul43)
  %cmp45 = icmp ne i64 %call44, 0
  br i1 %cmp45, label %do.body, label %if.end53

do.body:                                          ; preds = %for.end
  %call48 = call i32 @net_ratelimit()
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.then50, label %if.end53

if.then50:                                        ; preds = %do.body
  %call51 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([77 x i8], [77 x i8]* @.str.10, i32 0, i32 0))
  br label %if.end53

if.end53:                                         ; preds = %if.then50, %do.body, %for.end
  %19 = bitcast %struct.timespec* %1 to i8*
  call void @vfree(i8* %19)
  call void @xt_table_unlock(%struct.xt_table* %cond)
  %20 = load i32, i32* %ret, align 4, !tbaa !75
  br label %cleanup

put_module:                                       ; preds = %if.end11, %if.then10
  %me54 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %cond, i32 0, i32 3
  %21 = load %struct.module*, %struct.module** %me54, align 8, !tbaa !89
  call void @module_put(%struct.module* %21)
  call void @xt_table_unlock(%struct.xt_table* %cond)
  br label %free_newinfo_counters_untrans

free_newinfo_counters_untrans:                    ; preds = %put_module, %if.then6
  %22 = bitcast %struct.timespec* %1 to i8*
  call void @vfree(i8* %22)
  br label %out

out:                                              ; preds = %free_newinfo_counters_untrans, %if.then
  %23 = load i32, i32* %ret, align 4, !tbaa !75
  br label %cleanup

cleanup:                                          ; preds = %out, %if.end53
  %retval.0 = phi i32 [ %23, %out ], [ %20, %if.end53 ]
  %24 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %24) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @cleanup_entry(%struct.ip6t_entry* %e, %struct.net* %net) #0 {
entry:
  %par = alloca %struct.xt_tgdtor_param, align 8
  %0 = bitcast %struct.xt_tgdtor_param* %par to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %elems = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %add.ptr4.sink = phi i8* [ %add.ptr4, %for.body ], [ %arraydecay, %entry ]
  %1 = bitcast i8* %add.ptr4.sink to %struct.xt_entry_match*
  %2 = bitcast %struct.ip6t_entry* %e to i8*
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %3 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv = zext i16 %3 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  %4 = bitcast i8* %add.ptr to %struct.xt_entry_match*
  %cmp = icmp ult %struct.xt_entry_match* %1, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @cleanup_match(%struct.xt_entry_match* %1, %struct.net* %net)
  %5 = bitcast %struct.xt_entry_match* %1 to i8*
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %1, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u to i16*
  %6 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv2 = zext i16 %6 to i32
  %idx.ext3 = sext i32 %conv2 to i64
  %add.ptr4 = getelementptr inbounds i8, i8* %5, i64 %idx.ext3
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call = call %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %e)
  %net5 = getelementptr inbounds %struct.xt_tgdtor_param, %struct.xt_tgdtor_param* %par, i32 0, i32 0
  store %struct.net* %net, %struct.net** %net5, align 8, !tbaa !137
  %u6 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call, i32 0, i32 0
  %kernel = bitcast %union.anon.99* %u6 to %struct.anon.101*
  %target = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel, i32 0, i32 1
  %7 = load %struct.xt_target*, %struct.xt_target** %target, align 8, !tbaa !76
  %target7 = getelementptr inbounds %struct.xt_tgdtor_param, %struct.xt_tgdtor_param* %par, i32 0, i32 1
  store %struct.xt_target* %7, %struct.xt_target** %target7, align 8, !tbaa !139
  %data = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call, i32 0, i32 1
  %arraydecay8 = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  %targinfo = getelementptr inbounds %struct.xt_tgdtor_param, %struct.xt_tgdtor_param* %par, i32 0, i32 2
  store i8* %arraydecay8, i8** %targinfo, align 8, !tbaa !140
  %family = getelementptr inbounds %struct.xt_tgdtor_param, %struct.xt_tgdtor_param* %par, i32 0, i32 3
  store i8 10, i8* %family, align 8, !tbaa !141
  %target9 = getelementptr inbounds %struct.xt_tgdtor_param, %struct.xt_tgdtor_param* %par, i32 0, i32 1
  %8 = load %struct.xt_target*, %struct.xt_target** %target9, align 8, !tbaa !139
  %destroy = getelementptr inbounds %struct.xt_target, %struct.xt_target* %8, i32 0, i32 5
  %9 = load void (%struct.xt_tgdtor_param*)*, void (%struct.xt_tgdtor_param*)** %destroy, align 8, !tbaa !142
  %cmp10 = icmp ne void (%struct.xt_tgdtor_param*)* %9, null
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %target12 = getelementptr inbounds %struct.xt_tgdtor_param, %struct.xt_tgdtor_param* %par, i32 0, i32 1
  %10 = load %struct.xt_target*, %struct.xt_target** %target12, align 8, !tbaa !139
  %destroy13 = getelementptr inbounds %struct.xt_target, %struct.xt_target* %10, i32 0, i32 5
  %11 = load void (%struct.xt_tgdtor_param*)*, void (%struct.xt_tgdtor_param*)** %destroy13, align 8, !tbaa !142
  call void %11(%struct.xt_tgdtor_param* %par)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %target14 = getelementptr inbounds %struct.xt_tgdtor_param, %struct.xt_tgdtor_param* %par, i32 0, i32 1
  %12 = load %struct.xt_target*, %struct.xt_target** %target14, align 8, !tbaa !139
  %me = getelementptr inbounds %struct.xt_target, %struct.xt_target* %12, i32 0, i32 8
  %13 = load %struct.module*, %struct.module** %me, align 8, !tbaa !144
  call void @module_put(%struct.module* %13)
  %counters = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 5
  call void @xt_percpu_counter_free(%struct.timespec* %counters)
  %14 = bitcast %struct.xt_tgdtor_param* %par to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %14) #7
  ret void
}

declare void @xt_free_table_info(%struct.xt_table_info*) #1

; Function Attrs: nounwind uwtable
define internal void @cleanup_match(%struct.xt_entry_match* %m, %struct.net* %net) #0 {
entry:
  %par = alloca %struct.xt_mtdtor_param, align 8
  %0 = bitcast %struct.xt_mtdtor_param* %par to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %net1 = getelementptr inbounds %struct.xt_mtdtor_param, %struct.xt_mtdtor_param* %par, i32 0, i32 0
  store %struct.net* %net, %struct.net** %net1, align 8, !tbaa !145
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %kernel = bitcast %union.anon.108* %u to %struct.anon.110*
  %match = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel, i32 0, i32 1
  %1 = load %struct.xt_match*, %struct.xt_match** %match, align 8, !tbaa !76
  %match2 = getelementptr inbounds %struct.xt_mtdtor_param, %struct.xt_mtdtor_param* %par, i32 0, i32 1
  store %struct.xt_match* %1, %struct.xt_match** %match2, align 8, !tbaa !147
  %data = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  %matchinfo = getelementptr inbounds %struct.xt_mtdtor_param, %struct.xt_mtdtor_param* %par, i32 0, i32 2
  store i8* %arraydecay, i8** %matchinfo, align 8, !tbaa !148
  %family = getelementptr inbounds %struct.xt_mtdtor_param, %struct.xt_mtdtor_param* %par, i32 0, i32 3
  store i8 10, i8* %family, align 8, !tbaa !149
  %match3 = getelementptr inbounds %struct.xt_mtdtor_param, %struct.xt_mtdtor_param* %par, i32 0, i32 1
  %2 = load %struct.xt_match*, %struct.xt_match** %match3, align 8, !tbaa !147
  %destroy = getelementptr inbounds %struct.xt_match, %struct.xt_match* %2, i32 0, i32 5
  %3 = load void (%struct.xt_mtdtor_param*)*, void (%struct.xt_mtdtor_param*)** %destroy, align 8, !tbaa !150
  %cmp = icmp ne void (%struct.xt_mtdtor_param*)* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %match4 = getelementptr inbounds %struct.xt_mtdtor_param, %struct.xt_mtdtor_param* %par, i32 0, i32 1
  %4 = load %struct.xt_match*, %struct.xt_match** %match4, align 8, !tbaa !147
  %destroy5 = getelementptr inbounds %struct.xt_match, %struct.xt_match* %4, i32 0, i32 5
  %5 = load void (%struct.xt_mtdtor_param*)*, void (%struct.xt_mtdtor_param*)** %destroy5, align 8, !tbaa !150
  call void %5(%struct.xt_mtdtor_param* %par)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %match6 = getelementptr inbounds %struct.xt_mtdtor_param, %struct.xt_mtdtor_param* %par, i32 0, i32 1
  %6 = load %struct.xt_match*, %struct.xt_match** %match6, align 8, !tbaa !147
  %me = getelementptr inbounds %struct.xt_match, %struct.xt_match* %6, i32 0, i32 8
  %7 = load %struct.module*, %struct.module** %me, align 8, !tbaa !152
  call void @module_put(%struct.module* %7)
  %8 = bitcast %struct.xt_mtdtor_param* %par to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %8) #7
  ret void
}

declare void @xt_percpu_counter_free(%struct.timespec*) #1

declare %struct.xt_table_info* @xt_replace_table(%struct.xt_table*, i32, %struct.xt_table_info*, i32*) #1

declare i32 @net_ratelimit() #1

; Function Attrs: nounwind uwtable
define internal i32 @check_compat_entry_size_and_hooks(%struct.compat_ip6t_entry* %e, %struct.xt_table_info* %newinfo, i32* %size, i8* %base, i8* %limit) #0 {
entry:
  %off = alloca i32, align 4
  %0 = bitcast i32* %off to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = ptrtoint %struct.compat_ip6t_entry* %e to i64
  %rem = urem i64 %1, 4
  %cmp = icmp ne i64 %rem, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 164
  %cmp1 = icmp uge i8* %add.ptr, %limit
  br i1 %cmp1, label %cleanup, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %next_offset = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 3
  %4 = load i16, i16* %next_offset, align 2, !tbaa !130
  %conv = zext i16 %4 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 %idx.ext
  %cmp4 = icmp ugt i8* %add.ptr3, %limit
  br i1 %cmp4, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %next_offset6 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 3
  %5 = load i16, i16* %next_offset6, align 2, !tbaa !130
  %conv7 = zext i16 %5 to i64
  %cmp8 = icmp ult i64 %conv7, 196
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end
  %ipv6 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 0
  %call = call zeroext i1 @ip6_checkentry(%struct.ip6t_ip6* %ipv6)
  br i1 %call, label %if.end13, label %cleanup

if.end13:                                         ; preds = %if.end11
  %6 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %elems = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  %target_offset = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 2
  %7 = load i16, i16* %target_offset, align 4, !tbaa !153
  %conv14 = zext i16 %7 to i32
  %next_offset15 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 3
  %8 = load i16, i16* %next_offset15, align 2, !tbaa !130
  %conv16 = zext i16 %8 to i32
  %call17 = call i32 @xt_compat_check_entry_offsets(i8* %6, i8* %arraydecay, i32 %conv14, i32 %conv16)
  %tobool = icmp ne i32 %call17, 0
  br i1 %tobool, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end13
  store i32 4, i32* %off, align 4, !tbaa !75
  %9 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %9 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %base to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv20 = trunc i64 %sub.ptr.sub to i32
  %elems21 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 6
  %arraydecay22 = getelementptr inbounds [0 x i8], [0 x i8]* %elems21, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %if.end34, %if.end19
  %add.ptr37.sink = phi i8* [ %add.ptr37, %if.end34 ], [ %arraydecay22, %if.end19 ]
  %j.0 = phi i32 [ 0, %if.end19 ], [ %inc, %if.end34 ]
  %10 = bitcast i8* %add.ptr37.sink to %struct.xt_entry_match*
  %11 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %target_offset23 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 2
  %12 = load i16, i16* %target_offset23, align 4, !tbaa !153
  %conv24 = zext i16 %12 to i32
  %idx.ext25 = sext i32 %conv24 to i64
  %add.ptr26 = getelementptr inbounds i8, i8* %11, i64 %idx.ext25
  %13 = bitcast i8* %add.ptr26 to %struct.xt_entry_match*
  %cmp27 = icmp ult %struct.xt_entry_match* %10, %13
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ipv629 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 0
  %call30 = call i32 @compat_find_calc_match(%struct.xt_entry_match* %10, %struct.ip6t_ip6* %ipv629, i32* %off)
  %cmp31 = icmp ne i32 %call30, 0
  br i1 %cmp31, label %release_matches, label %if.end34

if.end34:                                         ; preds = %for.body
  %inc = add i32 %j.0, 1
  %14 = bitcast %struct.xt_entry_match* %10 to i8*
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %10, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u to i16*
  %15 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv35 = zext i16 %15 to i32
  %idx.ext36 = sext i32 %conv35 to i64
  %add.ptr37 = getelementptr inbounds i8, i8* %14, i64 %idx.ext36
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call38 = call %struct.xt_entry_target* @compat_ip6t_get_target(%struct.compat_ip6t_entry* %e)
  %u39 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call38, i32 0, i32 0
  %user = bitcast %union.anon.99* %u39 to %struct.anon.104*
  %name = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %arraydecay40 = getelementptr inbounds [29 x i8], [29 x i8]* %name, i32 0, i32 0
  %u41 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call38, i32 0, i32 0
  %user42 = bitcast %union.anon.99* %u41 to %struct.anon.104*
  %revision = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user42, i32 0, i32 2
  %16 = load i8, i8* %revision, align 1, !tbaa !76
  %call43 = call %struct.xt_target* @xt_request_find_target(i8 zeroext 10, i8* %arraydecay40, i8 zeroext %16)
  %17 = bitcast %struct.xt_target* %call43 to i8*
  %call44 = call zeroext i1 @IS_ERR.2(i8* %17)
  br i1 %call44, label %if.then45, label %if.end48

if.then45:                                        ; preds = %for.end
  %18 = bitcast %struct.xt_target* %call43 to i8*
  %call46 = call i64 @PTR_ERR.3(i8* %18)
  %conv47 = trunc i64 %call46 to i32
  br label %release_matches

if.end48:                                         ; preds = %for.end
  %u49 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call38, i32 0, i32 0
  %kernel = bitcast %union.anon.99* %u49 to %struct.anon.101*
  %target50 = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel, i32 0, i32 1
  store %struct.xt_target* %call43, %struct.xt_target** %target50, align 8, !tbaa !76
  %call51 = call i32 @xt_compat_target_offset(%struct.xt_target* %call43)
  %19 = load i32, i32* %off, align 4, !tbaa !75
  %add = add nsw i32 %19, %call51
  store i32 %add, i32* %off, align 4, !tbaa !75
  %20 = load i32, i32* %off, align 4, !tbaa !75
  %21 = load i32, i32* %size, align 4, !tbaa !75
  %add52 = add i32 %21, %20
  store i32 %add52, i32* %size, align 4, !tbaa !75
  %22 = load i32, i32* %off, align 4, !tbaa !75
  %call53 = call i32 @xt_compat_add_offset(i8 zeroext 10, i32 %conv20, i32 %22)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %out, label %cleanup

out:                                              ; preds = %if.end48
  %u57 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call38, i32 0, i32 0
  %kernel58 = bitcast %union.anon.99* %u57 to %struct.anon.101*
  %target59 = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel58, i32 0, i32 1
  %23 = load %struct.xt_target*, %struct.xt_target** %target59, align 8, !tbaa !76
  %me = getelementptr inbounds %struct.xt_target, %struct.xt_target* %23, i32 0, i32 8
  %24 = load %struct.module*, %struct.module** %me, align 8, !tbaa !144
  call void @module_put(%struct.module* %24)
  br label %release_matches

release_matches:                                  ; preds = %out, %if.then45, %for.body
  %ret.0 = phi i32 [ %conv47, %if.then45 ], [ %call53, %out ], [ %call30, %for.body ]
  %elems60 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 6
  %arraydecay61 = getelementptr inbounds [0 x i8], [0 x i8]* %elems60, i32 0, i32 0
  br label %for.cond62

for.cond62:                                       ; preds = %if.end73, %release_matches
  %add.ptr82.sink = phi i8* [ %add.ptr82, %if.end73 ], [ %arraydecay61, %release_matches ]
  %j.1 = phi i32 [ %j.0, %release_matches ], [ %dec, %if.end73 ]
  %25 = bitcast i8* %add.ptr82.sink to %struct.xt_entry_match*
  %26 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %target_offset63 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 2
  %27 = load i16, i16* %target_offset63, align 4, !tbaa !153
  %conv64 = zext i16 %27 to i32
  %idx.ext65 = sext i32 %conv64 to i64
  %add.ptr66 = getelementptr inbounds i8, i8* %26, i64 %idx.ext65
  %28 = bitcast i8* %add.ptr66 to %struct.xt_entry_match*
  %cmp67 = icmp ult %struct.xt_entry_match* %25, %28
  br i1 %cmp67, label %for.body69, label %cleanup

for.body69:                                       ; preds = %for.cond62
  %dec = add i32 %j.1, -1
  %cmp70 = icmp eq i32 %j.1, 0
  br i1 %cmp70, label %cleanup, label %if.end73

if.end73:                                         ; preds = %for.body69
  %u74 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %25, i32 0, i32 0
  %kernel75 = bitcast %union.anon.108* %u74 to %struct.anon.110*
  %match = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel75, i32 0, i32 1
  %29 = load %struct.xt_match*, %struct.xt_match** %match, align 8, !tbaa !76
  %me76 = getelementptr inbounds %struct.xt_match, %struct.xt_match* %29, i32 0, i32 8
  %30 = load %struct.module*, %struct.module** %me76, align 8, !tbaa !152
  call void @module_put(%struct.module* %30)
  %31 = bitcast %struct.xt_entry_match* %25 to i8*
  %u78 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %25, i32 0, i32 0
  %match_size79 = bitcast %union.anon.108* %u78 to i16*
  %32 = load i16, i16* %match_size79, align 8, !tbaa !76
  %conv80 = zext i16 %32 to i32
  %idx.ext81 = sext i32 %conv80 to i64
  %add.ptr82 = getelementptr inbounds i8, i8* %31, i64 %idx.ext81
  br label %for.cond62

cleanup:                                          ; preds = %for.body69, %for.cond62, %if.end48, %if.end13, %if.end11, %if.end, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ -22, %lor.lhs.false2 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ], [ -22, %if.end11 ], [ %call17, %if.end13 ], [ 0, %if.end48 ], [ %ret.0, %for.cond62 ], [ %ret.0, %for.body69 ]
  %33 = bitcast i32* %off to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %33) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @compat_copy_entry_from_user(%struct.compat_ip6t_entry* %e, i8** %dstptr, i32* %size, %struct.xt_table_info* %newinfo, i8* %base) #0 {
entry:
  %0 = load i32, i32* %size, align 4, !tbaa !75
  %1 = load i8*, i8** %dstptr, align 8, !tbaa !2
  %2 = bitcast i8* %1 to %struct.ip6t_entry*
  %cmp = icmp uge i64 168, 64
  %3 = bitcast %struct.ip6t_entry* %2 to i8*
  %4 = bitcast %struct.compat_ip6t_entry* %e to i8*
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i8* @__memcpy(i8* %3, i8* %4, i64 168)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %4, i64 168, i32 4, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %__ret.0 = phi i8* [ %call, %if.then ], [ %3, %if.else ]
  %cmp3 = icmp uge i64 16, 64
  %counters = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %2, i32 0, i32 5
  %5 = bitcast %struct.timespec* %counters to i8*
  %counters5 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 5
  %6 = bitcast %struct.timespec* %counters5 to i8*
  br i1 %cmp3, label %if.then4, label %if.else7

if.then4:                                         ; preds = %if.end
  %call6 = call i8* @__memcpy(i8* %5, i8* %6, i64 16)
  br label %if.end10

if.else7:                                         ; preds = %if.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 16, i32 4, i1 false)
  br label %if.end10

if.end10:                                         ; preds = %if.else7, %if.then4
  %__ret2.0 = phi i8* [ %call6, %if.then4 ], [ %5, %if.else7 ]
  %7 = load i8*, i8** %dstptr, align 8, !tbaa !2
  %add.ptr = getelementptr i8, i8* %7, i64 168
  store i8* %add.ptr, i8** %dstptr, align 8, !tbaa !2
  %8 = load i32, i32* %size, align 4, !tbaa !75
  %conv = zext i32 %8 to i64
  %add = add i64 %conv, 4
  %conv12 = trunc i64 %add to i32
  store i32 %conv12, i32* %size, align 4, !tbaa !75
  %elems = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end10
  %add.ptr19.sink = phi i8* [ %add.ptr19, %for.body ], [ %arraydecay, %if.end10 ]
  %9 = bitcast i8* %add.ptr19.sink to %struct.xt_entry_match*
  %10 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %target_offset = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 2
  %11 = load i16, i16* %target_offset, align 4, !tbaa !153
  %conv13 = zext i16 %11 to i32
  %idx.ext = sext i32 %conv13 to i64
  %add.ptr14 = getelementptr inbounds i8, i8* %10, i64 %idx.ext
  %12 = bitcast i8* %add.ptr14 to %struct.xt_entry_match*
  %cmp15 = icmp ult %struct.xt_entry_match* %9, %12
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @xt_compat_match_from_user(%struct.xt_entry_match* %9, i8** %dstptr, i32* %size)
  %13 = bitcast %struct.xt_entry_match* %9 to i8*
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %9, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u to i16*
  %14 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv17 = zext i16 %14 to i32
  %idx.ext18 = sext i32 %conv17 to i64
  %add.ptr19 = getelementptr inbounds i8, i8* %13, i64 %idx.ext18
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %target_offset20 = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 2
  %15 = load i16, i16* %target_offset20, align 4, !tbaa !153
  %conv21 = zext i16 %15 to i32
  %16 = load i32, i32* %size, align 4, !tbaa !75
  %sub = sub i32 %0, %16
  %sub22 = sub i32 %conv21, %sub
  %conv23 = trunc i32 %sub22 to i16
  %target_offset24 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %2, i32 0, i32 2
  store i16 %conv23, i16* %target_offset24, align 4, !tbaa !94
  %call25 = call %struct.xt_entry_target* @compat_ip6t_get_target(%struct.compat_ip6t_entry* %e)
  call void @xt_compat_target_from_user(%struct.xt_entry_target* %call25, i8** %dstptr, i32* %size)
  %next_offset = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 3
  %17 = load i16, i16* %next_offset, align 2, !tbaa !130
  %conv26 = zext i16 %17 to i32
  %18 = load i32, i32* %size, align 4, !tbaa !75
  %sub27 = sub i32 %0, %18
  %sub28 = sub i32 %conv26, %sub27
  %conv29 = trunc i32 %sub28 to i16
  %next_offset30 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %2, i32 0, i32 3
  store i16 %conv29, i16* %next_offset30, align 2, !tbaa !93
  br label %for.cond31

for.cond31:                                       ; preds = %for.inc60, %for.end
  %h.0 = phi i32 [ 0, %for.end ], [ %inc, %for.inc60 ]
  %cmp32 = icmp slt i32 %h.0, 5
  br i1 %cmp32, label %for.body34, label %for.end61

for.body34:                                       ; preds = %for.cond31
  %19 = bitcast %struct.ip6t_entry* %2 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %19 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %base to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %hook_entry = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 3
  %idxprom = sext i32 %h.0 to i64
  %arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom
  %20 = load i32, i32* %arrayidx, align 4, !tbaa !75
  %conv35 = zext i32 %20 to i64
  %cmp36 = icmp slt i64 %sub.ptr.sub, %conv35
  br i1 %cmp36, label %if.then38, label %if.end44

if.then38:                                        ; preds = %for.body34
  %21 = load i32, i32* %size, align 4, !tbaa !75
  %sub39 = sub i32 %0, %21
  %hook_entry40 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 3
  %idxprom41 = sext i32 %h.0 to i64
  %arrayidx42 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry40, i64 0, i64 %idxprom41
  %22 = load i32, i32* %arrayidx42, align 4, !tbaa !75
  %sub43 = sub i32 %22, %sub39
  store i32 %sub43, i32* %arrayidx42, align 4, !tbaa !75
  br label %if.end44

if.end44:                                         ; preds = %if.then38, %for.body34
  %23 = bitcast %struct.ip6t_entry* %2 to i8*
  %sub.ptr.lhs.cast45 = ptrtoint i8* %23 to i64
  %sub.ptr.rhs.cast46 = ptrtoint i8* %base to i64
  %sub.ptr.sub47 = sub i64 %sub.ptr.lhs.cast45, %sub.ptr.rhs.cast46
  %underflow = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 4
  %idxprom48 = sext i32 %h.0 to i64
  %arrayidx49 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i64 0, i64 %idxprom48
  %24 = load i32, i32* %arrayidx49, align 4, !tbaa !75
  %conv50 = zext i32 %24 to i64
  %cmp51 = icmp slt i64 %sub.ptr.sub47, %conv50
  br i1 %cmp51, label %if.then53, label %for.inc60

if.then53:                                        ; preds = %if.end44
  %25 = load i32, i32* %size, align 4, !tbaa !75
  %sub54 = sub i32 %0, %25
  %underflow55 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 4
  %idxprom56 = sext i32 %h.0 to i64
  %arrayidx57 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow55, i64 0, i64 %idxprom56
  %26 = load i32, i32* %arrayidx57, align 4, !tbaa !75
  %sub58 = sub i32 %26, %sub54
  store i32 %sub58, i32* %arrayidx57, align 4, !tbaa !75
  br label %for.inc60

for.inc60:                                        ; preds = %if.then53, %if.end44
  %inc = add nsw i32 %h.0, 1
  br label %for.cond31

for.end61:                                        ; preds = %for.cond31
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @translate_table(%struct.net* %net, %struct.xt_table_info* %newinfo, i8* %entry0, %struct.ip6t_replace* %repl) #0 {
entry:
  %alloc_state = alloca %struct.xt_percpu_counter_alloc_state, align 8
  %0 = bitcast %struct.xt_percpu_counter_alloc_state* %alloc_state to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast %struct.xt_percpu_counter_alloc_state* %alloc_state to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 16, i32 8, i1 false)
  %size = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 3
  %2 = load i32, i32* %size, align 8, !tbaa !136
  %size1 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 0
  store i32 %2, i32* %size1, align 8, !tbaa !87
  %num_entries = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 2
  %3 = load i32, i32* %num_entries, align 4, !tbaa !154
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 1
  store i32 %3, i32* %number, align 4, !tbaa !84
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp ult i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %hook_entry = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 3
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom
  store i32 -1, i32* %arrayidx, align 4, !tbaa !75
  %underflow = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 4
  %idxprom2 = zext i32 %i.0 to i64
  %arrayidx3 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i64 0, i64 %idxprom2
  store i32 -1, i32* %arrayidx3, align 4, !tbaa !75
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %number4 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 1
  %4 = load i32, i32* %number4, align 4, !tbaa !84
  %call = call i32* @xt_alloc_entry_offsets(i32 %4)
  %tobool = icmp ne i32* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %for.end
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc34, %if.end
  %add.ptr37.sink = phi i8* [ %add.ptr37, %for.inc34 ], [ %entry0, %if.end ]
  %i.1 = phi i32 [ 0, %if.end ], [ %inc25, %for.inc34 ]
  %5 = bitcast i8* %add.ptr37.sink to %struct.ip6t_entry*
  %size6 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 0
  %6 = load i32, i32* %size6, align 8, !tbaa !87
  %idx.ext = zext i32 %6 to i64
  %add.ptr = getelementptr inbounds i8, i8* %entry0, i64 %idx.ext
  %7 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %cmp7 = icmp ult %struct.ip6t_entry* %5, %7
  br i1 %cmp7, label %for.body8, label %for.end38

for.body8:                                        ; preds = %for.cond5
  %size9 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 3
  %8 = load i32, i32* %size9, align 8, !tbaa !136
  %idx.ext10 = zext i32 %8 to i64
  %add.ptr11 = getelementptr i8, i8* %entry0, i64 %idx.ext10
  %hook_entry12 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 4
  %arraydecay = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry12, i32 0, i32 0
  %underflow13 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 5
  %arraydecay14 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow13, i32 0, i32 0
  %valid_hooks = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 1
  %9 = load i32, i32* %valid_hooks, align 8, !tbaa !155
  %call15 = call i32 @check_entry_size_and_hooks(%struct.ip6t_entry* %5, %struct.xt_table_info* %newinfo, i8* %entry0, i8* %add.ptr11, i32* %arraydecay, i32* %arraydecay14, i32 %9)
  %cmp16 = icmp ne i32 %call15, 0
  br i1 %cmp16, label %out_free, label %if.end18

if.end18:                                         ; preds = %for.body8
  %num_entries19 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 2
  %10 = load i32, i32* %num_entries19, align 4, !tbaa !154
  %cmp20 = icmp ult i32 %i.1, %10
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end18
  %11 = bitcast %struct.ip6t_entry* %5 to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %11 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %entry0 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %idxprom22 = zext i32 %i.1 to i64
  %arrayidx23 = getelementptr inbounds i32, i32* %call, i64 %idxprom22
  store i32 %conv, i32* %arrayidx23, align 4, !tbaa !75
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end18
  %inc25 = add i32 %i.1, 1
  %call26 = call %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %5)
  %u = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call26, i32 0, i32 0
  %user = bitcast %union.anon.99* %u to %struct.anon.104*
  %name = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %arraydecay27 = getelementptr inbounds [29 x i8], [29 x i8]* %name, i32 0, i32 0
  %call28 = call i32 @strcmp(i8* %arraydecay27, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0))
  %cmp29 = icmp eq i32 %call28, 0
  br i1 %cmp29, label %if.then31, label %for.inc34

if.then31:                                        ; preds = %if.end24
  %stacksize = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 5
  %12 = load i32, i32* %stacksize, align 4, !tbaa !156
  %inc32 = add i32 %12, 1
  store i32 %inc32, i32* %stacksize, align 4, !tbaa !156
  br label %for.inc34

for.inc34:                                        ; preds = %if.then31, %if.end24
  %13 = bitcast %struct.ip6t_entry* %5 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %5, i32 0, i32 3
  %14 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv35 = zext i16 %14 to i32
  %idx.ext36 = sext i32 %conv35 to i64
  %add.ptr37 = getelementptr inbounds i8, i8* %13, i64 %idx.ext36
  br label %for.cond5

for.end38:                                        ; preds = %for.cond5
  %num_entries39 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 2
  %15 = load i32, i32* %num_entries39, align 4, !tbaa !154
  %cmp40 = icmp ne i32 %i.1, %15
  br i1 %cmp40, label %out_free, label %if.end43

if.end43:                                         ; preds = %for.end38
  br label %for.cond44

for.cond44:                                       ; preds = %for.inc66, %if.end43
  %i.2 = phi i32 [ 0, %if.end43 ], [ %inc67, %for.inc66 ]
  %cmp45 = icmp ult i32 %i.2, 5
  %valid_hooks48 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 1
  %16 = load i32, i32* %valid_hooks48, align 8, !tbaa !155
  br i1 %cmp45, label %for.body47, label %for.end68

for.body47:                                       ; preds = %for.cond44
  %shl = shl i32 1, %i.2
  %and = and i32 %16, %shl
  %tobool49 = icmp ne i32 %and, 0
  br i1 %tobool49, label %if.end51, label %for.inc66

if.end51:                                         ; preds = %for.body47
  %hook_entry52 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 3
  %idxprom53 = zext i32 %i.2 to i64
  %arrayidx54 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry52, i64 0, i64 %idxprom53
  %17 = load i32, i32* %arrayidx54, align 4, !tbaa !75
  %cmp55 = icmp eq i32 %17, -1
  br i1 %cmp55, label %out_free, label %if.end58

if.end58:                                         ; preds = %if.end51
  %underflow59 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 4
  %idxprom60 = zext i32 %i.2 to i64
  %arrayidx61 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow59, i64 0, i64 %idxprom60
  %18 = load i32, i32* %arrayidx61, align 4, !tbaa !75
  %cmp62 = icmp eq i32 %18, -1
  br i1 %cmp62, label %out_free, label %for.inc66

for.inc66:                                        ; preds = %if.end58, %for.body47
  %inc67 = add i32 %i.2, 1
  br label %for.cond44

for.end68:                                        ; preds = %for.cond44
  %call70 = call i32 @mark_source_chains(%struct.xt_table_info* %newinfo, i32 %16, i8* %entry0, i32* %call)
  %tobool71 = icmp ne i32 %call70, 0
  br i1 %tobool71, label %if.end73, label %out_free

if.end73:                                         ; preds = %for.end68
  %19 = bitcast i32* %call to i8*
  call void @kvfree(i8* %19)
  br label %for.cond74

for.cond74:                                       ; preds = %if.end88, %if.end73
  %add.ptr94.sink = phi i8* [ %add.ptr94, %if.end88 ], [ %entry0, %if.end73 ]
  %i.3 = phi i32 [ 0, %if.end73 ], [ %inc89, %if.end88 ]
  %ret.0 = phi i32 [ -22, %if.end73 ], [ %call84, %if.end88 ]
  %20 = bitcast i8* %add.ptr94.sink to %struct.ip6t_entry*
  %size75 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 0
  %21 = load i32, i32* %size75, align 8, !tbaa !87
  %idx.ext76 = zext i32 %21 to i64
  %add.ptr77 = getelementptr inbounds i8, i8* %entry0, i64 %idx.ext76
  %22 = bitcast i8* %add.ptr77 to %struct.ip6t_entry*
  %cmp78 = icmp ult %struct.ip6t_entry* %20, %22
  br i1 %cmp78, label %for.body80, label %for.end95

for.body80:                                       ; preds = %for.cond74
  %name81 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 0
  %arraydecay82 = getelementptr inbounds [32 x i8], [32 x i8]* %name81, i32 0, i32 0
  %size83 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 3
  %23 = load i32, i32* %size83, align 8, !tbaa !136
  %call84 = call i32 @find_check_entry(%struct.ip6t_entry* %20, %struct.net* %net, i8* %arraydecay82, i32 %23, %struct.xt_percpu_counter_alloc_state* %alloc_state)
  %cmp85 = icmp ne i32 %call84, 0
  br i1 %cmp85, label %for.end95, label %if.end88

if.end88:                                         ; preds = %for.body80
  %inc89 = add i32 %i.3, 1
  %24 = bitcast %struct.ip6t_entry* %20 to i8*
  %next_offset91 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %20, i32 0, i32 3
  %25 = load i16, i16* %next_offset91, align 2, !tbaa !93
  %conv92 = zext i16 %25 to i32
  %idx.ext93 = sext i32 %conv92 to i64
  %add.ptr94 = getelementptr inbounds i8, i8* %24, i64 %idx.ext93
  br label %for.cond74

for.end95:                                        ; preds = %for.body80, %for.cond74
  %ret.1 = phi i32 [ %call84, %for.body80 ], [ %ret.0, %for.cond74 ]
  %cmp96 = icmp ne i32 %ret.1, 0
  br i1 %cmp96, label %if.then98, label %cleanup

if.then98:                                        ; preds = %for.end95
  br label %for.cond99

for.cond99:                                       ; preds = %if.end109, %if.then98
  %add.ptr114.sink = phi i8* [ %add.ptr114, %if.end109 ], [ %entry0, %if.then98 ]
  %i.4 = phi i32 [ %i.3, %if.then98 ], [ %dec, %if.end109 ]
  %26 = bitcast i8* %add.ptr114.sink to %struct.ip6t_entry*
  %size100 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 0
  %27 = load i32, i32* %size100, align 8, !tbaa !87
  %idx.ext101 = zext i32 %27 to i64
  %add.ptr102 = getelementptr inbounds i8, i8* %entry0, i64 %idx.ext101
  %28 = bitcast i8* %add.ptr102 to %struct.ip6t_entry*
  %cmp103 = icmp ult %struct.ip6t_entry* %26, %28
  br i1 %cmp103, label %for.body105, label %cleanup

for.body105:                                      ; preds = %for.cond99
  %dec = add i32 %i.4, -1
  %cmp106 = icmp eq i32 %i.4, 0
  br i1 %cmp106, label %cleanup, label %if.end109

if.end109:                                        ; preds = %for.body105
  call void @cleanup_entry(%struct.ip6t_entry* %26, %struct.net* %net)
  %29 = bitcast %struct.ip6t_entry* %26 to i8*
  %next_offset111 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %26, i32 0, i32 3
  %30 = load i16, i16* %next_offset111, align 2, !tbaa !93
  %conv112 = zext i16 %30 to i32
  %idx.ext113 = sext i32 %conv112 to i64
  %add.ptr114 = getelementptr inbounds i8, i8* %29, i64 %idx.ext113
  br label %for.cond99

out_free:                                         ; preds = %for.end68, %if.end58, %if.end51, %for.end38, %for.body8
  %ret.2 = phi i32 [ %call15, %for.body8 ], [ -22, %for.end38 ], [ -22, %if.end51 ], [ -22, %if.end58 ], [ -40, %for.end68 ]
  %31 = bitcast i32* %call to i8*
  call void @kvfree(i8* %31)
  br label %cleanup

cleanup:                                          ; preds = %out_free, %for.body105, %for.cond99, %for.end95, %for.end
  %retval.0 = phi i32 [ %ret.2, %out_free ], [ -12, %for.end ], [ %ret.1, %for.cond99 ], [ %ret.1, %for.body105 ], [ %ret.1, %for.end95 ]
  %32 = bitcast %struct.xt_percpu_counter_alloc_state* %alloc_state to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %32) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @compat_release_entry(%struct.compat_ip6t_entry* %e) #0 {
entry:
  %elems = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %add.ptr5.sink = phi i8* [ %add.ptr5, %for.body ], [ %arraydecay, %entry ]
  %0 = bitcast i8* %add.ptr5.sink to %struct.xt_entry_match*
  %1 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %target_offset = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 2
  %2 = load i16, i16* %target_offset, align 4, !tbaa !153
  %conv = zext i16 %2 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %3 = bitcast i8* %add.ptr to %struct.xt_entry_match*
  %cmp = icmp ult %struct.xt_entry_match* %0, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %0, i32 0, i32 0
  %kernel = bitcast %union.anon.108* %u to %struct.anon.110*
  %match = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel, i32 0, i32 1
  %4 = load %struct.xt_match*, %struct.xt_match** %match, align 8, !tbaa !76
  %me = getelementptr inbounds %struct.xt_match, %struct.xt_match* %4, i32 0, i32 8
  %5 = load %struct.module*, %struct.module** %me, align 8, !tbaa !152
  call void @module_put(%struct.module* %5)
  %6 = bitcast %struct.xt_entry_match* %0 to i8*
  %u2 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %0, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u2 to i16*
  %7 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv3 = zext i16 %7 to i32
  %idx.ext4 = sext i32 %conv3 to i64
  %add.ptr5 = getelementptr inbounds i8, i8* %6, i64 %idx.ext4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call = call %struct.xt_entry_target* @compat_ip6t_get_target(%struct.compat_ip6t_entry* %e)
  %u6 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call, i32 0, i32 0
  %kernel7 = bitcast %union.anon.99* %u6 to %struct.anon.101*
  %target = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel7, i32 0, i32 1
  %8 = load %struct.xt_target*, %struct.xt_target** %target, align 8, !tbaa !76
  %me8 = getelementptr inbounds %struct.xt_target, %struct.xt_target* %8, i32 0, i32 8
  %9 = load %struct.module*, %struct.module** %me8, align 8, !tbaa !144
  call void @module_put(%struct.module* %9)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.xt_entry_target* @compat_ip6t_get_target(%struct.compat_ip6t_entry* %e) #2 {
entry:
  %0 = bitcast %struct.compat_ip6t_entry* %e to i8*
  %target_offset = getelementptr inbounds %struct.compat_ip6t_entry, %struct.compat_ip6t_entry* %e, i32 0, i32 2
  %1 = load i16, i16* %target_offset, align 4, !tbaa !153
  %conv = zext i16 %1 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %2 = bitcast i8* %add.ptr to %struct.xt_entry_target*
  ret %struct.xt_entry_target* %2
}

declare i32* @xt_alloc_entry_offsets(i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @check_entry_size_and_hooks(%struct.ip6t_entry* %e, %struct.xt_table_info* %newinfo, i8* %base, i8* %limit, i32* %hook_entries, i32* %underflows, i32 %valid_hooks) #0 {
entry:
  %.compoundliteral = alloca %struct.timespec, align 8
  %0 = ptrtoint %struct.ip6t_entry* %e to i64
  %rem = urem i64 %0, 8
  %cmp = icmp ne i64 %rem, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = bitcast %struct.ip6t_entry* %e to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 168
  %cmp1 = icmp uge i8* %add.ptr, %limit
  br i1 %cmp1, label %cleanup, label %lor.lhs.false2

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %2 = bitcast %struct.ip6t_entry* %e to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 3
  %3 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv = zext i16 %3 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr3 = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  %cmp4 = icmp ugt i8* %add.ptr3, %limit
  br i1 %cmp4, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false2
  %next_offset6 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 3
  %4 = load i16, i16* %next_offset6, align 2, !tbaa !93
  %conv7 = zext i16 %4 to i64
  %cmp8 = icmp ult i64 %conv7, 200
  br i1 %cmp8, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end
  %ipv6 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 0
  %call = call zeroext i1 @ip6_checkentry(%struct.ip6t_ip6* %ipv6)
  br i1 %call, label %if.end13, label %cleanup

if.end13:                                         ; preds = %if.end11
  %5 = bitcast %struct.ip6t_entry* %e to i8*
  %elems = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %6 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv14 = zext i16 %6 to i32
  %next_offset15 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 3
  %7 = load i16, i16* %next_offset15, align 2, !tbaa !93
  %conv16 = zext i16 %7 to i32
  %call17 = call i32 @xt_check_entry_offsets(i8* %5, i8* %arraydecay, i32 %conv14, i32 %conv16)
  %tobool = icmp ne i32 %call17, 0
  br i1 %tobool, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end13
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %h.0 = phi i32 [ 0, %if.end19 ], [ %inc, %for.inc ]
  %cmp20 = icmp ult i32 %h.0, 5
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %shl = shl i32 1, %h.0
  %and = and i32 %valid_hooks, %shl
  %tobool22 = icmp ne i32 %and, 0
  br i1 %tobool22, label %if.end24, label %for.inc

if.end24:                                         ; preds = %for.body
  %8 = bitcast %struct.ip6t_entry* %e to i8*
  %sub.ptr.lhs.cast = ptrtoint i8* %8 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %base to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %idxprom = zext i32 %h.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %hook_entries, i64 %idxprom
  %9 = load i32, i32* %arrayidx, align 4, !tbaa !75
  %conv25 = zext i32 %9 to i64
  %cmp26 = icmp eq i64 %sub.ptr.sub, %conv25
  br i1 %cmp26, label %if.then28, label %if.end33

if.then28:                                        ; preds = %if.end24
  %idxprom29 = zext i32 %h.0 to i64
  %arrayidx30 = getelementptr inbounds i32, i32* %hook_entries, i64 %idxprom29
  %10 = load i32, i32* %arrayidx30, align 4, !tbaa !75
  %hook_entry = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 3
  %idxprom31 = zext i32 %h.0 to i64
  %arrayidx32 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom31
  store i32 %10, i32* %arrayidx32, align 4, !tbaa !75
  br label %if.end33

if.end33:                                         ; preds = %if.then28, %if.end24
  %11 = bitcast %struct.ip6t_entry* %e to i8*
  %sub.ptr.lhs.cast34 = ptrtoint i8* %11 to i64
  %sub.ptr.rhs.cast35 = ptrtoint i8* %base to i64
  %sub.ptr.sub36 = sub i64 %sub.ptr.lhs.cast34, %sub.ptr.rhs.cast35
  %idxprom37 = zext i32 %h.0 to i64
  %arrayidx38 = getelementptr inbounds i32, i32* %underflows, i64 %idxprom37
  %12 = load i32, i32* %arrayidx38, align 4, !tbaa !75
  %conv39 = zext i32 %12 to i64
  %cmp40 = icmp eq i64 %sub.ptr.sub36, %conv39
  br i1 %cmp40, label %if.then42, label %for.inc

if.then42:                                        ; preds = %if.end33
  %call43 = call zeroext i1 @check_underflow(%struct.ip6t_entry* %e)
  br i1 %call43, label %if.end45, label %cleanup

if.end45:                                         ; preds = %if.then42
  %idxprom46 = zext i32 %h.0 to i64
  %arrayidx47 = getelementptr inbounds i32, i32* %underflows, i64 %idxprom46
  %13 = load i32, i32* %arrayidx47, align 4, !tbaa !75
  %underflow = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 4
  %idxprom48 = zext i32 %h.0 to i64
  %arrayidx49 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i64 0, i64 %idxprom48
  store i32 %13, i32* %arrayidx49, align 4, !tbaa !75
  br label %for.inc

for.inc:                                          ; preds = %if.end45, %if.end33, %for.body
  %inc = add i32 %h.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %counters = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 5
  %pcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %.compoundliteral, i32 0, i32 0
  store i64 0, i64* %pcnt, align 8, !tbaa !100
  %bcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %.compoundliteral, i32 0, i32 1
  store i64 0, i64* %bcnt, align 8, !tbaa !99
  %14 = bitcast %struct.timespec* %counters to i8*
  %15 = bitcast %struct.timespec* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 16, i32 8, i1 false), !tbaa.struct !157
  %comefrom = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 4
  store i32 0, i32* %comefrom, align 8, !tbaa !158
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then42, %if.end13, %if.end11, %if.end, %lor.lhs.false2, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ 0, %for.end ], [ -22, %lor.lhs.false2 ], [ -22, %lor.lhs.false ], [ -22, %entry ], [ -22, %if.end ], [ -22, %if.end11 ], [ %call17, %if.end13 ], [ -22, %if.then42 ]
  ret i32 %retval.0
}

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @mark_source_chains(%struct.xt_table_info* %newinfo, i32 %valid_hooks, i8* %entry0, i32* %offsets) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %hook.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.6, %for.inc ]
  %cmp = icmp ult i32 %hook.0, 5
  br i1 %cmp, label %for.body, label %cleanup113

for.body:                                         ; preds = %for.cond
  %hook_entry = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 3
  %idxprom = zext i32 %hook.0 to i64
  %arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !75
  %idx.ext = zext i32 %0 to i64
  %add.ptr = getelementptr i8, i8* %entry0, i64 %idx.ext
  %1 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %shl = shl i32 1, %hook.0
  %and = and i32 %valid_hooks, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %cleanup109

if.end:                                           ; preds = %for.body
  %conv = zext i32 %0 to i64
  %counters = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %1, i32 0, i32 5
  %pcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %counters, i32 0, i32 0
  store i64 %conv, i64* %pcnt, align 8, !tbaa !159
  br label %for.cond1

for.cond1:                                        ; preds = %cleanup.cont108, %if.end
  %pos.0 = phi i32 [ %0, %if.end ], [ %pos.5, %cleanup.cont108 ]
  %e.0 = phi %struct.ip6t_entry* [ %1, %if.end ], [ %e.5, %cleanup.cont108 ]
  %retval.1 = phi i32 [ %retval.0, %if.end ], [ %retval.5, %cleanup.cont108 ]
  %call = call %struct.xt_entry_target* @ip6t_get_target_c(%struct.ip6t_entry* %e.0)
  %2 = bitcast %struct.xt_entry_target* %call to i8*
  %3 = bitcast i8* %2 to %struct.xt_standard_target*
  %comefrom = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 4
  %4 = load i32, i32* %comefrom, align 8, !tbaa !158
  %shl2 = shl i32 1, %hook.0
  %and3 = and i32 %4, %shl2
  %comefrom4 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 4
  %5 = load i32, i32* %comefrom4, align 8, !tbaa !158
  %and5 = and i32 %5, 32
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %cleanup105, label %if.end8

if.end8:                                          ; preds = %for.cond1
  %shl9 = shl i32 1, %hook.0
  %or = or i32 %shl9, 32
  %comefrom10 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 4
  %6 = load i32, i32* %comefrom10, align 8, !tbaa !158
  %or11 = or i32 %6, %or
  store i32 %or11, i32* %comefrom10, align 8, !tbaa !158
  %call12 = call zeroext i1 @unconditional(%struct.ip6t_entry* %e.0)
  br i1 %call12, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end8
  %target = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %3, i32 0, i32 0
  %u = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %target, i32 0, i32 0
  %user = bitcast %union.anon.99* %u to %struct.anon.104*
  %name = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %arraydecay = getelementptr inbounds [29 x i8], [29 x i8]* %name, i32 0, i32 0
  %call14 = call i32 @strcmp(i8* %arraydecay, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.6, i32 0, i32 0))
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %land.lhs.true17, label %lor.lhs.false

land.lhs.true17:                                  ; preds = %land.lhs.true
  %verdict = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %3, i32 0, i32 1
  %7 = load i32, i32* %verdict, align 8, !tbaa !160
  %cmp18 = icmp slt i32 %7, 0
  %tobool20 = icmp ne i32 %and3, 0
  %or.cond = or i1 %cmp18, %tobool20
  br i1 %or.cond, label %if.then21, label %if.else

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end8
  %tobool20.old = icmp ne i32 %and3, 0
  br i1 %tobool20.old, label %if.then21, label %if.else

if.then21:                                        ; preds = %lor.lhs.false, %land.lhs.true17
  %target22 = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %3, i32 0, i32 0
  %u23 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %target22, i32 0, i32 0
  %user24 = bitcast %union.anon.99* %u23 to %struct.anon.104*
  %name25 = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user24, i32 0, i32 1
  %arraydecay26 = getelementptr inbounds [29 x i8], [29 x i8]* %name25, i32 0, i32 0
  %call27 = call i32 @strcmp(i8* %arraydecay26, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.6, i32 0, i32 0))
  %cmp28 = icmp eq i32 %call27, 0
  br i1 %cmp28, label %land.lhs.true30, label %if.end35

land.lhs.true30:                                  ; preds = %if.then21
  %verdict31 = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %3, i32 0, i32 1
  %8 = load i32, i32* %verdict31, align 8, !tbaa !160
  %cmp32 = icmp slt i32 %8, -6
  br i1 %cmp32, label %cleanup, label %if.end35

if.end35:                                         ; preds = %land.lhs.true30, %if.then21
  br label %do.body

do.body:                                          ; preds = %if.end45, %if.end35
  %pos.1 = phi i32 [ %pos.0, %if.end35 ], [ %conv39, %if.end45 ]
  %e.1 = phi %struct.ip6t_entry* [ %e.0, %if.end35 ], [ %11, %if.end45 ]
  %comefrom36 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.1, i32 0, i32 4
  %9 = load i32, i32* %comefrom36, align 8, !tbaa !158
  %xor = xor i32 %9, 32
  store i32 %xor, i32* %comefrom36, align 8, !tbaa !158
  %counters37 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.1, i32 0, i32 5
  %pcnt38 = getelementptr inbounds %struct.timespec, %struct.timespec* %counters37, i32 0, i32 0
  %10 = load i64, i64* %pcnt38, align 8, !tbaa !159
  %conv39 = trunc i64 %10 to i32
  %counters40 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.1, i32 0, i32 5
  %pcnt41 = getelementptr inbounds %struct.timespec, %struct.timespec* %counters40, i32 0, i32 0
  store i64 0, i64* %pcnt41, align 8, !tbaa !159
  %cmp42 = icmp eq i32 %conv39, %pos.1
  br i1 %cmp42, label %cleanup, label %if.end45

if.end45:                                         ; preds = %do.body
  %idx.ext46 = zext i32 %conv39 to i64
  %add.ptr47 = getelementptr i8, i8* %entry0, i64 %idx.ext46
  %11 = bitcast i8* %add.ptr47 to %struct.ip6t_entry*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %11, i32 0, i32 3
  %12 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv48 = zext i16 %12 to i32
  %add = add i32 %conv39, %conv48
  %cmp49 = icmp eq i32 %pos.1, %add
  br i1 %cmp49, label %do.body, label %do.end

do.end:                                           ; preds = %if.end45
  %next_offset51 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %11, i32 0, i32 3
  %13 = load i16, i16* %next_offset51, align 2, !tbaa !93
  %conv52 = zext i16 %13 to i32
  %idx.ext53 = zext i32 %conv39 to i64
  %add.ptr54 = getelementptr i8, i8* %entry0, i64 %idx.ext53
  %idx.ext55 = zext i32 %conv52 to i64
  %add.ptr56 = getelementptr i8, i8* %add.ptr54, i64 %idx.ext55
  %14 = bitcast i8* %add.ptr56 to %struct.ip6t_entry*
  %add57 = add i32 %conv39, %conv52
  %size58 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 0
  %15 = load i32, i32* %size58, align 8, !tbaa !87
  %cmp59 = icmp uge i32 %add57, %15
  br i1 %cmp59, label %cleanup, label %if.end62

if.end62:                                         ; preds = %do.end
  %conv63 = zext i32 %conv39 to i64
  %counters64 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %14, i32 0, i32 5
  %pcnt65 = getelementptr inbounds %struct.timespec, %struct.timespec* %counters64, i32 0, i32 0
  store i64 %conv63, i64* %pcnt65, align 8, !tbaa !159
  %add66 = add i32 %conv39, %conv52
  br label %cleanup

cleanup:                                          ; preds = %if.end62, %do.end, %do.body, %land.lhs.true30
  %pos.2 = phi i32 [ %add66, %if.end62 ], [ %pos.0, %land.lhs.true30 ], [ %conv39, %do.body ], [ %conv39, %do.end ]
  %e.2 = phi %struct.ip6t_entry* [ %14, %if.end62 ], [ %e.0, %land.lhs.true30 ], [ %e.1, %do.body ], [ %14, %do.end ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end62 ], [ 1, %land.lhs.true30 ], [ 9, %do.body ], [ 1, %do.end ]
  %retval.2 = phi i32 [ %retval.1, %if.end62 ], [ 0, %land.lhs.true30 ], [ %retval.1, %do.body ], [ 0, %do.end ]
  %cond1 = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond1, label %if.end104, label %cleanup105

if.else:                                          ; preds = %lor.lhs.false, %land.lhs.true17
  %verdict68 = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %3, i32 0, i32 1
  %16 = load i32, i32* %verdict68, align 8, !tbaa !160
  %target69 = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %3, i32 0, i32 0
  %u70 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %target69, i32 0, i32 0
  %user71 = bitcast %union.anon.99* %u70 to %struct.anon.104*
  %name72 = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user71, i32 0, i32 1
  %arraydecay73 = getelementptr inbounds [29 x i8], [29 x i8]* %name72, i32 0, i32 0
  %call74 = call i32 @strcmp(i8* %arraydecay73, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.6, i32 0, i32 0))
  %cmp75 = icmp eq i32 %call74, 0
  %cmp78 = icmp sge i32 %16, 0
  %or.cond2 = and i1 %cmp75, %cmp78
  br i1 %or.cond2, label %if.then80, label %if.else86

if.then80:                                        ; preds = %if.else
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 1
  %17 = load i32, i32* %number, align 4, !tbaa !84
  %call81 = call zeroext i1 @xt_find_jump_offset(i32* %offsets, i32 %16, i32 %17)
  br i1 %call81, label %if.end83, label %cleanup101

if.end83:                                         ; preds = %if.then80
  %idx.ext84 = sext i32 %16 to i64
  %add.ptr85 = getelementptr i8, i8* %entry0, i64 %idx.ext84
  %18 = bitcast i8* %add.ptr85 to %struct.ip6t_entry*
  br label %if.end95

if.else86:                                        ; preds = %if.else
  %next_offset87 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 3
  %19 = load i16, i16* %next_offset87, align 2, !tbaa !93
  %conv88 = zext i16 %19 to i32
  %add89 = add i32 %pos.0, %conv88
  %size90 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %newinfo, i32 0, i32 0
  %20 = load i32, i32* %size90, align 8, !tbaa !87
  %cmp91 = icmp uge i32 %add89, %20
  br i1 %cmp91, label %cleanup101, label %if.end95

if.end95:                                         ; preds = %if.else86, %if.end83
  %newpos.0 = phi i32 [ %16, %if.end83 ], [ %add89, %if.else86 ]
  %idx.ext96 = sext i32 %newpos.0 to i64
  %add.ptr97 = getelementptr i8, i8* %entry0, i64 %idx.ext96
  %21 = bitcast i8* %add.ptr97 to %struct.ip6t_entry*
  %conv98 = zext i32 %pos.0 to i64
  %counters99 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %21, i32 0, i32 5
  %pcnt100 = getelementptr inbounds %struct.timespec, %struct.timespec* %counters99, i32 0, i32 0
  store i64 %conv98, i64* %pcnt100, align 8, !tbaa !159
  br label %cleanup101

cleanup101:                                       ; preds = %if.end95, %if.else86, %if.then80
  %pos.3 = phi i32 [ %newpos.0, %if.end95 ], [ %pos.0, %if.then80 ], [ %pos.0, %if.else86 ]
  %e.3 = phi %struct.ip6t_entry* [ %21, %if.end95 ], [ %e.0, %if.then80 ], [ %e.0, %if.else86 ]
  %cleanup.dest.slot.1 = phi i32 [ 0, %if.end95 ], [ 1, %if.then80 ], [ 1, %if.else86 ]
  %retval.3 = phi i32 [ %retval.1, %if.end95 ], [ 0, %if.then80 ], [ 0, %if.else86 ]
  %cond = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %cond, label %if.end104, label %cleanup105

if.end104:                                        ; preds = %cleanup101, %cleanup
  %pos.4 = phi i32 [ %pos.2, %cleanup ], [ %pos.3, %cleanup101 ]
  %e.4 = phi %struct.ip6t_entry* [ %e.2, %cleanup ], [ %e.3, %cleanup101 ]
  %retval.4 = phi i32 [ %retval.2, %cleanup ], [ %retval.3, %cleanup101 ]
  br label %cleanup105

cleanup105:                                       ; preds = %if.end104, %cleanup101, %cleanup, %for.cond1
  %pos.5 = phi i32 [ %pos.2, %cleanup ], [ %pos.4, %if.end104 ], [ %pos.3, %cleanup101 ], [ %pos.0, %for.cond1 ]
  %e.5 = phi %struct.ip6t_entry* [ %e.2, %cleanup ], [ %e.4, %if.end104 ], [ %e.3, %cleanup101 ], [ %e.0, %for.cond1 ]
  %cleanup.dest.slot.2 = phi i32 [ %cleanup.dest.slot.0, %cleanup ], [ 0, %if.end104 ], [ %cleanup.dest.slot.1, %cleanup101 ], [ 1, %for.cond1 ]
  %retval.5 = phi i32 [ %retval.2, %cleanup ], [ %retval.4, %if.end104 ], [ %retval.3, %cleanup101 ], [ 0, %for.cond1 ]
  br label %NodeBlock

NodeBlock:                                        ; preds = %cleanup105
  %Pivot = icmp slt i32 %cleanup.dest.slot.2, 9
  br i1 %Pivot, label %LeafBlock, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %cleanup.dest.slot.2, 9
  br i1 %SwitchLeaf4, label %cleanup109, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.2, 0
  br i1 %SwitchLeaf, label %cleanup.cont108, label %NewDefault

cleanup.cont108:                                  ; preds = %LeafBlock
  br label %for.cond1

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock3
  br label %cleanup109.loopexit

cleanup109.loopexit:                              ; preds = %NewDefault
  br label %cleanup109

cleanup109:                                       ; preds = %cleanup109.loopexit, %LeafBlock3, %for.body
  %cleanup.dest.slot.3 = phi i32 [ %cleanup.dest.slot.2, %cleanup109.loopexit ], [ 4, %for.body ], [ 0, %LeafBlock3 ]
  %retval.6 = phi i32 [ %retval.5, %cleanup109.loopexit ], [ %retval.0, %for.body ], [ %retval.5, %LeafBlock3 ]
  br label %NodeBlock10

NodeBlock10:                                      ; preds = %cleanup109
  %Pivot11 = icmp slt i32 %cleanup.dest.slot.3, 4
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i32 %cleanup.dest.slot.3, 4
  br i1 %SwitchLeaf9, label %for.inc, label %NewDefault5

LeafBlock6:                                       ; preds = %NodeBlock10
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.3, 0
  br i1 %SwitchLeaf7, label %for.inc, label %NewDefault5

for.inc:                                          ; preds = %LeafBlock6, %LeafBlock8
  %inc = add i32 %hook.0, 1
  br label %for.cond

NewDefault5:                                      ; preds = %LeafBlock6, %LeafBlock8
  br label %cleanup113

cleanup113:                                       ; preds = %NewDefault5, %for.cond
  %retval.7 = phi i32 [ 1, %for.cond ], [ %retval.6, %NewDefault5 ]
  ret i32 %retval.7
}

declare void @kvfree(i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @find_check_entry(%struct.ip6t_entry* %e, %struct.net* %net, i8* %name, i32 %size, %struct.xt_percpu_counter_alloc_state* %alloc_state) #0 {
entry:
  %mtpar = alloca %struct.xt_mtchk_param, align 8
  %0 = bitcast %struct.xt_mtchk_param* %mtpar to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %0) #7
  %counters = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 5
  %call = call zeroext i1 @xt_percpu_counter_alloc(%struct.xt_percpu_counter_alloc_state* %alloc_state, %struct.timespec* %counters)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %net1 = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %mtpar, i32 0, i32 0
  store %struct.net* %net, %struct.net** %net1, align 8, !tbaa !161
  %table = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %mtpar, i32 0, i32 1
  store i8* %name, i8** %table, align 8, !tbaa !163
  %ipv6 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 0
  %1 = bitcast %struct.ip6t_ip6* %ipv6 to i8*
  %entryinfo = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %mtpar, i32 0, i32 2
  store i8* %1, i8** %entryinfo, align 8, !tbaa !164
  %comefrom = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 4
  %2 = load i32, i32* %comefrom, align 8, !tbaa !158
  %hook_mask = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %mtpar, i32 0, i32 5
  store i32 %2, i32* %hook_mask, align 8, !tbaa !165
  %family = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %mtpar, i32 0, i32 6
  store i8 10, i8* %family, align 4, !tbaa !166
  %elems = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 6
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %if.end
  %add.ptr10.sink = phi i8* [ %add.ptr10, %if.end7 ], [ %arraydecay, %if.end ]
  %j.0 = phi i32 [ 0, %if.end ], [ %inc, %if.end7 ]
  %3 = bitcast i8* %add.ptr10.sink to %struct.xt_entry_match*
  %4 = bitcast %struct.ip6t_entry* %e to i8*
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %5 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv = zext i16 %5 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %idx.ext
  %6 = bitcast i8* %add.ptr to %struct.xt_entry_match*
  %cmp = icmp ult %struct.xt_entry_match* %3, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call3 = call i32 @find_check_match(%struct.xt_entry_match* %3, %struct.xt_mtchk_param* %mtpar)
  %cmp4 = icmp ne i32 %call3, 0
  br i1 %cmp4, label %cleanup_matches, label %if.end7

if.end7:                                          ; preds = %for.body
  %inc = add i32 %j.0, 1
  %7 = bitcast %struct.xt_entry_match* %3 to i8*
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %3, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u to i16*
  %8 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv8 = zext i16 %8 to i32
  %idx.ext9 = sext i32 %conv8 to i64
  %add.ptr10 = getelementptr inbounds i8, i8* %7, i64 %idx.ext9
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call11 = call %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %e)
  %u12 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call11, i32 0, i32 0
  %user = bitcast %union.anon.99* %u12 to %struct.anon.104*
  %name13 = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %arraydecay14 = getelementptr inbounds [29 x i8], [29 x i8]* %name13, i32 0, i32 0
  %u15 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call11, i32 0, i32 0
  %user16 = bitcast %union.anon.99* %u15 to %struct.anon.104*
  %revision = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user16, i32 0, i32 2
  %9 = load i8, i8* %revision, align 1, !tbaa !76
  %call17 = call %struct.xt_target* @xt_request_find_target(i8 zeroext 10, i8* %arraydecay14, i8 zeroext %9)
  %10 = bitcast %struct.xt_target* %call17 to i8*
  %call18 = call zeroext i1 @IS_ERR.2(i8* %10)
  br i1 %call18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %for.end
  %11 = bitcast %struct.xt_target* %call17 to i8*
  %call20 = call i64 @PTR_ERR.3(i8* %11)
  %conv21 = trunc i64 %call20 to i32
  br label %cleanup_matches

if.end22:                                         ; preds = %for.end
  %u23 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call11, i32 0, i32 0
  %kernel = bitcast %union.anon.99* %u23 to %struct.anon.101*
  %target24 = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel, i32 0, i32 1
  store %struct.xt_target* %call17, %struct.xt_target** %target24, align 8, !tbaa !76
  %call25 = call i32 @check_target(%struct.ip6t_entry* %e, %struct.net* %net, i8* %name)
  %tobool = icmp ne i32 %call25, 0
  br i1 %tobool, label %err, label %cleanup

err:                                              ; preds = %if.end22
  %u28 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call11, i32 0, i32 0
  %kernel29 = bitcast %union.anon.99* %u28 to %struct.anon.101*
  %target30 = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel29, i32 0, i32 1
  %12 = load %struct.xt_target*, %struct.xt_target** %target30, align 8, !tbaa !76
  %me = getelementptr inbounds %struct.xt_target, %struct.xt_target* %12, i32 0, i32 8
  %13 = load %struct.module*, %struct.module** %me, align 8, !tbaa !144
  call void @module_put(%struct.module* %13)
  br label %cleanup_matches

cleanup_matches:                                  ; preds = %err, %if.then19, %for.body
  %ret.0 = phi i32 [ %conv21, %if.then19 ], [ %call25, %err ], [ %call3, %for.body ]
  %elems31 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 6
  %arraydecay32 = getelementptr inbounds [0 x i8], [0 x i8]* %elems31, i32 0, i32 0
  br label %for.cond33

for.cond33:                                       ; preds = %if.end44, %cleanup_matches
  %add.ptr50.sink = phi i8* [ %add.ptr50, %if.end44 ], [ %arraydecay32, %cleanup_matches ]
  %j.1 = phi i32 [ %j.0, %cleanup_matches ], [ %dec, %if.end44 ]
  %14 = bitcast i8* %add.ptr50.sink to %struct.xt_entry_match*
  %15 = bitcast %struct.ip6t_entry* %e to i8*
  %target_offset34 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %16 = load i16, i16* %target_offset34, align 4, !tbaa !94
  %conv35 = zext i16 %16 to i32
  %idx.ext36 = sext i32 %conv35 to i64
  %add.ptr37 = getelementptr inbounds i8, i8* %15, i64 %idx.ext36
  %17 = bitcast i8* %add.ptr37 to %struct.xt_entry_match*
  %cmp38 = icmp ult %struct.xt_entry_match* %14, %17
  br i1 %cmp38, label %for.body40, label %for.end51

for.body40:                                       ; preds = %for.cond33
  %dec = add i32 %j.1, -1
  %cmp41 = icmp eq i32 %j.1, 0
  br i1 %cmp41, label %for.end51, label %if.end44

if.end44:                                         ; preds = %for.body40
  call void @cleanup_match(%struct.xt_entry_match* %14, %struct.net* %net)
  %18 = bitcast %struct.xt_entry_match* %14 to i8*
  %u46 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %14, i32 0, i32 0
  %match_size47 = bitcast %union.anon.108* %u46 to i16*
  %19 = load i16, i16* %match_size47, align 8, !tbaa !76
  %conv48 = zext i16 %19 to i32
  %idx.ext49 = sext i32 %conv48 to i64
  %add.ptr50 = getelementptr inbounds i8, i8* %18, i64 %idx.ext49
  br label %for.cond33

for.end51:                                        ; preds = %for.body40, %for.cond33
  %counters52 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 5
  call void @xt_percpu_counter_free(%struct.timespec* %counters52)
  br label %cleanup

cleanup:                                          ; preds = %for.end51, %if.end22, %entry
  %retval.0 = phi i32 [ %ret.0, %for.end51 ], [ -12, %entry ], [ 0, %if.end22 ]
  %20 = bitcast %struct.xt_mtchk_param* %mtpar to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %20) #7
  ret i32 %retval.0
}

declare zeroext i1 @xt_percpu_counter_alloc(%struct.xt_percpu_counter_alloc_state*, %struct.timespec*) #1

; Function Attrs: nounwind uwtable
define internal i32 @find_check_match(%struct.xt_entry_match* %m, %struct.xt_mtchk_param* %par) #0 {
entry:
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %user = bitcast %union.anon.108* %u to %struct.anon.104*
  %name = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %arraydecay = getelementptr inbounds [29 x i8], [29 x i8]* %name, i32 0, i32 0
  %u1 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %user2 = bitcast %union.anon.108* %u1 to %struct.anon.104*
  %revision = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user2, i32 0, i32 2
  %0 = load i8, i8* %revision, align 1, !tbaa !76
  %call = call %struct.xt_match* @xt_request_find_match(i8 zeroext 10, i8* %arraydecay, i8 zeroext %0)
  %1 = bitcast %struct.xt_match* %call to i8*
  %call3 = call zeroext i1 @IS_ERR.2(i8* %1)
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.xt_match* %call to i8*
  %call4 = call i64 @PTR_ERR.3(i8* %2)
  %conv = trunc i64 %call4 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %u5 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %kernel = bitcast %union.anon.108* %u5 to %struct.anon.110*
  %match6 = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel, i32 0, i32 1
  store %struct.xt_match* %call, %struct.xt_match** %match6, align 8, !tbaa !76
  %call7 = call i32 @check_match(%struct.xt_entry_match* %m, %struct.xt_mtchk_param* %par)
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %err, label %cleanup

err:                                              ; preds = %if.end
  %u10 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %kernel11 = bitcast %union.anon.108* %u10 to %struct.anon.110*
  %match12 = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel11, i32 0, i32 1
  %3 = load %struct.xt_match*, %struct.xt_match** %match12, align 8, !tbaa !76
  %me = getelementptr inbounds %struct.xt_match, %struct.xt_match* %3, i32 0, i32 8
  %4 = load %struct.module*, %struct.module** %me, align 8, !tbaa !152
  call void @module_put(%struct.module* %4)
  br label %cleanup

cleanup:                                          ; preds = %err, %if.end, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ %call7, %err ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare %struct.xt_target* @xt_request_find_target(i8 zeroext, i8*, i8 zeroext) #1

; Function Attrs: nounwind uwtable
define internal i32 @check_target(%struct.ip6t_entry* %e, %struct.net* %net, i8* %name) #0 {
entry:
  %par = alloca %struct.xt_tgchk_param, align 8
  %call = call %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %e)
  %0 = bitcast %struct.xt_tgchk_param* %par to i8*
  call void @llvm.lifetime.start.p0i8(i64 48, i8* %0) #7
  %net1 = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 0
  store %struct.net* %net, %struct.net** %net1, align 8, !tbaa !167
  %table = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 1
  store i8* %name, i8** %table, align 8, !tbaa !169
  %entryinfo = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 2
  %1 = bitcast %struct.ip6t_entry* %e to i8*
  store i8* %1, i8** %entryinfo, align 8, !tbaa !170
  %target = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 3
  %u = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call, i32 0, i32 0
  %kernel = bitcast %union.anon.99* %u to %struct.anon.101*
  %target2 = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel, i32 0, i32 1
  %2 = load %struct.xt_target*, %struct.xt_target** %target2, align 8, !tbaa !76
  store %struct.xt_target* %2, %struct.xt_target** %target, align 8, !tbaa !171
  %targinfo = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 4
  %data = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  store i8* %arraydecay, i8** %targinfo, align 8, !tbaa !172
  %hook_mask = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 5
  %comefrom = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 4
  %3 = load i32, i32* %comefrom, align 8, !tbaa !158
  store i32 %3, i32* %hook_mask, align 8, !tbaa !173
  %family = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 6
  store i8 10, i8* %family, align 4, !tbaa !174
  %nft_compat = getelementptr inbounds %struct.xt_tgchk_param, %struct.xt_tgchk_param* %par, i32 0, i32 7
  store i8 0, i8* %nft_compat, align 1, !tbaa !175
  %call3 = call %struct.xt_entry_target* @ip6t_get_target(%struct.ip6t_entry* %e)
  %u4 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call3, i32 0, i32 0
  %target_size = bitcast %union.anon.99* %u4 to i16*
  %4 = load i16, i16* %target_size, align 8, !tbaa !76
  %conv = zext i16 %4 to i64
  %sub = sub i64 %conv, 32
  %conv5 = trunc i64 %sub to i32
  %ipv6 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 0
  %proto = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ipv6, i32 0, i32 8
  %5 = load i16, i16* %proto, align 8, !tbaa !176
  %conv6 = trunc i16 %5 to i8
  %ipv67 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 0
  %invflags = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ipv67, i32 0, i32 11
  %6 = load i8, i8* %invflags, align 4, !tbaa !177
  %conv8 = zext i8 %6 to i32
  %and = and i32 %conv8, 64
  %tobool = icmp ne i32 %and, 0
  %call9 = call i32 @xt_check_target(%struct.xt_tgchk_param* %par, i32 %conv5, i8 zeroext %conv6, i1 zeroext %tobool)
  %7 = bitcast %struct.xt_tgchk_param* %par to i8*
  call void @llvm.lifetime.end.p0i8(i64 48, i8* %7) #7
  ret i32 %call9
}

declare i32 @xt_check_target(%struct.xt_tgchk_param*, i32, i8 zeroext, i1 zeroext) #1

declare %struct.xt_match* @xt_request_find_match(i8 zeroext, i8*, i8 zeroext) #1

; Function Attrs: nounwind uwtable
define internal i32 @check_match(%struct.xt_entry_match* %m, %struct.xt_mtchk_param* %par) #0 {
entry:
  %entryinfo = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %par, i32 0, i32 2
  %0 = load i8*, i8** %entryinfo, align 8, !tbaa !164
  %1 = bitcast i8* %0 to %struct.ip6t_ip6*
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %kernel = bitcast %union.anon.108* %u to %struct.anon.110*
  %match = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel, i32 0, i32 1
  %2 = load %struct.xt_match*, %struct.xt_match** %match, align 8, !tbaa !76
  %match1 = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %par, i32 0, i32 3
  store %struct.xt_match* %2, %struct.xt_match** %match1, align 8, !tbaa !178
  %data = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  %matchinfo = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %par, i32 0, i32 4
  store i8* %arraydecay, i8** %matchinfo, align 8, !tbaa !179
  %u2 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u2 to i16*
  %3 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv = zext i16 %3 to i64
  %sub = sub i64 %conv, 32
  %conv3 = trunc i64 %sub to i32
  %proto = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %1, i32 0, i32 8
  %4 = load i16, i16* %proto, align 4, !tbaa !180
  %conv4 = trunc i16 %4 to i8
  %invflags = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %1, i32 0, i32 11
  %5 = load i8, i8* %invflags, align 4, !tbaa !181
  %conv5 = zext i8 %5 to i32
  %and = and i32 %conv5, 64
  %tobool = icmp ne i32 %and, 0
  %call = call i32 @xt_check_match(%struct.xt_mtchk_param* %par, i32 %conv3, i8 zeroext %conv4, i1 zeroext %tobool)
  ret i32 %call
}

declare i32 @xt_check_match(%struct.xt_mtchk_param*, i32, i8 zeroext, i1 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @unconditional(%struct.ip6t_entry* %e) #2 {
entry:
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 2
  %0 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv = zext i16 %0 to i64
  %cmp = icmp eq i64 %conv, 168
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %ipv6 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e, i32 0, i32 0
  %1 = bitcast %struct.ip6t_ip6* %ipv6 to i8*
  %call = call i32 @memcmp(i8* %1, i8* bitcast (%struct.ip6t_ip6* @unconditional.uncond to i8*), i64 136)
  %cmp2 = icmp eq i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  ret i1 %2
}

declare zeroext i1 @xt_find_jump_offset(i32*, i32, i32) #1

declare i32 @memcmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @ip6_checkentry(%struct.ip6t_ip6* %ipv6) #0 {
entry:
  %flags = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ipv6, i32 0, i32 10
  %0 = load i8, i8* %flags, align 1, !tbaa !182
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, -8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %invflags = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ipv6, i32 0, i32 11
  %1 = load i8, i8* %invflags, align 4, !tbaa !181
  %conv1 = zext i8 %1 to i32
  %and2 = and i32 %conv1, -128
  %tobool3 = icmp ne i32 %and2, 0
  %. = select i1 %tobool3, i1 false, i1 true
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i1 [ false, %entry ], [ %., %if.end ]
  ret i1 %retval.0
}

declare i32 @xt_check_entry_offsets(i8*, i8*, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @check_underflow(%struct.ip6t_entry* %e) #0 {
entry:
  %call = call zeroext i1 @unconditional(%struct.ip6t_entry* %e)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call %struct.xt_entry_target* @ip6t_get_target_c(%struct.ip6t_entry* %e)
  %u = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call1, i32 0, i32 0
  %user = bitcast %union.anon.99* %u to %struct.anon.104*
  %name = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %arraydecay = getelementptr inbounds [29 x i8], [29 x i8]* %name, i32 0, i32 0
  %call2 = call i32 @strcmp(i8* %arraydecay, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.6, i32 0, i32 0))
  %cmp = icmp ne i32 %call2, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %0 = bitcast %struct.xt_entry_target* %call1 to %struct.xt_standard_target*
  %verdict5 = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %0, i32 0, i32 1
  %1 = load i32, i32* %verdict5, align 8, !tbaa !160
  %sub = sub i32 0, %1
  %sub6 = sub i32 %sub, 1
  %cmp7 = icmp eq i32 %sub6, 0
  %cmp8 = icmp eq i32 %sub6, 1
  %.cmp8 = select i1 %cmp7, i1 true, i1 %cmp8
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.end, %entry
  %retval.0 = phi i1 [ %.cmp8, %if.end4 ], [ false, %entry ], [ false, %if.end ]
  ret i1 %retval.0
}

declare void @xt_compat_match_from_user(%struct.xt_entry_match*, i8**, i32*) #1

declare void @xt_compat_target_from_user(%struct.xt_entry_target*, i8**, i32*) #1

declare i32 @xt_compat_check_entry_offsets(i8*, i8*, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @compat_find_calc_match(%struct.xt_entry_match* %m, %struct.ip6t_ip6* %ipv6, i32* %size) #0 {
entry:
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %user = bitcast %union.anon.108* %u to %struct.anon.104*
  %name = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %arraydecay = getelementptr inbounds [29 x i8], [29 x i8]* %name, i32 0, i32 0
  %u1 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %user2 = bitcast %union.anon.108* %u1 to %struct.anon.104*
  %revision = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user2, i32 0, i32 2
  %0 = load i8, i8* %revision, align 1, !tbaa !76
  %call = call %struct.xt_match* @xt_request_find_match(i8 zeroext 10, i8* %arraydecay, i8 zeroext %0)
  %1 = bitcast %struct.xt_match* %call to i8*
  %call3 = call zeroext i1 @IS_ERR.2(i8* %1)
  br i1 %call3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = bitcast %struct.xt_match* %call to i8*
  %call4 = call i64 @PTR_ERR.3(i8* %2)
  %conv = trunc i64 %call4 to i32
  br label %cleanup

if.end:                                           ; preds = %entry
  %u5 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %m, i32 0, i32 0
  %kernel = bitcast %union.anon.108* %u5 to %struct.anon.110*
  %match6 = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel, i32 0, i32 1
  store %struct.xt_match* %call, %struct.xt_match** %match6, align 8, !tbaa !76
  %call7 = call i32 @xt_compat_match_offset(%struct.xt_match* %call)
  %3 = load i32, i32* %size, align 4, !tbaa !75
  %add = add nsw i32 %3, %call7
  store i32 %add, i32* %size, align 4, !tbaa !75
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @do_replace(%struct.net* %net, i8* %user, i32 %len) #0 {
entry:
  %tmp = alloca %struct.ip6t_replace, align 8
  %0 = bitcast %struct.ip6t_replace* %tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* %0) #7
  %1 = bitcast %struct.ip6t_replace* %tmp to i8*
  %call = call i64 @copy_from_user(i8* %1, i8* %user, i64 96)
  %cmp = icmp ne i64 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %num_counters = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 6
  %2 = load i32, i32* %num_counters, align 4, !tbaa !133
  %conv = zext i32 %2 to i64
  %cmp1 = icmp uge i64 %conv, 134217727
  br i1 %cmp1, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.end
  %num_counters5 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 6
  %3 = load i32, i32* %num_counters5, align 4, !tbaa !133
  %cmp6 = icmp eq i32 %3, 0
  br i1 %cmp6, label %cleanup, label %if.end9

if.end9:                                          ; preds = %if.end4
  %name = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 0
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %name, i64 0, i64 31
  store i8 0, i8* %arrayidx, align 1, !tbaa !76
  %size = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 3
  %4 = load i32, i32* %size, align 8, !tbaa !136
  %call10 = call %struct.xt_table_info* @xt_alloc_table_info(i32 %4)
  %tobool = icmp ne %struct.xt_table_info* %call10, null
  br i1 %tobool, label %if.end12, label %cleanup

if.end12:                                         ; preds = %if.end9
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call10, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  %add.ptr = getelementptr i8, i8* %user, i64 96
  %size13 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 3
  %5 = load i32, i32* %size13, align 8, !tbaa !136
  %conv14 = zext i32 %5 to i64
  %call15 = call i64 @copy_from_user(i8* %arraydecay, i8* %add.ptr, i64 %conv14)
  %cmp16 = icmp ne i64 %call15, 0
  br i1 %cmp16, label %free_newinfo, label %if.end19

if.end19:                                         ; preds = %if.end12
  %call20 = call i32 @translate_table(%struct.net* %net, %struct.xt_table_info* %call10, i8* %arraydecay, %struct.ip6t_replace* %tmp)
  %cmp21 = icmp ne i32 %call20, 0
  br i1 %cmp21, label %free_newinfo, label %if.end24

if.end24:                                         ; preds = %if.end19
  %name25 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 0
  %arraydecay26 = getelementptr inbounds [32 x i8], [32 x i8]* %name25, i32 0, i32 0
  %valid_hooks = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 1
  %6 = load i32, i32* %valid_hooks, align 8, !tbaa !155
  %num_counters27 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 6
  %7 = load i32, i32* %num_counters27, align 4, !tbaa !133
  %counters = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %tmp, i32 0, i32 7
  %8 = load %struct.timespec*, %struct.timespec** %counters, align 8, !tbaa !135
  %9 = bitcast %struct.timespec* %8 to i8*
  %call28 = call i32 @__do_replace(%struct.net* %net, i8* %arraydecay26, i32 %6, %struct.xt_table_info* %call10, i32 %7, i8* %9)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %free_newinfo_untrans, label %cleanup

free_newinfo_untrans:                             ; preds = %if.end24
  br label %for.cond

for.cond:                                         ; preds = %for.body, %free_newinfo_untrans
  %add.ptr38.sink = phi i8* [ %add.ptr38, %for.body ], [ %arraydecay, %free_newinfo_untrans ]
  %10 = bitcast i8* %add.ptr38.sink to %struct.ip6t_entry*
  %size32 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call10, i32 0, i32 0
  %11 = load i32, i32* %size32, align 8, !tbaa !87
  %idx.ext = zext i32 %11 to i64
  %add.ptr33 = getelementptr inbounds i8, i8* %arraydecay, i64 %idx.ext
  %12 = bitcast i8* %add.ptr33 to %struct.ip6t_entry*
  %cmp34 = icmp ult %struct.ip6t_entry* %10, %12
  br i1 %cmp34, label %for.body, label %free_newinfo

for.body:                                         ; preds = %for.cond
  call void @cleanup_entry(%struct.ip6t_entry* %10, %struct.net* %net)
  %13 = bitcast %struct.ip6t_entry* %10 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %10, i32 0, i32 3
  %14 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv36 = zext i16 %14 to i32
  %idx.ext37 = sext i32 %conv36 to i64
  %add.ptr38 = getelementptr inbounds i8, i8* %13, i64 %idx.ext37
  br label %for.cond

free_newinfo:                                     ; preds = %for.cond, %if.end19, %if.end12
  %ret.0 = phi i32 [ -14, %if.end12 ], [ %call20, %if.end19 ], [ %call28, %for.cond ]
  call void @xt_free_table_info(%struct.xt_table_info* %call10)
  br label %cleanup

cleanup:                                          ; preds = %free_newinfo, %if.end24, %if.end9, %if.end4, %if.end, %entry
  %retval.0 = phi i32 [ %ret.0, %free_newinfo ], [ -14, %entry ], [ -12, %if.end ], [ -22, %if.end4 ], [ -12, %if.end9 ], [ 0, %if.end24 ]
  %15 = bitcast %struct.ip6t_replace* %tmp to i8*
  call void @llvm.lifetime.end.p0i8(i64 96, i8* %15) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @icmp6_match(%struct.sk_buff* %skb, %struct.xt_action_param* %par) #0 {
entry:
  %_icmph = alloca %struct.icmp6hdr, align 4
  %0 = bitcast %struct.icmp6hdr* %_icmph to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %par, i32 0, i32 1
  %matchinfo = bitcast %union.anon.88* %1 to i8**
  %2 = load i8*, i8** %matchinfo, align 8, !tbaa !76
  %3 = bitcast i8* %2 to %struct.ip6t_icmp*
  %fragoff = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %par, i32 0, i32 3
  %4 = load i32, i32* %fragoff, align 8, !tbaa !183
  %cmp = icmp ne i32 %4, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %thoff = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %par, i32 0, i32 4
  %5 = load i32, i32* %thoff, align 4, !tbaa !185
  %6 = bitcast %struct.icmp6hdr* %_icmph to i8*
  %call = call i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 %5, i32 8, i8* %6)
  %7 = bitcast i8* %call to %struct.icmp6hdr*
  %cmp1 = icmp eq %struct.icmp6hdr* %7, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %hotdrop = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %par, i32 0, i32 5
  store i8 1, i8* %hotdrop, align 8, !tbaa !186
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %type = getelementptr inbounds %struct.ip6t_icmp, %struct.ip6t_icmp* %3, i32 0, i32 0
  %8 = load i8, i8* %type, align 1, !tbaa !187
  %code = getelementptr inbounds %struct.ip6t_icmp, %struct.ip6t_icmp* %3, i32 0, i32 1
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %code, i64 0, i64 0
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !76
  %code4 = getelementptr inbounds %struct.ip6t_icmp, %struct.ip6t_icmp* %3, i32 0, i32 1
  %arrayidx5 = getelementptr inbounds [2 x i8], [2 x i8]* %code4, i64 0, i64 1
  %10 = load i8, i8* %arrayidx5, align 1, !tbaa !76
  %icmp6_type = getelementptr inbounds %struct.icmp6hdr, %struct.icmp6hdr* %7, i32 0, i32 0
  %11 = load i8, i8* %icmp6_type, align 4, !tbaa !189
  %icmp6_code = getelementptr inbounds %struct.icmp6hdr, %struct.icmp6hdr* %7, i32 0, i32 1
  %12 = load i8, i8* %icmp6_code, align 1, !tbaa !191
  %invflags = getelementptr inbounds %struct.ip6t_icmp, %struct.ip6t_icmp* %3, i32 0, i32 2
  %13 = load i8, i8* %invflags, align 1, !tbaa !192
  %conv = zext i8 %13 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %call7 = call zeroext i1 @icmp6_type_code_match(i8 zeroext %8, i8 zeroext %9, i8 zeroext %10, i8 zeroext %11, i8 zeroext %12, i1 zeroext %lnot6)
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.then2, %entry
  %retval.0 = phi i1 [ false, %if.then2 ], [ %call7, %if.end3 ], [ false, %entry ]
  %14 = bitcast %struct.icmp6hdr* %_icmph to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #7
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @icmp6_checkentry(%struct.xt_mtchk_param* %par) #0 {
entry:
  %matchinfo = getelementptr inbounds %struct.xt_mtchk_param, %struct.xt_mtchk_param* %par, i32 0, i32 4
  %0 = load i8*, i8** %matchinfo, align 8, !tbaa !179
  %1 = bitcast i8* %0 to %struct.ip6t_icmp*
  %invflags = getelementptr inbounds %struct.ip6t_icmp, %struct.ip6t_icmp* %1, i32 0, i32 2
  %2 = load i8, i8* %invflags, align 1, !tbaa !192
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, -2
  %tobool = icmp ne i32 %and, 0
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 -22, i32 0
  ret i32 %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %buffer) #2 {
entry:
  %data = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 40
  %0 = load i8*, i8** %data, align 8, !tbaa !193
  %call = call i32 @skb_headlen(%struct.sk_buff* %skb)
  %call1 = call i8* @__skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %0, i32 %call, i8* %buffer)
  ret i8* %call1
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @icmp6_type_code_match(i8 zeroext %test_type, i8 zeroext %min_code, i8 zeroext %max_code, i8 zeroext %type, i8 zeroext %code, i1 zeroext %invert) #2 {
entry:
  %frombool = zext i1 %invert to i8
  %conv = zext i8 %type to i32
  %conv1 = zext i8 %test_type to i32
  %cmp = icmp eq i32 %conv, %conv1
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %conv3 = zext i8 %code to i32
  %conv4 = zext i8 %min_code to i32
  %cmp5 = icmp sge i32 %conv3, %conv4
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %conv7 = zext i8 %code to i32
  %conv8 = zext i8 %max_code to i32
  %cmp9 = icmp sle i32 %conv7, %conv8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %0 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp9, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  %tobool = trunc i8 %frombool to i1
  %conv11 = zext i1 %tobool to i32
  %xor = xor i32 %land.ext, %conv11
  %tobool12 = icmp ne i32 %xor, 0
  ret i1 %tobool12
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @skb_headlen(%struct.sk_buff* %skb) #2 {
entry:
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %0 = load i32, i32* %len, align 8, !tbaa !195
  %data_len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 9
  %1 = load i32, i32* %data_len, align 4, !tbaa !196
  %sub = sub i32 %0, %1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @__skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %data, i32 %hlen, i8* %buffer) #2 {
entry:
  %sub = sub nsw i32 %hlen, %offset
  %cmp = icmp sge i32 %sub, %len
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idx.ext = sext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %data, i64 %idx.ext
  br label %return

if.end:                                           ; preds = %entry
  %tobool = icmp ne %struct.sk_buff* %skb, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.end
  %call = call i32 @skb_copy_bits(%struct.sk_buff* %skb, i32 %offset, i8* %buffer, i32 %len)
  %cmp1 = icmp slt i32 %call, 0
  %.buffer = select i1 %cmp1, i8* null, i8* %buffer
  ret i8* %.buffer

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %add.ptr, %if.then ], [ null, %if.end ]
  ret i8* %retval.0
}

declare i32 @skb_copy_bits(%struct.sk_buff*, i32, i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @compat_standard_from_user(i8* %dst, i8* %src) #0 {
entry:
  %v = alloca i32, align 4
  %0 = bitcast i32* %v to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i8* %src to i32*
  %2 = load i32, i32* %1, align 4, !tbaa !75
  store i32 %2, i32* %v, align 4, !tbaa !75
  %3 = load i32, i32* %v, align 4, !tbaa !75
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %v, align 4, !tbaa !75
  %call = call i32 @xt_compat_calc_jump(i8 zeroext 10, i32 %4)
  %5 = load i32, i32* %v, align 4, !tbaa !75
  %add = add nsw i32 %5, %call
  store i32 %add, i32* %v, align 4, !tbaa !75
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cmp1 = icmp uge i64 4, 64
  %6 = bitcast i32* %v to i8*
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %call3 = call i8* @__memcpy(i8* %dst, i8* %6, i64 4)
  br label %if.end4

if.else:                                          ; preds = %if.end
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %6, i64 4, i32 1, i1 false)
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then2
  %__ret.0 = phi i8* [ %call3, %if.then2 ], [ %dst, %if.else ]
  %7 = bitcast i32* %v to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @compat_standard_to_user(i8* %dst, i8* %src) #0 {
entry:
  %cv = alloca i32, align 4
  %0 = bitcast i32* %cv to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i8* %src to i32*
  %2 = load i32, i32* %1, align 4, !tbaa !75
  store i32 %2, i32* %cv, align 4, !tbaa !75
  %3 = load i32, i32* %cv, align 4, !tbaa !75
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %cv, align 4, !tbaa !75
  %call = call i32 @xt_compat_calc_jump(i8 zeroext 10, i32 %4)
  %5 = load i32, i32* %cv, align 4, !tbaa !75
  %sub = sub nsw i32 %5, %call
  store i32 %sub, i32* %cv, align 4, !tbaa !75
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = bitcast i32* %cv to i8*
  %call1 = call i64 @copy_to_user(i8* %dst, i8* %6, i64 4)
  %tobool = icmp ne i64 %call1, 0
  %7 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 -14, i32 0
  %8 = bitcast i32* %cv to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #7
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define internal i32 @ip6t_error(%struct.sk_buff* %skb, %struct.xt_action_param* %par) #0 {
entry:
  %call = call i32 @net_ratelimit()
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %0 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %par, i32 0, i32 1
  %targinfo = bitcast %union.anon.88* %0 to i8**
  %1 = load i8*, i8** %targinfo, align 8, !tbaa !76
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.12, i32 0, i32 0), i8* %1)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

declare i32 @xt_compat_calc_jump(i8 zeroext, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @ip6_tables_net_init(%struct.net* %net) #0 {
entry:
  %call = call i32 @xt_proto_init(%struct.net* %net, i8 zeroext 10)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @ip6_tables_net_exit(%struct.net* %net) #0 {
entry:
  call void @xt_proto_fini(%struct.net* %net, i8 zeroext 10)
  ret void
}

declare void @xt_proto_fini(%struct.net*, i8 zeroext) #1

declare i32 @xt_proto_init(%struct.net*, i8 zeroext) #1

; Function Attrs: nounwind uwtable
define i32 @ip6t_do_table(%struct.sk_buff* %skb, %struct.nf_hook_state* %state, %struct.xt_table* %table) #0 {
entry:
  %acpar = alloca %struct.xt_action_param, align 8
  %hook1 = getelementptr inbounds %struct.nf_hook_state, %struct.nf_hook_state* %state, i32 0, i32 0
  %0 = load i32, i32* %hook1, align 8, !tbaa !197
  %1 = bitcast %struct.xt_action_param* %acpar to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %1) #7
  %in = getelementptr inbounds %struct.nf_hook_state, %struct.nf_hook_state* %state, i32 0, i32 2
  %2 = load %struct.net_device*, %struct.net_device** %in, align 8, !tbaa !198
  %tobool = icmp ne %struct.net_device* %2, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %in2 = getelementptr inbounds %struct.nf_hook_state, %struct.nf_hook_state* %state, i32 0, i32 2
  %3 = load %struct.net_device*, %struct.net_device** %in2, align 8, !tbaa !198
  %name = getelementptr inbounds %struct.net_device, %struct.net_device* %3, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %name, i32 0, i32 0
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i8* [ %arraydecay, %cond.true ], [ getelementptr inbounds ([16 x i8], [16 x i8]* @ip6t_do_table.nulldevname, i32 0, i32 0), %entry ]
  %out = getelementptr inbounds %struct.nf_hook_state, %struct.nf_hook_state* %state, i32 0, i32 3
  %4 = load %struct.net_device*, %struct.net_device** %out, align 8, !tbaa !199
  %tobool3 = icmp ne %struct.net_device* %4, null
  br i1 %tobool3, label %cond.true4, label %cond.end9

cond.true4:                                       ; preds = %cond.end
  %out5 = getelementptr inbounds %struct.nf_hook_state, %struct.nf_hook_state* %state, i32 0, i32 3
  %5 = load %struct.net_device*, %struct.net_device** %out5, align 8, !tbaa !199
  %name6 = getelementptr inbounds %struct.net_device, %struct.net_device* %5, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [16 x i8], [16 x i8]* %name6, i32 0, i32 0
  br label %cond.end9

cond.end9:                                        ; preds = %cond.true4, %cond.end
  %cond10 = phi i8* [ %arraydecay7, %cond.true4 ], [ getelementptr inbounds ([16 x i8], [16 x i8]* @ip6t_do_table.nulldevname, i32 0, i32 0), %cond.end ]
  %hotdrop = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 5
  store i8 0, i8* %hotdrop, align 8, !tbaa !186
  %state11 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 2
  store %struct.nf_hook_state* %state, %struct.nf_hook_state** %state11, align 8, !tbaa !200
  call void @local_bh_disable()
  %call = call i32 @xt_write_recseq_begin()
  %private12 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %table, i32 0, i32 2
  %6 = load %struct.xt_table_info*, %struct.xt_table_info** %private12, align 8, !tbaa !79
  %7 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !201
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 7
  %arraydecay17 = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  %jumpstack18 = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 6
  %8 = load i8***, i8**** %jumpstack18, align 8, !tbaa !202
  %idxprom = zext i32 %7 to i64
  %arrayidx = getelementptr inbounds i8**, i8*** %8, i64 %idxprom
  %9 = load i8**, i8*** %arrayidx, align 8, !tbaa !2
  %10 = bitcast i8** %9 to %struct.ip6t_entry**
  %call19 = call zeroext i1 @static_key_false(%struct.qspinlock* @xt_tee_enabled)
  br i1 %call19, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end9
  %stacksize = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 5
  %11 = load i32, i32* %stacksize, align 4, !tbaa !156
  call void @__this_cpu_preempt_check(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0))
  %12 = call i8 asm "movb %gs:$1,$0", "=q,*m,~{dirflag},~{fpsr},~{flags}"(i8* @nf_skb_duplicated) #8, !srcloc !203
  %tobool28 = trunc i8 %12 to i1
  %frombool = zext i1 %tobool28 to i8
  %tobool29 = trunc i8 %frombool to i1
  %frombool30 = zext i1 %tobool29 to i8
  %tobool32 = trunc i8 %frombool30 to i1
  %frombool33 = zext i1 %tobool32 to i8
  %tobool34 = trunc i8 %frombool33 to i1
  %frombool35 = zext i1 %tobool34 to i8
  %tobool36 = trunc i8 %frombool35 to i1
  %conv = zext i1 %tobool36 to i32
  %mul = mul i32 %11, %conv
  %idx.ext = zext i32 %mul to i64
  %add.ptr = getelementptr inbounds %struct.ip6t_entry*, %struct.ip6t_entry** %10, i64 %idx.ext
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end9
  %jumpstack.0 = phi %struct.ip6t_entry** [ %add.ptr, %if.then ], [ %10, %cond.end9 ]
  %hook_entry = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 3
  %idxprom37 = zext i32 %0 to i64
  %arrayidx38 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom37
  %13 = load i32, i32* %arrayidx38, align 4, !tbaa !75
  %call39 = call %struct.ip6t_entry* @get_entry(i8* %arraydecay17, i32 %13)
  br label %do.body40

do.body40:                                        ; preds = %do.cond129, %if.end
  %e.0 = phi %struct.ip6t_entry* [ %call39, %if.end ], [ %e.3, %do.cond129 ]
  %verdict.0 = phi i32 [ 0, %if.end ], [ %verdict.2, %do.cond129 ]
  %stackidx.0 = phi i32 [ 0, %if.end ], [ %stackidx.4, %do.cond129 ]
  %thoff = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 4
  store i32 0, i32* %thoff, align 4, !tbaa !185
  %ipv6 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 0
  %thoff41 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 4
  %fragoff = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 3
  %hotdrop42 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 5
  %call43 = call zeroext i1 @ip6_packet_match(%struct.sk_buff* %skb, i8* %cond, i8* %cond10, %struct.ip6t_ip6* %ipv6, i32* %thoff41, i32* %fragoff, i8* %hotdrop42)
  br i1 %call43, label %if.end46, label %no_match

no_match:                                         ; preds = %for.body, %do.body40
  %call45 = call %struct.ip6t_entry* @ip6t_next_entry(%struct.ip6t_entry* %e.0)
  br label %cleanup126

if.end46:                                         ; preds = %do.body40
  %elems = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 6
  %arraydecay47 = getelementptr inbounds [0 x i8], [0 x i8]* %elems, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end46
  %add.ptr62.sink = phi i8* [ %add.ptr62, %for.inc ], [ %arraydecay47, %if.end46 ]
  %14 = bitcast i8* %add.ptr62.sink to %struct.xt_entry_match*
  %15 = bitcast %struct.ip6t_entry* %e.0 to i8*
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 2
  %16 = load i16, i16* %target_offset, align 4, !tbaa !94
  %conv48 = zext i16 %16 to i32
  %idx.ext49 = sext i32 %conv48 to i64
  %add.ptr50 = getelementptr inbounds i8, i8* %15, i64 %idx.ext49
  %17 = bitcast i8* %add.ptr50 to %struct.xt_entry_match*
  %cmp = icmp ult %struct.xt_entry_match* %14, %17
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %u = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %14, i32 0, i32 0
  %kernel = bitcast %union.anon.108* %u to %struct.anon.110*
  %match = getelementptr inbounds %struct.anon.110, %struct.anon.110* %kernel, i32 0, i32 1
  %18 = load %struct.xt_match*, %struct.xt_match** %match, align 8, !tbaa !76
  %19 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 0
  %match52 = bitcast %union.anon.102* %19 to %struct.xt_match**
  store %struct.xt_match* %18, %struct.xt_match** %match52, align 8, !tbaa !76
  %data = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %14, i32 0, i32 1
  %arraydecay53 = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  %20 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 1
  %matchinfo = bitcast %union.anon.88* %20 to i8**
  store i8* %arraydecay53, i8** %matchinfo, align 8, !tbaa !76
  %21 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 0
  %match54 = bitcast %union.anon.102* %21 to %struct.xt_match**
  %22 = load %struct.xt_match*, %struct.xt_match** %match54, align 8, !tbaa !76
  %match55 = getelementptr inbounds %struct.xt_match, %struct.xt_match* %22, i32 0, i32 3
  %23 = load i1 (%struct.sk_buff*, %struct.xt_action_param*)*, i1 (%struct.sk_buff*, %struct.xt_action_param*)** %match55, align 8, !tbaa !204
  %call56 = call zeroext i1 %23(%struct.sk_buff* %skb, %struct.xt_action_param* %acpar)
  br i1 %call56, label %for.inc, label %no_match

for.inc:                                          ; preds = %for.body
  %24 = bitcast %struct.xt_entry_match* %14 to i8*
  %u59 = getelementptr inbounds %struct.xt_entry_match, %struct.xt_entry_match* %14, i32 0, i32 0
  %match_size = bitcast %union.anon.108* %u59 to i16*
  %25 = load i16, i16* %match_size, align 8, !tbaa !76
  %conv60 = zext i16 %25 to i32
  %idx.ext61 = sext i32 %conv60 to i64
  %add.ptr62 = getelementptr inbounds i8, i8* %24, i64 %idx.ext61
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %counters = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 5
  %call63 = call %struct.timespec* @xt_get_this_cpu_counter(%struct.timespec* %counters)
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %26 = load i32, i32* %len, align 8, !tbaa !195
  %conv65 = zext i32 %26 to i64
  %bcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %call63, i32 0, i32 1
  %27 = load i64, i64* %bcnt, align 8, !tbaa !99
  %add = add i64 %27, %conv65
  store i64 %add, i64* %bcnt, align 8, !tbaa !99
  %pcnt = getelementptr inbounds %struct.timespec, %struct.timespec* %call63, i32 0, i32 0
  %28 = load i64, i64* %pcnt, align 8, !tbaa !100
  %add66 = add i64 %28, 1
  store i64 %add66, i64* %pcnt, align 8, !tbaa !100
  %call69 = call %struct.xt_entry_target* @ip6t_get_target_c(%struct.ip6t_entry* %e.0)
  %u70 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call69, i32 0, i32 0
  %kernel71 = bitcast %union.anon.99* %u70 to %struct.anon.101*
  %target = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel71, i32 0, i32 1
  %29 = load %struct.xt_target*, %struct.xt_target** %target, align 8, !tbaa !76
  %target72 = getelementptr inbounds %struct.xt_target, %struct.xt_target* %29, i32 0, i32 3
  %30 = load i32 (%struct.sk_buff*, %struct.xt_action_param*)*, i32 (%struct.sk_buff*, %struct.xt_action_param*)** %target72, align 8, !tbaa !205
  %tobool73 = icmp ne i32 (%struct.sk_buff*, %struct.xt_action_param*)* %30, null
  br i1 %tobool73, label %if.end108, label %if.then74

if.then74:                                        ; preds = %for.end
  %31 = bitcast %struct.xt_entry_target* %call69 to %struct.xt_standard_target*
  %verdict75 = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %31, i32 0, i32 1
  %32 = load i32, i32* %verdict75, align 8, !tbaa !160
  %cmp76 = icmp slt i32 %32, 0
  br i1 %cmp76, label %if.then78, label %if.end94

if.then78:                                        ; preds = %if.then74
  %cmp79 = icmp ne i32 %32, -5
  br i1 %cmp79, label %if.then81, label %if.end83

if.then81:                                        ; preds = %if.then78
  %sub = sub nsw i32 0, %32
  %sub82 = sub i32 %sub, 1
  br label %cleanup126

if.end83:                                         ; preds = %if.then78
  %cmp84 = icmp eq i32 %stackidx.0, 0
  br i1 %cmp84, label %if.then86, label %if.else

if.then86:                                        ; preds = %if.end83
  %underflow = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %6, i32 0, i32 4
  %idxprom87 = zext i32 %0 to i64
  %arrayidx88 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i64 0, i64 %idxprom87
  %33 = load i32, i32* %arrayidx88, align 4, !tbaa !75
  %call89 = call %struct.ip6t_entry* @get_entry(i8* %arraydecay17, i32 %33)
  br label %cleanup126

if.else:                                          ; preds = %if.end83
  %dec = add i32 %stackidx.0, -1
  %idxprom90 = zext i32 %dec to i64
  %arrayidx91 = getelementptr inbounds %struct.ip6t_entry*, %struct.ip6t_entry** %jumpstack.0, i64 %idxprom90
  %34 = load %struct.ip6t_entry*, %struct.ip6t_entry** %arrayidx91, align 8, !tbaa !2
  %call92 = call %struct.ip6t_entry* @ip6t_next_entry(%struct.ip6t_entry* %34)
  br label %cleanup126

if.end94:                                         ; preds = %if.then74
  %idx.ext95 = sext i32 %32 to i64
  %add.ptr96 = getelementptr i8, i8* %arraydecay17, i64 %idx.ext95
  %call97 = call %struct.ip6t_entry* @ip6t_next_entry(%struct.ip6t_entry* %e.0)
  %35 = bitcast %struct.ip6t_entry* %call97 to i8*
  %cmp98 = icmp ne i8* %add.ptr96, %35
  br i1 %cmp98, label %land.lhs.true, label %if.end106

land.lhs.true:                                    ; preds = %if.end94
  %ipv6100 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %e.0, i32 0, i32 0
  %flags = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ipv6100, i32 0, i32 10
  %36 = load i8, i8* %flags, align 1, !tbaa !206
  %conv101 = zext i8 %36 to i32
  %and = and i32 %conv101, 4
  %tobool102 = icmp ne i32 %and, 0
  br i1 %tobool102, label %if.end106, label %if.then103

if.then103:                                       ; preds = %land.lhs.true
  %inc = add i32 %stackidx.0, 1
  %idxprom104 = zext i32 %stackidx.0 to i64
  %arrayidx105 = getelementptr inbounds %struct.ip6t_entry*, %struct.ip6t_entry** %jumpstack.0, i64 %idxprom104
  store %struct.ip6t_entry* %e.0, %struct.ip6t_entry** %arrayidx105, align 8, !tbaa !2
  br label %if.end106

if.end106:                                        ; preds = %if.then103, %land.lhs.true, %if.end94
  %stackidx.2 = phi i32 [ %stackidx.0, %land.lhs.true ], [ %inc, %if.then103 ], [ %stackidx.0, %if.end94 ]
  %call107 = call %struct.ip6t_entry* @get_entry(i8* %arraydecay17, i32 %32)
  br label %cleanup126

if.end108:                                        ; preds = %for.end
  %u109 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call69, i32 0, i32 0
  %kernel110 = bitcast %union.anon.99* %u109 to %struct.anon.101*
  %target111 = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel110, i32 0, i32 1
  %37 = load %struct.xt_target*, %struct.xt_target** %target111, align 8, !tbaa !76
  %38 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 0
  %target112 = bitcast %union.anon.102* %38 to %struct.xt_target**
  store %struct.xt_target* %37, %struct.xt_target** %target112, align 8, !tbaa !76
  %data113 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call69, i32 0, i32 1
  %arraydecay114 = getelementptr inbounds [0 x i8], [0 x i8]* %data113, i32 0, i32 0
  %39 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 1
  %targinfo = bitcast %union.anon.88* %39 to i8**
  store i8* %arraydecay114, i8** %targinfo, align 8, !tbaa !76
  %u115 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %call69, i32 0, i32 0
  %kernel116 = bitcast %union.anon.99* %u115 to %struct.anon.101*
  %target117 = getelementptr inbounds %struct.anon.101, %struct.anon.101* %kernel116, i32 0, i32 1
  %40 = load %struct.xt_target*, %struct.xt_target** %target117, align 8, !tbaa !76
  %target118 = getelementptr inbounds %struct.xt_target, %struct.xt_target* %40, i32 0, i32 3
  %41 = load i32 (%struct.sk_buff*, %struct.xt_action_param*)*, i32 (%struct.sk_buff*, %struct.xt_action_param*)** %target118, align 8, !tbaa !205
  %call119 = call i32 %41(%struct.sk_buff* %skb, %struct.xt_action_param* %acpar)
  %cmp120 = icmp eq i32 %call119, -1
  br i1 %cmp120, label %if.then122, label %cleanup126

if.then122:                                       ; preds = %if.end108
  %call123 = call %struct.ip6t_entry* @ip6t_next_entry(%struct.ip6t_entry* %e.0)
  br label %cleanup126

cleanup126:                                       ; preds = %if.then122, %if.end108, %if.end106, %if.else, %if.then86, %if.then81, %no_match
  %e.3 = phi %struct.ip6t_entry* [ %call45, %no_match ], [ %call123, %if.then122 ], [ %e.0, %if.then81 ], [ %call107, %if.end106 ], [ %call89, %if.then86 ], [ %call92, %if.else ], [ %e.0, %if.end108 ]
  %verdict.2 = phi i32 [ %verdict.0, %no_match ], [ %call119, %if.then122 ], [ %sub82, %if.then81 ], [ %verdict.0, %if.end106 ], [ %verdict.0, %if.else ], [ %verdict.0, %if.then86 ], [ %call119, %if.end108 ]
  %stackidx.4 = phi i32 [ %stackidx.0, %no_match ], [ %stackidx.0, %if.then122 ], [ %stackidx.0, %if.then81 ], [ %stackidx.2, %if.end106 ], [ %stackidx.0, %if.then86 ], [ %dec, %if.else ], [ %stackidx.0, %if.end108 ]
  %cleanup.dest.slot.1 = phi i32 [ 9, %no_match ], [ 0, %if.then122 ], [ 8, %if.then81 ], [ 9, %if.end106 ], [ 9, %if.else ], [ 9, %if.then86 ], [ 8, %if.end108 ]
  %cleanup.dest.slot.1.off = add i32 %cleanup.dest.slot.1, -8
  %switch = icmp ult i32 %cleanup.dest.slot.1.off, 1
  br i1 %switch, label %do.end132, label %do.cond129

do.cond129:                                       ; preds = %cleanup126
  %hotdrop130 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 5
  %42 = load i8, i8* %hotdrop130, align 8, !tbaa !186, !range !65
  %tobool131 = trunc i8 %42 to i1
  %lnot = xor i1 %tobool131, true
  br i1 %lnot, label %do.body40, label %do.end132

do.end132:                                        ; preds = %do.cond129, %cleanup126
  call void @xt_write_recseq_end(i32 %call)
  call void @local_bh_enable()
  %hotdrop133 = getelementptr inbounds %struct.xt_action_param, %struct.xt_action_param* %acpar, i32 0, i32 5
  %43 = load i8, i8* %hotdrop133, align 8, !tbaa !186, !range !65
  %tobool134 = trunc i8 %43 to i1
  %.verdict.2 = select i1 %tobool134, i32 0, i32 %verdict.2
  %44 = bitcast %struct.xt_action_param* %acpar to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %44) #7
  ret i32 %.verdict.2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @static_key_false(%struct.qspinlock* %key) #5 {
entry:
  %call = call i32 @static_key_count(%struct.qspinlock* %key)
  %cmp = icmp sgt i32 %call, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  %. = select i1 %tobool, i1 true, i1 false
  ret i1 %.
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.ip6t_entry* @get_entry(i8* %base, i32 %offset) #2 {
entry:
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %base, i64 %idx.ext
  %0 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  ret %struct.ip6t_entry* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @ip6_packet_match(%struct.sk_buff* %skb, i8* %indev, i8* %outdev, %struct.ip6t_ip6* %ip6info, i32* %protoff, i32* %fragoff, i8* %hotdrop) #2 {
entry:
  %_frag_off = alloca i16, align 2
  %call = call %struct.ipv6hdr* @ipv6_hdr(%struct.sk_buff* %skb)
  %saddr = getelementptr inbounds %struct.ipv6hdr, %struct.ipv6hdr* %call, i32 0, i32 5
  %smsk = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 2
  %src = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 0
  %call1 = call zeroext i1 @ipv6_masked_addr_cmp(%struct.in6_addr* %saddr, %struct.in6_addr* %smsk, %struct.in6_addr* %src)
  %conv = zext i1 %call1 to i32
  %invflags = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 11
  %0 = load i8, i8* %invflags, align 4, !tbaa !181
  %conv2 = zext i8 %0 to i32
  %and = and i32 %conv2, 8
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %xor = xor i32 %conv, %lnot.ext
  %tobool4 = icmp ne i32 %xor, 0
  br i1 %tobool4, label %cleanup87, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %daddr = getelementptr inbounds %struct.ipv6hdr, %struct.ipv6hdr* %call, i32 0, i32 6
  %dmsk = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 3
  %dst = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 1
  %call5 = call zeroext i1 @ipv6_masked_addr_cmp(%struct.in6_addr* %daddr, %struct.in6_addr* %dmsk, %struct.in6_addr* %dst)
  %conv6 = zext i1 %call5 to i32
  %invflags7 = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 11
  %1 = load i8, i8* %invflags7, align 4, !tbaa !181
  %conv8 = zext i8 %1 to i32
  %and9 = and i32 %conv8, 16
  %tobool10 = icmp ne i32 %and9, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %xor15 = xor i32 %conv6, %lnot.ext14
  %tobool16 = icmp ne i32 %xor15, 0
  br i1 %tobool16, label %cleanup87, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %iniface = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 4
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %iniface, i32 0, i32 0
  %iniface_mask = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 6
  %arraydecay17 = getelementptr inbounds [16 x i8], [16 x i8]* %iniface_mask, i32 0, i32 0
  %call18 = call i64 @ifname_compare_aligned(i8* %indev, i8* %arraydecay, i8* %arraydecay17)
  %cmp = icmp ne i64 %call18, 0
  %conv19 = zext i1 %cmp to i32
  %invflags20 = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 11
  %2 = load i8, i8* %invflags20, align 4, !tbaa !181
  %conv21 = zext i8 %2 to i32
  %and22 = and i32 %conv21, 1
  %tobool23 = icmp ne i32 %and22, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %xor28 = xor i32 %conv19, %lnot.ext27
  %tobool29 = icmp ne i32 %xor28, 0
  br i1 %tobool29, label %cleanup87, label %if.end31

if.end31:                                         ; preds = %if.end
  %outiface = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 5
  %arraydecay32 = getelementptr inbounds [16 x i8], [16 x i8]* %outiface, i32 0, i32 0
  %outiface_mask = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 7
  %arraydecay33 = getelementptr inbounds [16 x i8], [16 x i8]* %outiface_mask, i32 0, i32 0
  %call34 = call i64 @ifname_compare_aligned(i8* %outdev, i8* %arraydecay32, i8* %arraydecay33)
  %cmp35 = icmp ne i64 %call34, 0
  %conv36 = zext i1 %cmp35 to i32
  %invflags37 = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 11
  %3 = load i8, i8* %invflags37, align 4, !tbaa !181
  %conv38 = zext i8 %3 to i32
  %and39 = and i32 %conv38, 2
  %tobool40 = icmp ne i32 %and39, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %xor45 = xor i32 %conv36, %lnot.ext44
  %tobool46 = icmp ne i32 %xor45, 0
  br i1 %tobool46, label %cleanup87, label %if.end48

if.end48:                                         ; preds = %if.end31
  %flags = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 10
  %4 = load i8, i8* %flags, align 1, !tbaa !182
  %conv49 = zext i8 %4 to i32
  %and50 = and i32 %conv49, 1
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.then52, label %if.end86

if.then52:                                        ; preds = %if.end48
  %5 = bitcast i16* %_frag_off to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %5) #7
  %call53 = call i32 @ipv6_find_hdr(%struct.sk_buff* %skb, i32* %protoff, i32 -1, i16* %_frag_off, i32* null)
  %cmp54 = icmp slt i32 %call53, 0
  %6 = load i16, i16* %_frag_off, align 2, !tbaa !105
  %conv57 = zext i16 %6 to i32
  br i1 %cmp54, label %if.then56, label %if.end62

if.then56:                                        ; preds = %if.then52
  %cmp58 = icmp eq i32 %conv57, 0
  br i1 %cmp58, label %if.then60, label %cleanup

if.then60:                                        ; preds = %if.then56
  store i8 1, i8* %hotdrop, align 1, !tbaa !64
  br label %cleanup

if.end62:                                         ; preds = %if.then52
  store i32 %conv57, i32* %fragoff, align 4, !tbaa !75
  %proto = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 8
  %7 = load i16, i16* %proto, align 4, !tbaa !180
  %conv64 = zext i16 %7 to i32
  %cmp65 = icmp eq i32 %conv64, %call53
  br i1 %cmp65, label %if.then67, label %if.end74

if.then67:                                        ; preds = %if.end62
  %invflags68 = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 11
  %8 = load i8, i8* %invflags68, align 4, !tbaa !181
  %conv69 = zext i8 %8 to i32
  %and70 = and i32 %conv69, 64
  %tobool71 = icmp ne i32 %and70, 0
  %. = select i1 %tobool71, i1 false, i1 true
  br label %cleanup

if.end74:                                         ; preds = %if.end62
  %proto75 = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 8
  %9 = load i16, i16* %proto75, align 4, !tbaa !180
  %conv76 = zext i16 %9 to i32
  %cmp77 = icmp ne i32 %conv76, 0
  br i1 %cmp77, label %land.lhs.true, label %if.end84

land.lhs.true:                                    ; preds = %if.end74
  %invflags79 = getelementptr inbounds %struct.ip6t_ip6, %struct.ip6t_ip6* %ip6info, i32 0, i32 11
  %10 = load i8, i8* %invflags79, align 4, !tbaa !181
  %conv80 = zext i8 %10 to i32
  %and81 = and i32 %conv80, 64
  %tobool82 = icmp ne i32 %and81, 0
  br i1 %tobool82, label %if.end84, label %cleanup

if.end84:                                         ; preds = %land.lhs.true, %if.end74
  br label %cleanup

cleanup:                                          ; preds = %if.end84, %land.lhs.true, %if.then67, %if.then60, %if.then56
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end84 ], [ 1, %if.then60 ], [ 1, %if.then56 ], [ 1, %if.then67 ], [ 1, %land.lhs.true ]
  %retval.0 = phi i1 [ undef, %if.end84 ], [ false, %if.then60 ], [ false, %if.then56 ], [ %., %if.then67 ], [ false, %land.lhs.true ]
  %11 = bitcast i16* %_frag_off to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %11) #7
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %if.end86, label %cleanup87

if.end86:                                         ; preds = %cleanup, %if.end48
  br label %cleanup87

cleanup87:                                        ; preds = %if.end86, %cleanup, %if.end31, %if.end, %lor.lhs.false, %entry
  %retval.1 = phi i1 [ %retval.0, %cleanup ], [ true, %if.end86 ], [ false, %lor.lhs.false ], [ false, %entry ], [ false, %if.end ], [ false, %if.end31 ]
  ret i1 %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.ip6t_entry* @ip6t_next_entry(%struct.ip6t_entry* %entry1) #2 {
entry:
  %0 = bitcast %struct.ip6t_entry* %entry1 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %entry1, i32 0, i32 3
  %1 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv = zext i16 %1 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %2 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  ret %struct.ip6t_entry* %2
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.ipv6hdr* @ipv6_hdr(%struct.sk_buff* %skb) #2 {
entry:
  %call = call i8* @skb_network_header(%struct.sk_buff* %skb)
  %0 = bitcast i8* %call to %struct.ipv6hdr*
  ret %struct.ipv6hdr* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @ipv6_masked_addr_cmp(%struct.in6_addr* %a1, %struct.in6_addr* %m, %struct.in6_addr* %a2) #2 {
entry:
  %0 = bitcast %struct.in6_addr* %a1 to i64*
  %1 = bitcast %struct.in6_addr* %m to i64*
  %2 = bitcast %struct.in6_addr* %a2 to i64*
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %3 = load i64, i64* %arrayidx, align 8, !tbaa !98
  %arrayidx1 = getelementptr inbounds i64, i64* %2, i64 0
  %4 = load i64, i64* %arrayidx1, align 8, !tbaa !98
  %xor = xor i64 %3, %4
  %arrayidx2 = getelementptr inbounds i64, i64* %1, i64 0
  %5 = load i64, i64* %arrayidx2, align 8, !tbaa !98
  %and = and i64 %xor, %5
  %arrayidx3 = getelementptr inbounds i64, i64* %0, i64 1
  %6 = load i64, i64* %arrayidx3, align 8, !tbaa !98
  %arrayidx4 = getelementptr inbounds i64, i64* %2, i64 1
  %7 = load i64, i64* %arrayidx4, align 8, !tbaa !98
  %xor5 = xor i64 %6, %7
  %arrayidx6 = getelementptr inbounds i64, i64* %1, i64 1
  %8 = load i64, i64* %arrayidx6, align 8, !tbaa !98
  %and7 = and i64 %xor5, %8
  %or = or i64 %and, %and7
  %tobool = icmp ne i64 %or, 0
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  ret i1 %lnot8
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @ifname_compare_aligned(i8* %_a, i8* %_b, i8* %_mask) #2 {
entry:
  %0 = bitcast i8* %_a to i64*
  %1 = bitcast i8* %_b to i64*
  %2 = bitcast i8* %_mask to i64*
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %3 = load i64, i64* %arrayidx, align 8, !tbaa !98
  %arrayidx1 = getelementptr inbounds i64, i64* %1, i64 0
  %4 = load i64, i64* %arrayidx1, align 8, !tbaa !98
  %xor = xor i64 %3, %4
  %arrayidx2 = getelementptr inbounds i64, i64* %2, i64 0
  %5 = load i64, i64* %arrayidx2, align 8, !tbaa !98
  %and = and i64 %xor, %5
  %arrayidx3 = getelementptr inbounds i64, i64* %0, i64 1
  %6 = load i64, i64* %arrayidx3, align 8, !tbaa !98
  %arrayidx4 = getelementptr inbounds i64, i64* %1, i64 1
  %7 = load i64, i64* %arrayidx4, align 8, !tbaa !98
  %xor5 = xor i64 %6, %7
  %arrayidx6 = getelementptr inbounds i64, i64* %2, i64 1
  %8 = load i64, i64* %arrayidx6, align 8, !tbaa !98
  %and7 = and i64 %xor5, %8
  %or = or i64 %and, %and7
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body8

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_411()
  br label %do.body8

do.body8:                                         ; preds = %if.then, %entry
  %tobool9 = trunc i8 0 to i1
  %conv = zext i1 %tobool9 to i32
  %mul = mul nsw i32 2, %conv
  %sub = sub nsw i32 1, %mul
  %9 = zext i32 %sub to i64
  ret i64 %or
}

declare i32 @ipv6_find_hdr(%struct.sk_buff*, i32*, i32, i16*, i32*) #1

declare void @__compiletime_assert_411() #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @skb_network_header(%struct.sk_buff* %skb) #2 {
entry:
  %head = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 39
  %0 = load i8*, i8** %head, align 8, !tbaa !207
  %network_header = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 34
  %1 = load i16, i16* %network_header, align 4, !tbaa !208
  %conv = zext i16 %1 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  ret i8* %add.ptr
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @static_key_count(%struct.qspinlock* %key) #2 {
entry:
  %enabled = getelementptr inbounds %struct.qspinlock, %struct.qspinlock* %key, i32 0, i32 0
  %call = call i32 @atomic_read(%struct.atomic_t* %enabled)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #5 {
entry:
  %__u = alloca %struct.atomic_t, align 4
  %0 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %1 = bitcast i32* %counter to i8*
  %__c = bitcast %struct.atomic_t* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val = bitcast %struct.atomic_t* %__u to i32*
  %2 = load i32, i32* %__val, align 4, !tbaa !76
  %3 = bitcast %struct.atomic_t* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #7
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define void @ip6t_unregister_table(%struct.net* %net, %struct.xt_table* %table, %struct.nf_hook_ops* %ops) #0 {
entry:
  %valid_hooks = getelementptr inbounds %struct.xt_table, %struct.xt_table* %table, i32 0, i32 1
  %0 = load i32, i32* %valid_hooks, align 8, !tbaa !81
  %call = call i32 @__arch_hweight32(i32 %0)
  call void @nf_unregister_net_hooks(%struct.net* %net, %struct.nf_hook_ops* %ops, i32 %call)
  call void @__ip6t_unregister_table(%struct.net* %net, %struct.xt_table* %table)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @__arch_hweight32(i32 %w) #5 {
entry:
  %0 = call i32 asm "661:\0A\09call __sw_hweight32\0A662:\0A.skip -(((6651f-6641f)-(662b-661b)) > 0) * ((6651f-6641f)-(662b-661b)),0x90\0A663:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6641f - .\0A .word ( 4*32+23)\0A .byte 663b-661b\0A .byte 6651f-6641f\0A .byte 663b-662b\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6641:\0A\09.byte 0xf3,0x0f,0xb8,0xc7\0A6651:\0A\09.popsection", "={ax},{di},~{dirflag},~{fpsr},~{flags}"(i32 %w) #3, !srcloc !209
  ret i32 %0
}

declare void @nf_unregister_net_hooks(%struct.net*, %struct.nf_hook_ops*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @__ip6t_unregister_table(%struct.net* %net, %struct.xt_table* %table) #0 {
entry:
  %me = getelementptr inbounds %struct.xt_table, %struct.xt_table* %table, i32 0, i32 3
  %0 = load %struct.module*, %struct.module** %me, align 8, !tbaa !89
  %call = call i8* @xt_unregister_table(%struct.xt_table* %table)
  %1 = bitcast i8* %call to %struct.xt_table_info*
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %1, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %add.ptr2.sink = phi i8* [ %add.ptr2, %for.body ], [ %arraydecay, %entry ]
  %2 = bitcast i8* %add.ptr2.sink to %struct.ip6t_entry*
  %size = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %1, i32 0, i32 0
  %3 = load i32, i32* %size, align 8, !tbaa !87
  %idx.ext = zext i32 %3 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 %idx.ext
  %4 = bitcast i8* %add.ptr to %struct.ip6t_entry*
  %cmp = icmp ult %struct.ip6t_entry* %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @cleanup_entry(%struct.ip6t_entry* %2, %struct.net* %net)
  %5 = bitcast %struct.ip6t_entry* %2 to i8*
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %2, i32 0, i32 3
  %6 = load i16, i16* %next_offset, align 2, !tbaa !93
  %conv = zext i16 %6 to i32
  %idx.ext1 = sext i32 %conv to i64
  %add.ptr2 = getelementptr inbounds i8, i8* %5, i64 %idx.ext1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %number = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %1, i32 0, i32 1
  %7 = load i32, i32* %number, align 4, !tbaa !84
  %initial_entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %1, i32 0, i32 2
  %8 = load i32, i32* %initial_entries, align 8, !tbaa !92
  %cmp3 = icmp ugt i32 %7, %8
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  call void @module_put(%struct.module* %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  call void @xt_free_table_info(%struct.xt_table_info* %1)
  ret void
}

declare i8* @xt_unregister_table(%struct.xt_table*) #1

; Function Attrs: nounwind uwtable
define i32 @ip6t_register_table(%struct.net* %net, %struct.xt_table* %table, %struct.ip6t_replace* %repl, %struct.nf_hook_ops* %ops, %struct.xt_table** %res) #0 {
entry:
  %bootstrap = alloca %struct.xt_table_info, align 8
  %__u = alloca %union.anon.111, align 8
  %0 = bitcast %struct.xt_table_info* %bootstrap to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #7
  %1 = bitcast %struct.xt_table_info* %bootstrap to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 64, i32 8, i1 false)
  %size = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 3
  %2 = load i32, i32* %size, align 8, !tbaa !136
  %call = call %struct.xt_table_info* @xt_alloc_table_info(i32 %2)
  %tobool = icmp ne %struct.xt_table_info* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %entries = getelementptr inbounds %struct.xt_table_info, %struct.xt_table_info* %call, i32 0, i32 7
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %entries, i32 0, i32 0
  %size1 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 3
  %3 = load i32, i32* %size1, align 8, !tbaa !136
  %conv = zext i32 %3 to i64
  %entries2 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 8
  %arraydecay3 = getelementptr inbounds [0 x %struct.ip6t_entry], [0 x %struct.ip6t_entry]* %entries2, i32 0, i32 0
  %4 = bitcast %struct.ip6t_entry* %arraydecay3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %4, i64 %conv, i32 1, i1 false)
  %call4 = call i32 @translate_table(%struct.net* %net, %struct.xt_table_info* %call, i8* %arraydecay, %struct.ip6t_replace* %repl)
  %cmp = icmp ne i32 %call4, 0
  br i1 %cmp, label %out_free, label %if.end7

if.end7:                                          ; preds = %if.end
  %call8 = call %struct.xt_table* @xt_register_table(%struct.net* %net, %struct.xt_table* %table, %struct.xt_table_info* %bootstrap, %struct.xt_table_info* %call)
  %5 = bitcast %struct.xt_table* %call8 to i8*
  %call9 = call zeroext i1 @IS_ERR.2(i8* %5)
  br i1 %call9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.end7
  %6 = bitcast %struct.xt_table* %call8 to i8*
  %call11 = call i64 @PTR_ERR.3(i8* %6)
  %conv12 = trunc i64 %call11 to i32
  br label %out_free

if.end13:                                         ; preds = %if.end7
  %7 = bitcast %union.anon.111* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #7
  %__val = bitcast %union.anon.111* %__u to %struct.xt_table**
  store %struct.xt_table* %call8, %struct.xt_table** %__val, align 8, !tbaa !76
  %8 = bitcast %struct.xt_table** %res to i8*
  %__c = bitcast %union.anon.111* %__u to [1 x i8]*
  %arraydecay14 = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %8, i8* %arraydecay14, i32 8)
  %__val16 = bitcast %union.anon.111* %__u to %struct.xt_table**
  %9 = load %struct.xt_table*, %struct.xt_table** %__val16, align 8, !tbaa !76
  %10 = bitcast %union.anon.111* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %valid_hooks = getelementptr inbounds %struct.xt_table, %struct.xt_table* %table, i32 0, i32 1
  %11 = load i32, i32* %valid_hooks, align 8, !tbaa !81
  %call17 = call i32 @__arch_hweight32(i32 %11)
  %call18 = call i32 @nf_register_net_hooks(%struct.net* %net, %struct.nf_hook_ops* %ops, i32 %call17)
  %cmp19 = icmp ne i32 %call18, 0
  br i1 %cmp19, label %if.then21, label %cleanup

if.then21:                                        ; preds = %if.end13
  call void @__ip6t_unregister_table(%struct.net* %net, %struct.xt_table* %call8)
  store %struct.xt_table* null, %struct.xt_table** %res, align 8, !tbaa !2
  br label %cleanup

out_free:                                         ; preds = %if.then10, %if.end
  %ret.0 = phi i32 [ %conv12, %if.then10 ], [ %call4, %if.end ]
  call void @xt_free_table_info(%struct.xt_table_info* %call)
  br label %cleanup

cleanup:                                          ; preds = %out_free, %if.then21, %if.end13, %entry
  %retval.0 = phi i32 [ %ret.0, %out_free ], [ -12, %entry ], [ %call18, %if.then21 ], [ %call18, %if.end13 ]
  %12 = bitcast %struct.xt_table_info* %bootstrap to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %12) #7
  ret i32 %retval.0
}

declare %struct.xt_table* @xt_register_table(%struct.net*, %struct.xt_table*, %struct.xt_table_info*, %struct.xt_table_info*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !76
  store volatile i8 %0, i8* %p, align 1, !tbaa !76
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !105
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !105
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !75
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !75
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !106
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !106
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !210
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !211
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

declare i32 @nf_register_net_hooks(%struct.net*, %struct.nf_hook_ops*, i32) #1

declare void @nf_unregister_sockopt(%struct.nf_sockopt_ops*) #1

; Function Attrs: nounwind uwtable
define i8* @ip6t_alloc_initial_table(%struct.xt_table* %info) #0 {
entry:
  %.compoundliteral = alloca %struct.ip6t_error, align 8
  %.compoundliteral30 = alloca %struct.ip6t_standard, align 8
  %valid_hooks = getelementptr inbounds %struct.xt_table, %struct.xt_table* %info, i32 0, i32 1
  %0 = load i32, i32* %valid_hooks, align 8, !tbaa !81
  %call = call i32 @__arch_hweight32(i32 %0)
  %conv = zext i32 %call to i64
  %1 = mul i64 %conv, 208
  %2 = add i64 96, %1
  %add = add i64 %2, 8
  %sub = sub i64 %add, 1
  %and = and i64 %sub, -8
  %add1 = add i64 %and, 232
  %call2 = call i8* @kzalloc(i64 %add1, i32 20971712)
  %3 = bitcast i8* %call2 to %struct.anon.102*
  %cmp = icmp eq %struct.anon.102* %3, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = bitcast %struct.anon.102* %3 to i8*
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %and
  %5 = bitcast i8* %arrayidx to %struct.ip6t_error*
  %repl = getelementptr inbounds %struct.anon.102, %struct.anon.102* %3, i32 0, i32 0
  %name = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl, i32 0, i32 0
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %name4 = getelementptr inbounds %struct.xt_table, %struct.xt_table* %info, i32 0, i32 7
  %arraydecay5 = getelementptr inbounds [32 x i8], [32 x i8]* %name4, i32 0, i32 0
  %call6 = call i8* @strncpy(i8* %arraydecay, i8* %arraydecay5, i64 32)
  %entry7 = getelementptr inbounds %struct.ip6t_error, %struct.ip6t_error* %.compoundliteral, i32 0, i32 0
  %6 = bitcast %struct.ip6t_entry* %entry7 to i8*
  call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 168, i32 8, i1 false)
  %target_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %entry7, i32 0, i32 2
  store i16 168, i16* %target_offset, align 4, !tbaa !94
  %next_offset = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %entry7, i32 0, i32 3
  store i16 232, i16* %next_offset, align 2, !tbaa !93
  %target = getelementptr inbounds %struct.ip6t_error, %struct.ip6t_error* %.compoundliteral, i32 0, i32 1
  %target8 = getelementptr inbounds %struct.xt_error_target, %struct.xt_error_target* %target, i32 0, i32 0
  %u = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %target8, i32 0, i32 0
  %user = bitcast %union.anon.99* %u to %struct.anon.104*
  %target_size = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 0
  store i16 64, i16* %target_size, align 8, !tbaa !212
  %name9 = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 1
  %7 = bitcast [29 x i8]* %name9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i32 0, i32 0), i64 29, i32 1, i1 false), !tbaa.struct !214
  %revision = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user, i32 0, i32 2
  store i8 0, i8* %revision, align 1, !tbaa !215
  %data = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %target8, i32 0, i32 1
  %8 = bitcast [0 x i8]* %data to i8*
  %errorname = getelementptr inbounds %struct.xt_error_target, %struct.xt_error_target* %target, i32 0, i32 1
  %9 = bitcast [30 x i8]* %errorname to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.1, i32 0, i32 0), i64 30, i32 1, i1 false), !tbaa.struct !216
  %10 = bitcast %struct.ip6t_error* %5 to i8*
  %11 = bitcast %struct.ip6t_error* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 232, i32 8, i1 false), !tbaa.struct !217
  %repl10 = getelementptr inbounds %struct.anon.102, %struct.anon.102* %3, i32 0, i32 0
  %valid_hooks11 = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl10, i32 0, i32 1
  store i32 %0, i32* %valid_hooks11, align 8, !tbaa !75
  %add12 = add i32 %call, 1
  %repl13 = getelementptr inbounds %struct.anon.102, %struct.anon.102* %3, i32 0, i32 0
  %num_entries = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl13, i32 0, i32 2
  store i32 %add12, i32* %num_entries, align 4, !tbaa !75
  %conv14 = zext i32 %call to i64
  %mul = mul i64 %conv14, 208
  %add15 = add i64 %mul, 232
  %conv16 = trunc i64 %add15 to i32
  %repl17 = getelementptr inbounds %struct.anon.102, %struct.anon.102* %3, i32 0, i32 0
  %size = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl17, i32 0, i32 3
  store i32 %conv16, i32* %size, align 8, !tbaa !75
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %i.1, %for.inc ]
  %hooknum.0 = phi i32 [ 0, %if.end ], [ %inc45, %for.inc ]
  %bytes.0 = phi i32 [ 0, %if.end ], [ %bytes.1, %for.inc ]
  %hook_mask.0 = phi i32 [ %0, %if.end ], [ %shr, %for.inc ]
  %cmp18 = icmp ne i32 %hook_mask.0, 0
  br i1 %cmp18, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %and20 = and i32 %hook_mask.0, 1
  %tobool = icmp ne i32 %and20, 0
  br i1 %tobool, label %if.end22, label %for.inc

if.end22:                                         ; preds = %for.body
  %repl23 = getelementptr inbounds %struct.anon.102, %struct.anon.102* %3, i32 0, i32 0
  %hook_entry = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl23, i32 0, i32 4
  %idxprom = zext i32 %hooknum.0 to i64
  %arrayidx24 = getelementptr inbounds [5 x i32], [5 x i32]* %hook_entry, i64 0, i64 %idxprom
  store i32 %bytes.0, i32* %arrayidx24, align 4, !tbaa !75
  %repl25 = getelementptr inbounds %struct.anon.102, %struct.anon.102* %3, i32 0, i32 0
  %underflow = getelementptr inbounds %struct.ip6t_replace, %struct.ip6t_replace* %repl25, i32 0, i32 5
  %idxprom26 = zext i32 %hooknum.0 to i64
  %arrayidx27 = getelementptr inbounds [5 x i32], [5 x i32]* %underflow, i64 0, i64 %idxprom26
  store i32 %bytes.0, i32* %arrayidx27, align 4, !tbaa !75
  %entries = getelementptr inbounds %struct.anon.102, %struct.anon.102* %3, i32 0, i32 1
  %inc = add i32 %i.0, 1
  %idxprom28 = zext i32 %i.0 to i64
  %arrayidx29 = getelementptr inbounds [0 x %struct.ip6t_standard], [0 x %struct.ip6t_standard]* %entries, i64 0, i64 %idxprom28
  %12 = bitcast %struct.ip6t_standard* %.compoundliteral30 to i8*
  call void @llvm.memset.p0i8.i64(i8* %12, i8 0, i64 208, i32 8, i1 false)
  %entry31 = getelementptr inbounds %struct.ip6t_standard, %struct.ip6t_standard* %.compoundliteral30, i32 0, i32 0
  %target_offset32 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %entry31, i32 0, i32 2
  store i16 168, i16* %target_offset32, align 4, !tbaa !94
  %next_offset33 = getelementptr inbounds %struct.ip6t_entry, %struct.ip6t_entry* %entry31, i32 0, i32 3
  store i16 208, i16* %next_offset33, align 2, !tbaa !93
  %target34 = getelementptr inbounds %struct.ip6t_standard, %struct.ip6t_standard* %.compoundliteral30, i32 0, i32 1
  %target35 = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %target34, i32 0, i32 0
  %u36 = getelementptr inbounds %struct.xt_entry_target, %struct.xt_entry_target* %target35, i32 0, i32 0
  %user37 = bitcast %union.anon.99* %u36 to %struct.anon.104*
  %target_size38 = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user37, i32 0, i32 0
  store i16 40, i16* %target_size38, align 8, !tbaa !212
  %name39 = getelementptr inbounds %struct.anon.104, %struct.anon.104* %user37, i32 0, i32 1
  %13 = bitcast [29 x i8]* %name39 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.2, i32 0, i32 0), i64 29, i32 1, i1 false), !tbaa.struct !214
  %verdict = getelementptr inbounds %struct.xt_standard_target, %struct.xt_standard_target* %target34, i32 0, i32 1
  store i32 -2, i32* %verdict, align 8, !tbaa !160
  %14 = bitcast %struct.ip6t_standard* %arrayidx29 to i8*
  %15 = bitcast %struct.ip6t_standard* %.compoundliteral30 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 208, i32 8, i1 false), !tbaa.struct !218
  %conv42 = zext i32 %bytes.0 to i64
  %add43 = add i64 %conv42, 208
  %conv44 = trunc i64 %add43 to i32
  br label %for.inc

for.inc:                                          ; preds = %if.end22, %for.body
  %i.1 = phi i32 [ %inc, %if.end22 ], [ %i.0, %for.body ]
  %bytes.1 = phi i32 [ %conv44, %if.end22 ], [ %bytes.0, %for.body ]
  %shr = lshr i32 %hook_mask.0, 1
  %inc45 = add i32 %hooknum.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %entry ], [ 0, %for.cond ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  %16 = bitcast %struct.anon.102* %3 to i8*
  %. = select i1 %switch, i8* %16, i8* null
  ret i8* %.
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #2 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare i8* @strncpy(i8*, i8*, i64) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare noalias i8* @__kmalloc(i64, i32) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone }
attributes #4 = { argmemonly nounwind }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }
attributes #8 = { nounwind readonly }

!llvm.ident = !{!0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !3, i64 32}
!7 = !{!"nf_hook_state", !8, i64 0, !4, i64 4, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40}
!8 = !{!"int", !4, i64 0}
!9 = !{!10, !3, i64 1600}
!10 = !{!"net", !11, i64 0, !11, i64 4, !12, i64 8, !13, i64 16, !15, i64 24, !15, i64 40, !15, i64 56, !3, i64 72, !3, i64 80, !12, i64 88, !16, i64 96, !18, i64 120, !3, i64 144, !3, i64 152, !19, i64 160, !3, i64 264, !3, i64 272, !15, i64 280, !3, i64 296, !3, i64 304, !8, i64 312, !8, i64 316, !8, i64 320, !15, i64 328, !3, i64 344, !23, i64 352, !24, i64 376, !25, i64 480, !29, i64 520, !30, i64 576, !42, i64 1344, !50, i64 2112, !51, i64 3080, !52, i64 3296, !59, i64 3648, !3, i64 3840, !3, i64 3848, !3, i64 3856, !60, i64 3904, !3, i64 4928, !11, i64 4936}
!11 = !{!"", !8, i64 0}
!12 = !{!"spinlock", !4, i64 0}
!13 = !{!"", !14, i64 0}
!14 = !{!"long", !4, i64 0}
!15 = !{!"list_head", !3, i64 0, !3, i64 8}
!16 = !{!"idr", !17, i64 0, !8, i64 16}
!17 = !{!"radix_tree_root", !8, i64 0, !3, i64 8}
!18 = !{!"ns_common", !13, i64 0, !3, i64 8, !8, i64 16}
!19 = !{!"ctl_table_set", !3, i64 0, !20, i64 8}
!20 = !{!"ctl_dir", !21, i64 0, !22, i64 88}
!21 = !{!"ctl_table_header", !4, i64 0, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !15, i64 72}
!22 = !{!"rb_root", !3, i64 0}
!23 = !{!"netns_core", !3, i64 0, !8, i64 8, !3, i64 16}
!24 = !{!"netns_mib", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96}
!25 = !{!"netns_packet", !26, i64 0, !28, i64 32}
!26 = !{!"mutex", !13, i64 0, !12, i64 8, !27, i64 12, !15, i64 16}
!27 = !{!"optimistic_spin_queue", !11, i64 0}
!28 = !{!"hlist_head", !3, i64 0}
!29 = !{!"netns_unix", !8, i64 0, !3, i64 8}
!30 = !{!"netns_ipv4", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !31, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !31, i64 96, !3, i64 104, !3, i64 112, !3, i64 120, !3, i64 128, !3, i64 136, !32, i64 192, !3, i64 256, !3, i64 264, !3, i64 272, !3, i64 280, !3, i64 288, !3, i64 296, !8, i64 304, !8, i64 308, !8, i64 312, !8, i64 316, !8, i64 320, !8, i64 324, !37, i64 328, !8, i64 348, !8, i64 352, !8, i64 356, !8, i64 360, !8, i64 364, !8, i64 368, !8, i64 372, !8, i64 376, !8, i64 380, !8, i64 384, !8, i64 388, !8, i64 392, !8, i64 396, !8, i64 400, !8, i64 404, !8, i64 408, !8, i64 412, !8, i64 416, !8, i64 420, !8, i64 424, !8, i64 428, !8, i64 432, !8, i64 436, !8, i64 440, !8, i64 444, !8, i64 448, !8, i64 452, !40, i64 512, !8, i64 640, !8, i64 644, !8, i64 648, !8, i64 652, !8, i64 656, !41, i64 660, !11, i64 676, !3, i64 680, !8, i64 688, !3, i64 696, !8, i64 704, !8, i64 708, !11, i64 712}
!31 = !{!"_Bool", !4, i64 0}
!32 = !{!"netns_frags", !33, i64 0, !8, i64 40, !8, i64 44, !8, i64 48, !8, i64 52}
!33 = !{!"percpu_counter", !34, i64 0, !36, i64 8, !15, i64 16, !3, i64 32}
!34 = !{!"raw_spinlock", !35, i64 0}
!35 = !{!"qspinlock", !11, i64 0}
!36 = !{!"long long", !4, i64 0}
!37 = !{!"local_ports", !38, i64 0, !4, i64 8, !31, i64 16}
!38 = !{!"", !39, i64 0, !12, i64 4}
!39 = !{!"seqcount", !8, i64 0}
!40 = !{!"inet_timewait_death_row", !11, i64 0, !3, i64 64, !8, i64 72, !8, i64 76}
!41 = !{!"ping_group_range", !38, i64 0, !4, i64 8}
!42 = !{!"netns_ipv6", !43, i64 0, !3, i64 112, !3, i64 120, !3, i64 128, !32, i64 192, !3, i64 256, !3, i64 264, !3, i64 272, !3, i64 280, !3, i64 288, !3, i64 296, !3, i64 304, !44, i64 312, !3, i64 360, !3, i64 368, !15, i64 376, !46, i64 448, !48, i64 640, !12, i64 648, !8, i64 652, !14, i64 656, !3, i64 664, !3, i64 672, !3, i64 680, !3, i64 688, !3, i64 696, !11, i64 704, !11, i64 708, !3, i64 712}
!43 = !{!"netns_sysctl_ipv6", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !8, i64 40, !8, i64 44, !8, i64 48, !8, i64 52, !8, i64 56, !8, i64 60, !8, i64 64, !8, i64 68, !8, i64 72, !8, i64 76, !8, i64 80, !8, i64 84, !8, i64 88, !8, i64 92, !8, i64 96, !8, i64 100, !8, i64 104, !8, i64 108}
!44 = !{!"timer_list", !45, i64 0, !14, i64 16, !3, i64 24, !14, i64 32, !8, i64 40}
!45 = !{!"hlist_node", !3, i64 0, !3, i64 8}
!46 = !{!"dst_ops", !47, i64 0, !8, i64 4, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112, !3, i64 120, !33, i64 128}
!47 = !{!"short", !4, i64 0}
!48 = !{!"", !49, i64 0}
!49 = !{!"qrwlock", !11, i64 0, !35, i64 4}
!50 = !{!"netns_nf", !3, i64 0, !3, i64 8, !4, i64 16, !3, i64 120, !4, i64 128, !31, i64 960, !31, i64 961}
!51 = !{!"netns_xt", !4, i64 0, !31, i64 208, !31, i64 209}
!52 = !{!"netns_ct", !11, i64 0, !8, i64 4, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !8, i64 48, !8, i64 52, !8, i64 56, !8, i64 60, !31, i64 64, !8, i64 68, !8, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !53, i64 112}
!53 = !{!"nf_ip_net", !54, i64 0, !56, i64 32, !57, i64 128, !58, i64 160, !58, i64 192}
!54 = !{!"nf_generic_net", !55, i64 0, !8, i64 24}
!55 = !{!"nf_proto_net", !3, i64 0, !3, i64 8, !8, i64 16}
!56 = !{!"nf_tcp_net", !55, i64 0, !4, i64 24, !8, i64 80, !8, i64 84, !8, i64 88}
!57 = !{!"nf_udp_net", !55, i64 0, !4, i64 24}
!58 = !{!"nf_icmp_net", !55, i64 0, !8, i64 24}
!59 = !{!"netns_nf_frag", !43, i64 0, !32, i64 128}
!60 = !{!"netns_xfrm", !15, i64 0, !3, i64 16, !3, i64 24, !3, i64 32, !8, i64 40, !8, i64 44, !61, i64 48, !15, i64 80, !3, i64 96, !8, i64 104, !4, i64 112, !4, i64 136, !4, i64 184, !61, i64 208, !62, i64 240, !3, i64 288, !3, i64 296, !8, i64 304, !8, i64 308, !8, i64 312, !8, i64 316, !3, i64 320, !46, i64 384, !46, i64 576, !12, i64 768, !12, i64 772, !26, i64 776, !63, i64 808, !11, i64 896, !15, i64 904, !11, i64 920, !12, i64 924, !61, i64 928, !61, i64 960, !26, i64 992}
!61 = !{!"work_struct", !13, i64 0, !15, i64 8, !3, i64 24}
!62 = !{!"xfrm_policy_hthresh", !61, i64 0, !38, i64 32, !4, i64 40, !4, i64 41, !4, i64 42, !4, i64 43}
!63 = !{!"flow_cache", !8, i64 0, !3, i64 8, !45, i64 16, !8, i64 32, !8, i64 36, !44, i64 40}
!64 = !{!31, !31, i64 0}
!65 = !{i8 0, i8 2}
!66 = !{!67, !8, i64 200}
!67 = !{!"ip6t_standard", !68, i64 0, !72, i64 168}
!68 = !{!"ip6t_entry", !69, i64 0, !8, i64 136, !47, i64 140, !47, i64 142, !8, i64 144, !71, i64 152, !4, i64 168}
!69 = !{!"ip6t_ip6", !70, i64 0, !70, i64 16, !70, i64 32, !70, i64 48, !4, i64 64, !4, i64 80, !4, i64 96, !4, i64 112, !47, i64 128, !4, i64 130, !4, i64 131, !4, i64 132}
!70 = !{!"in6_addr", !4, i64 0}
!71 = !{!"xt_counters", !36, i64 0, !36, i64 8}
!72 = !{!"xt_standard_target", !73, i64 0, !8, i64 32}
!73 = !{!"xt_entry_target", !4, i64 0, !4, i64 32}
!74 = !{!10, !3, i64 72}
!75 = !{!8, !8, i64 0}
!76 = !{!4, !4, i64 0}
!77 = !{!78, !4, i64 29}
!78 = !{!"xt_get_revision", !4, i64 0, !4, i64 29}
!79 = !{!80, !3, i64 24}
!80 = !{!"xt_table", !15, i64 0, !8, i64 16, !3, i64 24, !3, i64 32, !4, i64 40, !8, i64 44, !3, i64 48, !4, i64 56}
!81 = !{!80, !8, i64 16}
!82 = !{!83, !8, i64 32}
!83 = !{!"ip6t_getinfo", !4, i64 0, !8, i64 32, !4, i64 36, !4, i64 56, !8, i64 76, !8, i64 80}
!84 = !{!85, !8, i64 4}
!85 = !{!"xt_table_info", !8, i64 0, !8, i64 4, !8, i64 8, !4, i64 12, !4, i64 32, !8, i64 52, !3, i64 56, !4, i64 64}
!86 = !{!83, !8, i64 76}
!87 = !{!85, !8, i64 0}
!88 = !{!83, !8, i64 80}
!89 = !{!80, !3, i64 32}
!90 = !{!91, !8, i64 32}
!91 = !{!"compat_ip6t_get_entries", !4, i64 0, !8, i64 32, !4, i64 36}
!92 = !{!85, !8, i64 8}
!93 = !{!68, !47, i64 142}
!94 = !{!68, !47, i64 140}
!95 = !{i32 -2141748653}
!96 = !{i32 -2141746944}
!97 = !{i32 -2141754397}
!98 = !{!14, !14, i64 0}
!99 = !{!71, !36, i64 8}
!100 = !{!71, !36, i64 0}
!101 = !{i32 -2141785976}
!102 = !{i32 -2146106327}
!103 = !{!39, !8, i64 0}
!104 = !{i32 -2146107059}
!105 = !{!47, !47, i64 0}
!106 = !{!36, !36, i64 0}
!107 = !{i32 -2147285057}
!108 = !{i32 -2147285019}
!109 = !{i32 1003715}
!110 = !{!111, !3, i64 0}
!111 = !{!"", !3, i64 0}
!112 = !{!113, !8, i64 32}
!113 = !{!"ip6t_get_entries", !4, i64 0, !8, i64 32, !4, i64 40}
!114 = !{!115, !8, i64 84}
!115 = !{!"compat_ip6t_replace", !4, i64 0, !8, i64 32, !8, i64 36, !8, i64 40, !4, i64 44, !4, i64 64, !8, i64 84, !8, i64 88, !4, i64 92}
!116 = !{!115, !8, i64 40}
!117 = !{!115, !8, i64 32}
!118 = !{!115, !8, i64 88}
!119 = !{!120, !8, i64 32}
!120 = !{!"xt_counters_info", !4, i64 0, !8, i64 32, !4, i64 40}
!121 = !{i32 -2141821411}
!122 = !{i32 -2141807397}
!123 = !{i32 -2141802271}
!124 = !{i32 -2141787015}
!125 = !{i32 -2141802155}
!126 = !{i32 -2141793783}
!127 = !{i32 -2146277501}
!128 = !{i32 -2146286038}
!129 = !{!115, !8, i64 36}
!130 = !{!131, !47, i64 142}
!131 = !{!"compat_ip6t_entry", !69, i64 0, !8, i64 136, !47, i64 140, !47, i64 142, !8, i64 144, !132, i64 148, !4, i64 164}
!132 = !{!"compat_xt_counters", !36, i64 0, !36, i64 8}
!133 = !{!134, !8, i64 84}
!134 = !{!"ip6t_replace", !4, i64 0, !8, i64 32, !8, i64 36, !8, i64 40, !4, i64 44, !4, i64 64, !8, i64 84, !3, i64 88, !4, i64 96}
!135 = !{!134, !3, i64 88}
!136 = !{!134, !8, i64 40}
!137 = !{!138, !3, i64 0}
!138 = !{!"xt_tgdtor_param", !3, i64 0, !3, i64 8, !3, i64 16, !4, i64 24}
!139 = !{!138, !3, i64 8}
!140 = !{!138, !3, i64 16}
!141 = !{!138, !4, i64 24}
!142 = !{!143, !3, i64 64}
!143 = !{!"xt_target", !15, i64 0, !4, i64 16, !4, i64 45, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !8, i64 104, !8, i64 108, !8, i64 112, !8, i64 116, !47, i64 120, !47, i64 122}
!144 = !{!143, !3, i64 88}
!145 = !{!146, !3, i64 0}
!146 = !{!"xt_mtdtor_param", !3, i64 0, !3, i64 8, !3, i64 16, !4, i64 24}
!147 = !{!146, !3, i64 8}
!148 = !{!146, !3, i64 16}
!149 = !{!146, !4, i64 24}
!150 = !{!151, !3, i64 64}
!151 = !{!"xt_match", !15, i64 0, !4, i64 16, !4, i64 45, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !8, i64 104, !8, i64 108, !8, i64 112, !8, i64 116, !47, i64 120, !47, i64 122}
!152 = !{!151, !3, i64 88}
!153 = !{!131, !47, i64 140}
!154 = !{!134, !8, i64 36}
!155 = !{!134, !8, i64 32}
!156 = !{!85, !8, i64 52}
!157 = !{i64 0, i64 8, !106, i64 8, i64 8, !106}
!158 = !{!68, !8, i64 144}
!159 = !{!68, !36, i64 152}
!160 = !{!72, !8, i64 32}
!161 = !{!162, !3, i64 0}
!162 = !{!"xt_mtchk_param", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !8, i64 40, !4, i64 44, !31, i64 45}
!163 = !{!162, !3, i64 8}
!164 = !{!162, !3, i64 16}
!165 = !{!162, !8, i64 40}
!166 = !{!162, !4, i64 44}
!167 = !{!168, !3, i64 0}
!168 = !{!"xt_tgchk_param", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !8, i64 40, !4, i64 44, !31, i64 45}
!169 = !{!168, !3, i64 8}
!170 = !{!168, !3, i64 16}
!171 = !{!168, !3, i64 24}
!172 = !{!168, !3, i64 32}
!173 = !{!168, !8, i64 40}
!174 = !{!168, !4, i64 44}
!175 = !{!168, !31, i64 45}
!176 = !{!68, !47, i64 128}
!177 = !{!68, !4, i64 132}
!178 = !{!162, !3, i64 24}
!179 = !{!162, !3, i64 32}
!180 = !{!69, !47, i64 128}
!181 = !{!69, !4, i64 132}
!182 = !{!69, !4, i64 131}
!183 = !{!184, !8, i64 24}
!184 = !{!"xt_action_param", !4, i64 0, !4, i64 8, !3, i64 16, !8, i64 24, !8, i64 28, !31, i64 32}
!185 = !{!184, !8, i64 28}
!186 = !{!184, !31, i64 32}
!187 = !{!188, !4, i64 0}
!188 = !{!"ip6t_icmp", !4, i64 0, !4, i64 1, !4, i64 3}
!189 = !{!190, !4, i64 0}
!190 = !{!"icmp6hdr", !4, i64 0, !4, i64 1, !47, i64 2, !4, i64 4}
!191 = !{!190, !4, i64 1}
!192 = !{!188, !4, i64 3}
!193 = !{!194, !3, i64 208}
!194 = !{!"sk_buff", !4, i64 0, !3, i64 24, !4, i64 32, !4, i64 40, !14, i64 88, !3, i64 96, !3, i64 104, !14, i64 112, !8, i64 120, !8, i64 124, !47, i64 128, !47, i64 130, !47, i64 132, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 134, !4, i64 136, !4, i64 136, !4, i64 136, !4, i64 136, !4, i64 136, !4, i64 136, !4, i64 136, !4, i64 137, !4, i64 137, !4, i64 137, !4, i64 137, !4, i64 137, !4, i64 137, !4, i64 137, !4, i64 137, !4, i64 138, !4, i64 138, !4, i64 138, !4, i64 138, !4, i64 138, !4, i64 138, !4, i64 139, !4, i64 139, !4, i64 139, !4, i64 139, !4, i64 139, !4, i64 139, !4, i64 139, !47, i64 140, !4, i64 144, !8, i64 148, !8, i64 152, !8, i64 156, !47, i64 160, !47, i64 162, !4, i64 164, !8, i64 168, !4, i64 172, !4, i64 176, !47, i64 178, !47, i64 180, !47, i64 182, !47, i64 184, !47, i64 186, !47, i64 188, !47, i64 190, !4, i64 192, !8, i64 192, !8, i64 196, !3, i64 200, !3, i64 208, !8, i64 216, !11, i64 220}
!195 = !{!194, !8, i64 120}
!196 = !{!194, !8, i64 124}
!197 = !{!7, !8, i64 0}
!198 = !{!7, !3, i64 8}
!199 = !{!7, !3, i64 16}
!200 = !{!184, !3, i64 16}
!201 = !{i32 -2141765409}
!202 = !{!85, !3, i64 56}
!203 = !{i32 -2141762234}
!204 = !{!151, !3, i64 48}
!205 = !{!143, !3, i64 48}
!206 = !{!68, !4, i64 131}
!207 = !{!194, !3, i64 200}
!208 = !{!194, !47, i64 188}
!209 = !{i32 -2147188193, i32 -2147188186, i32 -2147188170, i32 -2147188154, i32 -2147187846, i32 -2147188600, i32 -2147187840, i32 -2147187792, i32 -2147187728, i32 -2147187666, i32 -2147187609, i32 -2147187553, i32 -2147188520, i32 -2147188495, i32 -2147187220, i32 -2147187298, i32 -2147187206, i32 -2147187257}
!210 = !{i32 -2147284320}
!211 = !{i32 -2147284282}
!212 = !{!213, !47, i64 0}
!213 = !{!"", !47, i64 0, !4, i64 2, !4, i64 31}
!214 = !{i64 0, i64 29, !76}
!215 = !{!213, !4, i64 31}
!216 = !{i64 0, i64 30, !76}
!217 = !{i64 0, i64 16, !76, i64 0, i64 16, !76, i64 0, i64 16, !76, i64 16, i64 16, !76, i64 16, i64 16, !76, i64 16, i64 16, !76, i64 32, i64 16, !76, i64 32, i64 16, !76, i64 32, i64 16, !76, i64 48, i64 16, !76, i64 48, i64 16, !76, i64 48, i64 16, !76, i64 64, i64 16, !76, i64 80, i64 16, !76, i64 96, i64 16, !76, i64 112, i64 16, !76, i64 128, i64 2, !105, i64 130, i64 1, !76, i64 131, i64 1, !76, i64 132, i64 1, !76, i64 136, i64 4, !75, i64 140, i64 2, !105, i64 142, i64 2, !105, i64 144, i64 4, !75, i64 152, i64 8, !106, i64 160, i64 8, !106, i64 168, i64 0, !76, i64 168, i64 2, !105, i64 170, i64 29, !76, i64 199, i64 1, !76, i64 168, i64 2, !105, i64 176, i64 8, !2, i64 168, i64 2, !105, i64 200, i64 0, !76, i64 200, i64 30, !76}
!218 = !{i64 0, i64 16, !76, i64 0, i64 16, !76, i64 0, i64 16, !76, i64 16, i64 16, !76, i64 16, i64 16, !76, i64 16, i64 16, !76, i64 32, i64 16, !76, i64 32, i64 16, !76, i64 32, i64 16, !76, i64 48, i64 16, !76, i64 48, i64 16, !76, i64 48, i64 16, !76, i64 64, i64 16, !76, i64 80, i64 16, !76, i64 96, i64 16, !76, i64 112, i64 16, !76, i64 128, i64 2, !105, i64 130, i64 1, !76, i64 131, i64 1, !76, i64 132, i64 1, !76, i64 136, i64 4, !75, i64 140, i64 2, !105, i64 142, i64 2, !105, i64 144, i64 4, !75, i64 152, i64 8, !106, i64 160, i64 8, !106, i64 168, i64 0, !76, i64 168, i64 2, !105, i64 170, i64 29, !76, i64 199, i64 1, !76, i64 168, i64 2, !105, i64 176, i64 8, !2, i64 168, i64 2, !105, i64 200, i64 0, !76, i64 200, i64 4, !75}
