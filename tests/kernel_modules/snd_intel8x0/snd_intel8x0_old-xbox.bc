; ModuleID = 'tests/kernel_modules/snd_intel8x0/snd_intel8x0_old.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.46 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.46 = type { i8* }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.__wait_queue_head }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.shrink_control, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %union.anon.12, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.48, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.proc_dir_entry = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.arch_spinlock, i8 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.arch_spinlock = type { %union.anon.12 }
%struct.shrink_control = type { i32, i64 }
%struct.pcie_link_state = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.46, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.mutex = type { %union.anon.12, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.task_struct = type { i64, i8*, %union.anon.12, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.42, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %union.anon.12, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %union.anon.12, %union.anon.12, i64, i64, %struct.memcg_batch_info, i32, %union.anon.12, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %union.anon.12, %union.anon.12, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %union.anon.12, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.file = type { %union.anon.42, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %union.anon.12, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.42, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %union.anon.12, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.arch_spinlock, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %union.anon.12, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.12, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.12, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.36, i64, %union.anon.12, %union.anon.12, %union.anon.12, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.38, i32, i32, %struct.hlist_head, %union.anon.12, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.36 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.pid = type { %union.anon.12, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.46, i32 }
%struct.swap_info_struct = type opaque
%union.anon.38 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %struct.pgprot, i32, i32, i8*, %struct.lockdep_map }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.0, %union.anon.42, %struct.pgprot, i64 }
%struct.anon.0 = type { %struct.pgprot, %struct.pgprot }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %union.anon.12, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.load_weight = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %union.anon.12, %union.anon.12, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %union.anon.12, i32, %union.anon.14, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.42, %struct.pgprot }
%union.anon.14 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %union.anon.12, %union.anon.12, %union.anon.12, %union.anon.12, %union.anon.12, %union.anon.12, %union.anon.12, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.user_namespace = type opaque
%struct.group_info = type { %union.anon.12, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.18 }
%union.anon.18 = type { %struct.exception_table_entry }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.21, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.24 }
%union.anon.21 = type { %struct.load_weight }
%union.anon.24 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %union.anon.12, %union.anon.12, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %union.anon.12, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%union.anon.42 = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.26 }
%union.anon.26 = type { %struct.anon.30, [80 x i8] }
%struct.anon.30 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_pm_info = type { %union.anon.12, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %union.anon.12, %union.anon.12, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.pgprot, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type { %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request* }
%struct.pm_qos_constraints = type { %union.anon.42, i32, i32, i32, %struct.blocking_notifier_head* }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.pm_qos_flags = type { %struct.list_head, i32 }
%struct.dev_pm_qos_request = type { i32, %union.anon.47, %struct.device* }
%union.anon.47 = type { %struct.plist_node }
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i8*, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.sigset_t*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.sigset_t*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32, %struct.sigset_t*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.sigset_t*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.spinlock = type { %union.anon.11 }
%union.anon.11 = type { %struct.raw_spinlock }
%struct.klist_node = type { i8*, %struct.list_head, %struct.arch_spinlock }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%union.anon.12 = type { i32 }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.pci_vpd = type opaque
%union.anon.48 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.snd_pci_quirk = type { i16, i16, i16, i32, i8* }
%struct.shortname_table = type { i32, i8* }
%struct.ich_pcm_table = type { i8*, %struct.snd_pcm_ops*, %struct.snd_pcm_ops*, i64, i64, i32 }
%struct.snd_pcm_ops = type { i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*, i32, i8*)*, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)*, i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*, i32)*, i64 (%struct.snd_pcm_substream*)*, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)*, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)*, i32 (%struct.snd_pcm_substream*, i32, i64, i64)*, %struct.page* (%struct.snd_pcm_substream*, i64)*, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)*, i32 (%struct.snd_pcm_substream*)* }
%struct.snd_pcm_substream = type { %struct.snd_pcm*, %struct.snd_pcm_str*, i8*, i32, [32 x i8], i32, %struct.pm_qos_request, i64, %struct.snd_dma_buffer, i32, i64, %struct.snd_pcm_ops*, %struct.snd_pcm_runtime*, %struct.snd_timer*, i8, %struct.snd_pcm_substream*, %struct.list_head, %struct.snd_pcm_group, %struct.snd_pcm_group*, i8*, i32, %union.anon.12, i32, void (%struct.snd_pcm_substream*)*, %struct.pid*, %struct.snd_pcm_oss_substream, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.snd_info_entry*, i8 }
%struct.snd_pcm = type { %struct.snd_card*, %struct.list_head, i32, i32, i16, i16, [64 x i8], [80 x i8], [2 x %struct.snd_pcm_str], %struct.mutex, %struct.__wait_queue_head, i8*, void (%struct.snd_pcm*)*, %struct.device*, i8, %struct.exception_table_entry }
%struct.snd_card = type { i32, [16 x i8], [16 x i8], [32 x i8], [80 x i8], [80 x i8], [128 x i8], %struct.module*, i8*, void (%struct.snd_card*)*, %struct.list_head, i32, %struct.rw_semaphore, %struct.rwlock_t, i32, i32, %struct.list_head, %struct.list_head, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.proc_dir_entry*, %struct.list_head, %struct.snd_shutdown_f_ops*, %struct.spinlock, i32, i32, %struct.__wait_queue_head, %union.anon.12, %struct.device*, %struct.device*, i32, %struct.mutex, %struct.__wait_queue_head, %struct.snd_mixer_oss*, i32 }
%struct.snd_shutdown_f_ops = type opaque
%struct.snd_mixer_oss = type opaque
%struct.snd_pcm_str = type { i32, %struct.snd_pcm*, i32, i32, %struct.snd_pcm_substream*, %struct.snd_pcm_oss_stream, %struct.snd_info_entry*, %struct.snd_info_entry*, i32, %struct.snd_info_entry*, %struct.snd_kcontrol* }
%struct.snd_pcm_oss_stream = type { %struct.snd_pcm_oss_setup*, %struct.mutex, %struct.snd_info_entry* }
%struct.snd_pcm_oss_setup = type { i8*, i8, i32, i32, %struct.snd_pcm_oss_setup* }
%struct.snd_kcontrol = type { %struct.list_head, %struct.snd_ctl_elem_id, i32, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_info*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, i32 (%struct.snd_kcontrol*, %struct.snd_ctl_elem_value*)*, %union.anon.60, i64, i8*, void (%struct.snd_kcontrol*)*, [0 x %struct.snd_kcontrol_volatile] }
%struct.snd_ctl_elem_id = type { i32, i32, i32, i32, [44 x i8], i32 }
%struct.snd_ctl_elem_info = type { %struct.snd_ctl_elem_id, i32, i32, i32, i32, %union.anon.50, %union.anon.54, [56 x i8] }
%union.anon.50 = type { %struct.anon.53, [40 x i8] }
%struct.anon.53 = type { i32, i32, [64 x i8], i64, i32 }
%union.anon.54 = type { i16* }
%struct.snd_ctl_elem_value = type { %struct.snd_ctl_elem_id, i8, %union.anon.55, %struct.load_weight, [112 x i8] }
%union.anon.55 = type { %union.anon.56 }
%union.anon.56 = type { [128 x i64] }
%union.anon.60 = type { i32 (%struct.snd_kcontrol*, i32, i32, i32*)* }
%struct.snd_kcontrol_volatile = type { %struct.snd_ctl_file*, i32 }
%struct.snd_ctl_file = type { %struct.list_head, %struct.snd_card*, %struct.pid*, i32, i32, %struct.__wait_queue_head, %struct.spinlock, %struct.fasync_struct*, i32, %struct.list_head }
%struct.pm_qos_request = type { %struct.plist_node, i32, %struct.delayed_work }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.workqueue_struct = type opaque
%struct.snd_dma_buffer = type { %struct.snd_dma_device, i8*, i64, i64, i8* }
%struct.snd_dma_device = type { i32, %struct.device* }
%struct.snd_pcm_runtime = type { %struct.snd_pcm_substream*, %struct.load_weight, i32, i64, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, i32, i64, i32, i64, i64, i64, i32, i32, i32, i32, i32, i8, i32, i32, i64, i64, i64, i64, i64, i64, i64, %union.snd_pcm_sync_id, %struct.snd_pcm_mmap_status*, %struct.load_weight*, i64, %struct.__wait_queue_head, %struct.__wait_queue_head, %struct.fasync_struct*, i8*, void (%struct.snd_pcm_runtime*)*, %struct.snd_pcm_hardware, %struct.snd_pcm_hw_constraints, void (%struct.snd_pcm_substream*)*, void (%struct.snd_pcm_substream*)*, i32, i32, i8*, i64, i64, %struct.snd_dma_buffer*, %struct.snd_pcm_oss_runtime, %struct.snd_pcm_hwptr_log* }
%union.snd_pcm_sync_id = type { [4 x i32] }
%struct.snd_pcm_mmap_status = type { i32, i32, i64, %struct.load_weight, i32, %struct.load_weight }
%struct.snd_pcm_hardware = type { i32, i64, i32, i32, i32, i32, i32, i64, i64, i64, i32, i32, i64 }
%struct.snd_pcm_hw_constraints = type { [3 x %struct.snd_mask], [12 x %struct.snd_interval], i32, i32, %struct.snd_pcm_hw_rule* }
%struct.snd_mask = type { [8 x i32] }
%struct.snd_interval = type { i32, i32, i8 }
%struct.snd_pcm_hw_rule = type { i32, i32 (%struct.snd_pcm_hw_params*, %struct.snd_pcm_hw_rule*)*, i32, [4 x i32], i8* }
%struct.snd_pcm_hw_params = type { i32, [3 x %struct.snd_mask], [5 x %struct.snd_mask], [12 x %struct.snd_interval], [9 x %struct.snd_interval], i32, i32, i32, i32, i32, i32, i64, [64 x i8] }
%struct.snd_pcm_oss_runtime = type { i8, i32, i32, i32, i32, i32, i32, i64, i64, i64, i32, i64, i64, i64, i8*, i64, %struct.mutex, %struct.snd_pcm_plugin*, %struct.snd_pcm_plugin*, i32 }
%struct.snd_pcm_plugin = type opaque
%struct.snd_pcm_hwptr_log = type opaque
%struct.snd_timer = type opaque
%struct.snd_pcm_group = type { %struct.spinlock, %struct.list_head, i32 }
%struct.snd_pcm_oss_substream = type { i8, %struct.snd_pcm_oss_setup }
%struct.snd_info_entry = type { i8*, i16, i64, i16, %union.anon.49, %struct.snd_info_entry*, %struct.snd_card*, %struct.module*, i8*, void (%struct.snd_info_entry*)*, %struct.proc_dir_entry*, %struct.mutex, %struct.list_head, %struct.list_head }
%union.anon.49 = type { %struct.snd_info_entry_text }
%struct.snd_info_entry_text = type { void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* }
%struct.snd_info_buffer = type { i8*, i32, i32, i32, i32, i32 }
%struct.snd_pcm_chmap_elem = type { i8, [15 x i8] }
%struct.snd_pcm_hw_constraint_list = type { i32, i32*, i32 }
%struct.snd_ac97_bus_ops = type { void (%struct.snd_ac97*)*, void (%struct.snd_ac97*)*, void (%struct.snd_ac97*, i16, i16)*, i16 (%struct.snd_ac97*, i16)*, void (%struct.snd_ac97*)*, void (%struct.snd_ac97*)* }
%struct.snd_ac97 = type { %struct.snd_ac97_build_ops*, i8*, {}*, %struct.snd_ac97_bus*, %struct.pci_dev*, %struct.snd_info_entry*, %struct.snd_info_entry*, i16, i16, %struct.mutex, %struct.mutex, i16, i16, i32, i16, i16, i16, %struct.snd_ac97_res_table*, i32, i32, [6 x i32], i32, [128 x i16], [2 x i64], %union.anon.61, i8, i8, i32, %struct.delayed_work, %struct.device, [2 x %struct.snd_pcm_chmap*] }
%struct.snd_ac97_build_ops = type { i32 (%struct.snd_ac97*)*, i32 (%struct.snd_ac97*)*, i32 (%struct.snd_ac97*)*, i32 (%struct.snd_ac97*)*, {}*, {}*, {}* }
%struct.snd_ac97_bus = type { %struct.snd_ac97_bus_ops*, i8*, void (%struct.snd_ac97_bus*)*, %struct.snd_card*, i16, i8, i32, %struct.spinlock, [2 x [4 x i16]], i16, %struct.ac97_pcm*, [4 x %struct.snd_ac97*], %struct.snd_info_entry* }
%struct.ac97_pcm = type { %struct.snd_ac97_bus*, i8, i16, i16, i32, [2 x %struct.anon.63], i64 }
%struct.anon.63 = type { i16, [4 x i16], [4 x i8], [4 x %struct.snd_ac97*] }
%struct.snd_ac97_res_table = type { i16, i16 }
%union.anon.61 = type { i32, [28 x i8] }
%struct.snd_pcm_chmap = type { %struct.snd_pcm*, i32, %struct.snd_kcontrol*, %struct.snd_pcm_chmap_elem*, i32, i32, i8* }
%struct.ac97_quirk = type { i16, i16, i16, i32, i8*, i32 }
%struct.snd_device_ops = type { i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)* }
%struct.snd_device = type { %struct.list_head, %struct.snd_card*, i32, i32, i8*, %struct.snd_device_ops* }
%struct.cpuinfo_x86 = type { i8, i8, i8, i8, i32, i8, i8, i8, i32, i32, [11 x i32], [16 x i8], [64 x i8], i32, i32, i32, i64, i16, i16, i16, i16, i16, i16, i16, i8, i16, i32 }
%struct.pv_cpu_ops = type { i64 (i32)*, void (i32, i64)*, void ()*, i64 ()*, void (i64)*, i64 ()*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, void ()*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (i8*, i32)*, i64 ()*, void (%struct.thread_struct*, i32)*, void (i32)*, void (%struct.desc_struct*, i32, i8*)*, void (%struct.desc_struct*, i32, i8*, i32)*, void (%struct.gate_struct64*, i32, %struct.gate_struct64*)*, void (%struct.desc_struct*, i32)*, void (%struct.desc_struct*, i32)*, void (%struct.tss_struct*, %struct.thread_struct*)*, void (i32)*, void ()*, void ()*, void (i32*, i32*, i32*, i32*)*, i64 (i32, i32*)*, i32 (i32, i32, i32)*, i64 ()*, i64 (i32)*, i64 (i32*)*, void ()*, void ()*, void ()*, void ()*, void ()*, void (%struct.task_struct*)*, void (%struct.task_struct*)* }
%struct.desc_ptr = type <{ i16, i64 }>
%struct.gate_struct64 = type { i16, i16, i16, i16, i32, i32 }
%struct.tss_struct = type { %struct.x86_hw_tss, [1025 x i64], [64 x i64], [56 x i8] }
%struct.x86_hw_tss = type <{ i32, i64, i64, i64, i64, [7 x i64], i32, i32, i16, i16, [24 x i8] }>
%struct.intel8x0 = type { i32, i32, i8*, i8*, %struct.pci_dev*, %struct.snd_card*, i32, [6 x %struct.snd_pcm*], [6 x %struct.ichdev], i16, i32, i32, %struct.snd_ac97_bus*, [3 x %struct.snd_ac97*], [3 x i32], i32, i32, i32*, i32, i32, %struct.spinlock, i32, %struct.snd_dma_buffer, i32, i32 }
%struct.ichdev = type { i32, i64, i32*, i32, %struct.snd_pcm_substream*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.ac97_pcm*, i32, i8 }
%struct.snd_ac97_template = type { i8*, void (%struct.snd_ac97*)*, %struct.pci_dev*, i16, i16, i32, %struct.snd_ac97_res_table* }

@llvm.used = appending global [34 x i8*] [i8* getelementptr inbounds ([40 x i8], [40 x i8]* @__UNIQUE_ID_author51, i32 0, i32 0), i8* getelementptr inbounds ([85 x i8], [85 x i8]* @__UNIQUE_ID_description52, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license53, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_index to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_indextype88, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @__UNIQUE_ID_index89, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_id to i8*), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__UNIQUE_ID_idtype90, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @__UNIQUE_ID_id91, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_ac97_clock to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_ac97_clocktype92, i32 0, i32 0), i8* getelementptr inbounds ([87 x i8], [87 x i8]* @__UNIQUE_ID_ac97_clock93, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_ac97_quirk to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_ac97_quirktype94, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @__UNIQUE_ID_ac97_quirk95, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_buggy_semaphore to i8*), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_buggy_semaphoretype96, i32 0, i32 0), i8* getelementptr inbounds ([88 x i8], [88 x i8]* @__UNIQUE_ID_buggy_semaphore97, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_buggy_irq to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_buggy_irqtype98, i32 0, i32 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @__UNIQUE_ID_buggy_irq99, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_xbox to i8*), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__UNIQUE_ID_xboxtype100, i32 0, i32 0), i8* getelementptr inbounds ([82 x i8], [82 x i8]* @__UNIQUE_ID_xbox101, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_spdif_aclink to i8*), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__UNIQUE_ID_spdif_aclinktype102, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @__UNIQUE_ID_spdif_aclink103, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_inside_vm to i8*), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__UNIQUE_ID_inside_vmtype104, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @__UNIQUE_ID_inside_vm105, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_enable to i8*), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__UNIQUE_ID_enabletype109, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_joystick to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_joysticktype111, i32 0, i32 0)], section "llvm.metadata"
@__UNIQUE_ID_author51 = internal constant [40 x i8] c"author=Jaroslav Kysela <perex@perex.cz>\00", section ".modinfo", align 1
@__UNIQUE_ID_description52 = internal constant [85 x i8] c"description=Intel 82801AA,82901AB,i810,i820,i830,i840,i845,MX440; SiS 7012; Ali 5455\00", section ".modinfo", align 1
@__UNIQUE_ID_license53 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_index = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__param_str_index, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @index to i8*) } }, section "__param", align 8
@__UNIQUE_ID_indextype88 = internal constant [19 x i8] c"parmtype=index:int\00", section ".modinfo", align 1
@__UNIQUE_ID_index89 = internal constant [49 x i8] c"parm=index:Index value for Intel i8x0 soundcard.\00", section ".modinfo", align 1
@__param_id = internal constant %struct.kernel_param { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__param_str_id, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_charp, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i8** @id to i8*) } }, section "__param", align 8
@__UNIQUE_ID_idtype90 = internal constant [18 x i8] c"parmtype=id:charp\00", section ".modinfo", align 1
@__UNIQUE_ID_id91 = internal constant [44 x i8] c"parm=id:ID string for Intel i8x0 soundcard.\00", section ".modinfo", align 1
@__param_ac97_clock = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_ac97_clock, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @ac97_clock to i8*) } }, section "__param", align 8
@__UNIQUE_ID_ac97_clocktype92 = internal constant [24 x i8] c"parmtype=ac97_clock:int\00", section ".modinfo", align 1
@__UNIQUE_ID_ac97_clock93 = internal constant [87 x i8] c"parm=ac97_clock:AC'97 codec clock (0 = whitelist + auto-detect, 1 = force autodetect).\00", section ".modinfo", align 1
@__param_ac97_quirk = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_ac97_quirk, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_charp, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i8** @ac97_quirk to i8*) } }, section "__param", align 8
@__UNIQUE_ID_ac97_quirktype94 = internal constant [26 x i8] c"parmtype=ac97_quirk:charp\00", section ".modinfo", align 1
@__UNIQUE_ID_ac97_quirk95 = internal constant [55 x i8] c"parm=ac97_quirk:AC'97 workaround for strange hardware.\00", section ".modinfo", align 1
@__param_buggy_semaphore = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_buggy_semaphore, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 292, i16 -1, %union.anon.46 { i8* @buggy_semaphore } }, section "__param", align 8
@__UNIQUE_ID_buggy_semaphoretype96 = internal constant [30 x i8] c"parmtype=buggy_semaphore:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_buggy_semaphore97 = internal constant [88 x i8] c"parm=buggy_semaphore:Enable workaround for hardwares with problematic codec semaphores.\00", section ".modinfo", align 1
@__param_buggy_irq = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_buggy_irq, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bint, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @buggy_irq to i8*) } }, section "__param", align 8
@__UNIQUE_ID_buggy_irqtype98 = internal constant [24 x i8] c"parmtype=buggy_irq:bint\00", section ".modinfo", align 1
@__UNIQUE_ID_buggy_irq99 = internal constant [76 x i8] c"parm=buggy_irq:Enable workaround for buggy interrupts on some motherboards.\00", section ".modinfo", align 1
@__param_xbox = internal constant %struct.kernel_param { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @__param_str_xbox, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 292, i16 -1, %union.anon.46 { i8* @xbox } }, section "__param", align 8
@__UNIQUE_ID_xboxtype100 = internal constant [19 x i8] c"parmtype=xbox:bool\00", section ".modinfo", align 1
@__UNIQUE_ID_xbox101 = internal constant [82 x i8] c"parm=xbox:Set to 1 for Xbox, if you have problems with the AC'97 codec detection.\00", section ".modinfo", align 1
@__param_spdif_aclink = internal constant %struct.kernel_param { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__param_str_spdif_aclink, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @spdif_aclink to i8*) } }, section "__param", align 8
@__UNIQUE_ID_spdif_aclinktype102 = internal constant [26 x i8] c"parmtype=spdif_aclink:int\00", section ".modinfo", align 1
@__UNIQUE_ID_spdif_aclink103 = internal constant [39 x i8] c"parm=spdif_aclink:S/PDIF over AC-link.\00", section ".modinfo", align 1
@__param_inside_vm = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_inside_vm, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bint, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @inside_vm to i8*) } }, section "__param", align 8
@__UNIQUE_ID_inside_vmtype104 = internal constant [24 x i8] c"parmtype=inside_vm:bint\00", section ".modinfo", align 1
@__UNIQUE_ID_inside_vm105 = internal constant [43 x i8] c"parm=inside_vm:KVM/Parallels optimization.\00", section ".modinfo", align 1
@__param_enable = internal constant %struct.kernel_param { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @__param_str_enable, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 292, i16 -1, %union.anon.46 { i8* @enable } }, section "__param", align 8
@__UNIQUE_ID_enabletype109 = internal constant [21 x i8] c"parmtype=enable:bool\00", section ".modinfo", align 1
@__param_joystick = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_joystick, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.46 { i8* bitcast (i32* @joystick to i8*) } }, section "__param", align 8
@__UNIQUE_ID_joysticktype111 = internal constant [22 x i8] c"parmtype=joystick:int\00", section ".modinfo", align 1
@__param_str_joystick = internal constant [9 x i8] c"joystick\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@joystick = internal global i32 0, align 4
@__param_str_enable = internal constant [7 x i8] c"enable\00", align 1
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@enable = internal global i8 0, align 1
@__param_str_inside_vm = internal constant [10 x i8] c"inside_vm\00", align 1
@param_ops_bint = external global %struct.kernel_param_ops, align 8
@inside_vm = internal global i32 -1, align 4
@__param_str_spdif_aclink = internal constant [13 x i8] c"spdif_aclink\00", align 1
@spdif_aclink = internal global i32 -1, align 4
@__param_str_xbox = internal constant [5 x i8] c"xbox\00", align 1
@xbox = internal global i8 0, align 1
@__param_str_buggy_irq = internal constant [10 x i8] c"buggy_irq\00", align 1
@buggy_irq = internal global i32 -1, align 4
@__param_str_buggy_semaphore = internal constant [16 x i8] c"buggy_semaphore\00", align 16
@buggy_semaphore = internal global i8 0, align 1
@__param_str_ac97_quirk = internal constant [11 x i8] c"ac97_quirk\00", align 1
@param_ops_charp = external global %struct.kernel_param_ops, align 8
@ac97_quirk = internal global i8* null, align 8
@__param_str_ac97_clock = internal constant [11 x i8] c"ac97_clock\00", align 1
@ac97_clock = internal global i32 0, align 4
@__param_str_id = internal constant [3 x i8] c"id\00", align 1
@id = internal global i8* null, align 8
@__param_str_index = internal constant [6 x i8] c"index\00", align 1
@index = internal global i32 -1, align 4
@snd_intel8x0_ids = internal constant [24 x %struct.pci_device_id] [%struct.pci_device_id { i32 32902, i32 9237, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9253, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9285, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9349, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 9413, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9429, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9638, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9838, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 10206, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 9880, i32 -1, i32 -1, i32 0, i32 0, i64 1 }, %struct.pci_device_id { i32 32902, i32 29077, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 4153, i32 28690, i32 -1, i32 -1, i32 0, i32 0, i64 2 }, %struct.pci_device_id { i32 4318, i32 433, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 58, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 106, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 89, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 138, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 218, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 234, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4318, i32 619, i32 -1, i32 -1, i32 0, i32 0, i64 4 }, %struct.pci_device_id { i32 4130, i32 29805, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 4130, i32 29765, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 4281, i32 21589, i32 -1, i32 -1, i32 0, i32 0, i64 3 }, %struct.pci_device_id zeroinitializer], align 16
@intel8x0_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([24 x %struct.pci_device_id], [24 x %struct.pci_device_id]* @snd_intel8x0_ids, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @snd_intel8x0_probe, void (%struct.pci_dev*)* @snd_intel8x0_remove, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @intel8x0_pm, %struct.driver_private* null }, %struct.__wait_queue_head zeroinitializer }, align 8
@__this_module = external global %struct.module, align 8
@.str = private unnamed_addr constant [13 x i8] c"snd_intel8x0\00", align 1
@intel8x0_pm = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @intel8x0_suspend, i32 (%struct.device*)* @intel8x0_resume, i32 (%struct.device*)* @intel8x0_suspend, i32 (%struct.device*)* @intel8x0_resume, i32 (%struct.device*)* @intel8x0_suspend, i32 (%struct.device*)* @intel8x0_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null }, align 8
@.str.149 = private unnamed_addr constant [56 x i8] c"\013intel8x0: pci_enable_device failed, disabling device\0A\00", align 1
@.str.150 = private unnamed_addr constant [53 x i8] c"\013intel8x0: unable to grab IRQ %d, disabling device\0A\00", align 1
@.str.46 = private unnamed_addr constant [40 x i8] c"\013intel8x0: reset of registers failed?\0A\00", align 1
@.str.7 = private unnamed_addr constant [21 x i8] c"sound/pci/intel8x0.c\00", align 1
@.str.50 = private unnamed_addr constant [23 x i8] c"\013AC'97 reset failed.\0A\00", align 1
@ich_chip_reset_mode = internal global [2 x %struct.snd_pci_quirk] [%struct.snd_pci_quirk { i16 4116, i16 1311, i16 -1, i32 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.48, i32 0, i32 0) }, %struct.snd_pci_quirk zeroinitializer], align 16
@jiffies = external global i64, align 8
@.str.47 = private unnamed_addr constant [42 x i8] c"\013codec_ready: codec is not ready [0x%x]\0A\00", align 1
@.str.49 = private unnamed_addr constant [46 x i8] c"\013AC'97 warm reset still in progress? [0x%x]\0A\00", align 1
@.str.48 = private unnamed_addr constant [13 x i8] c"Thinkpad R32\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"ICH\00", align 1
@.str.3 = private unnamed_addr constant [7 x i8] c"NFORCE\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"ICH4\00", align 1
@.str.5 = private unnamed_addr constant [10 x i8] c"Intel ICH\00", align 1
@shortnames = internal global [23 x %struct.shortname_table] [%struct.shortname_table { i32 9237, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.11, i32 0, i32 0) }, %struct.shortname_table { i32 9253, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.12, i32 0, i32 0) }, %struct.shortname_table { i32 9285, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.13, i32 0, i32 0) }, %struct.shortname_table { i32 29077, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.14, i32 0, i32 0) }, %struct.shortname_table { i32 9349, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.15, i32 0, i32 0) }, %struct.shortname_table { i32 9413, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.16, i32 0, i32 0) }, %struct.shortname_table { i32 9429, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.17, i32 0, i32 0) }, %struct.shortname_table { i32 9638, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.18, i32 0, i32 0) }, %struct.shortname_table { i32 9838, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.19, i32 0, i32 0) }, %struct.shortname_table { i32 10206, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.20, i32 0, i32 0) }, %struct.shortname_table { i32 9880, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.21, i32 0, i32 0) }, %struct.shortname_table { i32 28690, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.22, i32 0, i32 0) }, %struct.shortname_table { i32 433, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.23, i32 0, i32 0) }, %struct.shortname_table { i32 106, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.24, i32 0, i32 0) }, %struct.shortname_table { i32 218, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.25, i32 0, i32 0) }, %struct.shortname_table { i32 234, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.26, i32 0, i32 0) }, %struct.shortname_table { i32 89, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0) }, %struct.shortname_table { i32 138, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i32 0, i32 0) }, %struct.shortname_table { i32 58, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.29, i32 0, i32 0) }, %struct.shortname_table { i32 29805, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.30, i32 0, i32 0) }, %struct.shortname_table { i32 29765, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.31, i32 0, i32 0) }, %struct.shortname_table { i32 21589, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.32, i32 0, i32 0) }, %struct.shortname_table zeroinitializer], align 16
@.str.6 = private unnamed_addr constant [21 x i8] c"%s with %s at irq %i\00", align 1
@.str.142 = private unnamed_addr constant [62 x i8] c"\014no playback buffer allocated - aborting measure ac97 clock\0A\00", align 1
@.str.143 = private unnamed_addr constant [36 x i8] c"\013cannot set ac97 rate: clock = %d\0A\00", align 1
@.str.144 = private unnamed_addr constant [49 x i8] c"\013intel8x0: measure - unreliable DMA position..\0A\00", align 1
@.str.145 = private unnamed_addr constant [40 x i8] c"\016%s: measured %lu usecs (%lu samples)\0A\00", align 1
@__func__.intel8x0_measure_ac97_clock = private unnamed_addr constant [28 x i8] c"intel8x0_measure_ac97_clock\00", align 1
@.str.146 = private unnamed_addr constant [36 x i8] c"\013intel8x0: ?? calculation error..\0A\00", align 1
@.str.147 = private unnamed_addr constant [41 x i8] c"\016intel8x0: measured clock %ld rejected\0A\00", align 1
@.str.148 = private unnamed_addr constant [28 x i8] c"\016intel8x0: clocking to %d\0A\00", align 1
@intel8x0_clock_list = internal global [6 x %struct.snd_pci_quirk] [%struct.snd_pci_quirk { i16 3601, i16 138, i16 -1, i32 41000, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.138, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4136, i16 190, i16 -1, i32 44100, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.138, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4136, i16 375, i16 -1, i32 48000, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.139, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4136, i16 429, i16 -1, i32 48000, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.140, i32 0, i32 0) }, %struct.snd_pci_quirk { i16 4163, i16 -32525, i16 -1, i32 48000, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.141, i32 0, i32 0) }, %struct.snd_pci_quirk zeroinitializer], align 16
@.str.137 = private unnamed_addr constant [49 x i8] c"\016intel8x0: white list rate for %04x:%04x is %i\0A\00", align 1
@.str.138 = private unnamed_addr constant [7 x i8] c"AD1885\00", align 1
@.str.139 = private unnamed_addr constant [7 x i8] c"AD1980\00", align 1
@.str.140 = private unnamed_addr constant [8 x i8] c"AD1981B\00", align 1
@.str.141 = private unnamed_addr constant [7 x i8] c"AD1985\00", align 1
@.str.124 = private unnamed_addr constant [9 x i8] c"intel8x0\00", align 1
@.str.125 = private unnamed_addr constant [11 x i8] c"Intel8x0\0A\0A\00", align 1
@.str.126 = private unnamed_addr constant [32 x i8] c"Global control        : 0x%08x\0A\00", align 1
@.str.127 = private unnamed_addr constant [32 x i8] c"Global status         : 0x%08x\0A\00", align 1
@.str.128 = private unnamed_addr constant [32 x i8] c"SDM                   : 0x%08x\0A\00", align 1
@.str.129 = private unnamed_addr constant [24 x i8] c"AC'97 codecs ready    :\00", align 1
@snd_intel8x0_proc_read.codecs = internal global [3 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.130, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.131, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.132, i32 0, i32 0)], align 16
@.str.133 = private unnamed_addr constant [4 x i8] c" %s\00", align 1
@.str.134 = private unnamed_addr constant [6 x i8] c" none\00", align 1
@.str.135 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.136 = private unnamed_addr constant [34 x i8] c"AC'97 codecs SDIN     : %i %i %i\0A\00", align 1
@.str.130 = private unnamed_addr constant [8 x i8] c"primary\00", align 1
@.str.131 = private unnamed_addr constant [10 x i8] c"secondary\00", align 1
@.str.132 = private unnamed_addr constant [9 x i8] c"tertiary\00", align 1
@intel_pcms = internal global [5 x %struct.ich_pcm_table] [%struct.ich_pcm_table { i8* null, %struct.snd_pcm_ops* @snd_intel8x0_playback_ops, %struct.snd_pcm_ops* @snd_intel8x0_capture_ops, i64 65536, i64 131072, i32 0 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.118, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture_mic_ops, i64 0, i64 131072, i32 2 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.119, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture_mic2_ops, i64 0, i64 131072, i32 3 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.120, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture2_ops, i64 0, i64 131072, i32 4 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.121, i32 0, i32 0), %struct.snd_pcm_ops* @snd_intel8x0_spdif_ops, %struct.snd_pcm_ops* null, i64 65536, i64 131072, i32 5 }], align 16
@nforce_pcms = internal global [3 x %struct.ich_pcm_table] [%struct.ich_pcm_table { i8* null, %struct.snd_pcm_ops* @snd_intel8x0_playback_ops, %struct.snd_pcm_ops* @snd_intel8x0_capture_ops, i64 65536, i64 131072, i32 0 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.118, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_capture_mic_ops, i64 0, i64 131072, i32 2 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.121, i32 0, i32 0), %struct.snd_pcm_ops* @snd_intel8x0_spdif_ops, %struct.snd_pcm_ops* null, i64 65536, i64 131072, i32 3 }], align 16
@ali_pcms = internal global [3 x %struct.ich_pcm_table] [%struct.ich_pcm_table { i8* null, %struct.snd_pcm_ops* @snd_intel8x0_ali_playback_ops, %struct.snd_pcm_ops* @snd_intel8x0_ali_capture_ops, i64 65536, i64 131072, i32 0 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.118, i32 0, i32 0), %struct.snd_pcm_ops* null, %struct.snd_pcm_ops* @snd_intel8x0_ali_capture_mic_ops, i64 0, i64 131072, i32 2 }, %struct.ich_pcm_table { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.121, i32 0, i32 0), %struct.snd_pcm_ops* @snd_intel8x0_ali_ac97spdifout_ops, %struct.snd_pcm_ops* null, i64 65536, i64 131072, i32 3 }], align 16
@.str.122 = private unnamed_addr constant [15 x i8] c"Intel ICH - %s\00", align 1
@.str.123 = private unnamed_addr constant [8 x i8] c"%s - %s\00", align 1
@snd_pcm_alt_chmaps = external constant [0 x %struct.snd_pcm_chmap_elem], align 1
@snd_intel8x0_ali_playback_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_ali_capture_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.118 = private unnamed_addr constant [8 x i8] c"MIC ADC\00", align 1
@snd_intel8x0_ali_capture_mic_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.121 = private unnamed_addr constant [7 x i8] c"IEC958\00", align 1
@snd_intel8x0_ali_ac97spdifout_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_ali_ac97spdifout_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_ali_ac97spdifout_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_ali_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_ali_trigger.fiforeg = internal global [3 x i32] [i32 12, i32 28, i32 44], align 4
@snd_intel8x0_stream = internal global %struct.snd_pcm_hardware { i32 852227, i64 4, i32 128, i32 48000, i32 48000, i32 2, i32 2, i64 131072, i64 32, i64 131072, i32 1, i32 1024, i64 0 }, align 8
@hw_constraints_channels8 = internal global %struct.snd_pcm_hw_constraint_list { i32 4, i32* getelementptr inbounds ([4 x i32], [4 x i32]* @channels8, i32 0, i32 0), i32 0 }, align 8
@hw_constraints_channels6 = internal global %struct.snd_pcm_hw_constraint_list { i32 3, i32* getelementptr inbounds ([3 x i32], [3 x i32]* @channels6, i32 0, i32 0), i32 0 }, align 8
@hw_constraints_channels4 = internal global %struct.snd_pcm_hw_constraint_list { i32 2, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @channels4, i32 0, i32 0), i32 0 }, align 8
@channels4 = internal global [2 x i32] [i32 2, i32 4], align 4
@channels6 = internal global [3 x i32] [i32 2, i32 4, i32 6], align 4
@channels8 = internal global [4 x i32] [i32 2, i32 4, i32 6, i32 8], align 16
@snd_intel8x0_playback_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_playback_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_capture_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_capture_mic_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_spdif_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_spdif_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_spdif_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.119 = private unnamed_addr constant [9 x i8] c"MIC2 ADC\00", align 1
@snd_intel8x0_capture_mic2_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic2_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_mic2_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@.str.120 = private unnamed_addr constant [5 x i8] c"ADC2\00", align 1
@snd_intel8x0_capture2_ops = internal global %struct.snd_pcm_ops { i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture2_open, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_capture2_close, i32 (%struct.snd_pcm_substream*, i32, i8*)* @snd_pcm_lib_ioctl, i32 (%struct.snd_pcm_substream*, %struct.snd_pcm_hw_params*)* @snd_intel8x0_hw_params, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_hw_free, i32 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_prepare, i32 (%struct.snd_pcm_substream*, i32)* @snd_intel8x0_pcm_trigger, i64 (%struct.snd_pcm_substream*)* @snd_intel8x0_pcm_pointer, i32 (%struct.snd_pcm_substream*, %struct.load_weight*)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i8*, i64)* null, i32 (%struct.snd_pcm_substream*, i32, i64, i64)* null, %struct.page* (%struct.snd_pcm_substream*, i64)* null, i32 (%struct.snd_pcm_substream*, %struct.vm_area_struct*)* null, i32 (%struct.snd_pcm_substream*)* null }, align 8
@snd_intel8x0_mixer.standard_bus_ops = internal global %struct.snd_ac97_bus_ops { void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*, i16, i16)* @snd_intel8x0_codec_write, i16 (%struct.snd_ac97*, i16)* @snd_intel8x0_codec_read, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null }, align 8
@snd_intel8x0_mixer.ali_bus_ops = internal global %struct.snd_ac97_bus_ops { void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*, i16, i16)* @snd_intel8x0_ali_codec_write, i16 (%struct.snd_ac97*, i16)* @snd_intel8x0_ali_codec_read, void (%struct.snd_ac97*)* null, void (%struct.snd_ac97*)* null }, align 8
@.str.51 = private unnamed_addr constant [34 x i8] c"\013Unable to initialize codec #%d\0A\00", align 1
@ac97_quirks = internal global [66 x %struct.ac97_quirk] [%struct.ac97_quirk { i16 3601, i16 14, i16 0, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.58, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 3601, i16 138, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.59, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 3601, i16 184, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.60, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 3601, i16 2144, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.61, i32 0, i32 0), i32 7 }, %struct.ac97_quirk { i16 4116, i16 1332, i16 0, i32 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.62, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4116, i16 7936, i16 0, i32 0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.63, i32 0, i32 0), i32 5 }, %struct.ac97_quirk { i16 4116, i16 615, i16 0, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.64, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4133, i16 130, i16 0, i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.65, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4133, i16 131, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.66, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 216, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.67, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 269, i16 0, i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.68, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 294, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.69, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 300, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.70, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 301, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.71, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 327, i16 0, i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.68, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 337, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.72, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 334, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.73, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 355, i16 0, i32 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.74, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 362, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.75, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 386, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.76, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4136, i16 390, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.77, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4136, i16 392, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.78, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4136, i16 393, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.79, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4136, i16 401, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.75, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 109, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.80, i32 0, i32 0), i32 7 }, %struct.ac97_quirk { i16 4156, i16 195, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.81, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 2188, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.82, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2192, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.83, i32 0, i32 0), i32 7 }, %struct.ac97_quirk { i16 4156, i16 4765, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.84, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 2360, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.85, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2460, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.86, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2372, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.87, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 2356, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.88, i32 0, i32 0), i32 8 }, %struct.ac97_quirk { i16 4156, i16 4849, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.89, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 4850, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.90, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4156, i16 12296, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.91, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4173, i16 -32444, i16 0, i32 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.92, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4173, i16 -32361, i16 0, i32 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.93, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4173, i16 -32320, i16 0, i32 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.94, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4173, i16 -32315, i16 0, i32 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.95, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 4163, i16 -32525, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.96, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 4303, i16 4547, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.97, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4645, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.98, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4691, i16 0, i32 0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.99, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4733, i16 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.100, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4734, i16 0, i32 0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.101, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4844, i16 0, i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.102, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4303, i16 4850, i16 0, i32 0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.103, i32 0, i32 0), i32 2 }, %struct.ac97_quirk { i16 4337, i16 9829, i16 0, i32 0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.104, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4337, i16 10373, i16 0, i32 0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.105, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4337, i16 10389, i16 0, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.106, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4343, i16 -31924, i16 0, i32 0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.107, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4362, i16 86, i16 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.108, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 4564, i16 21365, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.109, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 5218, i16 21616, i16 0, i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.110, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 5663, i16 8239, i16 0, i32 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.111, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 5663, i16 8250, i16 0, i32 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.112, i32 0, i32 0), i32 6 }, %struct.ac97_quirk { i16 5940, i16 136, i16 0, i32 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.113, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 -32634, i16 8192, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.114, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 -32634, i16 16384, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.114, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 -32634, i16 18518, i16 0, i32 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.115, i32 0, i32 0), i32 2 }, %struct.ac97_quirk { i16 -32634, i16 19780, i16 0, i32 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.116, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 -32634, i16 19798, i16 0, i32 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.117, i32 0, i32 0), i32 1 }, %struct.ac97_quirk { i16 -32634, i16 24576, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.114, i32 0, i32 0), i32 4 }, %struct.ac97_quirk { i16 -32634, i16 -8192, i16 -16, i32 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.114, i32 0, i32 0), i32 4 }, %struct.ac97_quirk zeroinitializer], align 16
@ac97_pcm_defs = internal global [6 x %struct.ac97_pcm] [%struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 2, i16 0, i16 0, i32 0, [2 x %struct.anon.63] [%struct.anon.63 { i16 984, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.63 { i16 408, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.63] [%struct.anon.63 { i16 24, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.63 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.63] [%struct.anon.63 { i16 64, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.63 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 10, i16 0, i16 0, i32 0, [2 x %struct.anon.63] [%struct.anon.63 { i16 3072, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.63 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.63] [%struct.anon.63 { i16 24, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.63 zeroinitializer], i64 0 }, %struct.ac97_pcm { %struct.snd_ac97_bus* null, i8 3, i16 0, i16 0, i32 0, [2 x %struct.anon.63] [%struct.anon.63 { i16 64, [4 x i16] zeroinitializer, [4 x i8] zeroinitializer, [4 x %struct.snd_ac97*] zeroinitializer }, %struct.anon.63 zeroinitializer], i64 0 }], align 16
@.str.58 = private unnamed_addr constant [18 x i8] c"Compaq Deskpro EN\00", align 1
@.str.59 = private unnamed_addr constant [17 x i8] c"Compaq Evo W4000\00", align 1
@.str.60 = private unnamed_addr constant [17 x i8] c"Compaq Evo D510C\00", align 1
@.str.61 = private unnamed_addr constant [17 x i8] c"HP/Compaq nx7010\00", align 1
@.str.62 = private unnamed_addr constant [13 x i8] c"ThinkPad X31\00", align 1
@.str.63 = private unnamed_addr constant [8 x i8] c"MS-9128\00", align 1
@.str.64 = private unnamed_addr constant [18 x i8] c"IBM NetVista A30p\00", align 1
@.str.65 = private unnamed_addr constant [21 x i8] c"Acer Travelmate 2310\00", align 1
@.str.66 = private unnamed_addr constant [20 x i8] c"Acer Aspire 3003LCi\00", align 1
@.str.67 = private unnamed_addr constant [19 x i8] c"Dell Precision 530\00", align 1
@.str.68 = private unnamed_addr constant [5 x i8] c"Dell\00", align 1
@.str.69 = private unnamed_addr constant [20 x i8] c"Dell Optiplex GX260\00", align 1
@.str.70 = private unnamed_addr constant [19 x i8] c"Dell Precision 650\00", align 1
@.str.71 = private unnamed_addr constant [19 x i8] c"Dell Precision 450\00", align 1
@.str.72 = private unnamed_addr constant [20 x i8] c"Dell Optiplex GX270\00", align 1
@.str.73 = private unnamed_addr constant [10 x i8] c"Dell D800\00", align 1
@.str.74 = private unnamed_addr constant [13 x i8] c"Dell Unknown\00", align 1
@.str.75 = private unnamed_addr constant [19 x i8] c"Dell Inspiron 8600\00", align 1
@.str.76 = private unnamed_addr constant [19 x i8] c"Dell Latitude D610\00", align 1
@.str.77 = private unnamed_addr constant [19 x i8] c"Dell Latitude D810\00", align 1
@.str.78 = private unnamed_addr constant [19 x i8] c"Dell Inspiron 6000\00", align 1
@.str.79 = private unnamed_addr constant [19 x i8] c"Dell Inspiron 9300\00", align 1
@.str.80 = private unnamed_addr constant [10 x i8] c"HP zv5000\00", align 1
@.str.81 = private unnamed_addr constant [10 x i8] c"HP xw6000\00", align 1
@.str.82 = private unnamed_addr constant [10 x i8] c"HP nc8000\00", align 1
@.str.83 = private unnamed_addr constant [10 x i8] c"HP nc6000\00", align 1
@.str.84 = private unnamed_addr constant [10 x i8] c"HP xw8000\00", align 1
@.str.85 = private unnamed_addr constant [10 x i8] c"HP nc4200\00", align 1
@.str.86 = private unnamed_addr constant [17 x i8] c"HP nx6110/nc6120\00", align 1
@.str.87 = private unnamed_addr constant [10 x i8] c"HP nc6220\00", align 1
@.str.88 = private unnamed_addr constant [10 x i8] c"HP nc8220\00", align 1
@.str.89 = private unnamed_addr constant [10 x i8] c"HP xw8200\00", align 1
@.str.90 = private unnamed_addr constant [10 x i8] c"HP xw6200\00", align 1
@.str.91 = private unnamed_addr constant [10 x i8] c"HP xw4200\00", align 1
@.str.92 = private unnamed_addr constant [5 x i8] c"Sony\00", align 1
@.str.93 = private unnamed_addr constant [10 x i8] c"Sony S1XP\00", align 1
@.str.94 = private unnamed_addr constant [20 x i8] c"Sony VAIO VGN-T350P\00", align 1
@.str.95 = private unnamed_addr constant [19 x i8] c"Sony VAIO VGN-B1VP\00", align 1
@.str.96 = private unnamed_addr constant [17 x i8] c"ASUS ICH5/AD1985\00", align 1
@.str.97 = private unnamed_addr constant [22 x i8] c"Fujitsu-Siemens E4010\00", align 1
@.str.98 = private unnamed_addr constant [22 x i8] c"Fujitsu-Siemens T3010\00", align 1
@.str.99 = private unnamed_addr constant [14 x i8] c"Fujitsu S6210\00", align 1
@.str.100 = private unnamed_addr constant [23 x i8] c"Fujitsu Lifebook P7010\00", align 1
@.str.101 = private unnamed_addr constant [24 x i8] c"Fujitsu Lifebook C1211D\00", align 1
@.str.102 = private unnamed_addr constant [21 x i8] c"Fujitsu-Siemens 4010\00", align 1
@.str.103 = private unnamed_addr constant [29 x i8] c"Fujitsu-Siemens Celsius H320\00", align 1
@.str.104 = private unnamed_addr constant [24 x i8] c"Fujitsu-Siemens Celsius\00", align 1
@.str.105 = private unnamed_addr constant [11 x i8] c"AMD64 Mobo\00", align 1
@.str.106 = private unnamed_addr constant [18 x i8] c"Tyan Thunder K8WE\00", align 1
@.str.107 = private unnamed_addr constant [16 x i8] c"Panasonic CF-R4\00", align 1
@.str.108 = private unnamed_addr constant [23 x i8] c"Fujitsu-Siemens Scenic\00", align 1
@.str.109 = private unnamed_addr constant [22 x i8] c"ADI AD1985 (discrete)\00", align 1
@.str.110 = private unnamed_addr constant [21 x i8] c"MSI P4 ATX 645 Ultra\00", align 1
@.str.111 = private unnamed_addr constant [13 x i8] c"Gateway M520\00", align 1
@.str.112 = private unnamed_addr constant [15 x i8] c"Gateway 4525GZ\00", align 1
@.str.113 = private unnamed_addr constant [22 x i8] c"Fujitsu-Siemens D1522\00", align 1
@.str.114 = private unnamed_addr constant [18 x i8] c"Intel ICH5/AD1985\00", align 1
@.str.115 = private unnamed_addr constant [23 x i8] c"Intel D845WN (82801BA)\00", align 1
@.str.116 = private unnamed_addr constant [15 x i8] c"Intel D850EMV2\00", align 1
@.str.117 = private unnamed_addr constant [17 x i8] c"Intel ICH/AD1885\00", align 1
@.str.57 = private unnamed_addr constant [39 x i8] c"\014intel8x0: AC97 codec ready timeout.\0A\00", align 1
@.str.56 = private unnamed_addr constant [31 x i8] c"\014ali_codec_semaphore timeout\0A\00", align 1
@.str.54 = private unnamed_addr constant [59 x i8] c"\013codec_read %d: semaphore is not ready for register 0x%x\0A\00", align 1
@.str.55 = private unnamed_addr constant [49 x i8] c"\013codec_read %d: read timeout for register 0x%x\0A\00", align 1
@.str.53 = private unnamed_addr constant [56 x i8] c"\013codec_semaphore: semaphore is not ready [0x%x][0x%x]\0A\00", align 1
@.str.52 = private unnamed_addr constant [60 x i8] c"\013codec_write %d: semaphore is not ready for register 0x%x\0A\00", align 1
@.str.33 = private unnamed_addr constant [26 x i8] c"&(&chip->reg_lock)->rlock\00", align 1
@snd_intel8x0_create.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.34 = private unnamed_addr constant [31 x i8] c"\013AC'97 space ioremap problem\0A\00", align 1
@.str.35 = private unnamed_addr constant [36 x i8] c"\013Controller space ioremap problem\0A\00", align 1
@snd_intel8x0_create.bdbars = internal global [5 x i32] [i32 3, i32 6, i32 3, i32 6, i32 4], align 16
@snd_intel8x0_create.intel_regs = internal global [6 x %struct.exception_table_entry] [%struct.exception_table_entry { i32 32, i32 0 }, %struct.exception_table_entry { i32 64, i32 16 }, %struct.exception_table_entry { i32 128, i32 32 }, %struct.exception_table_entry { i32 16777216, i32 64 }, %struct.exception_table_entry { i32 33554432, i32 80 }, %struct.exception_table_entry { i32 67108864, i32 96 }], align 16
@snd_intel8x0_create.nforce_regs = internal global [4 x %struct.exception_table_entry] [%struct.exception_table_entry { i32 32, i32 0 }, %struct.exception_table_entry { i32 64, i32 16 }, %struct.exception_table_entry { i32 128, i32 32 }, %struct.exception_table_entry { i32 16, i32 112 }], align 16
@snd_intel8x0_create.ali_regs = internal global [6 x %struct.exception_table_entry] [%struct.exception_table_entry { i32 65536, i32 64 }, %struct.exception_table_entry { i32 131072, i32 80 }, %struct.exception_table_entry { i32 262144, i32 96 }, %struct.exception_table_entry { i32 524288, i32 112 }, %struct.exception_table_entry { i32 4194304, i32 160 }, %struct.exception_table_entry { i32 8388608, i32 176 }], align 16
@.str.36 = private unnamed_addr constant [48 x i8] c"\013intel8x0: cannot allocate buffer descriptors\0A\00", align 1
@ich_codec_bits = internal global [3 x i32] [i32 256, i32 512, i32 268435456], align 4
@sis_codec_bits = internal global [3 x i32] [i32 256, i32 512, i32 262144], align 4
@.str.37 = private unnamed_addr constant [25 x i8] c"\013unable to grab IRQ %d\0A\00", align 1
@snd_intel8x0_create.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_intel8x0_dev_free, i32 (%struct.snd_device*)* null, i32 (%struct.snd_device*)* null }, align 8
@.str.38 = private unnamed_addr constant [19 x i8] c"enable (forced) VM\00", align 1
@.str.39 = private unnamed_addr constant [20 x i8] c"disable (forced) VM\00", align 1
@boot_cpu_data = external global %struct.cpuinfo_x86, align 64
@.str.41 = private unnamed_addr constant [20 x i8] c"enable Parallels VM\00", align 1
@.str.42 = private unnamed_addr constant [29 x i8] c"disable (unknown or VT-d) VM\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"enable KVM\00", align 1
@.str.43 = private unnamed_addr constant [29 x i8] c"\016intel8x0: %s optimization\0A\00", align 1
@.str.44 = private unnamed_addr constant [10 x i8] c"KVMKVMKVM\00", align 1
@pv_cpu_ops = external global %struct.pv_cpu_ops, align 8
@.str.45 = private unnamed_addr constant [60 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/paravirt.h\00", align 1
@.str.11 = private unnamed_addr constant [18 x i8] c"Intel 82801AA-ICH\00", align 1
@.str.12 = private unnamed_addr constant [19 x i8] c"Intel 82901AB-ICH0\00", align 1
@.str.13 = private unnamed_addr constant [19 x i8] c"Intel 82801BA-ICH2\00", align 1
@.str.14 = private unnamed_addr constant [12 x i8] c"Intel 440MX\00", align 1
@.str.15 = private unnamed_addr constant [19 x i8] c"Intel 82801CA-ICH3\00", align 1
@.str.16 = private unnamed_addr constant [19 x i8] c"Intel 82801DB-ICH4\00", align 1
@.str.17 = private unnamed_addr constant [11 x i8] c"Intel ICH5\00", align 1
@.str.18 = private unnamed_addr constant [14 x i8] c"Intel 6300ESB\00", align 1
@.str.19 = private unnamed_addr constant [11 x i8] c"Intel ICH6\00", align 1
@.str.20 = private unnamed_addr constant [11 x i8] c"Intel ICH7\00", align 1
@.str.21 = private unnamed_addr constant [11 x i8] c"Intel ESB2\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"SiS SI7012\00", align 1
@.str.23 = private unnamed_addr constant [14 x i8] c"NVidia nForce\00", align 1
@.str.24 = private unnamed_addr constant [15 x i8] c"NVidia nForce2\00", align 1
@.str.25 = private unnamed_addr constant [15 x i8] c"NVidia nForce3\00", align 1
@.str.26 = private unnamed_addr constant [12 x i8] c"NVidia CK8S\00", align 1
@.str.27 = private unnamed_addr constant [13 x i8] c"NVidia CK804\00", align 1
@.str.28 = private unnamed_addr constant [11 x i8] c"NVidia CK8\00", align 1
@.str.29 = private unnamed_addr constant [13 x i8] c"NVidia MCP04\00", align 1
@.str.30 = private unnamed_addr constant [12 x i8] c"AMD AMD8111\00", align 1
@.str.31 = private unnamed_addr constant [11 x i8] c"AMD AMD768\00", align 1
@.str.32 = private unnamed_addr constant [10 x i8] c"ALi M5455\00", align 1
@spdif_aclink_defaults = internal global [2 x %struct.snd_pci_quirk] [%struct.snd_pci_quirk { i16 5243, i16 7194, i16 -1, i32 1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.10, i32 0, i32 0) }, %struct.snd_pci_quirk zeroinitializer], align 16
@.str.8 = private unnamed_addr constant [45 x i8] c"\016intel8x0: Using SPDIF over AC-Link for %s\0A\00", align 1
@.str.9 = private unnamed_addr constant [47 x i8] c"\016intel8x0: Using integrated SPDIF DMA for %s\0A\00", align 1
@.str.10 = private unnamed_addr constant [9 x i8] c"ASUS KN8\00", align 1

@__mod_pci_device_table = alias %struct.pci_device_id, getelementptr inbounds ([24 x %struct.pci_device_id], [24 x %struct.pci_device_id]* @snd_intel8x0_ids, i32 0, i32 0)
@init_module = alias i32 (), i32 ()* @intel8x0_driver_init
@cleanup_module = alias void (), void ()* @intel8x0_driver_exit

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_driver_init() #0 section ".init.text" {
entry:
  %call = call i32 @__pci_register_driver(%struct.pci_driver* @intel8x0_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))
  ret i32 %call
}

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_probe(%struct.pci_dev* %pci, %struct.pci_device_id* %pci_id) #2 {
entry:
  %card = alloca %struct.snd_card*, align 8
  %chip = alloca %struct.intel8x0*, align 8
  %0 = bitcast %struct.snd_card** %card to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.intel8x0** %chip to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = load i32, i32* @index, align 4, !tbaa !2
  %3 = load i8*, i8** @id, align 8, !tbaa !6
  %call = call i32 @snd_card_create(i32 %2, i8* %3, %struct.module* @__this_module, i32 0, %struct.snd_card** %card)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %cmp1 = icmp slt i32 %4, 0
  br i1 %cmp1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %call3 = call i32 @check_default_spdif_aclink(%struct.pci_dev* %pci)
  store i32 %call3, i32* @spdif_aclink, align 4, !tbaa !2
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %5 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %driver = getelementptr inbounds %struct.snd_card, %struct.snd_card* %5, i32 0, i32 2
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %driver, i32 0, i32 0
  %call5 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0))
  %6 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end14, label %if.then6

if.then6:                                         ; preds = %if.end4
  %driver_data = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %pci_id, i32 0, i32 6
  %7 = load i64, i64* %driver_data, align 8, !tbaa !8
  %Pivot = icmp slt i64 %7, 4
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %if.then6
  %SwitchLeaf2 = icmp eq i64 %7, 4
  br i1 %SwitchLeaf2, label %sw.bb, label %if.end14

LeafBlock:                                        ; preds = %if.then6
  %SwitchLeaf = icmp eq i64 %7, 1
  br i1 %SwitchLeaf, label %sw.bb10, label %if.end14

sw.bb:                                            ; preds = %LeafBlock1
  %8 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %driver7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %8, i32 0, i32 2
  %arraydecay8 = getelementptr inbounds [16 x i8], [16 x i8]* %driver7, i32 0, i32 0
  %call9 = call i8* @strcpy(i8* %arraydecay8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end14

sw.bb10:                                          ; preds = %LeafBlock
  %9 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %driver11 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %9, i32 0, i32 2
  %arraydecay12 = getelementptr inbounds [16 x i8], [16 x i8]* %driver11, i32 0, i32 0
  %call13 = call i8* @strcpy(i8* %arraydecay12, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0))
  br label %if.end14

if.end14:                                         ; preds = %sw.bb10, %sw.bb, %LeafBlock, %LeafBlock1, %if.end4
  %10 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %10, i32 0, i32 3
  %arraydecay15 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  %call16 = call i8* @strcpy(i8* %arraydecay15, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.5, i32 0, i32 0))
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %name.0 = phi %struct.shortname_table* [ getelementptr inbounds ([23 x %struct.shortname_table], [23 x %struct.shortname_table]* @shortnames, i32 0, i32 0), %if.end14 ], [ %incdec.ptr, %for.inc ]
  %id = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 0, i32 0
  %11 = load i32, i32* %id, align 8, !tbaa !11
  %tobool17 = icmp ne i32 %11, 0
  br i1 %tobool17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %device = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 8
  %12 = load i16, i16* %device, align 2, !tbaa !13
  %conv = zext i16 %12 to i32
  %id18 = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 0, i32 0
  %13 = load i32, i32* %id18, align 8, !tbaa !11
  %cmp19 = icmp eq i32 %conv, %13
  br i1 %cmp19, label %if.then21, label %for.inc

if.then21:                                        ; preds = %for.body
  %14 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %shortname22 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %14, i32 0, i32 3
  %arraydecay23 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname22, i32 0, i32 0
  %s = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 0, i32 1
  %15 = load i8*, i8** %s, align 8, !tbaa !38
  %call24 = call i8* @strcpy(i8* %arraydecay23, i8* %15)
  br label %for.end

for.inc:                                          ; preds = %for.body
  %incdec.ptr = getelementptr inbounds %struct.shortname_table, %struct.shortname_table* %name.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %if.then21, %for.cond
  %16 = load i32, i32* @buggy_irq, align 4, !tbaa !2
  %cmp26 = icmp slt i32 %16, 0
  br i1 %cmp26, label %if.then28, label %if.end34

if.then28:                                        ; preds = %for.end
  %driver_data29 = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %pci_id, i32 0, i32 6
  %17 = load i64, i64* %driver_data29, align 8, !tbaa !8
  %cmp30 = icmp eq i64 %17, 4
  %.sink = select i1 %cmp30, i32 1, i32 0
  store i32 %.sink, i32* @buggy_irq, align 4, !tbaa !2
  br label %if.end34

if.end34:                                         ; preds = %if.then28, %for.end
  %18 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %driver_data35 = getelementptr inbounds %struct.pci_device_id, %struct.pci_device_id* %pci_id, i32 0, i32 6
  %19 = load i64, i64* %driver_data35, align 8, !tbaa !8
  %call36 = call i32 @snd_intel8x0_create()
  %cmp37 = icmp slt i32 %call36, 0
  br i1 %cmp37, label %if.then39, label %if.end41

if.then39:                                        ; preds = %if.end34
  %20 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call40 = call i32 @snd_card_free(%struct.snd_card* %20)
  br label %cleanup

if.end41:                                         ; preds = %if.end34
  %21 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %22 = bitcast %struct.intel8x0* %21 to i8*
  %23 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %23, i32 0, i32 8
  store i8* %22, i8** %private_data, align 8, !tbaa !39
  %24 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %25 = load i32, i32* @ac97_clock, align 4, !tbaa !2
  %26 = load i8*, i8** @ac97_quirk, align 8, !tbaa !6
  %call42 = call i32 @snd_intel8x0_mixer(%struct.intel8x0* %24, i32 %25, i8* %26)
  %cmp43 = icmp slt i32 %call42, 0
  br i1 %cmp43, label %if.then45, label %if.end47

if.then45:                                        ; preds = %if.end41
  %27 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call46 = call i32 @snd_card_free(%struct.snd_card* %27)
  br label %cleanup

if.end47:                                         ; preds = %if.end41
  %28 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %call48 = call i32 @snd_intel8x0_pcm(%struct.intel8x0* %28)
  %cmp49 = icmp slt i32 %call48, 0
  br i1 %cmp49, label %if.then51, label %if.end53

if.then51:                                        ; preds = %if.end47
  %29 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call52 = call i32 @snd_card_free(%struct.snd_card* %29)
  br label %cleanup

if.end53:                                         ; preds = %if.end47
  %30 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  call void @snd_intel8x0_proc_init(%struct.intel8x0* %30)
  %31 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %longname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %31, i32 0, i32 4
  %arraydecay54 = getelementptr inbounds [80 x i8], [80 x i8]* %longname, i32 0, i32 0
  %32 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %shortname55 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %32, i32 0, i32 3
  %arraydecay56 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname55, i32 0, i32 0
  %33 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %33, i32 0, i32 13
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 0
  %34 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  %call57 = call i8* @snd_ac97_get_short_name(%struct.snd_ac97* %34)
  %35 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  %irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %35, i32 0, i32 1
  %36 = load i32, i32* %irq, align 4, !tbaa !45
  %call58 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay54, i64 80, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0), i8* %arraydecay56, i8* %call57, i32 %36)
  %37 = load i32, i32* @ac97_clock, align 4, !tbaa !2
  %cmp59 = icmp eq i32 %37, 0
  %38 = load i32, i32* @ac97_clock, align 4
  %cmp61 = icmp eq i32 %38, 1
  %or.cond = or i1 %cmp59, %cmp61
  br i1 %or.cond, label %if.then63, label %if.end74

if.then63:                                        ; preds = %if.end53
  %39 = load i32, i32* @ac97_clock, align 4, !tbaa !2
  %cmp64 = icmp eq i32 %39, 0
  %40 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  br i1 %cmp64, label %if.then66, label %if.else72

if.then66:                                        ; preds = %if.then63
  %call67 = call i32 @intel8x0_in_clock_list(%struct.intel8x0* %40)
  %cmp68 = icmp eq i32 %call67, 0
  br i1 %cmp68, label %if.then70, label %if.end74

if.then70:                                        ; preds = %if.then66
  %41 = load %struct.intel8x0*, %struct.intel8x0** %chip, align 8, !tbaa !6
  call void @intel8x0_measure_ac97_clock(%struct.intel8x0* %41)
  br label %if.end74

if.else72:                                        ; preds = %if.then63
  call void @intel8x0_measure_ac97_clock(%struct.intel8x0* %40)
  br label %if.end74

if.end74:                                         ; preds = %if.else72, %if.then70, %if.then66, %if.end53
  %42 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  %call75 = call i32 @snd_card_register(%struct.snd_card* %42)
  %cmp76 = icmp slt i32 %call75, 0
  %43 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !6
  br i1 %cmp76, label %if.then78, label %if.end80

if.then78:                                        ; preds = %if.end74
  %call79 = call i32 @snd_card_free(%struct.snd_card* %43)
  br label %cleanup

if.end80:                                         ; preds = %if.end74
  %44 = bitcast %struct.snd_card* %43 to i8*
  call void @pci_set_drvdata(%struct.pci_dev* %pci, i8* %44)
  br label %cleanup

cleanup:                                          ; preds = %if.end80, %if.then78, %if.then51, %if.then45, %if.then39, %entry
  %retval.0 = phi i32 [ %call36, %if.then39 ], [ %call42, %if.then45 ], [ %call48, %if.then51 ], [ %call75, %if.then78 ], [ 0, %if.end80 ], [ %call, %entry ]
  %45 = bitcast %struct.intel8x0** %chip to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %45) #7
  %46 = bitcast %struct.snd_card** %card to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %46) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_remove(%struct.pci_dev* %pci) #2 {
entry:
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %pci)
  %0 = bitcast i8* %call to %struct.snd_card*
  %call1 = call i32 @snd_card_free(%struct.snd_card* %0)
  call void @pci_set_drvdata(%struct.pci_dev* %pci, i8* null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_suspend(%struct.device* %dev) #2 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %2 = bitcast i8* %call to %struct.snd_card*
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 8
  %3 = load i8*, i8** %private_data, align 8, !tbaa !39
  %4 = bitcast i8* %3 to %struct.intel8x0*
  call void @snd_power_change_state(%struct.snd_card* %2, i32 768)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %pcm_devs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 6
  %5 = load i32, i32* %pcm_devs, align 8, !tbaa !49
  %cmp = icmp slt i32 %i.0, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pcm = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.snd_pcm*], [6 x %struct.snd_pcm*]* %pcm, i64 0, i64 %idxprom
  %6 = load %struct.snd_pcm*, %struct.snd_pcm** %arrayidx, align 8, !tbaa !6
  %call1 = call i32 @snd_pcm_suspend_all(%struct.snd_pcm* %6)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end21

if.then:                                          ; preds = %for.end
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc18, %if.then
  %i.1 = phi i32 [ 0, %if.then ], [ %inc19, %for.inc18 ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 21
  %7 = load i32, i32* %bdbars_count, align 8, !tbaa !50
  %cmp3 = icmp ult i32 %i.1, %7
  br i1 %cmp3, label %for.body4, label %if.end21

for.body4:                                        ; preds = %for.cond2
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 8
  %idxprom5 = sext i32 %i.1 to i64
  %arrayidx6 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom5
  %substream = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx6, i32 0, i32 4
  %8 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !51
  %tobool7 = icmp ne %struct.snd_pcm_substream* %8, null
  br i1 %tobool7, label %land.lhs.true, label %for.inc18

land.lhs.true:                                    ; preds = %for.body4
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx6, i32 0, i32 25
  %bf.load8 = load i8, i8* %page_attr_changed, align 4
  %bf.clear9 = and i8 %bf.load8, 1
  %bf.cast10 = zext i8 %bf.clear9 to i32
  %tobool11 = icmp ne i32 %bf.cast10, 0
  br i1 %tobool11, label %if.then12, label %for.inc18

if.then12:                                        ; preds = %land.lhs.true
  %substream13 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx6, i32 0, i32 4
  %9 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream13, align 8, !tbaa !51
  %runtime14 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %9, i32 0, i32 12
  %10 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime14, align 8, !tbaa !53
  %dma_area = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %10, i32 0, i32 50
  %11 = load i8*, i8** %dma_area, align 8, !tbaa !61
  %tobool15 = icmp ne i8* %11, null
  br label %for.inc18

for.inc18:                                        ; preds = %if.then12, %land.lhs.true, %for.body4
  %inc19 = add nsw i32 %i.1, 1
  br label %for.cond2

if.end21:                                         ; preds = %for.cond2, %for.end
  br label %for.cond22

for.cond22:                                       ; preds = %for.body24, %if.end21
  %i.2 = phi i32 [ 0, %if.end21 ], [ %inc28, %for.body24 ]
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 16
  %12 = load i32, i32* %ncodecs, align 8, !tbaa !67
  %cmp23 = icmp ult i32 %i.2, %12
  br i1 %cmp23, label %for.body24, label %for.end29

for.body24:                                       ; preds = %for.cond22
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 13
  %idxprom25 = sext i32 %i.2 to i64
  %arrayidx26 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 %idxprom25
  %13 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx26, align 8, !tbaa !6
  call void @snd_ac97_suspend(%struct.snd_ac97* %13)
  %inc28 = add nsw i32 %i.2, 1
  br label %for.cond22

for.end29:                                        ; preds = %for.cond22
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 0
  %14 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp30 = icmp eq i32 %14, 1
  br i1 %cmp30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %for.end29
  %call32 = call zeroext i8 @igetbyte(%struct.intel8x0* %4, i32 128)
  %conv = zext i8 %call32 to i32
  %sdm_saved = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 11
  store i32 %conv, i32* %sdm_saved, align 8, !tbaa !69
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %for.end29
  %irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 1
  %15 = load i32, i32* %irq, align 4, !tbaa !45
  %cmp34 = icmp sge i32 %15, 0
  br i1 %cmp34, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.end33
  %irq37 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 1
  %16 = load i32, i32* %irq37, align 4, !tbaa !45
  %17 = bitcast %struct.intel8x0* %4 to i8*
  call void @free_irq(i32 %16, i8* %17)
  %irq38 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 1
  store i32 -1, i32* %irq38, align 4, !tbaa !45
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %if.end33
  call void @pci_disable_device(%struct.pci_dev* %1)
  %call40 = call i32 @pci_save_state(%struct.pci_dev* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_resume(%struct.device* %dev) #2 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -152
  %1 = bitcast i8* %add.ptr to %struct.pci_dev*
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %2 = bitcast i8* %call to %struct.snd_card*
  %private_data = getelementptr inbounds %struct.snd_card, %struct.snd_card* %2, i32 0, i32 8
  %3 = load i8*, i8** %private_data, align 8, !tbaa !39
  %4 = bitcast i8* %3 to %struct.intel8x0*
  %call1 = call i32 @pci_set_power_state(%struct.pci_dev* %1, i32 0)
  call void @pci_restore_state(%struct.pci_dev* %1)
  %call2 = call i32 @pci_enable_device(%struct.pci_dev* %1)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.149, i32 0, i32 0))
  %call4 = call i32 @snd_card_disconnect(%struct.snd_card* %2)
  br label %cleanup97

if.end:                                           ; preds = %entry
  call void @pci_set_master(%struct.pci_dev* %1)
  call void @snd_intel8x0_chip_init(%struct.intel8x0* %4, i32 0)
  %irq = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 36
  %5 = load i32, i32* %irq, align 4, !tbaa !70
  %6 = bitcast %struct.intel8x0* %4 to i8*
  %call6 = call i32 @request_irq(i32 %5, i32 (i32, i8*)* @snd_intel8x0_interrupt, i64 128, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* %6)
  %tobool = icmp ne i32 %call6, 0
  %irq8 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %1, i32 0, i32 36
  %7 = load i32, i32* %irq8, align 4, !tbaa !70
  br i1 %tobool, label %if.then7, label %if.end11

if.then7:                                         ; preds = %if.end
  %call9 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.150, i32 0, i32 0), i32 %7)
  %call10 = call i32 @snd_card_disconnect(%struct.snd_card* %2)
  br label %cleanup97

if.end11:                                         ; preds = %if.end
  %irq13 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 1
  store i32 %7, i32* %irq13, align 4, !tbaa !45
  %irq14 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 1
  %8 = load i32, i32* %irq14, align 4, !tbaa !45
  call void @synchronize_irq(i32 %8)
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 0
  %9 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp15 = icmp ne i32 %9, 1
  %10 = load i32, i32* @spdif_aclink, align 4
  %tobool16 = icmp ne i32 %10, 0
  %or.cond = or i1 %cmp15, %tobool16
  br i1 %or.cond, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.end11
  %sdm_saved = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 11
  %11 = load i32, i32* %sdm_saved, align 8, !tbaa !69
  %conv = trunc i32 %11 to i8
  call void @iputbyte(%struct.intel8x0* %4, i32 128, i8 zeroext %conv)
  %call18 = call i32 @igetdword(%struct.intel8x0* %4, i32 44)
  %and = and i32 %call18, 1073741823
  %or = or i32 %and, -1073741824
  call void @iputdword(%struct.intel8x0* %4, i32 44, i32 %or)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end11
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool20 = icmp ne i32 %bf.cast, 0
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end19
  %i.0 = phi i32 [ 0, %if.end19 ], [ %inc, %for.body ]
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 16
  %12 = load i32, i32* %ncodecs, align 8, !tbaa !67
  %cmp23 = icmp ult i32 %i.0, %12
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 %idxprom
  %13 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  call void @snd_ac97_resume(%struct.snd_ac97* %13)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %fix_nocache25 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 9
  %bf.load26 = load i16, i16* %fix_nocache25, align 8
  %bf.lshr27 = lshr i16 %bf.load26, 8
  %bf.clear28 = and i16 %bf.lshr27, 1
  %bf.cast29 = zext i16 %bf.clear28 to i32
  %tobool30 = icmp ne i32 %bf.cast29, 0
  br i1 %tobool30, label %if.then31, label %if.end57

if.then31:                                        ; preds = %for.end
  br label %for.cond32

for.cond32:                                       ; preds = %for.inc54, %if.then31
  %i.1 = phi i32 [ 0, %if.then31 ], [ %inc55, %for.inc54 ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 21
  %14 = load i32, i32* %bdbars_count, align 8, !tbaa !50
  %cmp33 = icmp ult i32 %i.1, %14
  br i1 %cmp33, label %for.body35, label %if.end57

for.body35:                                       ; preds = %for.cond32
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 8
  %idxprom36 = sext i32 %i.1 to i64
  %arrayidx37 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom36
  %substream = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx37, i32 0, i32 4
  %15 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !51
  %tobool38 = icmp ne %struct.snd_pcm_substream* %15, null
  br i1 %tobool38, label %land.lhs.true39, label %for.inc54

land.lhs.true39:                                  ; preds = %for.body35
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx37, i32 0, i32 25
  %bf.load40 = load i8, i8* %page_attr_changed, align 4
  %bf.clear41 = and i8 %bf.load40, 1
  %bf.cast42 = zext i8 %bf.clear41 to i32
  %tobool43 = icmp ne i32 %bf.cast42, 0
  br i1 %tobool43, label %if.then44, label %for.inc54

if.then44:                                        ; preds = %land.lhs.true39
  %substream45 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx37, i32 0, i32 4
  %16 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream45, align 8, !tbaa !51
  %runtime46 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %16, i32 0, i32 12
  %17 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime46, align 8, !tbaa !53
  %dma_area = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %17, i32 0, i32 50
  %18 = load i8*, i8** %dma_area, align 8, !tbaa !61
  %tobool47 = icmp ne i8* %18, null
  br label %for.inc54

for.inc54:                                        ; preds = %if.then44, %land.lhs.true39, %for.body35
  %inc55 = add nsw i32 %i.1, 1
  br label %for.cond32

if.end57:                                         ; preds = %for.cond32, %for.end
  br label %for.cond58

for.cond58:                                       ; preds = %LeafBlock, %if.end57
  %i.2 = phi i32 [ 0, %if.end57 ], [ %inc95, %LeafBlock ]
  %bdbars_count59 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 21
  %19 = load i32, i32* %bdbars_count59, align 8, !tbaa !50
  %cmp60 = icmp ult i32 %i.2, %19
  br i1 %cmp60, label %for.body62, label %for.end96

for.body62:                                       ; preds = %for.cond58
  %ichd64 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %4, i32 0, i32 8
  %idxprom65 = sext i32 %i.2 to i64
  %arrayidx66 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd64, i64 0, i64 %idxprom65
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 1
  %20 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %substream67 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 4
  %21 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream67, align 8, !tbaa !51
  %tobool68 = icmp ne %struct.snd_pcm_substream* %21, null
  br i1 %tobool68, label %lor.lhs.false, label %LeafBlock

lor.lhs.false:                                    ; preds = %for.body62
  %suspended = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 25
  %bf.load69 = load i8, i8* %suspended, align 4
  %bf.lshr70 = lshr i8 %bf.load69, 1
  %bf.clear71 = and i8 %bf.lshr70, 1
  %bf.cast72 = zext i8 %bf.clear71 to i32
  %tobool73 = icmp ne i32 %bf.cast72, 0
  br i1 %tobool73, label %if.end75, label %LeafBlock

if.end75:                                         ; preds = %lor.lhs.false
  %ichd76 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 0
  %22 = load i32, i32* %ichd76, align 8, !tbaa !72
  %cmp77 = icmp eq i32 %22, 1
  br i1 %cmp77, label %if.then79, label %if.end82

if.then79:                                        ; preds = %if.end75
  %substream80 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 4
  %23 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream80, align 8, !tbaa !51
  %runtime81 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %23, i32 0, i32 12
  %24 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime81, align 8, !tbaa !53
  call void @snd_intel8x0_setup_pcm_out(%struct.intel8x0* %4, %struct.snd_pcm_runtime* %24)
  br label %if.end82

if.end82:                                         ; preds = %if.then79, %if.end75
  %add = add i64 %20, 0
  %conv83 = trunc i64 %add to i32
  %bdbar_addr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 3
  %25 = load i32, i32* %bdbar_addr, align 8, !tbaa !73
  call void @iputdword(%struct.intel8x0* %4, i32 %conv83, i32 %25)
  %add84 = add i64 %20, 5
  %conv85 = trunc i64 %add84 to i32
  %lvi = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 13
  %26 = load i32, i32* %lvi, align 8, !tbaa !74
  %conv86 = trunc i32 %26 to i8
  call void @iputbyte(%struct.intel8x0* %4, i32 %conv85, i8 zeroext %conv86)
  %add87 = add i64 %20, 4
  %conv88 = trunc i64 %add87 to i32
  %civ = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 15
  %27 = load i32, i32* %civ, align 8, !tbaa !75
  %conv89 = trunc i32 %27 to i8
  call void @iputbyte(%struct.intel8x0* %4, i32 %conv88, i8 zeroext %conv89)
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx66, i32 0, i32 19
  %28 = load i32, i32* %roff_sr, align 8, !tbaa !76
  %conv90 = zext i32 %28 to i64
  %add91 = add i64 %20, %conv90
  %conv92 = trunc i64 %add91 to i32
  call void @iputbyte(%struct.intel8x0* %4, i32 %conv92, i8 zeroext 28)
  br label %LeafBlock

LeafBlock:                                        ; preds = %if.end82, %lor.lhs.false, %for.body62
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end82 ], [ 14, %lor.lhs.false ], [ 14, %for.body62 ]
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 14
  %inc95 = add nsw i32 %i.2, 1
  br label %for.cond58

for.end96:                                        ; preds = %for.cond58
  call void @snd_power_change_state(%struct.snd_card* %2, i32 0)
  br label %cleanup97

cleanup97:                                        ; preds = %for.end96, %if.then7, %if.then
  %retval.0 = phi i32 [ -5, %if.then ], [ -5, %if.then7 ], [ 0, %for.end96 ]
  ret i32 %retval.0
}

declare i8* @dev_get_drvdata(%struct.device*) #1

declare i32 @pci_set_power_state(%struct.pci_dev*, i32) #1

declare void @pci_restore_state(%struct.pci_dev*) #1

declare i32 @pci_enable_device(%struct.pci_dev*) #1

declare i32 @printk(i8*, ...) #1

declare i32 @snd_card_disconnect(%struct.snd_card*) #1

declare void @pci_set_master(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_chip_init(%struct.intel8x0* %chip, i32 %probing) #2 {
entry:
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %0 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp = icmp ne i32 %0, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @snd_intel8x0_ich_chip_init(%struct.intel8x0* %chip, i32 %probing)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %if.then
  %call3 = call zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 0)
  br label %if.end8

if.else:                                          ; preds = %entry
  %call4 = call i32 @snd_intel8x0_ali_chip_init(%struct.intel8x0* %chip, i32 %probing)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.else, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end8
  %i.0 = phi i32 [ 0, %if.end8 ], [ %inc, %for.body ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %1 = load i32, i32* %bdbars_count, align 8, !tbaa !50
  %cmp9 = icmp ult i32 %i.0, %1
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 1
  %2 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %add = add i64 11, %2
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv, i8 zeroext 0)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond10

for.cond10:                                       ; preds = %for.body14, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc22, %for.body14 ]
  %bdbars_count11 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %3 = load i32, i32* %bdbars_count11, align 8, !tbaa !50
  %cmp12 = icmp ult i32 %i.1, %3
  br i1 %cmp12, label %for.body14, label %for.end23

for.body14:                                       ; preds = %for.cond10
  %ichd15 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom16 = zext i32 %i.1 to i64
  %arrayidx17 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd15, i64 0, i64 %idxprom16
  %reg_offset18 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx17, i32 0, i32 1
  %4 = load i64, i64* %reg_offset18, align 8, !tbaa !71
  %add19 = add i64 11, %4
  %conv20 = trunc i64 %add19 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv20, i8 zeroext 2)
  %inc22 = add i32 %i.1, 1
  br label %for.cond10

for.end23:                                        ; preds = %for.cond10
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc48, %for.end23
  %i.2 = phi i32 [ 0, %for.end23 ], [ %inc49, %for.inc48 ]
  %bdbars_count25 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %5 = load i32, i32* %bdbars_count25, align 8, !tbaa !50
  %cmp26 = icmp ult i32 %i.2, %5
  br i1 %cmp26, label %for.body28, label %for.end50

for.body28:                                       ; preds = %for.cond24
  br label %while.cond

while.cond:                                       ; preds = %if.end42, %for.body28
  %timeout.0 = phi i32 [ 100000, %for.body28 ], [ %dec, %if.end42 ]
  %dec = add i32 %timeout.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %if.then45, label %while.body

while.body:                                       ; preds = %while.cond
  %ichd31 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom32 = zext i32 %i.2 to i64
  %arrayidx33 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd31, i64 0, i64 %idxprom32
  %reg_offset34 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx33, i32 0, i32 1
  %6 = load i64, i64* %reg_offset34, align 8, !tbaa !71
  %add35 = add i64 11, %6
  %conv36 = trunc i64 %add35 to i32
  %call37 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv36)
  %conv38 = zext i8 %call37 to i32
  %and = and i32 %conv38, 2
  %cmp39 = icmp eq i32 %and, 0
  br i1 %cmp39, label %while.end, label %if.end42

if.end42:                                         ; preds = %while.body
  br label %while.cond

while.end:                                        ; preds = %while.body
  %cmp43 = icmp eq i32 %dec, 0
  br i1 %cmp43, label %if.then45, label %for.inc48

if.then45:                                        ; preds = %while.end, %while.cond
  %call46 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.46, i32 0, i32 0))
  br label %for.inc48

for.inc48:                                        ; preds = %if.then45, %while.end
  %inc49 = add i32 %i.2, 1
  br label %for.cond24

for.end50:                                        ; preds = %for.cond24
  br label %for.cond51

for.cond51:                                       ; preds = %for.body55, %for.end50
  %i.3 = phi i32 [ 0, %for.end50 ], [ %inc66, %for.body55 ]
  %bdbars_count52 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %7 = load i32, i32* %bdbars_count52, align 8, !tbaa !50
  %cmp53 = icmp ult i32 %i.3, %7
  br i1 %cmp53, label %for.body55, label %cleanup

for.body55:                                       ; preds = %for.cond51
  %ichd56 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom57 = zext i32 %i.3 to i64
  %arrayidx58 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd56, i64 0, i64 %idxprom57
  %reg_offset59 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx58, i32 0, i32 1
  %8 = load i64, i64* %reg_offset59, align 8, !tbaa !71
  %add60 = add i64 0, %8
  %conv61 = trunc i64 %add60 to i32
  %ichd62 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom63 = zext i32 %i.3 to i64
  %arrayidx64 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd62, i64 0, i64 %idxprom63
  %bdbar_addr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx64, i32 0, i32 3
  %9 = load i32, i32* %bdbar_addr, align 8, !tbaa !73
  call void @iputdword(%struct.intel8x0* %chip, i32 %conv61, i32 %9)
  %inc66 = add i32 %i.3, 1
  br label %for.cond51

cleanup:                                          ; preds = %for.cond51, %if.else, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call4, %if.else ], [ 0, %for.cond51 ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_interrupt(i32 %irq, i8* %dev_id) #2 {
entry:
  %0 = bitcast i8* %dev_id to %struct.intel8x0*
  %int_sta_reg = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 23
  %1 = load i32, i32* %int_sta_reg, align 8, !tbaa !77
  %call = call i32 @igetdword(%struct.intel8x0* %0, i32 %1)
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %int_sta_mask = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 24
  %2 = load i32, i32* %int_sta_mask, align 4, !tbaa !78
  %and = and i32 %call, %2
  %cmp1 = icmp eq i32 %and, 0
  br i1 %cmp1, label %if.then2, label %if.end10

if.then2:                                         ; preds = %if.end
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.then2
  %int_sta_reg4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 23
  %3 = load i32, i32* %int_sta_reg4, align 8, !tbaa !77
  call void @iputdword(%struct.intel8x0* %0, i32 %3, i32 %call)
  %buggy_irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 9
  %bf.load = load i16, i16* %buggy_irq, align 8
  %bf.lshr = lshr i16 %bf.load, 9
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool5 = icmp ne i32 %bf.cast, 0
  %call. = select i1 %tobool5, i32 %call, i32 0
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.then2
  %status.1 = phi i32 [ %call., %if.then3 ], [ %call, %if.then2 ]
  %cmp9 = icmp ne i32 %status.1, 0
  %conv = zext i1 %cmp9 to i32
  br label %cleanup

if.end10:                                         ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.inc ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 21
  %4 = load i32, i32* %bdbars_count, align 8, !tbaa !50
  %cmp11 = icmp ult i32 %i.0, %4
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %int_sta_mask13 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 21
  %5 = load i32, i32* %int_sta_mask13, align 8, !tbaa !79
  %and14 = and i32 %call, %5
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %for.inc

if.then16:                                        ; preds = %for.body
  call void @snd_intel8x0_update(%struct.intel8x0* %0, %struct.ichdev* %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %if.then16, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %int_sta_reg18 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 23
  %6 = load i32, i32* %int_sta_reg18, align 8, !tbaa !77
  %int_sta_mask19 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 24
  %7 = load i32, i32* %int_sta_mask19, align 4, !tbaa !78
  %and20 = and i32 %call, %7
  call void @iputdword(%struct.intel8x0* %0, i32 %6, i32 %and20)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end8, %entry
  %retval.0 = phi i32 [ %conv, %if.end8 ], [ 1, %for.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) #3 {
entry:
  %call = call i32 @request_threaded_irq(i32 %irq, i32 (i32, i8*)* %handler, i32 (i32, i8*)* null, i64 %flags, i8* %name, i8* %dev)
  ret i32 %call
}

declare void @synchronize_irq(i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @iputbyte(%struct.intel8x0* %chip, i32 %offset, i8 zeroext %val) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !80
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite8(i8 zeroext %val, i8* %add.ptr)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @igetdword(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !80
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread32(i8* %add.ptr)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @iputdword(%struct.intel8x0* %chip, i32 %offset, i32 %val) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !80
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite32(i32 %val, i8* %add.ptr)
  ret void
}

declare void @snd_ac97_resume(%struct.snd_ac97*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_setup_pcm_out(%struct.intel8x0* %chip, %struct.snd_pcm_runtime* %runtime) #2 {
entry:
  %rate = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 13
  %0 = load i32, i32* %rate, align 4, !tbaa !81
  %cmp = icmp ugt i32 %0, 48000
  %conv = zext i1 %cmp to i32
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_lock_irq(%struct.spinlock* %reg_lock)
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %1 = load i32, i32* %device_type, align 8, !tbaa !68
  %Pivot = icmp slt i32 %1, 3
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %entry
  %SwitchLeaf2 = icmp eq i32 %1, 3
  br i1 %SwitchLeaf2, label %sw.bb, label %sw.default

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %1, 2
  br i1 %SwitchLeaf, label %sw.bb9, label %sw.default

sw.bb:                                            ; preds = %LeafBlock1
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 0)
  %and = and i32 %call, -769
  %channels = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %2 = load i32, i32* %channels, align 8, !tbaa !82
  %cmp1 = icmp eq i32 %2, 4
  %tobool = icmp ne i32 %conv, 0
  %or.cond = or i1 %cmp1, %tobool
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %or = or i32 %and, 256
  br label %if.end8

if.else:                                          ; preds = %sw.bb
  %channels3 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %3 = load i32, i32* %channels3, align 8, !tbaa !82
  %cmp4 = icmp eq i32 %3, 6
  %or7 = or i32 %and, 512
  %or7.and = select i1 %cmp4, i32 %or7, i32 %and
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then
  %cnt.1 = phi i32 [ %or, %if.then ], [ %or7.and, %if.else ]
  call void @iputdword(%struct.intel8x0* %chip, i32 0, i32 %cnt.1)
  br label %sw.epilog

sw.bb9:                                           ; preds = %LeafBlock
  %call10 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and11 = and i32 %call10, -193
  %channels12 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %4 = load i32, i32* %channels12, align 8, !tbaa !82
  %cmp13 = icmp eq i32 %4, 4
  %tobool16 = icmp ne i32 %conv, 0
  %or.cond3 = or i1 %cmp13, %tobool16
  br i1 %or.cond3, label %if.then17, label %if.else19

if.then17:                                        ; preds = %sw.bb9
  %or18 = or i32 %and11, 64
  br label %if.end26

if.else19:                                        ; preds = %sw.bb9
  %channels20 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %5 = load i32, i32* %channels20, align 8, !tbaa !82
  %cmp21 = icmp eq i32 %5, 6
  %or24 = or i32 %and11, 128
  %or24.and11 = select i1 %cmp21, i32 %or24, i32 %and11
  br label %if.end26

if.end26:                                         ; preds = %if.else19, %if.then17
  %cnt.3 = phi i32 [ %or18, %if.then17 ], [ %or24.and11, %if.else19 ]
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %cnt.3)
  br label %sw.epilog

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1
  %call27 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and28 = and i32 %call27, -7340033
  %channels29 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %6 = load i32, i32* %channels29, align 8, !tbaa !82
  %cmp30 = icmp eq i32 %6, 4
  %tobool33 = icmp ne i32 %conv, 0
  %or.cond4 = or i1 %cmp30, %tobool33
  br i1 %or.cond4, label %if.then34, label %if.else36

if.then34:                                        ; preds = %sw.default
  %or35 = or i32 %and28, 1048576
  br label %if.end50

if.else36:                                        ; preds = %sw.default
  %channels37 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %7 = load i32, i32* %channels37, align 8, !tbaa !82
  %cmp38 = icmp eq i32 %7, 6
  br i1 %cmp38, label %if.then40, label %if.else42

if.then40:                                        ; preds = %if.else36
  %or41 = or i32 %and28, 2097152
  br label %if.end50

if.else42:                                        ; preds = %if.else36
  %channels43 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 14
  %8 = load i32, i32* %channels43, align 8, !tbaa !82
  %cmp44 = icmp eq i32 %8, 8
  %or47 = or i32 %and28, 3145728
  %or47.and28 = select i1 %cmp44, i32 %or47, i32 %and28
  br label %if.end50

if.end50:                                         ; preds = %if.else42, %if.then40, %if.then34
  %cnt.6 = phi i32 [ %or35, %if.then34 ], [ %or41, %if.then40 ], [ %or47.and28, %if.else42 ]
  %device_type51 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %9 = load i32, i32* %device_type51, align 8, !tbaa !68
  %cmp52 = icmp eq i32 %9, 4
  br i1 %cmp52, label %if.then54, label %if.else62

if.then54:                                        ; preds = %if.end50
  %and55 = and i32 %cnt.6, 3145728
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end73

if.then57:                                        ; preds = %if.then54
  %and58 = and i32 %cnt.6, -3145729
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %and58)
  %reg_lock59 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_unlock_irq(%struct.spinlock* %reg_lock59)
  call void @msleep(i32 50)
  %reg_lock60 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_lock_irq(%struct.spinlock* %reg_lock60)
  br label %if.end73

if.else62:                                        ; preds = %if.end50
  %device_type63 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %10 = load i32, i32* %device_type63, align 8, !tbaa !68
  %cmp64 = icmp eq i32 %10, 1
  br i1 %cmp64, label %if.then66, label %if.end73

if.then66:                                        ; preds = %if.else62
  %sample_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 21
  %11 = load i32, i32* %sample_bits, align 4, !tbaa !83
  %cmp67 = icmp ugt i32 %11, 16
  %or70 = or i32 %cnt.6, 4194304
  %or70.cnt.6 = select i1 %cmp67, i32 %or70, i32 %cnt.6
  br label %if.end73

if.end73:                                         ; preds = %if.then66, %if.else62, %if.then57, %if.then54
  %cnt.9 = phi i32 [ %cnt.6, %if.then57 ], [ %cnt.6, %if.then54 ], [ %or70.cnt.6, %if.then66 ], [ %cnt.6, %if.else62 ]
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %cnt.9)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end73, %if.end26, %if.end8
  %reg_lock74 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_unlock_irq(%struct.spinlock* %reg_lock74)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_power_change_state(%struct.snd_card* %card, i32 %state) #3 {
entry:
  %power_state = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 30
  store i32 %state, i32* %power_state, align 8, !tbaa !84
  %power_sleep = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 32
  call void @__wake_up(%struct.__wait_queue_head* %power_sleep, i32 3, i32 1, i8* null)
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @msleep(i32) #1

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @iowrite32(i32, i8*) #1

declare i32 @ioread32(i8*) #1

declare void @iowrite8(i8 zeroext, i8*) #1

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_intel8x0_update(%struct.intel8x0* %chip, %struct.ichdev* %ichdev) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 1
  %0 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %reg_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 19
  %5 = load i32, i32* %roff_sr, align 8, !tbaa !76
  %conv5 = zext i32 %5 to i64
  %add = add i64 %0, %conv5
  %conv6 = trunc i64 %add to i32
  %call7 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  %add9 = add i64 %0, 4
  %conv10 = trunc i64 %add9 to i32
  %call11 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv10)
  %conv12 = zext i8 %call11 to i32
  %and = and i32 %conv8, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.end28

if.else:                                          ; preds = %entry
  %civ13 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  %6 = load i32, i32* %civ13, align 8, !tbaa !75
  %cmp14 = icmp eq i32 %conv12, %6
  %civ17 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  %7 = load i32, i32* %civ17, align 8, !tbaa !75
  br i1 %cmp14, label %if.then16, label %if.else20

if.then16:                                        ; preds = %if.else
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* %civ17, align 8, !tbaa !75
  %civ18 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  %8 = load i32, i32* %civ18, align 8, !tbaa !75
  %and19 = and i32 %8, 31
  store i32 %and19, i32* %civ18, align 8, !tbaa !75
  br label %if.end28

if.else20:                                        ; preds = %if.else
  %sub = sub nsw i32 %conv12, %7
  %cmp22 = icmp slt i32 %sub, 0
  %add25 = add nsw i32 %sub, 32
  %add25.sub = select i1 %cmp22, i32 %add25, i32 %sub
  %civ26 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  store i32 %conv12, i32* %civ26, align 8, !tbaa !75
  br label %if.end28

if.end28:                                         ; preds = %if.else20, %if.then16, %entry
  %step.2 = phi i32 [ 0, %entry ], [ 1, %if.then16 ], [ %add25.sub, %if.else20 ]
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %9 = load i32, i32* %fragsize1, align 4, !tbaa !85
  %mul = mul i32 %step.2, %9
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 9
  %10 = load i32, i32* %position, align 8, !tbaa !86
  %add29 = add i32 %10, %mul
  store i32 %add29, i32* %position, align 8, !tbaa !86
  %in_measurement = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_measurement, align 8
  %bf.lshr = lshr i16 %bf.load, 7
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool30 = icmp ne i32 %bf.cast, 0
  br i1 %tobool30, label %if.end33, label %if.then31

if.then31:                                        ; preds = %if.end28
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %11 = load i32, i32* %size, align 4, !tbaa !87
  %position32 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 9
  %12 = load i32, i32* %position32, align 8, !tbaa !86
  %rem = urem i32 %12, %11
  store i32 %rem, i32* %position32, align 8, !tbaa !86
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end28
  %lvi = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %13 = load i32, i32* %lvi, align 8, !tbaa !74
  %add34 = add nsw i32 %13, %step.2
  store i32 %add34, i32* %lvi, align 8, !tbaa !74
  %lvi35 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %14 = load i32, i32* %lvi35, align 8, !tbaa !74
  %and36 = and i32 %14, 31
  store i32 %and36, i32* %lvi35, align 8, !tbaa !74
  %add37 = add i64 %0, 5
  %conv38 = trunc i64 %add37 to i32
  %lvi39 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %15 = load i32, i32* %lvi39, align 8, !tbaa !74
  %conv40 = trunc i32 %15 to i8
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv38, i8 zeroext %conv40)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end33
  %i.0 = phi i32 [ 0, %if.end33 ], [ %inc58, %for.inc ]
  %ack.0 = phi i32 [ 0, %if.end33 ], [ %ack.1, %for.inc ]
  %cmp41 = icmp slt i32 %i.0, %step.2
  br i1 %cmp41, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %lvi_frag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  %16 = load i32, i32* %lvi_frag, align 4, !tbaa !88
  %inc43 = add nsw i32 %16, 1
  store i32 %inc43, i32* %lvi_frag, align 4, !tbaa !88
  %frags = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 12
  %17 = load i32, i32* %frags, align 4, !tbaa !89
  %lvi_frag44 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  %18 = load i32, i32* %lvi_frag44, align 4, !tbaa !88
  %rem45 = srem i32 %18, %17
  store i32 %rem45, i32* %lvi_frag44, align 4, !tbaa !88
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %19 = load i32, i32* %physbuf, align 8, !tbaa !90
  %lvi_frag46 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  %20 = load i32, i32* %lvi_frag46, align 4, !tbaa !88
  %fragsize147 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %21 = load i32, i32* %fragsize147, align 4, !tbaa !85
  %mul48 = mul i32 %20, %21
  %add49 = add i32 %19, %mul48
  %bdbar = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 2
  %22 = load i32*, i32** %bdbar, align 8, !tbaa !91
  %lvi50 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  %23 = load i32, i32* %lvi50, align 8, !tbaa !74
  %mul51 = mul nsw i32 %23, 2
  %idxprom = sext i32 %mul51 to i64
  %arrayidx = getelementptr inbounds i32, i32* %22, i64 %idxprom
  store i32 %add49, i32* %arrayidx, align 4, !tbaa !2
  %ack52 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 16
  %24 = load i32, i32* %ack52, align 4, !tbaa !92
  %dec = add nsw i32 %24, -1
  store i32 %dec, i32* %ack52, align 4, !tbaa !92
  %cmp53 = icmp eq i32 %dec, 0
  br i1 %cmp53, label %if.then55, label %for.inc

if.then55:                                        ; preds = %for.body
  %ack_reload = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 17
  %25 = load i32, i32* %ack_reload, align 8, !tbaa !93
  %ack56 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 16
  store i32 %25, i32* %ack56, align 4, !tbaa !92
  br label %for.inc

for.inc:                                          ; preds = %if.then55, %for.body
  %ack.1 = phi i32 [ 1, %if.then55 ], [ %ack.0, %for.body ]
  %inc58 = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %reg_lock59 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_unlock_irqrestore(%struct.spinlock* %reg_lock59, i64 %call2)
  %tobool60 = icmp ne i32 %ack.0, 0
  br i1 %tobool60, label %land.lhs.true, label %if.end64

land.lhs.true:                                    ; preds = %for.end
  %substream = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 4
  %26 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !51
  %tobool61 = icmp ne %struct.snd_pcm_substream* %26, null
  br i1 %tobool61, label %if.then62, label %if.end64

if.then62:                                        ; preds = %land.lhs.true
  %substream63 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 4
  %27 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream63, align 8, !tbaa !51
  call void @snd_pcm_period_elapsed(%struct.snd_pcm_substream* %27)
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %land.lhs.true, %for.end
  %roff_sr65 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 19
  %28 = load i32, i32* %roff_sr65, align 8, !tbaa !76
  %conv66 = zext i32 %28 to i64
  %add67 = add i64 %0, %conv66
  %conv68 = trunc i64 %add67 to i32
  %and69 = and i32 %conv8, 28
  %conv70 = trunc i32 %and69 to i8
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv68, i8 zeroext %conv70)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !80
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread8(i8* %add.ptr)
  %conv = trunc i32 %call to i8
  ret i8 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @snd_pcm_period_elapsed(%struct.snd_pcm_substream*) #1

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

declare i32 @ioread8(i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ich_chip_init(%struct.intel8x0* %chip, i32 %probing) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy19 = alloca i64, align 8
  %__dummy220 = alloca i64, align 8
  %__dummy36 = alloca i64, align 8
  %__dummy237 = alloca i64, align 8
  %__dummy43 = alloca i64, align 8
  %__dummy244 = alloca i64, align 8
  %__dummy82 = alloca i64, align 8
  %__dummy283 = alloca i64, align 8
  %__dummy89 = alloca i64, align 8
  %__dummy290 = alloca i64, align 8
  %val = alloca i32, align 4
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %0 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp = icmp eq i32 %0, 4
  %or = or i32 32992, 16
  %or. = select i1 %cmp, i32 %or, i32 32992
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and = and i32 %call, %or.
  call void @iputdword(%struct.intel8x0* %chip, i32 48, i32 %and)
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %1 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !94
  %call1 = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %1, %struct.snd_pci_quirk* getelementptr inbounds ([2 x %struct.snd_pci_quirk], [2 x %struct.snd_pci_quirk]* @ich_chip_reset_mode, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call1, null
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %entry
  %call3 = call i32 @snd_intel8x0_ich_chip_cold_reset(%struct.intel8x0* %chip)
  br label %if.end5

if.else:                                          ; preds = %entry
  %call4 = call i32 @snd_intel8x0_ich_chip_reset(%struct.intel8x0* %chip)
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then2
  %err.0 = phi i32 [ %call4, %if.else ], [ %call3, %if.then2 ]
  %cmp6 = icmp slt i32 %err.0, 0
  br i1 %cmp6, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end5
  %tobool9 = icmp ne i32 %probing, 0
  br i1 %tobool9, label %if.then10, label %if.else60

if.then10:                                        ; preds = %if.end8
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %add = add i64 %2, 250
  br label %do.body

do.body:                                          ; preds = %land.lhs.true, %if.then10
  %call11 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %codec_isr_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %3 = load i32, i32* %codec_isr_bits, align 8, !tbaa !96
  %and12 = and i32 %call11, %3
  %cond = icmp eq i32 %and12, 0
  br i1 %cond, label %if.end15, label %if.end30

if.end15:                                         ; preds = %do.body
  %call16 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %cmp17 = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp17 to i32
  %6 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %tobool18 = icmp ne i32 1, 0
  br i1 %tobool18, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %if.end15
  %8 = bitcast i64* %__dummy19 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #7
  %9 = bitcast i64* %__dummy220 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #7
  %cmp21 = icmp eq i64* %__dummy19, %__dummy220
  %conv22 = zext i1 %cmp21 to i32
  %10 = bitcast i64* %__dummy220 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %11 = bitcast i64* %__dummy19 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #7
  %12 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %sub = sub nsw i64 %add, %12
  %cmp25 = icmp sge i64 %sub, 0
  br i1 %cmp25, label %do.body, label %do.end

do.end:                                           ; preds = %land.lhs.true, %if.end15
  %tobool27 = icmp ne i32 %and12, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %do.end
  %call29 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2488, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.47, i32 0, i32 0), i32 %call29)
  br label %cleanup

if.end30:                                         ; preds = %do.end, %do.body
  %13 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %add31 = add i64 %13, 62
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end30
  %status.1 = phi i32 [ %and12, %if.end30 ], [ %or59, %while.body ]
  %codec_isr_bits32 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %14 = load i32, i32* %codec_isr_bits32, align 8, !tbaa !96
  %cmp33 = icmp ne i32 %status.1, %14
  br i1 %cmp33, label %land.rhs35, label %if.end101

land.rhs35:                                       ; preds = %while.cond
  %15 = bitcast i64* %__dummy36 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %15) #7
  %16 = bitcast i64* %__dummy237 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #7
  %cmp38 = icmp eq i64* %__dummy36, %__dummy237
  %conv39 = zext i1 %cmp38 to i32
  %17 = bitcast i64* %__dummy237 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #7
  %18 = bitcast i64* %__dummy36 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #7
  %tobool41 = icmp ne i32 1, 0
  br i1 %tobool41, label %land.lhs.true42, label %if.end101

land.lhs.true42:                                  ; preds = %land.rhs35
  %19 = bitcast i64* %__dummy43 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %19) #7
  %20 = bitcast i64* %__dummy244 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #7
  %cmp45 = icmp eq i64* %__dummy43, %__dummy244
  %conv46 = zext i1 %cmp45 to i32
  %21 = bitcast i64* %__dummy244 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %21) #7
  %22 = bitcast i64* %__dummy43 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #7
  %23 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %sub50 = sub nsw i64 %add31, %23
  %cmp51 = icmp sge i64 %sub50, 0
  br i1 %cmp51, label %while.body, label %if.end101

while.body:                                       ; preds = %land.lhs.true42
  %call55 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %call56 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %codec_isr_bits57 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %24 = load i32, i32* %codec_isr_bits57, align 8, !tbaa !96
  %and58 = and i32 %call56, %24
  %or59 = or i32 %status.1, %and58
  br label %while.cond

if.else60:                                        ; preds = %if.end8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else60
  %status.2 = phi i32 [ 0, %if.else60 ], [ %status.3, %for.inc ]
  %i.0 = phi i32 [ 0, %if.else60 ], [ %inc, %for.inc ]
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 16
  %25 = load i32, i32* %ncodecs, align 8, !tbaa !67
  %cmp61 = icmp ult i32 %i.0, %25
  br i1 %cmp61, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 %idxprom
  %26 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  %tobool63 = icmp ne %struct.snd_ac97* %26, null
  br i1 %tobool63, label %if.then64, label %for.inc

if.then64:                                        ; preds = %for.body
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 17
  %27 = load i32*, i32** %codec_bit, align 8, !tbaa !97
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom65 = sext i32 %i.0 to i64
  %arrayidx66 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 %idxprom65
  %28 = load i32, i32* %arrayidx66, align 4, !tbaa !2
  %idxprom67 = zext i32 %28 to i64
  %arrayidx68 = getelementptr inbounds i32, i32* %27, i64 %idxprom67
  %29 = load i32, i32* %arrayidx68, align 4, !tbaa !2
  %or69 = or i32 %status.2, %29
  br label %for.inc

for.inc:                                          ; preds = %if.then64, %for.body
  %status.3 = phi i32 [ %or69, %if.then64 ], [ %status.2, %for.body ]
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %add71 = add i64 %30, 250
  br label %do.body72

do.body72:                                        ; preds = %land.lhs.true88, %for.end
  %call73 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %codec_isr_bits74 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %31 = load i32, i32* %codec_isr_bits74, align 8, !tbaa !96
  %and75 = and i32 %call73, %31
  %cmp76 = icmp eq i32 %status.2, %and75
  br i1 %cmp76, label %if.end101, label %if.end79

if.end79:                                         ; preds = %do.body72
  %call80 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %32 = bitcast i64* %__dummy82 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %32) #7
  %33 = bitcast i64* %__dummy283 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %33) #7
  %cmp84 = icmp eq i64* %__dummy82, %__dummy283
  %conv85 = zext i1 %cmp84 to i32
  %34 = bitcast i64* %__dummy283 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %34) #7
  %35 = bitcast i64* %__dummy82 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %35) #7
  %tobool87 = icmp ne i32 1, 0
  br i1 %tobool87, label %land.lhs.true88, label %if.end101

land.lhs.true88:                                  ; preds = %if.end79
  %36 = bitcast i64* %__dummy89 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %36) #7
  %37 = bitcast i64* %__dummy290 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %37) #7
  %cmp91 = icmp eq i64* %__dummy89, %__dummy290
  %conv92 = zext i1 %cmp91 to i32
  %38 = bitcast i64* %__dummy290 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %38) #7
  %39 = bitcast i64* %__dummy89 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %39) #7
  %40 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %sub96 = sub nsw i64 %add71, %40
  %cmp97 = icmp sge i64 %sub96, 0
  br i1 %cmp97, label %do.body72, label %if.end101

if.end101:                                        ; preds = %land.lhs.true88, %if.end79, %do.body72, %land.lhs.true42, %land.rhs35, %while.cond
  %device_type102 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %41 = load i32, i32* %device_type102, align 8, !tbaa !68
  %cmp103 = icmp eq i32 %41, 2
  br i1 %cmp103, label %if.then105, label %if.end110

if.then105:                                       ; preds = %if.end101
  %call106 = call zeroext i16 @igetword(%struct.intel8x0* %chip, i32 76)
  %conv107 = zext i16 %call106 to i32
  %or108 = or i32 %conv107, 1
  %conv109 = trunc i32 %or108 to i16
  call void @iputword(%struct.intel8x0* %chip, i32 76, i16 zeroext %conv109)
  br label %if.end110

if.end110:                                        ; preds = %if.then105, %if.end101
  %device_type111 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %42 = load i32, i32* %device_type111, align 8, !tbaa !68
  %cmp112 = icmp ne i32 %42, 4
  %43 = load i32, i32* @spdif_aclink, align 4
  %tobool115 = icmp ne i32 %43, 0
  %or.cond = or i1 %cmp112, %tobool115
  br i1 %or.cond, label %cleanup, label %if.then116

if.then116:                                       ; preds = %if.end110
  %44 = bitcast i32* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %44) #7
  %pci117 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %45 = load %struct.pci_dev*, %struct.pci_dev** %pci117, align 8, !tbaa !94
  call void @pci_read_config_dword(%struct.pci_dev* %45, i32 76, i32* %val)
  %46 = load i32, i32* %val, align 4, !tbaa !2
  %or119 = or i32 %46, 16777216
  store i32 %or119, i32* %val, align 4, !tbaa !2
  %pci120 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %47 = load %struct.pci_dev*, %struct.pci_dev** %pci120, align 8, !tbaa !94
  %48 = load i32, i32* %val, align 4, !tbaa !2
  call void @pci_write_config_dword(%struct.pci_dev* %47, i32 76, i32 %48)
  %49 = bitcast i32* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %49) #7
  br label %cleanup

cleanup:                                          ; preds = %if.then116, %if.end110, %if.then28, %if.end5
  %retval.0 = phi i32 [ -5, %if.then28 ], [ %err.0, %if.end5 ], [ 0, %if.end110 ], [ 0, %if.then116 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %addr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !98
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread16(i8* %add.ptr)
  %conv = trunc i32 %call to i16
  ret i16 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_chip_init(%struct.intel8x0* %chip, i32 %probing) #2 {
entry:
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 0)
  %and = and i32 %call, 2
  %cmp = icmp eq i32 %and, 0
  %.sink = select i1 %cmp, i32 2, i32 1
  %or1 = or i32 %call, %.sink
  %and2 = and i32 %or1, 2147483647
  call void @iputdword(%struct.intel8x0* %chip, i32 0, i32 %and2)
  br label %for.cond

for.cond:                                         ; preds = %if.end7, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end7 ]
  %cmp3 = icmp slt i32 %i.0, 125
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call4 = call i32 @igetdword(%struct.intel8x0* %chip, i32 24)
  %and5 = and i32 %call4, 2
  %tobool = icmp ne i32 %and5, 0
  br i1 %tobool, label %if.end7, label %__ok

if.end7:                                          ; preds = %for.body
  %call8 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2551, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.50, i32 0, i32 0))
  %tobool9 = icmp ne i32 %probing, 0
  br i1 %tobool9, label %cleanup, label %__ok

__ok:                                             ; preds = %for.end, %for.body
  br label %for.cond12

for.cond12:                                       ; preds = %if.end19, %__ok
  %i.1 = phi i32 [ 0, %__ok ], [ %inc23, %if.end19 ]
  %cmp13 = icmp slt i32 %i.1, 125
  br i1 %cmp13, label %for.body14, label %for.end24

for.body14:                                       ; preds = %for.cond12
  %call15 = call i32 @igetdword(%struct.intel8x0* %chip, i32 52)
  %and16 = and i32 %call15, 128
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %for.end24, label %if.end19

if.end19:                                         ; preds = %for.body14
  %or20 = or i32 %call15, 128
  call void @iputdword(%struct.intel8x0* %chip, i32 52, i32 %or20)
  %call21 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %inc23 = add nsw i32 %i.1, 1
  br label %for.cond12

for.end24:                                        ; preds = %for.body14, %for.cond12
  call void @do_ali_reset(%struct.intel8x0* %chip)
  br label %cleanup

cleanup:                                          ; preds = %for.end24, %for.end
  %retval.0 = phi i32 [ 0, %for.end24 ], [ -5, %for.end ]
  ret i32 %retval.0
}

declare i64 @schedule_timeout_uninterruptible(i64) #1

declare void @__snd_printk(i32, i8*, i32, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal void @do_ali_reset(%struct.intel8x0* %chip) #2 {
entry:
  call void @iputdword(%struct.intel8x0* %chip, i32 0, i32 -2147483648)
  call void @iputdword(%struct.intel8x0* %chip, i32 12, i32 -2088533117)
  call void @iputdword(%struct.intel8x0* %chip, i32 28, i32 -2088533117)
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 -2088533117)
  call void @iputdword(%struct.intel8x0* %chip, i32 16, i32 524290)
  call void @iputdword(%struct.intel8x0* %chip, i32 20, i32 0)
  call void @iputdword(%struct.intel8x0* %chip, i32 24, i32 0)
  ret void
}

declare i32 @ioread16(i8*) #1

declare %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev*, %struct.snd_pci_quirk*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ich_chip_cold_reset(%struct.intel8x0* %chip) #2 {
entry:
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %0 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !94
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %0, %struct.snd_pci_quirk* getelementptr inbounds ([2 x %struct.snd_pci_quirk], [2 x %struct.snd_pci_quirk]* @ich_chip_reset_mode, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call, null
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and = and i32 %call1, -3145737
  %and2 = and i32 %and, -3
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %and2)
  %call3 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  call void @__const_udelay(i64 42950)
  %or = or i32 %call3, 2
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %or)
  call void @msleep(i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -5, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ich_chip_reset(%struct.intel8x0* %chip) #2 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy8 = alloca i64, align 8
  %__dummy29 = alloca i64, align 8
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and = and i32 %call, -3145737
  %and1 = and i32 %and, 2
  %cmp = icmp eq i32 %and1, 0
  %0 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 2, i32 4
  %or = or i32 %and, %cond
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %or)
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %add = add i64 %1, 62
  %add2 = add i64 %add, 1
  br label %do.body

do.body:                                          ; preds = %land.lhs.true, %entry
  %call3 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and4 = and i32 %call3, 4
  %cmp5 = icmp eq i32 %and4, 0
  br i1 %cmp5, label %cleanup, label %if.end

if.end:                                           ; preds = %do.body
  %call6 = call i64 @schedule_timeout_uninterruptible(i64 1)
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %cmp7 = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp7 to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %do.end

land.lhs.true:                                    ; preds = %if.end
  %6 = bitcast i64* %__dummy8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy29 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #7
  %cmp10 = icmp eq i64* %__dummy8, %__dummy29
  %conv11 = zext i1 %cmp10 to i32
  %8 = bitcast i64* %__dummy29 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #7
  %9 = bitcast i64* %__dummy8 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #7
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !95
  %sub = sub nsw i64 %add2, %10
  %cmp14 = icmp sge i64 %sub, 0
  br i1 %cmp14, label %do.body, label %do.end

do.end:                                           ; preds = %land.lhs.true, %if.end
  %call16 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2446, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.49, i32 0, i32 0), i32 %call16)
  br label %cleanup

cleanup:                                          ; preds = %do.end, %do.body
  %retval.0 = phi i32 [ -5, %do.end ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @igetword(%struct.intel8x0* %chip, i32 %offset) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !80
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  %call = call i32 @ioread16(i8* %add.ptr)
  %conv = trunc i32 %call to i16
  ret i16 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @iputword(%struct.intel8x0* %chip, i32 %offset, i16 zeroext %val) #3 {
entry:
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %0 = load i8*, i8** %bmaddr, align 8, !tbaa !80
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite16(i16 zeroext %val, i8* %add.ptr)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_read_config_dword(%struct.pci_dev* %dev, i32 %where, i32* %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !99
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !100
  %call = call i32 @pci_bus_read_config_dword(%struct.pci_bus* %0, i32 %1, i32 %where, i32* %val)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_write_config_dword(%struct.pci_dev* %dev, i32 %where, i32 %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !99
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !100
  %call = call i32 @pci_bus_write_config_dword(%struct.pci_bus* %0, i32 %1, i32 %where, i32 %val)
  ret void
}

declare i32 @pci_bus_write_config_dword(%struct.pci_bus*, i32, i32, i32) #1

declare i32 @pci_bus_read_config_dword(%struct.pci_bus*, i32, i32, i32*) #1

declare void @iowrite16(i16 zeroext, i8*) #1

declare void @__const_udelay(i64) #1

declare i32 @snd_pcm_suspend_all(%struct.snd_pcm*) #1

declare void @snd_ac97_suspend(%struct.snd_ac97*) #1

declare void @free_irq(i32, i8*) #1

declare void @pci_disable_device(%struct.pci_dev*) #1

declare i32 @pci_save_state(%struct.pci_dev*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare i32 @snd_card_free(%struct.snd_card*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pdev, i32 0, i32 34
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

declare i32 @dev_set_drvdata(%struct.device*, i8*) #1

declare i32 @snd_card_create(i32, i8*, %struct.module*, i32, %struct.snd_card**) #1

; Function Attrs: nounwind uwtable
define internal i32 @check_default_spdif_aclink(%struct.pci_dev* %pci) #2 {
entry:
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %pci, %struct.snd_pci_quirk* getelementptr inbounds ([2 x %struct.snd_pci_quirk], [2 x %struct.snd_pci_quirk]* @spdif_aclink_defaults, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %entry
  %value = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 3
  %0 = load i32, i32* %value, align 8, !tbaa !101
  %tobool1 = icmp ne i32 %0, 0
  %name = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 4
  %1 = load i8*, i8** %name, align 8, !tbaa !103
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 3271, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.8, i32 0, i32 0), i8* %1)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 3275, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.9, i32 0, i32 0), i8* %1)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  %value4 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 3
  %2 = load i32, i32* %value4, align 8, !tbaa !101
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ %2, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

declare i8* @strcpy(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_create() #2 {
entry:
  br label %if.end

if.end:                                           ; preds = %entry
  %call1 = call i8* @kzalloc(i64 1088, i32 208)
  %0 = bitcast i8* %call1 to %struct.intel8x0*
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load i8, i8* @xbox, align 1, !tbaa !104, !range !105
  %tobool20 = trunc i8 %1 to i1
  br i1 %tobool20, label %if.then21, label %cleanup

if.then21:                                        ; preds = %do.body
  %xbox = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %0, i32 0, i32 9
  %bf.load22 = load i16, i16* %xbox, align 8
  %bf.clear23 = and i16 %bf.load22, -1025
  %bf.set24 = or i16 %bf.clear23, 1024
  store i16 %bf.set24, i16* %xbox, align 8
  br label %cleanup

if.end107:                                        ; preds = %if.end107
  br label %if.end107

for.body133:                                      ; preds = %for.body133
  br label %for.body133

for.body170:                                      ; preds = %for.body170
  br label %for.body170

cleanup:                                          ; preds = %do.body, %if.then21
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mixer(%struct.intel8x0* %chip, i32 %ac97_clock, i8* %quirk_override) #2 {
entry:
  %pbus = alloca %struct.snd_ac97_bus*, align 8
  %ac97 = alloca %struct.snd_ac97_template, align 8
  %0 = bitcast %struct.snd_ac97_bus** %pbus to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast %struct.snd_ac97_template* %ac97 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %1) #7
  %spdif_idx = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 -1, i32* %spdif_idx, align 4, !tbaa !106
  %2 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %3 = load i32, i32* %device_type, align 8, !tbaa !68
  %Pivot4 = icmp slt i32 %3, 3
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %if.then
  %Pivot = icmp slt i32 %3, 4
  br i1 %Pivot, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %3, 4
  br i1 %SwitchLeaf2, label %sw.bb, label %if.end

LeafBlock:                                        ; preds = %if.then
  %SwitchLeaf = icmp eq i32 %3, 1
  br i1 %SwitchLeaf, label %sw.bb4, label %if.end

sw.bb:                                            ; preds = %LeafBlock1
  %spdif_idx1 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 3, i32* %spdif_idx1, align 4, !tbaa !106
  br label %if.end

sw.bb2:                                           ; preds = %NodeBlock
  %spdif_idx3 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 3, i32* %spdif_idx3, align 4, !tbaa !106
  br label %if.end

sw.bb4:                                           ; preds = %LeafBlock
  %spdif_idx5 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  store i32 5, i32* %spdif_idx5, align 4, !tbaa !106
  br label %if.end

if.end:                                           ; preds = %sw.bb4, %sw.bb2, %sw.bb, %LeafBlock, %LeafBlock1, %entry
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.clear = and i16 %bf.load, -33
  %bf.set = or i16 %bf.clear, 32
  store i16 %bf.set, i16* %in_ac97_init, align 8
  %4 = bitcast %struct.snd_ac97_template* %ac97 to i8*
  call void @llvm.memset.p0i8.i64(i8* %4, i8 0, i64 40, i32 8, i1 false)
  %5 = bitcast %struct.intel8x0* %chip to i8*
  %private_data = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 0
  store i8* %5, i8** %private_data, align 8, !tbaa !107
  %private_free = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 1
  store void (%struct.snd_ac97*)* @snd_intel8x0_mixer_free_ac97, void (%struct.snd_ac97*)** %private_free, align 8, !tbaa !109
  %scaps = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 5
  store i32 2080, i32* %scaps, align 4, !tbaa !110
  %xbox = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load6 = load i16, i16* %xbox, align 8
  %bf.lshr = lshr i16 %bf.load6, 10
  %bf.clear7 = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear7 to i32
  %tobool8 = icmp ne i32 %bf.cast, 0
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %scaps10 = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 5
  %6 = load i32, i32* %scaps10, align 4, !tbaa !110
  %or = or i32 %6, 256
  store i32 %or, i32* %scaps10, align 4, !tbaa !110
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  %device_type12 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %7 = load i32, i32* %device_type12, align 8, !tbaa !68
  %cmp = icmp ne i32 %7, 3
  br i1 %cmp, label %if.then13, label %if.else67

if.then13:                                        ; preds = %if.end11
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %in_sdin_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load14 = load i16, i16* %in_sdin_init, align 8
  %bf.clear15 = and i16 %bf.load14, -65
  %bf.set16 = or i16 %bf.clear15, 64
  store i16 %bf.set16, i16* %in_sdin_init, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then13
  %codecs.0 = phi i32 [ 0, %if.then13 ], [ %codecs.1, %for.inc ]
  %i.0 = phi i32 [ 0, %if.then13 ], [ %inc60, %for.inc ]
  %max_codecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 15
  %8 = load i32, i32* %max_codecs, align 4, !tbaa !111
  %cmp17 = icmp ult i32 %i.0, %8
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 17
  %9 = load i32*, i32** %codec_bit, align 8, !tbaa !97
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %9, i64 %idxprom
  %10 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %and = and i32 %call, %10
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.end20, label %for.inc

if.end20:                                         ; preds = %for.body
  %device_type21 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %11 = load i32, i32* %device_type21, align 8, !tbaa !68
  %cmp22 = icmp eq i32 %11, 1
  br i1 %cmp22, label %if.then23, label %if.end59.sink.split

if.then23:                                        ; preds = %if.end20
  call void @snd_intel8x0_codec_read_test(%struct.intel8x0* %chip, i32 %codecs.0)
  %call24 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 128)
  %conv = zext i8 %call24 to i32
  %and25 = and i32 %conv, 3
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom26 = zext i32 %codecs.0 to i64
  %arrayidx27 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 %idxprom26
  store i32 %and25, i32* %arrayidx27, align 4, !tbaa !2
  %ac97_sdin28 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom29 = zext i32 %codecs.0 to i64
  %arrayidx30 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin28, i64 0, i64 %idxprom29
  %12 = load i32, i32* %arrayidx30, align 4, !tbaa !2
  %cmp31 = icmp uge i32 %12, 3
  %lnot = xor i1 %cmp31, true
  %lnot33 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot33 to i32
  %tobool34 = icmp ne i32 %lnot.ext, 0
  %lnot35 = xor i1 %tobool34, true
  %lnot37 = xor i1 %lnot35, true
  %lnot.ext38 = zext i1 %lnot37 to i32
  %conv39 = sext i32 %lnot.ext38 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv39, i64 0)
  %tobool40 = icmp ne i64 %expval, 0
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.then23
  call void @warn_slowpath_null(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2252)
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.then23
  %tobool43 = icmp ne i32 %lnot.ext, 0
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %if.end59.sink.split, label %if.end59

if.end59.sink.split:                              ; preds = %if.end42, %if.end20
  %.sink = phi i32 [ 0, %if.end42 ], [ %i.0, %if.end20 ]
  %ac97_sdin52 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom53 = zext i32 %codecs.0 to i64
  %arrayidx54 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin52, i64 0, i64 %idxprom53
  store i32 %.sink, i32* %arrayidx54, align 4, !tbaa !2
  br label %if.end59

if.end59:                                         ; preds = %if.end59.sink.split, %if.end42
  %inc = add i32 %codecs.0, 1
  br label %for.inc

for.inc:                                          ; preds = %if.end59, %for.body
  %codecs.1 = phi i32 [ %inc, %if.end59 ], [ %codecs.0, %for.body ]
  %inc60 = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %in_sdin_init61 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load62 = load i16, i16* %in_sdin_init61, align 8
  %bf.clear63 = and i16 %bf.load62, -65
  store i16 %bf.clear63, i16* %in_sdin_init61, align 8
  %tobool64 = icmp ne i32 %codecs.0, 0
  %codecs.0. = select i1 %tobool64, i32 %codecs.0, i32 1
  br label %if.end81

if.else67:                                        ; preds = %if.end11
  br label %for.cond68

for.cond68:                                       ; preds = %for.inc78, %if.else67
  %codecs.3 = phi i32 [ 1, %if.else67 ], [ %codecs.4, %for.inc78 ]
  %i.1 = phi i32 [ 0, %if.else67 ], [ %inc79, %for.inc78 ]
  %cmp69 = icmp ult i32 %i.1, 100
  br i1 %cmp69, label %for.body71, label %if.end81

for.body71:                                       ; preds = %for.cond68
  %call72 = call i32 @igetdword(%struct.intel8x0* %chip, i32 52)
  %and73 = and i32 %call72, 64
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %LeafBlock6, label %if.end76

if.end76:                                         ; preds = %for.body71
  %or77 = or i32 %call72, 64
  call void @iputdword(%struct.intel8x0* %chip, i32 52, i32 %or77)
  call void @__const_udelay(i64 4295)
  br label %LeafBlock6

LeafBlock6:                                       ; preds = %if.end76, %for.body71
  %codecs.4 = phi i32 [ %codecs.3, %if.end76 ], [ 2, %for.body71 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end76 ], [ 6, %for.body71 ]
  %SwitchLeaf7 = icmp eq i32 %cleanup.dest.slot.0, 6
  br i1 %SwitchLeaf7, label %if.end81, label %for.inc78

for.inc78:                                        ; preds = %LeafBlock6
  %inc79 = add i32 %i.1, 1
  br label %for.cond68

if.end81:                                         ; preds = %LeafBlock6, %for.cond68, %for.end
  %codecs.6 = phi i32 [ %codecs.0., %for.end ], [ %codecs.4, %LeafBlock6 ], [ %codecs.3, %for.cond68 ]
  %ops.0 = phi %struct.snd_ac97_bus_ops* [ @snd_intel8x0_mixer.standard_bus_ops, %for.end ], [ @snd_intel8x0_mixer.ali_bus_ops, %LeafBlock6 ], [ @snd_intel8x0_mixer.ali_bus_ops, %for.cond68 ]
  %card = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %13 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !112
  %14 = bitcast %struct.intel8x0* %chip to i8*
  %call82 = call i32 @snd_ac97_bus(%struct.snd_card* %13, i32 0, %struct.snd_ac97_bus_ops* %ops.0, i8* %14, %struct.snd_ac97_bus** %pbus)
  %cmp83 = icmp slt i32 %call82, 0
  br i1 %cmp83, label %__err, label %if.end86

if.end86:                                         ; preds = %if.end81
  %15 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %private_free87 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %15, i32 0, i32 2
  store void (%struct.snd_ac97_bus*)* @snd_intel8x0_mixer_free_ac97_bus, void (%struct.snd_ac97_bus*)** %private_free87, align 8, !tbaa !113
  %cmp88 = icmp sge i32 %ac97_clock, 8000
  %cmp90 = icmp sle i32 %ac97_clock, 48000
  %or.cond = and i1 %cmp88, %cmp90
  br i1 %or.cond, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.end86
  %16 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %clock = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %16, i32 0, i32 6
  store i32 %ac97_clock, i32* %clock, align 4, !tbaa !115
  br label %if.end93

if.end93:                                         ; preds = %if.then92, %if.end86
  %device_type94 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %17 = load i32, i32* %device_type94, align 8, !tbaa !68
  %cmp95 = icmp eq i32 %17, 3
  %18 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %no_vra = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %18, i32 0, i32 5
  %bf.load98 = load i8, i8* %no_vra, align 2
  %.sink9 = select i1 %cmp95, i8 -2, i8 -3
  %.sink8 = select i1 %cmp95, i8 1, i8 2
  %bf.clear103 = and i8 %bf.load98, %.sink9
  %bf.set104 = or i8 %bf.clear103, %.sink8
  store i8 %bf.set104, i8* %no_vra, align 2
  %19 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  store %struct.snd_ac97_bus* %19, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !116
  %ncodecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 16
  store i32 %codecs.6, i32* %ncodecs, align 8, !tbaa !67
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %20 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !94
  %pci106 = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 2
  store %struct.pci_dev* %20, %struct.pci_dev** %pci106, align 8, !tbaa !117
  br label %for.cond107

for.cond107:                                      ; preds = %for.inc128, %if.end93
  %i.2 = phi i32 [ 0, %if.end93 ], [ %inc129, %for.inc128 ]
  %cmp108 = icmp ult i32 %i.2, %codecs.6
  br i1 %cmp108, label %for.body110, label %for.end130

for.body110:                                      ; preds = %for.cond107
  %conv111 = trunc i32 %i.2 to i16
  %num = getelementptr inbounds %struct.snd_ac97_template, %struct.snd_ac97_template* %ac97, i32 0, i32 3
  store i16 %conv111, i16* %num, align 8, !tbaa !118
  %21 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %ac97112 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %idxprom113 = zext i32 %i.2 to i64
  %arrayidx114 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97112, i64 0, i64 %idxprom113
  %call115 = call i32 @snd_ac97_mixer(%struct.snd_ac97_bus* %21, %struct.snd_ac97_template* %ac97, %struct.snd_ac97** %arrayidx114)
  %cmp116 = icmp slt i32 %call115, 0
  br i1 %cmp116, label %if.then118, label %for.inc128

if.then118:                                       ; preds = %for.body110
  %cmp119 = icmp ne i32 %call115, -13
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.then118
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2293, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.51, i32 0, i32 0), i32 %i.2)
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.then118
  %cmp123 = icmp eq i32 %i.2, 0
  br i1 %cmp123, label %__err, label %for.inc128

for.inc128:                                       ; preds = %if.end122, %for.body110
  %inc129 = add i32 %i.2, 1
  br label %for.cond107

for.end130:                                       ; preds = %for.cond107
  %ac97131 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx132 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97131, i64 0, i64 0
  %22 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx132, align 8, !tbaa !6
  %call133 = call i32 @snd_ac97_tune_hardware(%struct.snd_ac97* %22, %struct.ac97_quirk* getelementptr inbounds ([66 x %struct.ac97_quirk], [66 x %struct.ac97_quirk]* @ac97_quirks, i32 0, i32 0), i8* %quirk_override)
  %device_type134 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %23 = load i32, i32* %device_type134, align 8, !tbaa !68
  %cmp135 = icmp eq i32 %23, 1
  br i1 %cmp135, label %if.then137, label %if.end141

if.then137:                                       ; preds = %for.end130
  %24 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %isdin = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %24, i32 0, i32 5
  %bf.load138 = load i8, i8* %isdin, align 2
  %bf.clear139 = and i8 %bf.load138, -5
  %bf.set140 = or i8 %bf.clear139, 4
  store i8 %bf.set140, i8* %isdin, align 2
  br label %if.end141

if.end141:                                        ; preds = %if.then137, %for.end130
  %device_type142 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %25 = load i32, i32* %device_type142, align 8, !tbaa !68
  %cmp143 = icmp ne i32 %25, 1
  %sub = sub i32 6, 2
  %sub. = select i1 %cmp143, i32 %sub, i32 6
  %spdif_idx147 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %26 = load i32, i32* %spdif_idx147, align 4, !tbaa !106
  %cmp148 = icmp slt i32 %26, 0
  %dec = add i32 %sub., -1
  %i.4 = select i1 %cmp148, i32 %dec, i32 %sub.
  %27 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %conv152 = trunc i32 %i.4 to i16
  %call153 = call i32 @snd_ac97_pcm_assign(%struct.snd_ac97_bus* %27, i16 zeroext %conv152, %struct.ac97_pcm* getelementptr inbounds ([6 x %struct.ac97_pcm], [6 x %struct.ac97_pcm]* @ac97_pcm_defs, i32 0, i32 0))
  %cmp154 = icmp slt i32 %call153, 0
  br i1 %cmp154, label %__err, label %if.end157

if.end157:                                        ; preds = %if.end141
  %28 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %28, i32 0, i32 10
  %29 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms, align 8, !tbaa !119
  %arrayidx158 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %29, i64 0
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx159 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx159, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx158, %struct.ac97_pcm** %pcm, align 8, !tbaa !120
  %30 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms160 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %30, i32 0, i32 10
  %31 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms160, align 8, !tbaa !119
  %arrayidx161 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %31, i64 1
  %ichd162 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx163 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd162, i64 0, i64 0
  %pcm164 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx163, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx161, %struct.ac97_pcm** %pcm164, align 8, !tbaa !120
  %32 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms165 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %32, i32 0, i32 10
  %33 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms165, align 8, !tbaa !119
  %arrayidx166 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %33, i64 2
  %ichd167 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx168 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd167, i64 0, i64 2
  %pcm169 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx168, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx166, %struct.ac97_pcm** %pcm169, align 8, !tbaa !120
  %spdif_idx170 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %34 = load i32, i32* %spdif_idx170, align 4, !tbaa !106
  %cmp171 = icmp sge i32 %34, 0
  br i1 %cmp171, label %if.then173, label %if.end181

if.then173:                                       ; preds = %if.end157
  %35 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms174 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %35, i32 0, i32 10
  %36 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms174, align 8, !tbaa !119
  %arrayidx175 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %36, i64 3
  %ichd176 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %spdif_idx177 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %37 = load i32, i32* %spdif_idx177, align 4, !tbaa !106
  %idxprom178 = sext i32 %37 to i64
  %arrayidx179 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd176, i64 0, i64 %idxprom178
  %pcm180 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx179, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx175, %struct.ac97_pcm** %pcm180, align 8, !tbaa !120
  br label %if.end181

if.end181:                                        ; preds = %if.then173, %if.end157
  %device_type182 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %38 = load i32, i32* %device_type182, align 8, !tbaa !68
  %cmp183 = icmp eq i32 %38, 1
  br i1 %cmp183, label %if.then185, label %if.end196

if.then185:                                       ; preds = %if.end181
  %39 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms186 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %39, i32 0, i32 10
  %40 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms186, align 8, !tbaa !119
  %arrayidx187 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %40, i64 4
  %ichd188 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx189 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd188, i64 0, i64 4
  %pcm190 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx189, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx187, %struct.ac97_pcm** %pcm190, align 8, !tbaa !120
  %41 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms191 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %41, i32 0, i32 10
  %42 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms191, align 8, !tbaa !119
  %arrayidx192 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %42, i64 5
  %ichd193 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx194 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd193, i64 0, i64 3
  %pcm195 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx194, i32 0, i32 23
  store %struct.ac97_pcm* %arrayidx192, %struct.ac97_pcm** %pcm195, align 8, !tbaa !120
  br label %if.end196

if.end196:                                        ; preds = %if.then185, %if.end181
  %device_type197 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %43 = load i32, i32* %device_type197, align 8, !tbaa !68
  %cmp198 = icmp eq i32 %43, 1
  br i1 %cmp198, label %if.then200, label %if.end250

if.then200:                                       ; preds = %if.end196
  %ichd202 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx203 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd202, i64 0, i64 4
  %pcm204 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx203, i32 0, i32 23
  %44 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm204, align 8, !tbaa !120
  %call206 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 128)
  %conv207 = zext i8 %call206 to i32
  %and208 = and i32 %conv207, -241
  %conv209 = trunc i32 %and208 to i8
  %tobool210 = icmp ne %struct.ac97_pcm* %44, null
  %conv212 = zext i8 %conv209 to i32
  br i1 %tobool210, label %if.then211, label %if.else245

if.then211:                                       ; preds = %if.then200
  %or213 = or i32 %conv212, 8
  %conv214 = trunc i32 %or213 to i8
  %ac97_sdin215 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %arrayidx216 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin215, i64 0, i64 0
  %45 = load i32, i32* %arrayidx216, align 8, !tbaa !2
  %shl = shl i32 %45, 4
  %conv217 = zext i8 %conv214 to i32
  %or218 = or i32 %conv217, %shl
  %conv219 = trunc i32 %or218 to i8
  br label %for.cond220

for.cond220:                                      ; preds = %for.inc242, %if.then211
  %i.5 = phi i32 [ 1, %if.then211 ], [ %inc243, %for.inc242 ]
  %cmp221 = icmp ult i32 %i.5, 4
  br i1 %cmp221, label %for.body223, label %if.end249

for.body223:                                      ; preds = %for.cond220
  %r = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %44, i32 0, i32 5
  %arrayidx224 = getelementptr inbounds [2 x %struct.anon.63], [2 x %struct.anon.63]* %r, i64 0, i64 0
  %codec = getelementptr inbounds %struct.anon.63, %struct.anon.63* %arrayidx224, i32 0, i32 3
  %idxprom225 = zext i32 %i.5 to i64
  %arrayidx226 = getelementptr inbounds [4 x %struct.snd_ac97*], [4 x %struct.snd_ac97*]* %codec, i64 0, i64 %idxprom225
  %46 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx226, align 8, !tbaa !6
  %tobool227 = icmp ne %struct.snd_ac97* %46, null
  br i1 %tobool227, label %if.then228, label %for.inc242

if.then228:                                       ; preds = %for.body223
  %ac97_sdin229 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %r230 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %44, i32 0, i32 5
  %arrayidx231 = getelementptr inbounds [2 x %struct.anon.63], [2 x %struct.anon.63]* %r230, i64 0, i64 0
  %codec232 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %arrayidx231, i32 0, i32 3
  %arrayidx233 = getelementptr inbounds [4 x %struct.snd_ac97*], [4 x %struct.snd_ac97*]* %codec232, i64 0, i64 1
  %47 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx233, align 8, !tbaa !6
  %num234 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %47, i32 0, i32 11
  %48 = load i16, i16* %num234, align 8, !tbaa !121
  %idxprom235 = zext i16 %48 to i64
  %arrayidx236 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin229, i64 0, i64 %idxprom235
  %49 = load i32, i32* %arrayidx236, align 4, !tbaa !2
  %shl237 = shl i32 %49, 6
  %conv238 = zext i8 %conv219 to i32
  %or239 = or i32 %conv238, %shl237
  %conv240 = trunc i32 %or239 to i8
  br label %if.end249

for.inc242:                                       ; preds = %for.body223
  %inc243 = add i32 %i.5, 1
  br label %for.cond220

if.else245:                                       ; preds = %if.then200
  %and247 = and i32 %conv212, -9
  %conv248 = trunc i32 %and247 to i8
  br label %if.end249

if.end249:                                        ; preds = %if.else245, %if.then228, %for.cond220
  %tmp205.1 = phi i8 [ %conv248, %if.else245 ], [ %conv240, %if.then228 ], [ %conv219, %for.cond220 ]
  call void @iputbyte(%struct.intel8x0* %chip, i32 128, i8 zeroext %tmp205.1)
  br label %if.end250

if.end250:                                        ; preds = %if.end249, %if.end196
  %50 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms251 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %50, i32 0, i32 10
  %51 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms251, align 8, !tbaa !119
  %arrayidx252 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %51, i64 0
  %r253 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %arrayidx252, i32 0, i32 5
  %arrayidx254 = getelementptr inbounds [2 x %struct.anon.63], [2 x %struct.anon.63]* %r253, i64 0, i64 0
  %slots = getelementptr inbounds %struct.anon.63, %struct.anon.63* %arrayidx254, i32 0, i32 0
  %52 = load i16, i16* %slots, align 8, !tbaa !123
  %conv255 = zext i16 %52 to i32
  %and256 = and i32 %conv255, 128
  %tobool257 = icmp ne i32 %and256, 0
  br i1 %tobool257, label %if.then258, label %if.end284

if.then258:                                       ; preds = %if.end250
  %multi4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load259 = load i16, i16* %multi4, align 8
  %bf.clear260 = and i16 %bf.load259, -2
  %bf.set261 = or i16 %bf.clear260, 1
  store i16 %bf.set261, i16* %multi4, align 8
  %53 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms262 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %53, i32 0, i32 10
  %54 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms262, align 8, !tbaa !119
  %arrayidx263 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %54, i64 0
  %r264 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %arrayidx263, i32 0, i32 5
  %arrayidx265 = getelementptr inbounds [2 x %struct.anon.63], [2 x %struct.anon.63]* %r264, i64 0, i64 0
  %slots266 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %arrayidx265, i32 0, i32 0
  %55 = load i16, i16* %slots266, align 8, !tbaa !123
  %conv267 = zext i16 %55 to i32
  %and268 = and i32 %conv267, 512
  %tobool269 = icmp ne i32 %and268, 0
  br i1 %tobool269, label %if.then270, label %if.end284

if.then270:                                       ; preds = %if.then258
  %multi6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load271 = load i16, i16* %multi6, align 8
  %bf.clear272 = and i16 %bf.load271, -3
  %bf.set273 = or i16 %bf.clear272, 2
  store i16 %bf.set273, i16* %multi6, align 8
  %ac97274 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx275 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97274, i64 0, i64 0
  %56 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx275, align 8, !tbaa !6
  %flags = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %56, i32 0, i32 19
  %57 = load i32, i32* %flags, align 4, !tbaa !125
  %and276 = and i32 %57, 524288
  %tobool277 = icmp ne i32 %and276, 0
  br i1 %tobool277, label %if.then278, label %if.end284

if.then278:                                       ; preds = %if.then270
  %multi8 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load279 = load i16, i16* %multi8, align 8
  %bf.clear280 = and i16 %bf.load279, -5
  %bf.set281 = or i16 %bf.clear280, 4
  store i16 %bf.set281, i16* %multi8, align 8
  br label %if.end284

if.end284:                                        ; preds = %if.then278, %if.then270, %if.then258, %if.end250
  %58 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %pbus, align 8, !tbaa !6
  %pcms285 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %58, i32 0, i32 10
  %59 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcms285, align 8, !tbaa !119
  %arrayidx286 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %59, i64 0
  %r287 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %arrayidx286, i32 0, i32 5
  %arrayidx288 = getelementptr inbounds [2 x %struct.anon.63], [2 x %struct.anon.63]* %r287, i64 0, i64 1
  %rslots = getelementptr inbounds %struct.anon.63, %struct.anon.63* %arrayidx288, i32 0, i32 1
  %arrayidx289 = getelementptr inbounds [4 x i16], [4 x i16]* %rslots, i64 0, i64 0
  %60 = load i16, i16* %arrayidx289, align 2, !tbaa !126
  %tobool290 = icmp ne i16 %60, 0
  br i1 %tobool290, label %if.then291, label %if.end296

if.then291:                                       ; preds = %if.end284
  %dra292 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load293 = load i16, i16* %dra292, align 8
  %bf.clear294 = and i16 %bf.load293, -9
  %bf.set295 = or i16 %bf.clear294, 8
  store i16 %bf.set295, i16* %dra292, align 8
  br label %if.end296

if.end296:                                        ; preds = %if.then291, %if.end284
  %device_type297 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %61 = load i32, i32* %device_type297, align 8, !tbaa !68
  %cmp298 = icmp eq i32 %61, 1
  br i1 %cmp298, label %if.then300, label %if.end310

if.then300:                                       ; preds = %if.end296
  %call301 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and302 = and i32 %call301, 12582912
  %cmp303 = icmp eq i32 %and302, 4194304
  br i1 %cmp303, label %if.then305, label %if.end310

if.then305:                                       ; preds = %if.then300
  %smp20bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load306 = load i16, i16* %smp20bit, align 8
  %bf.clear307 = and i16 %bf.load306, -17
  %bf.set308 = or i16 %bf.clear307, 16
  store i16 %bf.set308, i16* %smp20bit, align 8
  br label %if.end310

if.end310:                                        ; preds = %if.then305, %if.then300, %if.end296
  %device_type311 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %62 = load i32, i32* %device_type311, align 8, !tbaa !68
  %cmp312 = icmp ne i32 %62, 4
  %63 = load i32, i32* @spdif_aclink, align 4
  %tobool315 = icmp ne i32 %63, 0
  %or.cond10 = or i1 %cmp312, %tobool315
  br i1 %or.cond10, label %if.end322, label %if.then316

if.then316:                                       ; preds = %if.end310
  %ichd317 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %spdif_idx318 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 10
  %64 = load i32, i32* %spdif_idx318, align 4, !tbaa !106
  %idxprom319 = sext i32 %64 to i64
  %arrayidx320 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd317, i64 0, i64 %idxprom319
  %pcm321 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx320, i32 0, i32 23
  %65 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm321, align 8, !tbaa !120
  %rates = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %65, i32 0, i32 4
  store i32 128, i32* %rates, align 8, !tbaa !127
  br label %if.end322

if.end322:                                        ; preds = %if.then316, %if.end310
  %device_type323 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %66 = load i32, i32* %device_type323, align 8, !tbaa !68
  %cmp324 = icmp ne i32 %66, 1
  %67 = load i32, i32* @spdif_aclink, align 4
  %tobool327 = icmp ne i32 %67, 0
  %or.cond11 = or i1 %cmp324, %tobool327
  br i1 %or.cond11, label %if.end335, label %if.then328

if.then328:                                       ; preds = %if.end322
  %call329 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and330 = and i32 %call329, 1073741823
  %or331 = or i32 %and330, -1073741824
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %or331)
  %ac97332 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx333 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97332, i64 0, i64 0
  %68 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx333, align 8, !tbaa !6
  %call334 = call i32 @snd_ac97_update_bits(%struct.snd_ac97* %68, i16 zeroext 42, i16 zeroext 48, i16 zeroext 48)
  br label %if.end335

if.end335:                                        ; preds = %if.then328, %if.end322
  %in_ac97_init336 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load337 = load i16, i16* %in_ac97_init336, align 8
  %bf.clear338 = and i16 %bf.load337, -33
  store i16 %bf.clear338, i16* %in_ac97_init336, align 8
  br label %cleanup346

__err:                                            ; preds = %if.end141, %if.end122, %if.end81
  %err.0 = phi i32 [ %call82, %if.end81 ], [ %call115, %if.end122 ], [ %call153, %if.end141 ]
  %device_type339 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %69 = load i32, i32* %device_type339, align 8, !tbaa !68
  %cmp340 = icmp ne i32 %69, 3
  br i1 %cmp340, label %if.then342, label %cleanup346

if.then342:                                       ; preds = %__err
  %call343 = call i32 @igetdword(%struct.intel8x0* %chip, i32 44)
  %and344 = and i32 %call343, -3
  call void @iputdword(%struct.intel8x0* %chip, i32 44, i32 %and344)
  br label %cleanup346

cleanup346:                                       ; preds = %if.then342, %__err, %if.end335
  %retval.0 = phi i32 [ 0, %if.end335 ], [ %err.0, %if.then342 ], [ %err.0, %__err ]
  %70 = bitcast %struct.snd_ac97_template* %ac97 to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %70) #7
  %71 = bitcast %struct.snd_ac97_bus** %pbus to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %71) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm(%struct.intel8x0* %chip) #2 {
entry:
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %0 = load i32, i32* %device_type, align 8, !tbaa !68
  %Pivot4 = icmp slt i32 %0, 3
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %0, 4
  br i1 %Pivot, label %sw.epilog, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %0, 4
  br i1 %SwitchLeaf2, label %sw.bb1, label %sw.epilog

LeafBlock:                                        ; preds = %entry
  %SwitchLeaf = icmp eq i32 %0, 1
  br i1 %SwitchLeaf, label %sw.bb, label %sw.epilog

sw.bb:                                            ; preds = %LeafBlock
  %1 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool = icmp ne i32 %1, 0
  %dec = add nsw i32 5, -1
  %dec. = select i1 %tobool, i32 %dec, i32 5
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %2 = load i32, i32* @spdif_aclink, align 4, !tbaa !2
  %tobool2 = icmp ne i32 %2, 0
  %dec4 = add nsw i32 3, -1
  %dec4. = select i1 %tobool2, i32 %dec4, i32 3
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %sw.bb, %LeafBlock, %LeafBlock1, %NodeBlock
  %tbl.0 = phi %struct.ich_pcm_table* [ getelementptr inbounds ([5 x %struct.ich_pcm_table], [5 x %struct.ich_pcm_table]* @intel_pcms, i32 0, i32 0), %sw.bb ], [ getelementptr inbounds ([3 x %struct.ich_pcm_table], [3 x %struct.ich_pcm_table]* @nforce_pcms, i32 0, i32 0), %sw.bb1 ], [ getelementptr inbounds ([3 x %struct.ich_pcm_table], [3 x %struct.ich_pcm_table]* @ali_pcms, i32 0, i32 0), %NodeBlock ], [ getelementptr inbounds ([5 x %struct.ich_pcm_table], [5 x %struct.ich_pcm_table]* @intel_pcms, i32 0, i32 0), %LeafBlock ], [ getelementptr inbounds ([5 x %struct.ich_pcm_table], [5 x %struct.ich_pcm_table]* @intel_pcms, i32 0, i32 0), %LeafBlock1 ]
  %tblsize.2 = phi i32 [ %dec., %sw.bb ], [ %dec4., %sw.bb1 ], [ 3, %NodeBlock ], [ 2, %LeafBlock ], [ 2, %LeafBlock1 ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %device.0 = phi i32 [ 0, %sw.epilog ], [ %device.1, %for.inc ]
  %i.0 = phi i32 [ 0, %sw.epilog ], [ %inc18, %for.inc ]
  %cmp = icmp slt i32 %i.0, %tblsize.2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idx.ext = sext i32 %i.0 to i64
  %add.ptr = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %tbl.0, i64 %idx.ext
  %cmp7 = icmp sgt i32 %i.0, 0
  br i1 %cmp7, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %for.body
  %ac97_idx = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %add.ptr, i32 0, i32 5
  %3 = load i32, i32* %ac97_idx, align 8, !tbaa !129
  %tobool8 = icmp ne i32 %3, 0
  br i1 %tobool8, label %if.then9, label %if.end14

if.then9:                                         ; preds = %land.lhs.true
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %ac97_idx10 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %add.ptr, i32 0, i32 5
  %4 = load i32, i32* %ac97_idx10, align 8, !tbaa !129
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 23
  %5 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !120
  %tobool11 = icmp ne %struct.ac97_pcm* %5, null
  br i1 %tobool11, label %if.end14, label %for.inc

if.end14:                                         ; preds = %if.then9, %land.lhs.true, %for.body
  %call = call i32 @snd_intel8x0_pcm1(%struct.intel8x0* %chip, i32 %device.0, %struct.ich_pcm_table* %add.ptr)
  %cmp15 = icmp slt i32 %call, 0
  br i1 %cmp15, label %cleanup, label %if.end17

if.end17:                                         ; preds = %if.end14
  %inc = add nsw i32 %device.0, 1
  br label %for.inc

for.inc:                                          ; preds = %if.end17, %if.then9
  %device.1 = phi i32 [ %inc, %if.end17 ], [ %device.0, %if.then9 ]
  %inc18 = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %pcm_devs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 6
  store i32 %device.0, i32* %pcm_devs, align 8, !tbaa !49
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.end14
  %retval.0 = phi i32 [ 0, %for.end ], [ %call, %if.end14 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_proc_init(%struct.intel8x0* %chip) #2 {
entry:
  %entry1 = alloca %struct.snd_info_entry*, align 8
  %0 = bitcast %struct.snd_info_entry** %entry1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %card = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %1 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !112
  %call = call i32 @snd_card_proc_new(%struct.snd_card* %1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.124, i32 0, i32 0), %struct.snd_info_entry** %entry1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry1, align 8, !tbaa !6
  %3 = bitcast %struct.intel8x0* %chip to i8*
  call void @snd_info_set_text_ops(%struct.snd_info_entry* %2, i8* %3, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_intel8x0_proc_read)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = bitcast %struct.snd_info_entry** %entry1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  ret void
}

declare i8* @snd_ac97_get_short_name(%struct.snd_ac97*) #1

declare i32 @snprintf(i8*, i64, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @intel8x0_in_clock_list(%struct.intel8x0* %chip) #2 {
entry:
  %pci1 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %0 = load %struct.pci_dev*, %struct.pci_dev** %pci1, align 8, !tbaa !94
  %call = call %struct.snd_pci_quirk* @snd_pci_quirk_lookup(%struct.pci_dev* %0, %struct.snd_pci_quirk* getelementptr inbounds ([6 x %struct.snd_pci_quirk], [6 x %struct.snd_pci_quirk]* @intel8x0_clock_list, i32 0, i32 0))
  %tobool = icmp ne %struct.snd_pci_quirk* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %subsystem_vendor = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %0, i32 0, i32 9
  %1 = load i16, i16* %subsystem_vendor, align 8, !tbaa !131
  %conv = zext i16 %1 to i32
  %subsystem_device = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %0, i32 0, i32 10
  %2 = load i16, i16* %subsystem_device, align 2, !tbaa !132
  %conv2 = zext i16 %2 to i32
  %value = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 3
  %3 = load i32, i32* %value, align 8, !tbaa !101
  %call3 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.137, i32 0, i32 0), i32 %conv, i32 %conv2, i32 %3)
  %value4 = getelementptr inbounds %struct.snd_pci_quirk, %struct.snd_pci_quirk* %call, i32 0, i32 3
  %4 = load i32, i32* %value4, align 8, !tbaa !101
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %5 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !116
  %clock = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %5, i32 0, i32 6
  store i32 %4, i32* %clock, align 4, !tbaa !115
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 1, %if.end ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @intel8x0_measure_ac97_clock(%struct.intel8x0* %chip) #2 {
entry:
  %start_time = alloca %struct.load_weight, align 8
  %stop_time = alloca %struct.load_weight, align 8
  %0 = bitcast %struct.load_weight* %start_time to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast %struct.load_weight* %stop_time to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %1) #7
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %2 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !116
  %clock = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %2, i32 0, i32 6
  %3 = load i32, i32* %clock, align 4, !tbaa !115
  %cmp = icmp ne i32 %3, 48000
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %__again

__again:                                          ; preds = %if.then104, %if.end
  %timeout.0 = phi i32 [ 1000, %if.end ], [ %timeout.2, %if.then104 ]
  %attempt.0 = phi i32 [ 1, %if.end ], [ %inc, %if.then104 ]
  %pcm = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 7
  %arrayidx = getelementptr inbounds [6 x %struct.snd_pcm*], [6 x %struct.snd_pcm*]* %pcm, i64 0, i64 0
  %4 = load %struct.snd_pcm*, %struct.snd_pcm** %arrayidx, align 8, !tbaa !6
  %streams = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %4, i32 0, i32 8
  %arrayidx1 = getelementptr inbounds [2 x %struct.snd_pcm_str], [2 x %struct.snd_pcm_str]* %streams, i64 0, i64 0
  %substream = getelementptr inbounds %struct.snd_pcm_str, %struct.snd_pcm_str* %arrayidx1, i32 0, i32 4
  %5 = load %struct.snd_pcm_substream*, %struct.snd_pcm_substream** %substream, align 8, !tbaa !133
  %tobool = icmp ne %struct.snd_pcm_substream* %5, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %__again
  %dma_buffer = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %5, i32 0, i32 8
  %bytes = getelementptr inbounds %struct.snd_dma_buffer, %struct.snd_dma_buffer* %dma_buffer, i32 0, i32 3
  %6 = load i64, i64* %bytes, align 8, !tbaa !136
  %cmp2 = icmp ult i64 %6, 32768
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %lor.lhs.false, %__again
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2783, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.142, i32 0, i32 0))
  br label %cleanup

if.end4:                                          ; preds = %lor.lhs.false
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %arrayidx5 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %dma_buffer6 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %5, i32 0, i32 8
  %addr = getelementptr inbounds %struct.snd_dma_buffer, %struct.snd_dma_buffer* %dma_buffer6, i32 0, i32 2
  %7 = load i64, i64* %addr, align 8, !tbaa !137
  %conv = trunc i64 %7 to i32
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 5
  store i32 %conv, i32* %physbuf, align 8, !tbaa !90
  %fragsize = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 7
  store i32 32768, i32* %fragsize, align 8, !tbaa !138
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 6
  store i32 32768, i32* %size, align 4, !tbaa !87
  %substream7 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream7, align 8, !tbaa !51
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx8 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 0
  %8 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx8, align 8, !tbaa !6
  %call = call i32 @snd_ac97_set_rate(%struct.snd_ac97* %8, i32 44, i32 48000)
  %cmp9 = icmp slt i32 %call, 0
  br i1 %cmp9, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end4
  %ac97_bus12 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %9 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus12, align 8, !tbaa !116
  %clock13 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %9, i32 0, i32 6
  %10 = load i32, i32* %clock13, align 4, !tbaa !115
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2793, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.143, i32 0, i32 0), i32 %10)
  br label %cleanup

if.end14:                                         ; preds = %if.end4
  call void @snd_intel8x0_setup_periods(%struct.intel8x0* %chip, %struct.ichdev* %arrayidx5)
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %11 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_lock_irq(%struct.spinlock* %reg_lock)
  %in_measurement = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_measurement, align 8
  %bf.clear = and i16 %bf.load, -129
  %bf.set = or i16 %bf.clear, 128
  store i16 %bf.set, i16* %in_measurement, align 8
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %12 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp15 = icmp ne i32 %12, 3
  %add = add i64 %11, 11
  %conv18 = trunc i64 %add to i32
  br i1 %cmp15, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end14
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv18, i8 zeroext 17)
  br label %if.end21

if.else:                                          ; preds = %if.end14
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv18, i8 zeroext 16)
  %ali_slot = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 22
  %13 = load i32, i32* %ali_slot, align 4, !tbaa !139
  %shl = shl i32 1, %13
  call void @iputdword(%struct.intel8x0* %chip, i32 8, i32 %shl)
  br label %if.end21

if.end21:                                         ; preds = %if.else, %if.then17
  call void @ktime_get_ts(%struct.load_weight* %start_time)
  %reg_lock22 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_unlock_irq(%struct.spinlock* %reg_lock22)
  call void @msleep(i32 50)
  %reg_lock23 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_lock_irq(%struct.spinlock* %reg_lock23)
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end21
  %timeout.1 = phi i32 [ %timeout.0, %if.end21 ], [ %dec, %do.cond ]
  %reg_offset24 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %14 = load i64, i64* %reg_offset24, align 8, !tbaa !71
  %add25 = add i64 %14, 4
  %conv26 = trunc i64 %add25 to i32
  %call27 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv26)
  %conv28 = zext i8 %call27 to i32
  %reg_offset29 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %15 = load i64, i64* %reg_offset29, align 8, !tbaa !71
  %roff_picb = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 20
  %16 = load i32, i32* %roff_picb, align 4, !tbaa !140
  %conv30 = zext i32 %16 to i64
  %add31 = add i64 %15, %conv30
  %conv32 = trunc i64 %add31 to i32
  %call33 = call zeroext i16 @igetword(%struct.intel8x0* %chip, i32 %conv32)
  %conv34 = zext i16 %call33 to i64
  %cmp35 = icmp eq i64 %conv34, 0
  br i1 %cmp35, label %if.then37, label %if.end38

if.then37:                                        ; preds = %do.body
  call void @__const_udelay(i64 42950)
  br label %do.cond

if.end38:                                         ; preds = %do.body
  %reg_offset39 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %17 = load i64, i64* %reg_offset39, align 8, !tbaa !71
  %add40 = add i64 %17, 4
  %conv41 = trunc i64 %add40 to i32
  %call42 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv41)
  %conv43 = zext i8 %call42 to i32
  %cmp44 = icmp eq i32 %conv28, %conv43
  br i1 %cmp44, label %land.lhs.true, label %do.cond

land.lhs.true:                                    ; preds = %if.end38
  %reg_offset46 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 1
  %18 = load i64, i64* %reg_offset46, align 8, !tbaa !71
  %roff_picb47 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 20
  %19 = load i32, i32* %roff_picb47, align 4, !tbaa !140
  %conv48 = zext i32 %19 to i64
  %add49 = add i64 %18, %conv48
  %conv50 = trunc i64 %add49 to i32
  %call51 = call zeroext i16 @igetword(%struct.intel8x0* %chip, i32 %conv50)
  %conv52 = zext i16 %call51 to i64
  %cmp53 = icmp eq i64 %conv34, %conv52
  br i1 %cmp53, label %do.end, label %do.cond

do.cond:                                          ; preds = %land.lhs.true, %if.end38, %if.then37
  %dec = add nsw i32 %timeout.1, -1
  %tobool57 = icmp ne i32 %timeout.1, 0
  br i1 %tobool57, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %land.lhs.true
  %timeout.2 = phi i32 [ %timeout.1, %land.lhs.true ], [ %dec, %do.cond ]
  %cmp58 = icmp eq i64 %conv34, 0
  br i1 %cmp58, label %if.end66, label %if.else61

if.else61:                                        ; preds = %do.end
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 8
  %20 = load i32, i32* %fragsize1, align 4, !tbaa !85
  %conv62 = zext i32 %20 to i64
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 10
  %21 = load i32, i32* %pos_shift, align 4, !tbaa !141
  %sh_prom = zext i32 %21 to i64
  %shl63 = shl i64 %conv34, %sh_prom
  %sub = sub i64 %conv62, %shl63
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 9
  %22 = load i32, i32* %position, align 8, !tbaa !86
  %conv64 = zext i32 %22 to i64
  %add65 = add i64 %sub, %conv64
  br label %if.end66

if.end66:                                         ; preds = %if.else61, %do.end
  %pos.0 = phi i64 [ %add65, %if.else61 ], [ 0, %do.end ]
  %in_measurement67 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load68 = load i16, i16* %in_measurement67, align 8
  %bf.clear69 = and i16 %bf.load68, -129
  store i16 %bf.clear69, i16* %in_measurement67, align 8
  call void @ktime_get_ts(%struct.load_weight* %stop_time)
  %device_type70 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %23 = load i32, i32* %device_type70, align 8, !tbaa !68
  %cmp71 = icmp eq i32 %23, 3
  br i1 %cmp71, label %if.then73, label %if.else83

if.then73:                                        ; preds = %if.end66
  %ali_slot74 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 22
  %24 = load i32, i32* %ali_slot74, align 4, !tbaa !139
  %add75 = add i32 %24, 16
  %shl76 = shl i32 1, %add75
  call void @iputdword(%struct.intel8x0* %chip, i32 8, i32 %shl76)
  %add77 = add i64 %11, 11
  %conv78 = trunc i64 %add77 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv78, i8 zeroext 0)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then73
  %add79 = add i64 %11, 11
  %conv80 = trunc i64 %add79 to i32
  %call81 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv80)
  %tobool82 = icmp ne i8 %call81, 0
  br i1 %tobool82, label %while.body, label %if.end95

while.body:                                       ; preds = %while.cond
  br label %while.cond

if.else83:                                        ; preds = %if.end66
  %add84 = add i64 %11, 11
  %conv85 = trunc i64 %add84 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv85, i8 zeroext 0)
  br label %while.cond86

while.cond86:                                     ; preds = %while.body93, %if.else83
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx5, i32 0, i32 19
  %25 = load i32, i32* %roff_sr, align 8, !tbaa !76
  %conv87 = zext i32 %25 to i64
  %add88 = add i64 %11, %conv87
  %conv89 = trunc i64 %add88 to i32
  %call90 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 %conv89)
  %conv91 = zext i8 %call90 to i32
  %and = and i32 %conv91, 1
  %tobool92 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool92, true
  br i1 %lnot, label %while.body93, label %if.end95

while.body93:                                     ; preds = %while.cond86
  br label %while.cond86

if.end95:                                         ; preds = %while.cond86, %while.cond
  %add96 = add i64 %11, 11
  %conv97 = trunc i64 %add96 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv97, i8 zeroext 2)
  %reg_lock98 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 20
  call void @spin_unlock_irq(%struct.spinlock* %reg_lock98)
  %cmp99 = icmp eq i64 %pos.0, 0
  br i1 %cmp99, label %if.then101, label %if.end106

if.then101:                                       ; preds = %if.end95
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2847, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.144, i32 0, i32 0))
  br label %__retry

__retry:                                          ; preds = %if.then129, %if.then116, %if.then101
  %cmp102 = icmp slt i32 %attempt.0, 3
  br i1 %cmp102, label %if.then104, label %__end

if.then104:                                       ; preds = %__retry
  call void @msleep(i32 300)
  %inc = add nsw i32 %attempt.0, 1
  br label %__again

if.end106:                                        ; preds = %if.end95
  %div = udiv i64 %pos.0, 4
  %tv_sec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %stop_time, i32 0, i32 0
  %26 = load i64, i64* %tv_sec, align 8, !tbaa !142
  %tv_sec107 = getelementptr inbounds %struct.load_weight, %struct.load_weight* %start_time, i32 0, i32 0
  %27 = load i64, i64* %tv_sec107, align 8, !tbaa !142
  %sub108 = sub nsw i64 %26, %27
  %mul = mul i64 %sub108, 1000000
  %tv_nsec = getelementptr inbounds %struct.load_weight, %struct.load_weight* %stop_time, i32 0, i32 1
  %28 = load i64, i64* %tv_nsec, align 8, !tbaa !143
  %tv_nsec109 = getelementptr inbounds %struct.load_weight, %struct.load_weight* %start_time, i32 0, i32 1
  %29 = load i64, i64* %tv_nsec109, align 8, !tbaa !143
  %sub110 = sub nsw i64 %28, %29
  %div111 = sdiv i64 %sub110, 1000
  %add112 = add i64 %mul, %div111
  %call113 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.145, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.intel8x0_measure_ac97_clock, i32 0, i32 0), i64 %add112, i64 %div)
  %cmp114 = icmp eq i64 %add112, 0
  br i1 %cmp114, label %if.then116, label %if.end117

if.then116:                                       ; preds = %if.end106
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 2863, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.146, i32 0, i32 0))
  br label %__retry

if.end117:                                        ; preds = %if.end106
  %mul118 = mul i64 %div, 1000
  %div119 = udiv i64 %mul118, %add112
  %mul120 = mul i64 %div119, 1000
  %rem = urem i64 %mul118, %add112
  %mul121 = mul i64 %rem, 1000
  %div122 = udiv i64 %mul121, %add112
  %add123 = add i64 %mul120, %div122
  %cmp124 = icmp ult i64 %add123, 40000
  %cmp127 = icmp uge i64 %add123, 60000
  %or.cond = or i1 %cmp124, %cmp127
  br i1 %or.cond, label %if.then129, label %if.else131

if.then129:                                       ; preds = %if.end117
  %call130 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.147, i32 0, i32 0), i64 %add123)
  br label %__retry

if.else131:                                       ; preds = %if.end117
  %cmp132 = icmp ugt i64 %add123, 40500
  %cmp135 = icmp ult i64 %add123, 41500
  %or.cond1 = and i1 %cmp132, %cmp135
  br i1 %or.cond1, label %if.then137, label %if.else140

if.then137:                                       ; preds = %if.else131
  %ac97_bus138 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %30 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus138, align 8, !tbaa !116
  %clock139 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %30, i32 0, i32 6
  store i32 41000, i32* %clock139, align 4, !tbaa !115
  br label %__end

if.else140:                                       ; preds = %if.else131
  %cmp141 = icmp ugt i64 %add123, 43600
  %cmp144 = icmp ult i64 %add123, 44600
  %or.cond2 = and i1 %cmp141, %cmp144
  br i1 %or.cond2, label %if.then146, label %if.else149

if.then146:                                       ; preds = %if.else140
  %ac97_bus147 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %31 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus147, align 8, !tbaa !116
  %clock148 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %31, i32 0, i32 6
  store i32 44100, i32* %clock148, align 4, !tbaa !115
  br label %__end

if.else149:                                       ; preds = %if.else140
  %cmp150 = icmp ult i64 %add123, 47500
  %cmp153 = icmp ugt i64 %add123, 48500
  %or.cond3 = or i1 %cmp150, %cmp153
  br i1 %or.cond3, label %if.then155, label %__end

if.then155:                                       ; preds = %if.else149
  %ac97_bus156 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %32 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus156, align 8, !tbaa !116
  %clock157 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %32, i32 0, i32 6
  %33 = load i32, i32* %clock157, align 4, !tbaa !115
  %mul158 = mul i32 %33, 48000
  %conv159 = zext i32 %mul158 to i64
  %div160 = udiv i64 %conv159, %add123
  %conv161 = trunc i64 %div160 to i32
  %ac97_bus162 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %34 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus162, align 8, !tbaa !116
  %clock163 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %34, i32 0, i32 6
  store i32 %conv161, i32* %clock163, align 4, !tbaa !115
  br label %__end

__end:                                            ; preds = %if.then155, %if.else149, %if.then146, %if.then137, %__retry
  %ac97_bus168 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 12
  %35 = load %struct.snd_ac97_bus*, %struct.snd_ac97_bus** %ac97_bus168, align 8, !tbaa !116
  %clock169 = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %35, i32 0, i32 6
  %36 = load i32, i32* %clock169, align 4, !tbaa !115
  %call170 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.148, i32 0, i32 0), i32 %36)
  %ac97171 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx172 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97171, i64 0, i64 0
  %37 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx172, align 8, !tbaa !6
  %call173 = call i32 @snd_ac97_update_power(%struct.snd_ac97* %37, i32 44, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %__end, %if.then11, %if.then3, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then3 ], [ 1, %if.then11 ], [ 0, %__end ], [ 1, %entry ]
  %38 = bitcast %struct.load_weight* %stop_time to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %38) #7
  %39 = bitcast %struct.load_weight* %start_time to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %39) #7
  ret void
}

declare i32 @snd_card_register(%struct.snd_card*) #1

declare i32 @snd_ac97_set_rate(%struct.snd_ac97*, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_setup_periods(%struct.intel8x0* %chip, %struct.ichdev* %ichdev) #2 {
entry:
  %bdbar1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 2
  %0 = load i32*, i32** %bdbar1, align 8, !tbaa !91
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 1
  %1 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %add = add i64 %1, 0
  %conv = trunc i64 %add to i32
  %bdbar_addr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 3
  %2 = load i32, i32* %bdbar_addr, align 8, !tbaa !73
  call void @iputdword(%struct.intel8x0* %chip, i32 %conv, i32 %2)
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %3 = load i32, i32* %size, align 4, !tbaa !87
  %fragsize = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %4 = load i32, i32* %fragsize, align 8, !tbaa !138
  %cmp = icmp eq i32 %3, %4
  %ack = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 2, i32* %ack, align 4, !tbaa !92
  %ack_reload = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 17
  store i32 2, i32* %ack_reload, align 8, !tbaa !93
  %fragsize3 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %5 = load i32, i32* %fragsize3, align 8, !tbaa !138
  %shr = lshr i32 %5, 1
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  store i32 %shr, i32* %fragsize1, align 4, !tbaa !85
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %idx.0 = phi i32 [ 0, %if.then ], [ %add26, %for.body ]
  %cmp4 = icmp slt i32 %idx.0, 64
  br i1 %cmp4, label %for.body, label %if.end

for.body:                                         ; preds = %for.cond
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %6 = load i32, i32* %physbuf, align 8, !tbaa !90
  %add6 = add nsw i32 %idx.0, 0
  %idxprom = sext i32 %add6 to i64
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %idxprom
  store i32 %6, i32* %arrayidx, align 4, !tbaa !2
  %fragsize17 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %7 = load i32, i32* %fragsize17, align 4, !tbaa !85
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 10
  %8 = load i32, i32* %pos_shift, align 4, !tbaa !141
  %shr8 = lshr i32 %7, %8
  %or = or i32 -2147483648, %shr8
  %add9 = add nsw i32 %idx.0, 1
  %idxprom10 = sext i32 %add9 to i64
  %arrayidx11 = getelementptr inbounds i32, i32* %0, i64 %idxprom10
  store i32 %or, i32* %arrayidx11, align 4, !tbaa !2
  %physbuf12 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %9 = load i32, i32* %physbuf12, align 8, !tbaa !90
  %size13 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %10 = load i32, i32* %size13, align 4, !tbaa !87
  %shr14 = lshr i32 %10, 1
  %add15 = add i32 %9, %shr14
  %add16 = add nsw i32 %idx.0, 2
  %idxprom17 = sext i32 %add16 to i64
  %arrayidx18 = getelementptr inbounds i32, i32* %0, i64 %idxprom17
  store i32 %add15, i32* %arrayidx18, align 4, !tbaa !2
  %fragsize119 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  %11 = load i32, i32* %fragsize119, align 4, !tbaa !85
  %pos_shift20 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 10
  %12 = load i32, i32* %pos_shift20, align 4, !tbaa !141
  %shr21 = lshr i32 %11, %12
  %or22 = or i32 -2147483648, %shr21
  %add23 = add nsw i32 %idx.0, 3
  %idxprom24 = sext i32 %add23 to i64
  %arrayidx25 = getelementptr inbounds i32, i32* %0, i64 %idxprom24
  store i32 %or22, i32* %arrayidx25, align 4, !tbaa !2
  %add26 = add nsw i32 %idx.0, 4
  br label %for.cond

if.else:                                          ; preds = %entry
  store i32 1, i32* %ack, align 4, !tbaa !92
  %ack_reload28 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 17
  store i32 1, i32* %ack_reload28, align 8, !tbaa !93
  %fragsize29 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %13 = load i32, i32* %fragsize29, align 8, !tbaa !138
  %fragsize130 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 8
  store i32 %13, i32* %fragsize130, align 4, !tbaa !85
  br label %for.cond31

for.cond31:                                       ; preds = %for.body34, %if.else
  %idx.1 = phi i32 [ 0, %if.else ], [ %add51, %for.body34 ]
  %cmp32 = icmp slt i32 %idx.1, 64
  br i1 %cmp32, label %for.body34, label %for.end52

for.body34:                                       ; preds = %for.cond31
  %physbuf35 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 5
  %14 = load i32, i32* %physbuf35, align 8, !tbaa !90
  %shr36 = ashr i32 %idx.1, 1
  %fragsize37 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %15 = load i32, i32* %fragsize37, align 8, !tbaa !138
  %mul = mul i32 %shr36, %15
  %size38 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %16 = load i32, i32* %size38, align 4, !tbaa !87
  %rem = urem i32 %mul, %16
  %add39 = add i32 %14, %rem
  %add40 = add nsw i32 %idx.1, 0
  %idxprom41 = sext i32 %add40 to i64
  %arrayidx42 = getelementptr inbounds i32, i32* %0, i64 %idxprom41
  store i32 %add39, i32* %arrayidx42, align 4, !tbaa !2
  %fragsize43 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %17 = load i32, i32* %fragsize43, align 8, !tbaa !138
  %pos_shift44 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 10
  %18 = load i32, i32* %pos_shift44, align 4, !tbaa !141
  %shr45 = lshr i32 %17, %18
  %or46 = or i32 -2147483648, %shr45
  %add47 = add nsw i32 %idx.1, 1
  %idxprom48 = sext i32 %add47 to i64
  %arrayidx49 = getelementptr inbounds i32, i32* %0, i64 %idxprom48
  store i32 %or46, i32* %arrayidx49, align 4, !tbaa !2
  %add51 = add nsw i32 %idx.1, 2
  br label %for.cond31

for.end52:                                        ; preds = %for.cond31
  %size53 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 6
  %19 = load i32, i32* %size53, align 4, !tbaa !87
  %fragsize54 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 7
  %20 = load i32, i32* %fragsize54, align 8, !tbaa !138
  %div = udiv i32 %19, %20
  br label %if.end

if.end:                                           ; preds = %for.end52, %for.cond
  %div.sink = phi i32 [ %div, %for.end52 ], [ 2, %for.cond ]
  %frags55 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 12
  store i32 %div.sink, i32* %frags55, align 4, !tbaa !89
  %add56 = add i64 %1, 5
  %conv57 = trunc i64 %add56 to i32
  %lvi = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 13
  store i32 31, i32* %lvi, align 8, !tbaa !74
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv57, i8 zeroext 31)
  %civ = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 15
  store i32 0, i32* %civ, align 8, !tbaa !75
  %add58 = add i64 %1, 4
  %conv59 = trunc i64 %add58 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv59, i8 zeroext 0)
  %frags60 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 12
  %21 = load i32, i32* %frags60, align 4, !tbaa !89
  %rem61 = srem i32 31, %21
  %lvi_frag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 14
  store i32 %rem61, i32* %lvi_frag, align 4, !tbaa !88
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 9
  store i32 0, i32* %position, align 8, !tbaa !86
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 19
  %22 = load i32, i32* %roff_sr, align 8, !tbaa !76
  %conv62 = zext i32 %22 to i64
  %add63 = add i64 %1, %conv62
  %conv64 = trunc i64 %add63 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv64, i8 zeroext 28)
  ret void
}

declare void @ktime_get_ts(%struct.load_weight*) #1

declare i32 @snd_ac97_update_power(%struct.snd_ac97*, i32, i32) #1

declare i32 @snd_card_proc_new(%struct.snd_card*, i8*, %struct.snd_info_entry**) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_proc_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 8
  %0 = load i8*, i8** %private_data, align 8, !tbaa !144
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.125, i32 0, i32 0))
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %2 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp = icmp eq i32 %2, 3
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i32 @igetdword(%struct.intel8x0* %1, i32 48)
  %call3 = call i32 @igetdword(%struct.intel8x0* %1, i32 44)
  %call4 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.126, i32 0, i32 0), i32 %call3)
  %call5 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.127, i32 0, i32 0), i32 %call2)
  %device_type6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %3 = load i32, i32* %device_type6, align 8, !tbaa !68
  %cmp7 = icmp eq i32 %3, 1
  br i1 %cmp7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %if.end
  %call9 = call i32 @igetdword(%struct.intel8x0* %1, i32 128)
  %call10 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.128, i32 0, i32 0), i32 %call9)
  br label %if.end11

if.end11:                                         ; preds = %if.then8, %if.end
  %call12 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.129, i32 0, i32 0))
  %codec_isr_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 18
  %4 = load i32, i32* %codec_isr_bits, align 8, !tbaa !96
  %and = and i32 %call2, %4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end11
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then13
  %i.0 = phi i32 [ 0, %if.then13 ], [ %inc, %for.inc ]
  %max_codecs = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 15
  %5 = load i32, i32* %max_codecs, align 4, !tbaa !111
  %cmp14 = icmp ult i32 %i.0, %5
  br i1 %cmp14, label %for.body, label %if.end23

for.body:                                         ; preds = %for.cond
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 17
  %6 = load i32*, i32** %codec_bit, align 8, !tbaa !97
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %6, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %and15 = and i32 %call2, %7
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %for.inc

if.then17:                                        ; preds = %for.body
  %idxprom18 = sext i32 %i.0 to i64
  %arrayidx19 = getelementptr inbounds [3 x i8*], [3 x i8*]* @snd_intel8x0_proc_read.codecs, i64 0, i64 %idxprom18
  %8 = load i8*, i8** %arrayidx19, align 8, !tbaa !6
  %call20 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.133, i32 0, i32 0), i8* %8)
  br label %for.inc

for.inc:                                          ; preds = %if.then17, %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.end11
  %call22 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.134, i32 0, i32 0))
  br label %if.end23

if.end23:                                         ; preds = %if.else, %for.cond
  %call24 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.135, i32 0, i32 0))
  %device_type25 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %9 = load i32, i32* %device_type25, align 8, !tbaa !68
  %cmp26 = icmp eq i32 %9, 1
  br i1 %cmp26, label %if.then29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end23
  %device_type27 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %10 = load i32, i32* %device_type27, align 8, !tbaa !68
  %cmp28 = icmp eq i32 %10, 2
  br i1 %cmp28, label %if.then29, label %cleanup.cont

if.then29:                                        ; preds = %lor.lhs.false, %if.end23
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 14
  %arrayidx30 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 0
  %11 = load i32, i32* %arrayidx30, align 8, !tbaa !2
  %ac97_sdin31 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 14
  %arrayidx32 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin31, i64 0, i64 1
  %12 = load i32, i32* %arrayidx32, align 4, !tbaa !2
  %ac97_sdin33 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 14
  %arrayidx34 = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin33, i64 0, i64 2
  %13 = load i32, i32* %arrayidx34, align 8, !tbaa !2
  %call35 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.136, i32 0, i32 0), i32 %11, i32 %12, i32 %13)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then29, %lor.lhs.false, %entry
  %cleanup.dest.slot.0 = phi i32 [ 1, %entry ], [ 0, %if.then29 ], [ 0, %lor.lhs.false ]
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @snd_info_set_text_ops(%struct.snd_info_entry* %entry1, i8* %private_data, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %read) #3 {
entry:
  %private_data2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 8
  store i8* %private_data, i8** %private_data2, align 8, !tbaa !144
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 4
  %text = bitcast %union.anon.49* %c to %struct.snd_info_entry_text*
  %read3 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read3, align 8, !tbaa !146
  ret void
}

declare i32 @snd_iprintf(%struct.snd_info_buffer*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm1(%struct.intel8x0* %chip, i32 %device, %struct.ich_pcm_table* %rec) #2 {
entry:
  %pcm = alloca %struct.snd_pcm*, align 8
  %name = alloca [32 x i8], align 16
  %chmap = alloca %struct.snd_pcm_chmap*, align 8
  %0 = bitcast %struct.snd_pcm** %pcm to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast [32 x i8]* %name to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %1) #7
  %suffix = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 0
  %2 = load i8*, i8** %suffix, align 8, !tbaa !147
  %tobool = icmp ne i8* %2, null
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %suffix1 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 0
  %3 = load i8*, i8** %suffix1, align 8, !tbaa !147
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.122, i32 0, i32 0), i8* %3)
  br label %if.end

if.else:                                          ; preds = %entry
  %call3 = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.5, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %card = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %4 = load %struct.snd_card*, %struct.snd_card** %card, align 8, !tbaa !112
  %arraydecay4 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %playback_ops = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %5 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops, align 8, !tbaa !148
  %tobool5 = icmp ne %struct.snd_pcm_ops* %5, null
  %6 = zext i1 %tobool5 to i64
  %cond = select i1 %tobool5, i32 1, i32 0
  %capture_ops = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 2
  %7 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %capture_ops, align 8, !tbaa !149
  %tobool6 = icmp ne %struct.snd_pcm_ops* %7, null
  %8 = zext i1 %tobool6 to i64
  %cond7 = select i1 %tobool6, i32 1, i32 0
  %call8 = call i32 @snd_pcm_new(%struct.snd_card* %4, i8* %arraydecay4, i32 %device, i32 %cond, i32 %cond7, %struct.snd_pcm** %pcm)
  %cmp = icmp slt i32 %call8, 0
  br i1 %cmp, label %cleanup74, label %if.end10

if.end10:                                         ; preds = %if.end
  %playback_ops11 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %9 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops11, align 8, !tbaa !148
  %tobool12 = icmp ne %struct.snd_pcm_ops* %9, null
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end10
  %10 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %playback_ops14 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %11 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops14, align 8, !tbaa !148
  call void @snd_pcm_set_ops(%struct.snd_pcm* %10, i32 0, %struct.snd_pcm_ops* %11)
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end10
  %capture_ops16 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 2
  %12 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %capture_ops16, align 8, !tbaa !149
  %tobool17 = icmp ne %struct.snd_pcm_ops* %12, null
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end15
  %13 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %capture_ops19 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 2
  %14 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %capture_ops19, align 8, !tbaa !149
  call void @snd_pcm_set_ops(%struct.snd_pcm* %13, i32 1, %struct.snd_pcm_ops* %14)
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end15
  %15 = bitcast %struct.intel8x0* %chip to i8*
  %16 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %private_data = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %16, i32 0, i32 11
  store i8* %15, i8** %private_data, align 8, !tbaa !150
  %17 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %info_flags = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %17, i32 0, i32 3
  store i32 0, i32* %info_flags, align 4, !tbaa !153
  %suffix21 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 0
  %18 = load i8*, i8** %suffix21, align 8, !tbaa !147
  %tobool22 = icmp ne i8* %18, null
  %19 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %name24 = getelementptr inbounds %struct.snd_pcm, %struct.snd_pcm* %19, i32 0, i32 7
  %arraydecay25 = getelementptr inbounds [80 x i8], [80 x i8]* %name24, i32 0, i32 0
  %card26 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 5
  %20 = load %struct.snd_card*, %struct.snd_card** %card26, align 8, !tbaa !112
  %shortname = getelementptr inbounds %struct.snd_card, %struct.snd_card* %20, i32 0, i32 3
  %arraydecay27 = getelementptr inbounds [32 x i8], [32 x i8]* %shortname, i32 0, i32 0
  br i1 %tobool22, label %if.then23, label %if.else30

if.then23:                                        ; preds = %if.end20
  %suffix28 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 0
  %21 = load i8*, i8** %suffix28, align 8, !tbaa !147
  %call29 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay25, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.123, i32 0, i32 0), i8* %arraydecay27, i8* %21)
  br label %if.end37

if.else30:                                        ; preds = %if.end20
  %call36 = call i8* @strcpy(i8* %arraydecay25, i8* %arraydecay27)
  br label %if.end37

if.end37:                                         ; preds = %if.else30, %if.then23
  %22 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %pcm38 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 7
  %idxprom = sext i32 %device to i64
  %arrayidx = getelementptr inbounds [6 x %struct.snd_pcm*], [6 x %struct.snd_pcm*]* %pcm38, i64 0, i64 %idxprom
  store %struct.snd_pcm* %22, %struct.snd_pcm** %arrayidx, align 8, !tbaa !6
  %23 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %24 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !94
  %dev = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %24, i32 0, i32 34
  %25 = bitcast %struct.device* %dev to i8*
  %prealloc_size = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 3
  %26 = load i64, i64* %prealloc_size, align 8, !tbaa !154
  %prealloc_max_size = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 4
  %27 = load i64, i64* %prealloc_max_size, align 8, !tbaa !155
  %call39 = call i32 @snd_pcm_lib_preallocate_pages_for_all(%struct.snd_pcm* %23, i32 2, i8* %25, i64 %26, i64 %27)
  %ac97_idx = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 5
  %28 = load i32, i32* %ac97_idx, align 8, !tbaa !129
  %cmp40 = icmp eq i32 %28, 1
  br i1 %cmp40, label %land.lhs.true, label %cleanup74

land.lhs.true:                                    ; preds = %if.end37
  %playback_ops41 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 1
  %29 = load %struct.snd_pcm_ops*, %struct.snd_pcm_ops** %playback_ops41, align 8, !tbaa !148
  %tobool42 = icmp ne %struct.snd_pcm_ops* %29, null
  br i1 %tobool42, label %if.then43, label %cleanup74

if.then43:                                        ; preds = %land.lhs.true
  %30 = bitcast %struct.snd_pcm_chmap** %chmap to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %30) #7
  %ac97_idx44 = getelementptr inbounds %struct.ich_pcm_table, %struct.ich_pcm_table* %rec, i32 0, i32 5
  %31 = load i32, i32* %ac97_idx44, align 8, !tbaa !129
  %cmp45 = icmp eq i32 %31, 1
  br i1 %cmp45, label %if.then46, label %if.end65

if.then46:                                        ; preds = %if.then43
  %multi8 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %multi8, align 8
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool47 = icmp ne i32 %bf.cast, 0
  br i1 %tobool47, label %if.end65, label %if.else49

if.else49:                                        ; preds = %if.then46
  %multi6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load50 = load i16, i16* %multi6, align 8
  %bf.lshr51 = lshr i16 %bf.load50, 1
  %bf.clear52 = and i16 %bf.lshr51, 1
  %bf.cast53 = zext i16 %bf.clear52 to i32
  %tobool54 = icmp ne i32 %bf.cast53, 0
  br i1 %tobool54, label %if.end65, label %if.else56

if.else56:                                        ; preds = %if.else49
  %multi4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load57 = load i16, i16* %multi4, align 8
  %bf.clear58 = and i16 %bf.load57, 1
  %bf.cast59 = zext i16 %bf.clear58 to i32
  %tobool60 = icmp ne i32 %bf.cast59, 0
  %. = select i1 %tobool60, i32 4, i32 2
  br label %if.end65

if.end65:                                         ; preds = %if.else56, %if.else49, %if.then46, %if.then43
  %chs.3 = phi i32 [ 2, %if.then43 ], [ 8, %if.then46 ], [ %., %if.else56 ], [ 6, %if.else49 ]
  %32 = load %struct.snd_pcm*, %struct.snd_pcm** %pcm, align 8, !tbaa !6
  %call66 = call i32 @snd_pcm_add_chmap_ctls(%struct.snd_pcm* %32, i32 0, %struct.snd_pcm_chmap_elem* getelementptr inbounds ([0 x %struct.snd_pcm_chmap_elem], [0 x %struct.snd_pcm_chmap_elem]* @snd_pcm_alt_chmaps, i32 0, i32 0), i32 %chs.3, i64 0, %struct.snd_pcm_chmap** %chmap)
  %cmp67 = icmp slt i32 %call66, 0
  br i1 %cmp67, label %cleanup, label %if.end69

if.end69:                                         ; preds = %if.end65
  %33 = load %struct.snd_pcm_chmap*, %struct.snd_pcm_chmap** %chmap, align 8, !tbaa !6
  %channel_mask = getelementptr inbounds %struct.snd_pcm_chmap, %struct.snd_pcm_chmap* %33, i32 0, i32 5
  store i32 340, i32* %channel_mask, align 4, !tbaa !156
  %34 = load %struct.snd_pcm_chmap*, %struct.snd_pcm_chmap** %chmap, align 8, !tbaa !6
  %ac97 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 13
  %arrayidx70 = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac97, i64 0, i64 0
  %35 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx70, align 8, !tbaa !6
  %chmaps = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %35, i32 0, i32 30
  %arrayidx71 = getelementptr inbounds [2 x %struct.snd_pcm_chmap*], [2 x %struct.snd_pcm_chmap*]* %chmaps, i64 0, i64 0
  store %struct.snd_pcm_chmap* %34, %struct.snd_pcm_chmap** %arrayidx71, align 8, !tbaa !6
  br label %cleanup

cleanup:                                          ; preds = %if.end69, %if.end65
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end69 ], [ 1, %if.end65 ]
  %36 = bitcast %struct.snd_pcm_chmap** %chmap to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %36) #7
  %SwitchLeaf = icmp eq i32 %cleanup.dest.slot.0, 0
  %.call66 = select i1 %SwitchLeaf, i32 0, i32 %call66
  br label %cleanup74

cleanup74:                                        ; preds = %cleanup, %land.lhs.true, %if.end37, %if.end
  %retval.1 = phi i32 [ %call8, %if.end ], [ 0, %land.lhs.true ], [ 0, %if.end37 ], [ %.call66, %cleanup ]
  %37 = bitcast [32 x i8]* %name to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %37) #7
  %38 = bitcast %struct.snd_pcm** %pcm to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %38) #7
  ret i32 %retval.1
}

declare i32 @sprintf(i8*, i8*, ...) #1

declare i32 @snd_pcm_new(%struct.snd_card*, i8*, i32, i32, i32, %struct.snd_pcm**) #1

declare void @snd_pcm_set_ops(%struct.snd_pcm*, i32, %struct.snd_pcm_ops*) #1

declare i32 @snd_pcm_lib_preallocate_pages_for_all(%struct.snd_pcm*, i32, i8*, i64, i64) #1

declare i32 @snd_pcm_add_chmap_ctls(%struct.snd_pcm*, i32, %struct.snd_pcm_chmap_elem*, i32, i64, %struct.snd_pcm_chmap**) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_ac97spdifout_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  call void @spin_lock_irq(%struct.spinlock* %reg_lock)
  %call = call i32 @igetdword(%struct.intel8x0* %1, i32 16)
  %or = or i32 %call, 2097152
  call void @iputdword(%struct.intel8x0* %1, i32 16, i32 %or)
  %reg_lock1 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  call void @spin_unlock_irq(%struct.spinlock* %reg_lock1)
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %call2 = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call2
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_ac97spdifout_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !51
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  call void @spin_lock_irq(%struct.spinlock* %reg_lock)
  %call = call i32 @igetdword(%struct.intel8x0* %1, i32 16)
  %and = and i32 %call, -2097153
  call void @iputdword(%struct.intel8x0* %1, i32 16, i32 %and)
  %reg_lock2 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  call void @spin_unlock_irq(%struct.spinlock* %reg_lock2)
  ret i32 0
}

declare i32 @snd_pcm_lib_ioctl(%struct.snd_pcm_substream*, i32, i8*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_hw_params(%struct.snd_pcm_substream* %substream, %struct.snd_pcm_hw_params* %hw_params) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !53
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 42
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !159
  %4 = bitcast i8* %3 to %struct.ichdev*
  %runtime3 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %5 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime3, align 8, !tbaa !53
  %call = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %hw_params, i32 11)
  %min = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call, i32 0, i32 0
  %6 = load i32, i32* %min, align 4, !tbaa !160
  %cmp = icmp ugt i32 %6, 48000
  %conv = zext i1 %cmp to i32
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load4 = load i8, i8* %page_attr_changed, align 4
  %bf.clear5 = and i8 %bf.load4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %tobool7 = icmp ne i32 %bf.cast6, 0
  br i1 %tobool7, label %do.end, label %if.end

do.end:                                           ; preds = %land.lhs.true
  %page_attr_changed8 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load9 = load i8, i8* %page_attr_changed8, align 4
  %bf.clear10 = and i8 %bf.load9, -2
  store i8 %bf.clear10, i8* %page_attr_changed8, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %land.lhs.true, %entry
  %call11 = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %hw_params, i32 18)
  %min12 = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call11, i32 0, i32 0
  %7 = load i32, i32* %min12, align 4, !tbaa !160
  %conv13 = zext i32 %7 to i64
  %call14 = call i32 @snd_pcm_lib_malloc_pages(%struct.snd_pcm_substream* %substream, i64 %conv13)
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %fix_nocache19 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load20 = load i16, i16* %fix_nocache19, align 8
  %bf.lshr21 = lshr i16 %bf.load20, 8
  %bf.clear22 = and i16 %bf.lshr21, 1
  %bf.cast23 = zext i16 %bf.clear22 to i32
  %tobool24 = icmp ne i32 %bf.cast23, 0
  br i1 %tobool24, label %if.then25, label %if.end41

if.then25:                                        ; preds = %if.end18
  %dma_area = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %5, i32 0, i32 50
  %8 = load i8*, i8** %dma_area, align 8, !tbaa !61
  %tobool26 = icmp ne i8* %8, null
  br i1 %tobool26, label %land.lhs.true27, label %if.end41

land.lhs.true27:                                  ; preds = %if.then25
  %page_attr_changed28 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load29 = load i8, i8* %page_attr_changed28, align 4
  %bf.clear30 = and i8 %bf.load29, 1
  %bf.cast31 = zext i8 %bf.clear30 to i32
  %tobool32 = icmp ne i32 %bf.cast31, 0
  br i1 %tobool32, label %if.end41, label %do.end36

do.end36:                                         ; preds = %land.lhs.true27
  %page_attr_changed37 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load38 = load i8, i8* %page_attr_changed37, align 4
  %bf.clear39 = and i8 %bf.load38, -2
  %bf.set = or i8 %bf.clear39, 1
  store i8 %bf.set, i8* %page_attr_changed37, align 4
  br label %if.end41

if.end41:                                         ; preds = %do.end36, %land.lhs.true27, %if.then25, %if.end18
  %pcm_open_flag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  %9 = load i32, i32* %pcm_open_flag, align 8, !tbaa !162
  %tobool42 = icmp ne i32 %9, 0
  br i1 %tobool42, label %if.then43, label %if.end46

if.then43:                                        ; preds = %if.end41
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %10 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !120
  %call44 = call i32 @snd_ac97_pcm_close(%struct.ac97_pcm* %10)
  %pcm_open_flag45 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  store i32 0, i32* %pcm_open_flag45, align 8, !tbaa !162
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %if.end41
  %pcm47 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %11 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm47, align 8, !tbaa !120
  %call48 = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %hw_params, i32 11)
  %min49 = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call48, i32 0, i32 0
  %12 = load i32, i32* %min49, align 4, !tbaa !160
  %call50 = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %hw_params, i32 10)
  %min51 = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call50, i32 0, i32 0
  %13 = load i32, i32* %min51, align 4, !tbaa !160
  %pcm52 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %14 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm52, align 8, !tbaa !120
  %r = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %14, i32 0, i32 5
  %idxprom = sext i32 %conv to i64
  %arrayidx = getelementptr inbounds [2 x %struct.anon.63], [2 x %struct.anon.63]* %r, i64 0, i64 %idxprom
  %slots = getelementptr inbounds %struct.anon.63, %struct.anon.63* %arrayidx, i32 0, i32 0
  %15 = load i16, i16* %slots, align 8, !tbaa !123
  %call53 = call i32 @snd_ac97_pcm_open(%struct.ac97_pcm* %11, i32 %12, i32 %13, i16 zeroext %15)
  %cmp54 = icmp sge i32 %call53, 0
  br i1 %cmp54, label %if.then56, label %cleanup

if.then56:                                        ; preds = %if.end46
  %pcm_open_flag57 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  store i32 1, i32* %pcm_open_flag57, align 8, !tbaa !162
  %ichd = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 0
  %16 = load i32, i32* %ichd, align 8, !tbaa !72
  %cmp58 = icmp eq i32 %16, 1
  br i1 %cmp58, label %land.lhs.true60, label %cleanup

land.lhs.true60:                                  ; preds = %if.then56
  %spdif_idx = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 10
  %17 = load i32, i32* %spdif_idx, align 4, !tbaa !106
  %cmp61 = icmp slt i32 %17, 0
  br i1 %cmp61, label %if.then63, label %cleanup

if.then63:                                        ; preds = %land.lhs.true60
  %pcm64 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %18 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm64, align 8, !tbaa !120
  %r65 = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %18, i32 0, i32 5
  %arrayidx66 = getelementptr inbounds [2 x %struct.anon.63], [2 x %struct.anon.63]* %r65, i64 0, i64 0
  %codec = getelementptr inbounds %struct.anon.63, %struct.anon.63* %arrayidx66, i32 0, i32 3
  %arrayidx67 = getelementptr inbounds [4 x %struct.snd_ac97*], [4 x %struct.snd_ac97*]* %codec, i64 0, i64 0
  %19 = load %struct.snd_ac97*, %struct.snd_ac97** %arrayidx67, align 8, !tbaa !6
  %call68 = call %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %hw_params, i32 11)
  %min69 = getelementptr inbounds %struct.snd_interval, %struct.snd_interval* %call68, i32 0, i32 0
  %20 = load i32, i32* %min69, align 4, !tbaa !160
  %call70 = call i32 @snd_ac97_set_rate(%struct.snd_ac97* %19, i32 58, i32 %20)
  br label %cleanup

cleanup:                                          ; preds = %if.then63, %land.lhs.true60, %if.then56, %if.end46, %if.end
  %retval.0 = phi i32 [ %call14, %if.end ], [ %call53, %if.then56 ], [ %call53, %land.lhs.true60 ], [ %call53, %if.then63 ], [ %call53, %if.end46 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_hw_free(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !53
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 42
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !159
  %4 = bitcast i8* %3 to %struct.ichdev*
  %pcm_open_flag = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  %5 = load i32, i32* %pcm_open_flag, align 8, !tbaa !162
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 23
  %6 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !120
  %call = call i32 @snd_ac97_pcm_close(%struct.ac97_pcm* %6)
  %pcm_open_flag2 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 24
  store i32 0, i32* %pcm_open_flag2, align 8, !tbaa !162
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool3 = icmp ne i32 %bf.cast, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.end
  %page_attr_changed = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load4 = load i8, i8* %page_attr_changed, align 4
  %bf.clear5 = and i8 %bf.load4, 1
  %bf.cast6 = zext i8 %bf.clear5 to i32
  %tobool7 = icmp ne i32 %bf.cast6, 0
  br i1 %tobool7, label %do.end, label %if.end12

do.end:                                           ; preds = %land.lhs.true
  %page_attr_changed9 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load10 = load i8, i8* %page_attr_changed9, align 4
  %bf.clear11 = and i8 %bf.load10, -2
  store i8 %bf.clear11, i8* %page_attr_changed9, align 4
  br label %if.end12

if.end12:                                         ; preds = %do.end, %land.lhs.true, %if.end
  %call13 = call i32 @snd_pcm_lib_free_pages(%struct.snd_pcm_substream* %substream)
  ret i32 %call13
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm_prepare(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !53
  %runtime2 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %3 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime2, align 8, !tbaa !53
  %private_data3 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %3, i32 0, i32 42
  %4 = load i8*, i8** %private_data3, align 8, !tbaa !159
  %5 = bitcast i8* %4 to %struct.ichdev*
  %dma_addr = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 51
  %6 = load i64, i64* %dma_addr, align 8, !tbaa !163
  %conv = trunc i64 %6 to i32
  %physbuf = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 5
  store i32 %conv, i32* %physbuf, align 8, !tbaa !90
  %call = call i64 @snd_pcm_lib_buffer_bytes(%struct.snd_pcm_substream* %substream)
  %conv4 = trunc i64 %call to i32
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 6
  store i32 %conv4, i32* %size, align 4, !tbaa !87
  %call5 = call i64 @snd_pcm_lib_period_bytes(%struct.snd_pcm_substream* %substream)
  %conv6 = trunc i64 %call5 to i32
  %fragsize = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 7
  store i32 %conv6, i32* %fragsize, align 8, !tbaa !138
  %ichd = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 0
  %7 = load i32, i32* %ichd, align 8, !tbaa !72
  %cmp = icmp eq i32 %7, 1
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  call void @snd_intel8x0_setup_pcm_out(%struct.intel8x0* %1, %struct.snd_pcm_runtime* %2)
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %8 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp8 = icmp eq i32 %8, 1
  br i1 %cmp8, label %if.then10, label %if.end13

if.then10:                                        ; preds = %if.then
  %sample_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 21
  %9 = load i32, i32* %sample_bits, align 4, !tbaa !83
  %cmp11 = icmp ugt i32 %9, 16
  %10 = zext i1 %cmp11 to i64
  %cond = select i1 %cmp11, i32 2, i32 1
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %5, i32 0, i32 10
  store i32 %cond, i32* %pos_shift, align 4, !tbaa !141
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %if.then, %entry
  call void @snd_intel8x0_setup_periods(%struct.intel8x0* %1, %struct.ichdev* %5)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_trigger(%struct.snd_pcm_substream* %substream, i32 %cmd) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !53
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 42
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !159
  %4 = bitcast i8* %3 to %struct.ichdev*
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %5 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %call = call i32 @igetdword(%struct.intel8x0* %1, i32 8)
  %Pivot12 = icmp slt i32 %cmd, 4
  br i1 %Pivot12, label %NodeBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %cmd, 5
  br i1 %Pivot10, label %sw.bb2, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, 6
  br i1 %Pivot8, label %sw.bb20, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, 6
  br i1 %SwitchLeaf6, label %sw.bb, label %cleanup

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %cmd, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, 3
  br i1 %Pivot, label %LeafBlock1, label %sw.bb24

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 1
  br i1 %SwitchLeaf2, label %sw.bb2, label %cleanup

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, 0
  br i1 %SwitchLeaf, label %sw.bb24, label %cleanup

sw.bb:                                            ; preds = %LeafBlock5
  %suspended = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load = load i8, i8* %suspended, align 4
  %bf.clear = and i8 %bf.load, -3
  store i8 %bf.clear, i8* %suspended, align 4
  br label %sw.bb2

sw.bb2:                                           ; preds = %sw.bb, %LeafBlock1, %NodeBlock9
  %stream = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 5
  %6 = load i32, i32* %stream, align 4, !tbaa !164
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb2
  %ali_slot = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %7 = load i32, i32* %ali_slot, align 4, !tbaa !139
  %div = udiv i32 %7, 4
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds [3 x i32], [3 x i32]* @snd_intel8x0_ali_trigger.fiforeg, i64 0, i64 %idxprom
  %8 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %call3 = call i32 @igetdword(%struct.intel8x0* %1, i32 %8)
  %ali_slot4 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %9 = load i32, i32* %ali_slot4, align 4, !tbaa !139
  %rem = urem i32 %9, 4
  %shl = shl i32 255, %rem
  %neg = xor i32 %shl, -1
  %and = and i32 %call3, %neg
  %ali_slot5 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %10 = load i32, i32* %ali_slot5, align 4, !tbaa !139
  %rem6 = urem i32 %10, 4
  %shl7 = shl i32 131, %rem6
  %or = or i32 %and, %shl7
  %ali_slot8 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %11 = load i32, i32* %ali_slot8, align 4, !tbaa !139
  %div9 = udiv i32 %11, 4
  %idxprom10 = zext i32 %div9 to i64
  %arrayidx11 = getelementptr inbounds [3 x i32], [3 x i32]* @snd_intel8x0_ali_trigger.fiforeg, i64 0, i64 %idxprom10
  %12 = load i32, i32* %arrayidx11, align 4, !tbaa !2
  call void @iputdword(%struct.intel8x0* %1, i32 %12, i32 %or)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb2
  %add = add i64 %5, 11
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv, i8 zeroext 16)
  %ali_slot12 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %13 = load i32, i32* %ali_slot12, align 4, !tbaa !139
  %add13 = add i32 %13, 16
  %shl14 = shl i32 1, %add13
  %neg15 = xor i32 %shl14, -1
  %and16 = and i32 %call, %neg15
  %ali_slot17 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %14 = load i32, i32* %ali_slot17, align 4, !tbaa !139
  %shl18 = shl i32 1, %14
  %or19 = or i32 %and16, %shl18
  call void @iputdword(%struct.intel8x0* %1, i32 8, i32 %or19)
  br label %cleanup

sw.bb20:                                          ; preds = %NodeBlock7
  %suspended21 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load22 = load i8, i8* %suspended21, align 4
  %bf.clear23 = and i8 %bf.load22, -3
  %bf.set = or i8 %bf.clear23, 2
  store i8 %bf.set, i8* %suspended21, align 4
  br label %sw.bb24

sw.bb24:                                          ; preds = %sw.bb20, %LeafBlock, %NodeBlock
  %ali_slot25 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 22
  %15 = load i32, i32* %ali_slot25, align 4, !tbaa !139
  %add26 = add i32 %15, 16
  %shl27 = shl i32 1, %add26
  %or28 = or i32 %call, %shl27
  call void @iputdword(%struct.intel8x0* %1, i32 8, i32 %or28)
  %add29 = add i64 %5, 11
  %conv30 = trunc i64 %add29 to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv30, i8 zeroext 0)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb24
  %add31 = add i64 %5, 11
  %conv32 = trunc i64 %add31 to i32
  %call33 = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv32)
  %tobool = icmp ne i8 %call33, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %cmp34 = icmp eq i32 %cmd, 3
  br i1 %cmp34, label %cleanup, label %if.end37

if.end37:                                         ; preds = %while.end
  %add38 = add i64 %5, 11
  %conv39 = trunc i64 %add38 to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv39, i8 zeroext 2)
  %add40 = add i64 %5, 6
  %conv41 = trunc i64 %add40 to i32
  %add42 = add i64 %5, 6
  %conv43 = trunc i64 %add42 to i32
  %call44 = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv43)
  %conv45 = zext i8 %call44 to i32
  %or46 = or i32 %conv45, 30
  %conv47 = trunc i32 %or46 to i8
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv41, i8 zeroext %conv47)
  %call48 = call i32 @igetdword(%struct.intel8x0* %1, i32 24)
  %int_sta_mask = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 21
  %16 = load i32, i32* %int_sta_mask, align 8, !tbaa !79
  %and49 = and i32 %call48, %16
  call void @iputdword(%struct.intel8x0* %1, i32 24, i32 %and49)
  br label %cleanup

cleanup:                                          ; preds = %if.end37, %while.end, %if.end, %LeafBlock, %LeafBlock1, %LeafBlock5
  %retval.0 = phi i32 [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock5 ], [ 0, %while.end ], [ 0, %if.end37 ], [ 0, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_intel8x0_pcm_pointer(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !53
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 42
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !159
  %4 = bitcast i8* %3 to %struct.ichdev*
  %reg_lock = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  call void @spin_lock(%struct.spinlock* %reg_lock)
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %timeout.0 = phi i32 [ 10, %entry ], [ %dec, %do.cond ]
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %5 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %add = add i64 %5, 4
  %conv = trunc i64 %add to i32
  %call = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv)
  %conv2 = zext i8 %call to i32
  %reg_offset3 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %6 = load i64, i64* %reg_offset3, align 8, !tbaa !71
  %roff_picb = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 20
  %7 = load i32, i32* %roff_picb, align 4, !tbaa !140
  %conv4 = zext i32 %7 to i64
  %add5 = add i64 %6, %conv4
  %conv6 = trunc i64 %add5 to i32
  %call7 = call zeroext i16 @igetword(%struct.intel8x0* %1, i32 %conv6)
  %conv8 = zext i16 %call7 to i64
  %position9 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 9
  %8 = load i32, i32* %position9, align 8, !tbaa !86
  %cmp = icmp eq i64 %conv8, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  call void @__const_udelay(i64 42950)
  br label %do.cond

if.end:                                           ; preds = %do.body
  %reg_offset11 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %9 = load i64, i64* %reg_offset11, align 8, !tbaa !71
  %add12 = add i64 %9, 4
  %conv13 = trunc i64 %add12 to i32
  %call14 = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv13)
  %conv15 = zext i8 %call14 to i32
  %cmp16 = icmp ne i32 %conv2, %conv15
  br i1 %cmp16, label %do.cond, label %if.end19

if.end19:                                         ; preds = %if.end
  %inside_vm = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %inside_vm, align 8
  %bf.lshr = lshr i16 %bf.load, 12
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %do.end, label %if.end21

if.end21:                                         ; preds = %if.end19
  %reg_offset22 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %10 = load i64, i64* %reg_offset22, align 8, !tbaa !71
  %roff_picb23 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 20
  %11 = load i32, i32* %roff_picb23, align 4, !tbaa !140
  %conv24 = zext i32 %11 to i64
  %add25 = add i64 %10, %conv24
  %conv26 = trunc i64 %add25 to i32
  %call27 = call zeroext i16 @igetword(%struct.intel8x0* %1, i32 %conv26)
  %conv28 = zext i16 %call27 to i64
  %cmp29 = icmp eq i64 %conv8, %conv28
  br i1 %cmp29, label %do.end, label %do.cond

do.cond:                                          ; preds = %if.end21, %if.end, %if.then
  %dec = add nsw i32 %timeout.0, -1
  %tobool33 = icmp ne i32 %timeout.0, 0
  br i1 %tobool33, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %if.end21, %if.end19
  %last_pos = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %12 = load i32, i32* %last_pos, align 8, !tbaa !165
  %conv34 = zext i32 %12 to i64
  %cmp35 = icmp ne i64 %conv8, 0
  br i1 %cmp35, label %if.then37, label %if.end57

if.then37:                                        ; preds = %do.end
  %pos_shift = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 10
  %13 = load i32, i32* %pos_shift, align 4, !tbaa !141
  %sh_prom = zext i32 %13 to i64
  %shl = shl i64 %conv8, %sh_prom
  %fragsize1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 8
  %14 = load i32, i32* %fragsize1, align 4, !tbaa !85
  %conv38 = zext i32 %14 to i64
  %sub = sub i64 %conv38, %shl
  %conv39 = zext i32 %8 to i64
  %add40 = add i64 %sub, %conv39
  %last_pos41 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %15 = load i32, i32* %last_pos41, align 8, !tbaa !165
  %conv42 = zext i32 %15 to i64
  %cmp43 = icmp ult i64 %add40, %conv42
  br i1 %cmp43, label %if.then45, label %if.end57

if.then45:                                        ; preds = %if.then37
  %fragsize146 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 8
  %16 = load i32, i32* %fragsize146, align 4, !tbaa !85
  %div = udiv i32 %8, %16
  %last_pos47 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %17 = load i32, i32* %last_pos47, align 8, !tbaa !165
  %fragsize148 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 8
  %18 = load i32, i32* %fragsize148, align 4, !tbaa !85
  %div49 = udiv i32 %17, %18
  %cmp50 = icmp eq i32 %div, %div49
  br i1 %cmp50, label %if.then52, label %if.end57

if.then52:                                        ; preds = %if.then45
  %last_pos53 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  %19 = load i32, i32* %last_pos53, align 8, !tbaa !165
  %conv54 = zext i32 %19 to i64
  br label %if.end57

if.end57:                                         ; preds = %if.then52, %if.then45, %if.then37, %do.end
  %ptr.2 = phi i64 [ %conv34, %do.end ], [ %add40, %if.then37 ], [ %conv54, %if.then52 ], [ %add40, %if.then45 ]
  %conv58 = trunc i64 %ptr.2 to i32
  %last_pos59 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  store i32 %conv58, i32* %last_pos59, align 8, !tbaa !165
  %reg_lock60 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 20
  call void @spin_unlock(%struct.spinlock* %reg_lock60)
  %size = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 6
  %20 = load i32, i32* %size, align 4, !tbaa !87
  %conv61 = zext i32 %20 to i64
  %cmp62 = icmp uge i64 %ptr.2, %conv61
  br i1 %cmp62, label %cleanup, label %if.end65

if.end65:                                         ; preds = %if.end57
  %runtime66 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %21 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime66, align 8, !tbaa !53
  %call67 = call i64 @bytes_to_frames(%struct.snd_pcm_runtime* %21, i64 %ptr.2)
  br label %cleanup

cleanup:                                          ; preds = %if.end65, %if.end57
  %retval.0 = phi i64 [ %call67, %if.end65 ], [ 0, %if.end57 ]
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.11* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @bytes_to_frames(%struct.snd_pcm_runtime* %runtime, i64 %size) #3 {
entry:
  %mul = mul nsw i64 %size, 8
  %frame_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 20
  %0 = load i32, i32* %frame_bits, align 8, !tbaa !166
  %conv = zext i32 %0 to i64
  %div = sdiv i64 %mul, %conv
  ret i64 %div
}

declare void @_raw_spin_unlock(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @snd_pcm_lib_buffer_bytes(%struct.snd_pcm_substream* %substream) #3 {
entry:
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %0 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !53
  %buffer_size = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %0, i32 0, i32 17
  %1 = load i64, i64* %buffer_size, align 8, !tbaa !167
  %call = call i64 @frames_to_bytes(%struct.snd_pcm_runtime* %0, i64 %1)
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @snd_pcm_lib_period_bytes(%struct.snd_pcm_substream* %substream) #3 {
entry:
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %0 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !53
  %period_size = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %0, i32 0, i32 15
  %1 = load i64, i64* %period_size, align 8, !tbaa !168
  %call = call i64 @frames_to_bytes(%struct.snd_pcm_runtime* %0, i64 %1)
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @frames_to_bytes(%struct.snd_pcm_runtime* %runtime, i64 %size) #3 {
entry:
  %frame_bits = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %runtime, i32 0, i32 20
  %0 = load i32, i32* %frame_bits, align 8, !tbaa !166
  %conv = zext i32 %0 to i64
  %mul = mul nsw i64 %size, %conv
  %div = sdiv i64 %mul, 8
  ret i64 %div
}

declare i32 @snd_ac97_pcm_close(%struct.ac97_pcm*) #1

declare i32 @snd_pcm_lib_free_pages(%struct.snd_pcm_substream*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.snd_interval* @hw_param_interval_c(%struct.snd_pcm_hw_params* %params, i32 %var) #3 {
entry:
  %intervals = getelementptr inbounds %struct.snd_pcm_hw_params, %struct.snd_pcm_hw_params* %params, i32 0, i32 3
  %sub = sub nsw i32 %var, 8
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [12 x %struct.snd_interval], [12 x %struct.snd_interval]* %intervals, i64 0, i64 %idxprom
  ret %struct.snd_interval* %arrayidx
}

declare i32 @snd_pcm_lib_malloc_pages(%struct.snd_pcm_substream*, i64) #1

declare i32 @snd_ac97_pcm_open(%struct.ac97_pcm*, i32, i32, i16 zeroext) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %ichdev) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !53
  %substream2 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 4
  store %struct.snd_pcm_substream* %substream, %struct.snd_pcm_substream** %substream2, align 8, !tbaa !51
  %hw = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %3 = bitcast %struct.snd_pcm_hardware* %hw to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* bitcast (%struct.snd_pcm_hardware* @snd_intel8x0_stream to i8*), i64 80, i32 8, i1 false), !tbaa.struct !169
  %pcm = getelementptr inbounds %struct.ichdev, %struct.ichdev* %ichdev, i32 0, i32 23
  %4 = load %struct.ac97_pcm*, %struct.ac97_pcm** %pcm, align 8, !tbaa !120
  %rates = getelementptr inbounds %struct.ac97_pcm, %struct.ac97_pcm* %4, i32 0, i32 4
  %5 = load i32, i32* %rates, align 8, !tbaa !127
  %hw3 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %rates4 = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw3, i32 0, i32 2
  store i32 %5, i32* %rates4, align 8, !tbaa !171
  %call = call i32 @snd_pcm_limit_hw_rates(%struct.snd_pcm_runtime* %2)
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %6 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp = icmp eq i32 %6, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %hw5 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %buffer_bytes_max = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw5, i32 0, i32 7
  store i64 65536, i64* %buffer_bytes_max, align 8, !tbaa !172
  %hw6 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %period_bytes_max = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw6, i32 0, i32 9
  store i64 65536, i64* %period_bytes_max, align 8, !tbaa !173
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call7 = call i32 @snd_pcm_hw_constraint_integer(%struct.snd_pcm_runtime* %2, i32 15)
  %cmp8 = icmp slt i32 %call7, 0
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end
  %7 = bitcast %struct.ichdev* %ichdev to i8*
  %private_data11 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 42
  store i8* %7, i8** %private_data11, align 8, !tbaa !159
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.end
  %retval.0 = phi i32 [ 0, %if.end10 ], [ %call7, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

declare i32 @snd_pcm_limit_hw_rates(%struct.snd_pcm_runtime*) #1

declare i32 @snd_pcm_hw_constraint_integer(%struct.snd_pcm_runtime*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 2
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 2
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !51
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 0
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 0
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !51
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_playback_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime1 = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime1, align 8, !tbaa !53
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %multi8 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %multi8, align 8
  %bf.lshr = lshr i16 %bf.load, 2
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %hw = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %channels_max = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw, i32 0, i32 6
  store i32 8, i32* %channels_max, align 8, !tbaa !174
  %call3 = call i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime* %2, i32 0, i32 10, %struct.snd_pcm_hw_constraint_list* @hw_constraints_channels8)
  br label %if.end24

if.else:                                          ; preds = %if.end
  %multi6 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load4 = load i16, i16* %multi6, align 8
  %bf.lshr5 = lshr i16 %bf.load4, 1
  %bf.clear6 = and i16 %bf.lshr5, 1
  %bf.cast7 = zext i16 %bf.clear6 to i32
  %tobool8 = icmp ne i32 %bf.cast7, 0
  br i1 %tobool8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.else
  %hw10 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %channels_max11 = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw10, i32 0, i32 6
  store i32 6, i32* %channels_max11, align 8, !tbaa !174
  %call12 = call i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime* %2, i32 0, i32 10, %struct.snd_pcm_hw_constraint_list* @hw_constraints_channels6)
  br label %if.end24

if.else13:                                        ; preds = %if.else
  %multi4 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load14 = load i16, i16* %multi4, align 8
  %bf.clear15 = and i16 %bf.load14, 1
  %bf.cast16 = zext i16 %bf.clear15 to i32
  %tobool17 = icmp ne i32 %bf.cast16, 0
  br i1 %tobool17, label %if.then18, label %if.end24

if.then18:                                        ; preds = %if.else13
  %hw19 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %channels_max20 = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw19, i32 0, i32 6
  store i32 4, i32* %channels_max20, align 8, !tbaa !174
  %call21 = call i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime* %2, i32 0, i32 10, %struct.snd_pcm_hw_constraint_list* @hw_constraints_channels4)
  br label %if.end24

if.end24:                                         ; preds = %if.then18, %if.else13, %if.then9, %if.then2
  %dra = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load25 = load i16, i16* %dra, align 8
  %bf.lshr26 = lshr i16 %bf.load25, 3
  %bf.clear27 = and i16 %bf.lshr26, 1
  %bf.cast28 = zext i16 %bf.clear27 to i32
  %tobool29 = icmp ne i32 %bf.cast28, 0
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end24
  %call31 = call i32 @snd_ac97_pcm_double_rate_rules(%struct.snd_pcm_runtime* %2)
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end24
  %smp20bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load33 = load i16, i16* %smp20bit, align 8
  %bf.lshr34 = lshr i16 %bf.load33, 4
  %bf.clear35 = and i16 %bf.lshr34, 1
  %bf.cast36 = zext i16 %bf.clear35 to i32
  %tobool37 = icmp ne i32 %bf.cast36, 0
  br i1 %tobool37, label %if.then38, label %cleanup

if.then38:                                        ; preds = %if.end32
  %hw39 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 44
  %formats = getelementptr inbounds %struct.snd_pcm_hardware, %struct.snd_pcm_hardware* %hw39, i32 0, i32 1
  %3 = load i64, i64* %formats, align 8, !tbaa !175
  %or = or i64 %3, 1024
  store i64 %or, i64* %formats, align 8, !tbaa !175
  %call40 = call i32 @snd_pcm_hw_constraint_msbits(%struct.snd_pcm_runtime* %2, i32 0, i32 32, i32 20)
  br label %cleanup

cleanup:                                          ; preds = %if.then38, %if.end32, %entry
  %retval.0 = phi i32 [ %call, %entry ], [ 0, %if.then38 ], [ 0, %if.end32 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_playback_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 1
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !51
  ret i32 0
}

declare i32 @snd_pcm_hw_constraint_list(%struct.snd_pcm_runtime*, i32, i32, %struct.snd_pcm_hw_constraint_list*) #1

declare i32 @snd_ac97_pcm_double_rate_rules(%struct.snd_pcm_runtime*) #1

declare i32 @snd_pcm_hw_constraint_msbits(%struct.snd_pcm_runtime*, i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_spdif_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %2 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp = icmp eq i32 %2, 4
  %3 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 3, i32 5
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %idxprom = sext i32 %cond to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_spdif_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 0
  %2 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp = icmp eq i32 %2, 4
  %3 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 3, i32 5
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %idxprom = sext i32 %cond to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !51
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_pcm_trigger(%struct.snd_pcm_substream* %substream, i32 %cmd) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %runtime = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 12
  %2 = load %struct.snd_pcm_runtime*, %struct.snd_pcm_runtime** %runtime, align 8, !tbaa !53
  %private_data1 = getelementptr inbounds %struct.snd_pcm_runtime, %struct.snd_pcm_runtime* %2, i32 0, i32 42
  %3 = load i8*, i8** %private_data1, align 8, !tbaa !159
  %4 = bitcast i8* %3 to %struct.ichdev*
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 1
  %5 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %Pivot12 = icmp slt i32 %cmd, 4
  br i1 %Pivot12, label %NodeBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %cmd, 5
  br i1 %Pivot10, label %sw.bb2, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %cmd, 6
  br i1 %Pivot8, label %sw.bb3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %cmd, 6
  br i1 %SwitchLeaf6, label %sw.bb, label %cleanup

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %cmd, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %cmd, 3
  br i1 %Pivot, label %LeafBlock1, label %sw.epilog

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %cmd, 1
  br i1 %SwitchLeaf2, label %sw.bb2, label %cleanup

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %cmd, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %cleanup

sw.bb:                                            ; preds = %LeafBlock5
  %suspended = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load = load i8, i8* %suspended, align 4
  %bf.clear = and i8 %bf.load, -3
  store i8 %bf.clear, i8* %suspended, align 4
  br label %sw.bb2

sw.bb2:                                           ; preds = %sw.bb, %LeafBlock1, %NodeBlock9
  %position = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 9
  %6 = load i32, i32* %position, align 8, !tbaa !86
  %last_pos = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 11
  store i32 %6, i32* %last_pos, align 8, !tbaa !165
  br label %sw.epilog

sw.bb3:                                           ; preds = %NodeBlock7
  %suspended4 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 25
  %bf.load5 = load i8, i8* %suspended4, align 4
  %bf.clear6 = and i8 %bf.load5, -3
  %bf.set = or i8 %bf.clear6, 2
  store i8 %bf.set, i8* %suspended4, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb3, %sw.bb2, %LeafBlock, %NodeBlock
  %val.0 = phi i8 [ 17, %sw.bb2 ], [ 0, %LeafBlock ], [ 0, %sw.bb3 ], [ 16, %NodeBlock ]
  %add = add i64 %5, 11
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv, i8 zeroext %val.0)
  %cmp = icmp eq i32 %cmd, 0
  br i1 %cmp, label %if.then, label %cleanup

if.then:                                          ; preds = %sw.epilog
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %roff_sr = getelementptr inbounds %struct.ichdev, %struct.ichdev* %4, i32 0, i32 19
  %7 = load i32, i32* %roff_sr, align 8, !tbaa !76
  %conv10 = zext i32 %7 to i64
  %add11 = add i64 %5, %conv10
  %conv12 = trunc i64 %add11 to i32
  %call = call zeroext i8 @igetbyte(%struct.intel8x0* %1, i32 %conv12)
  %conv13 = zext i8 %call to i32
  %and = and i32 %conv13, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %add14 = add i64 %5, 11
  %conv15 = trunc i64 %add14 to i32
  call void @iputbyte(%struct.intel8x0* %1, i32 %conv15, i8 zeroext 2)
  br label %cleanup

cleanup:                                          ; preds = %while.end, %sw.epilog, %LeafBlock, %LeafBlock1, %LeafBlock5
  %retval.0 = phi i32 [ -22, %LeafBlock ], [ -22, %LeafBlock1 ], [ -22, %LeafBlock5 ], [ 0, %while.end ], [ 0, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture2_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 4
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_capture2_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 4
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !51
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic2_open(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %call = call i32 @snd_intel8x0_pcm_open(%struct.snd_pcm_substream* %substream, %struct.ichdev* %arrayidx)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_mic2_close(%struct.snd_pcm_substream* %substream) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_pcm_substream, %struct.snd_pcm_substream* %substream, i32 0, i32 2
  %0 = load i8*, i8** %private_data, align 8, !tbaa !158
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 8
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 3
  %substream1 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 4
  store %struct.snd_pcm_substream* null, %struct.snd_pcm_substream** %substream1, align 8, !tbaa !51
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #4

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_mixer_free_ac97(%struct.snd_ac97* %ac97) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !176
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ac971 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 13
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !121
  %idxprom = zext i16 %2 to i64
  %arrayidx = getelementptr inbounds [3 x %struct.snd_ac97*], [3 x %struct.snd_ac97*]* %ac971, i64 0, i64 %idxprom
  store %struct.snd_ac97* null, %struct.snd_ac97** %arrayidx, align 8, !tbaa !6
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_codec_read_test(%struct.intel8x0* %chip, i32 %codec) #2 {
entry:
  %call = call i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %chip, i32 %codec)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %mul = mul i32 %codec, 128
  %call1 = call zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 %mul)
  %call2 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and = and i32 %call2, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.then
  %codec_ready_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 19
  %0 = load i32, i32* %codec_ready_bits, align 4, !tbaa !177
  %or = or i32 %0, 1
  %neg = xor i32 %or, -1
  %and4 = and i32 %call2, %neg
  call void @iputdword(%struct.intel8x0* %chip, i32 48, i32 %and4)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.then, %entry
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

declare void @warn_slowpath_null(i8*, i32) #1

declare i32 @snd_ac97_bus(%struct.snd_card*, i32, %struct.snd_ac97_bus_ops*, i8*, %struct.snd_ac97_bus**) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_mixer_free_ac97_bus(%struct.snd_ac97_bus* %bus) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97_bus, %struct.snd_ac97_bus* %bus, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !178
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %ac97_bus = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 12
  store %struct.snd_ac97_bus* null, %struct.snd_ac97_bus** %ac97_bus, align 8, !tbaa !116
  ret void
}

declare i32 @snd_ac97_mixer(%struct.snd_ac97_bus*, %struct.snd_ac97_template*, %struct.snd_ac97**) #1

declare i32 @snd_ac97_tune_hardware(%struct.snd_ac97*, %struct.ac97_quirk*, i8*) #1

declare i32 @snd_ac97_pcm_assign(%struct.snd_ac97_bus*, i16 zeroext, %struct.ac97_pcm*) #1

declare i32 @snd_ac97_update_bits(%struct.snd_ac97*, i16 zeroext, i16 zeroext, i16 zeroext) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_ali_codec_write(%struct.snd_ac97* %ac97, i16 zeroext %reg, i16 zeroext %val) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !176
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %call = call i32 @snd_intel8x0_ali_codec_semaphore(%struct.intel8x0* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @iputword(%struct.intel8x0* %1, i32 32, i16 zeroext %val)
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !121
  %tobool1 = icmp ne i16 %2, 0
  %conv = zext i16 %reg to i32
  %or = or i32 %conv, 256
  %conv3 = trunc i32 %or to i16
  %reg.addr.0 = select i1 %tobool1, i16 %conv3, i16 %reg
  call void @iputword(%struct.intel8x0* %1, i32 34, i16 zeroext %reg.addr.0)
  %call5 = call i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %1, i32 1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end ], [ 1, %entry ]
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @snd_intel8x0_ali_codec_read(%struct.snd_ac97* %ac97, i16 zeroext %reg) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !176
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %call = call i32 @snd_intel8x0_ali_codec_semaphore(%struct.intel8x0* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %__err, label %if.end

if.end:                                           ; preds = %entry
  %conv = zext i16 %reg to i32
  %or = or i32 %conv, 128
  %conv1 = trunc i32 %or to i16
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !121
  %tobool2 = icmp ne i16 %2, 0
  %conv4 = zext i16 %conv1 to i32
  %or5 = or i32 %conv4, 256
  %conv6 = trunc i32 %or5 to i16
  %reg.addr.0 = select i1 %tobool2, i16 %conv6, i16 %conv1
  call void @iputword(%struct.intel8x0* %1, i32 34, i16 zeroext %reg.addr.0)
  %call8 = call i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %1, i32 2)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %__err, label %if.end11

if.end11:                                         ; preds = %if.end
  %call12 = call zeroext i16 @igetword(%struct.intel8x0* %1, i32 36)
  br label %__err

__err:                                            ; preds = %if.end11, %if.end, %entry
  %data.0 = phi i16 [ %call12, %if.end11 ], [ -1, %entry ], [ -1, %if.end ]
  ret i16 %data.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_codec_semaphore(%struct.intel8x0* %chip) #2 {
entry:
  %buggy_semaphore = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %buggy_semaphore, align 8
  %bf.lshr = lshr i16 %bf.load, 11
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %time.0 = phi i32 [ 100, %if.end ], [ %dec, %while.body ]
  %dec = add nsw i32 %time.0, -1
  %cond = icmp eq i32 %dec, 0
  br i1 %cond, label %land.lhs.true, label %land.rhs

land.rhs:                                         ; preds = %while.cond
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 60)
  %and = and i32 %call, -2147483648
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  call void @__const_udelay(i64 4295)
  br label %while.cond

while.end:                                        ; preds = %land.rhs
  %tobool3 = icmp ne i32 %dec, 0
  br i1 %tobool3, label %if.end10, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.end, %while.cond
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load4 = load i16, i16* %in_ac97_init, align 8
  %bf.lshr5 = lshr i16 %bf.load4, 5
  %bf.clear6 = and i16 %bf.lshr5, 1
  %bf.cast7 = zext i16 %bf.clear6 to i32
  %tobool8 = icmp ne i32 %bf.cast7, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %land.lhs.true
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 634, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.56, i32 0, i32 0))
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.lhs.true, %while.end
  %call11 = call i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %chip, i32 8)
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %entry
  %retval.0 = phi i32 [ %call11, %if.end10 ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_ali_codec_ready(%struct.intel8x0* %chip, i32 %mask) #2 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %count.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %.retval.0, %for.inc ]
  %cmp = icmp slt i32 %count.0, 127
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 56)
  %conv = zext i8 %call to i32
  %and = and i32 %conv, %mask
  %tobool = icmp ne i32 %and, 0
  %. = select i1 %tobool, i32 1, i32 0
  %.retval.0 = select i1 %tobool, i32 0, i32 %retval.0
  %SwitchLeaf = icmp eq i32 %., 0
  br i1 %SwitchLeaf, label %for.inc, label %cleanup4

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %count.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool1 = icmp ne i32 %bf.cast, 0
  br i1 %tobool1, label %cleanup4, label %if.then2

if.then2:                                         ; preds = %for.end
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 622, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.57, i32 0, i32 0))
  br label %cleanup4

cleanup4:                                         ; preds = %if.then2, %for.end, %for.body
  %retval.2 = phi i32 [ -16, %if.then2 ], [ -16, %for.end ], [ %.retval.0, %for.body ]
  ret i32 %retval.2
}

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_codec_write(%struct.snd_ac97* %ac97, i16 zeroext %reg, i16 zeroext %val) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !176
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !121
  %conv = zext i16 %2 to i32
  %call = call i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %1, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end6, label %if.then2

if.then2:                                         ; preds = %if.then
  %num3 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %3 = load i16, i16* %num3, align 8, !tbaa !121
  %conv4 = zext i16 %3 to i32
  %conv5 = zext i16 %reg to i32
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 565, i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.52, i32 0, i32 0), i32 %conv4, i32 %conv5)
  br label %if.end6

if.end6:                                          ; preds = %if.then2, %if.then, %entry
  %conv7 = zext i16 %reg to i32
  %num8 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %4 = load i16, i16* %num8, align 8, !tbaa !121
  %conv9 = zext i16 %4 to i32
  %mul = mul nsw i32 %conv9, 128
  %add = add nsw i32 %conv7, %mul
  call void @iaputword(%struct.intel8x0* %1, i32 %add, i16 zeroext %val)
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @snd_intel8x0_codec_read(%struct.snd_ac97* %ac97, i16 zeroext %reg) #2 {
entry:
  %private_data = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 1
  %0 = load i8*, i8** %private_data, align 8, !tbaa !176
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %num = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %2 = load i16, i16* %num, align 8, !tbaa !121
  %conv = zext i16 %2 to i32
  %call = call i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %1, i32 %conv)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %in_ac97_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load = load i16, i16* %in_ac97_init, align 8
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end26, label %if.then2

if.then2:                                         ; preds = %if.then
  %num3 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %3 = load i16, i16* %num3, align 8, !tbaa !121
  %conv4 = zext i16 %3 to i32
  %conv5 = zext i16 %reg to i32
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 579, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.54, i32 0, i32 0), i32 %conv4, i32 %conv5)
  br label %if.end26

if.else:                                          ; preds = %entry
  %conv6 = zext i16 %reg to i32
  %num7 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %4 = load i16, i16* %num7, align 8, !tbaa !121
  %conv8 = zext i16 %4 to i32
  %mul = mul nsw i32 %conv8, 128
  %add = add nsw i32 %conv6, %mul
  %call9 = call zeroext i16 @iagetword(%struct.intel8x0* %1, i32 %add)
  %call10 = call i32 @igetdword(%struct.intel8x0* %1, i32 48)
  %and = and i32 %call10, 32768
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end26

if.then12:                                        ; preds = %if.else
  %codec_ready_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 19
  %5 = load i32, i32* %codec_ready_bits, align 4, !tbaa !177
  %or = or i32 %5, 1
  %neg = xor i32 %or, -1
  %and13 = and i32 %call10, %neg
  call void @iputdword(%struct.intel8x0* %1, i32 48, i32 %and13)
  %in_ac97_init14 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %1, i32 0, i32 9
  %bf.load15 = load i16, i16* %in_ac97_init14, align 8
  %bf.lshr16 = lshr i16 %bf.load15, 5
  %bf.clear17 = and i16 %bf.lshr16, 1
  %bf.cast18 = zext i16 %bf.clear17 to i32
  %tobool19 = icmp ne i32 %bf.cast18, 0
  br i1 %tobool19, label %if.end26, label %if.then20

if.then20:                                        ; preds = %if.then12
  %num21 = getelementptr inbounds %struct.snd_ac97, %struct.snd_ac97* %ac97, i32 0, i32 11
  %6 = load i16, i16* %num21, align 8, !tbaa !121
  %conv22 = zext i16 %6 to i32
  %conv23 = zext i16 %reg to i32
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 588, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.55, i32 0, i32 0), i32 %conv22, i32 %conv23)
  br label %if.end26

if.end26:                                         ; preds = %if.then20, %if.then12, %if.else, %if.then2, %if.then
  %res.1 = phi i16 [ -1, %if.then2 ], [ -1, %if.then ], [ %call9, %if.else ], [ -1, %if.then20 ], [ -1, %if.then12 ]
  ret i16 %res.1
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_codec_semaphore(%struct.intel8x0* %chip, i32 %codec) #2 {
entry:
  %cmp = icmp ugt i32 %codec, 2
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %in_sdin_init = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %in_sdin_init, align 8
  %bf.lshr = lshr i16 %bf.load, 6
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %codec_isr_bits = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 18
  %0 = load i32, i32* %codec_isr_bits, align 8, !tbaa !96
  br label %if.end4

if.else:                                          ; preds = %if.end
  %codec_bit = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 17
  %1 = load i32*, i32** %codec_bit, align 8, !tbaa !97
  %ac97_sdin = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 14
  %idxprom = zext i32 %codec to i64
  %arrayidx = getelementptr inbounds [3 x i32], [3 x i32]* %ac97_sdin, i64 0, i64 %idxprom
  %2 = load i32, i32* %arrayidx, align 4, !tbaa !2
  %idxprom2 = zext i32 %2 to i64
  %arrayidx3 = getelementptr inbounds i32, i32* %1, i64 %idxprom2
  %3 = load i32, i32* %arrayidx3, align 4, !tbaa !2
  br label %if.end4

if.end4:                                          ; preds = %if.else, %if.then1
  %codec.addr.0 = phi i32 [ %0, %if.then1 ], [ %3, %if.else ]
  %call = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  %and = and i32 %call, %codec.addr.0
  %cmp5 = icmp eq i32 %and, 0
  br i1 %cmp5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end4
  %buggy_semaphore = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load8 = load i16, i16* %buggy_semaphore, align 8
  %bf.lshr9 = lshr i16 %bf.load8, 11
  %bf.clear10 = and i16 %bf.lshr9, 1
  %bf.cast11 = zext i16 %bf.clear10 to i32
  %tobool12 = icmp ne i32 %bf.cast11, 0
  br i1 %tobool12, label %cleanup, label %if.end14

if.end14:                                         ; preds = %if.end7
  br label %do.body

do.body:                                          ; preds = %if.end19, %if.end14
  %time.0 = phi i32 [ 100, %if.end14 ], [ %dec, %if.end19 ]
  %call15 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 52)
  %conv = zext i8 %call15 to i32
  %and16 = and i32 %conv, 1
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.end19, label %cleanup

if.end19:                                         ; preds = %do.body
  call void @__const_udelay(i64 42950)
  %dec = add nsw i32 %time.0, -1
  %tobool20 = icmp ne i32 %time.0, 0
  br i1 %tobool20, label %do.body, label %do.end

do.end:                                           ; preds = %if.end19
  %call21 = call zeroext i8 @igetbyte(%struct.intel8x0* %chip, i32 52)
  %conv22 = zext i8 %call21 to i32
  %call23 = call i32 @igetdword(%struct.intel8x0* %chip, i32 48)
  call void (i32, i8*, i32, i8*, ...) @__snd_printk(i32 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.7, i32 0, i32 0), i32 551, i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.53, i32 0, i32 0), i32 %conv22, i32 %call23)
  %call24 = call zeroext i16 @iagetword(%struct.intel8x0* %chip, i32 0)
  br label %cleanup

cleanup:                                          ; preds = %do.end, %do.body, %if.end7, %if.end4, %entry
  %retval.0 = phi i32 [ -16, %do.end ], [ -5, %entry ], [ -5, %if.end4 ], [ 0, %if.end7 ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @iaputword(%struct.intel8x0* %chip, i32 %offset, i16 zeroext %val) #3 {
entry:
  %addr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %0 = load i8*, i8** %addr, align 8, !tbaa !98
  %idx.ext = zext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %0, i64 %idx.ext
  call void @iowrite16(i16 zeroext %val, i8* %add.ptr)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal void @snd_intel8x0_inside_vm(%struct.pci_dev* %pci) #2 {
entry:
  %0 = load i32, i32* @inside_vm, align 4, !tbaa !2
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %tobool = icmp ne i32 %0, 0
  %1 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.38, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.39, i32 0, i32 0)
  br label %fini

if.end:                                           ; preds = %entry
  %call = call zeroext i1 @kvm_para_available()
  %conv = zext i1 %call to i32
  %tobool1 = icmp ne i32 %conv, 0
  br i1 %tobool1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end
  %call2 = call i32 @constant_test_bit(i32 159, i64* bitcast (i32* getelementptr inbounds (%struct.cpuinfo_x86, %struct.cpuinfo_x86* @boot_cpu_data, i32 0, i32 10, i32 0) to i64*))
  %tobool3 = icmp ne i32 %call2, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %2 = phi i1 [ true, %if.end ], [ %tobool3, %lor.rhs ]
  %lor.ext = zext i1 %2 to i32
  %tobool4 = icmp ne i32 %lor.ext, 0
  br i1 %tobool4, label %if.end6, label %fini

if.end6:                                          ; preds = %lor.end
  %subsystem_vendor = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 9
  %3 = load i16, i16* %subsystem_vendor, align 8, !tbaa !131
  %conv7 = zext i16 %3 to i32
  %cmp8 = icmp eq i32 %conv7, 6900
  br i1 %cmp8, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end6
  %subsystem_device = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 10
  %4 = load i16, i16* %subsystem_device, align 2, !tbaa !132
  %conv10 = zext i16 %4 to i32
  %cmp11 = icmp eq i32 %conv10, 4352
  br i1 %cmp11, label %fini, label %if.else

if.else:                                          ; preds = %land.lhs.true, %if.end6
  %subsystem_vendor14 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %pci, i32 0, i32 9
  %5 = load i16, i16* %subsystem_vendor14, align 8, !tbaa !131
  %conv15 = zext i16 %5 to i32
  %cmp16 = icmp eq i32 %conv15, 6840
  %lor.ext. = select i1 %cmp16, i32 %lor.ext, i32 0
  %. = select i1 %cmp16, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.41, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.42, i32 0, i32 0)
  br label %fini

fini:                                             ; preds = %if.else, %land.lhs.true, %lor.end, %if.then
  %result.2 = phi i32 [ %0, %if.then ], [ %lor.ext, %lor.end ], [ %lor.ext., %if.else ], [ %lor.ext, %land.lhs.true ]
  %msg.2 = phi i8* [ %cond, %if.then ], [ null, %lor.end ], [ %., %if.else ], [ getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), %land.lhs.true ]
  %cmp22 = icmp ne i8* %msg.2, null
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %fini
  %call25 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.43, i32 0, i32 0), i8* %msg.2)
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %fini
  ret void
}

declare i32 @pci_request_regions(%struct.pci_dev*, i8*) #1

declare void @kfree(i8*) #1

declare i8* @pci_iomap(%struct.pci_dev*, i32, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_free(%struct.intel8x0* %chip) #2 {
entry:
  %val = alloca i32, align 4
  %irq = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 1
  %0 = load i32, i32* %irq, align 4, !tbaa !45
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %__hw_end, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %bdbars_count = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %1 = load i32, i32* %bdbars_count, align 8, !tbaa !50
  %cmp1 = icmp ult i32 %i.0, %1
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %ichd = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd, i64 0, i64 %idxprom
  %reg_offset = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx, i32 0, i32 1
  %2 = load i64, i64* %reg_offset, align 8, !tbaa !71
  %add = add i64 11, %2
  %conv = trunc i64 %add to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv, i8 zeroext 0)
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond2

for.cond2:                                        ; preds = %for.body6, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc14, %for.body6 ]
  %bdbars_count3 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 21
  %3 = load i32, i32* %bdbars_count3, align 8, !tbaa !50
  %cmp4 = icmp ult i32 %i.1, %3
  br i1 %cmp4, label %for.body6, label %for.end15

for.body6:                                        ; preds = %for.cond2
  %ichd7 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 8
  %idxprom8 = zext i32 %i.1 to i64
  %arrayidx9 = getelementptr inbounds [6 x %struct.ichdev], [6 x %struct.ichdev]* %ichd7, i64 0, i64 %idxprom8
  %reg_offset10 = getelementptr inbounds %struct.ichdev, %struct.ichdev* %arrayidx9, i32 0, i32 1
  %4 = load i64, i64* %reg_offset10, align 8, !tbaa !71
  %add11 = add i64 11, %4
  %conv12 = trunc i64 %add11 to i32
  call void @iputbyte(%struct.intel8x0* %chip, i32 %conv12, i8 zeroext 2)
  %inc14 = add i32 %i.1, 1
  br label %for.cond2

for.end15:                                        ; preds = %for.cond2
  %device_type = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 0
  %5 = load i32, i32* %device_type, align 8, !tbaa !68
  %cmp16 = icmp ne i32 %5, 4
  %6 = load i32, i32* @spdif_aclink, align 4
  %tobool = icmp ne i32 %6, 0
  %or.cond = or i1 %cmp16, %tobool
  br i1 %or.cond, label %__hw_end, label %if.then18

if.then18:                                        ; preds = %for.end15
  %7 = bitcast i32* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #7
  %pci = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %8 = load %struct.pci_dev*, %struct.pci_dev** %pci, align 8, !tbaa !94
  call void @pci_read_config_dword(%struct.pci_dev* %8, i32 76, i32* %val)
  %9 = load i32, i32* %val, align 4, !tbaa !2
  %and = and i32 %9, -16777217
  store i32 %and, i32* %val, align 4, !tbaa !2
  %pci19 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %10 = load %struct.pci_dev*, %struct.pci_dev** %pci19, align 8, !tbaa !94
  %11 = load i32, i32* %val, align 4, !tbaa !2
  call void @pci_write_config_dword(%struct.pci_dev* %10, i32 76, i32 %11)
  %12 = bitcast i32* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #7
  br label %__hw_end

__hw_end:                                         ; preds = %if.then18, %for.end15, %entry
  %irq22 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 1
  %13 = load i32, i32* %irq22, align 4, !tbaa !45
  %cmp23 = icmp sge i32 %13, 0
  br i1 %cmp23, label %if.then25, label %if.end27

if.then25:                                        ; preds = %__hw_end
  %irq26 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 1
  %14 = load i32, i32* %irq26, align 4, !tbaa !45
  %15 = bitcast %struct.intel8x0* %chip to i8*
  call void @free_irq(i32 %14, i8* %15)
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %__hw_end
  %bdbars = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 22
  %area = getelementptr inbounds %struct.snd_dma_buffer, %struct.snd_dma_buffer* %bdbars, i32 0, i32 1
  %16 = load i8*, i8** %area, align 8, !tbaa !179
  %tobool28 = icmp ne i8* %16, null
  br i1 %tobool28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %if.end27
  %fix_nocache = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 9
  %bf.load = load i16, i16* %fix_nocache, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = zext i16 %bf.clear to i32
  %tobool30 = icmp ne i32 %bf.cast, 0
  %bdbars33 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 22
  call void @snd_dma_free_pages(%struct.snd_dma_buffer* %bdbars33)
  br label %if.end34

if.end34:                                         ; preds = %if.then29, %if.end27
  %addr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %17 = load i8*, i8** %addr, align 8, !tbaa !98
  %tobool35 = icmp ne i8* %17, null
  br i1 %tobool35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.end34
  %pci37 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %18 = load %struct.pci_dev*, %struct.pci_dev** %pci37, align 8, !tbaa !94
  %addr38 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 2
  %19 = load i8*, i8** %addr38, align 8, !tbaa !98
  call void @pci_iounmap(%struct.pci_dev* %18, i8* %19)
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %if.end34
  %bmaddr = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %20 = load i8*, i8** %bmaddr, align 8, !tbaa !80
  %tobool40 = icmp ne i8* %20, null
  br i1 %tobool40, label %if.then41, label %if.end44

if.then41:                                        ; preds = %if.end39
  %pci42 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %21 = load %struct.pci_dev*, %struct.pci_dev** %pci42, align 8, !tbaa !94
  %bmaddr43 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 3
  %22 = load i8*, i8** %bmaddr43, align 8, !tbaa !80
  call void @pci_iounmap(%struct.pci_dev* %21, i8* %22)
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %if.end39
  %pci45 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %23 = load %struct.pci_dev*, %struct.pci_dev** %pci45, align 8, !tbaa !94
  call void @pci_release_regions(%struct.pci_dev* %23)
  %pci46 = getelementptr inbounds %struct.intel8x0, %struct.intel8x0* %chip, i32 0, i32 4
  %24 = load %struct.pci_dev*, %struct.pci_dev** %pci46, align 8, !tbaa !94
  call void @pci_disable_device(%struct.pci_dev* %24)
  %25 = bitcast %struct.intel8x0* %chip to i8*
  call void @kfree(i8* %25)
  ret i32 0
}

declare i32 @snd_dma_alloc_pages(i32, %struct.device*, i64, %struct.snd_dma_buffer*) #1

declare i32 @snd_device_new(%struct.snd_card*, i32, i8*, %struct.snd_device_ops*) #1

; Function Attrs: nounwind uwtable
define internal i32 @snd_intel8x0_dev_free(%struct.snd_device* %device) #2 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !180
  %1 = bitcast i8* %0 to %struct.intel8x0*
  %call = call i32 @snd_intel8x0_free(%struct.intel8x0* %1)
  ret i32 %call
}

declare void @snd_dma_free_pages(%struct.snd_dma_buffer*) #1

declare void @pci_iounmap(%struct.pci_dev*, i8*) #1

declare void @pci_release_regions(%struct.pci_dev*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @kvm_para_available() #3 {
entry:
  %eax = alloca i32, align 4
  %ebx = alloca i32, align 4
  %ecx = alloca i32, align 4
  %edx = alloca i32, align 4
  %signature = alloca [13 x i8], align 1
  %0 = bitcast i32* %eax to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i32* %ebx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  %2 = bitcast i32* %ecx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %3 = bitcast i32* %edx to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #7
  %4 = bitcast [13 x i8]* %signature to i8*
  call void @llvm.lifetime.start.p0i8(i64 13, i8* %4) #7
  %5 = load i32, i32* getelementptr inbounds (%struct.cpuinfo_x86, %struct.cpuinfo_x86* @boot_cpu_data, i32 0, i32 9), align 16, !tbaa !182
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %cleanup, label %cond.true1

cond.true1:                                       ; preds = %entry
  %call = call i32 @constant_test_bit(i32 159, i64* bitcast (i32* getelementptr inbounds (%struct.cpuinfo_x86, %struct.cpuinfo_x86* @boot_cpu_data, i32 0, i32 10, i32 0) to i64*))
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then5, label %if.end41

if.then5:                                         ; preds = %cond.true1
  call void @cpuid(i32 1073741824, i32* %eax, i32* %ebx, i32* %ecx, i32* %edx)
  %cmp6 = icmp uge i64 4, 64
  %arraydecay = getelementptr inbounds [13 x i8], [13 x i8]* %signature, i32 0, i32 0
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 0
  %6 = bitcast i32* %ebx to i8*
  br i1 %cmp6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.then5
  %call8 = call i8* @__memcpy(i8* %add.ptr, i8* %6, i64 4)
  br label %if.end11

if.else:                                          ; preds = %if.then5
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %6, i64 4, i32 1, i1 false)
  br label %if.end11

if.end11:                                         ; preds = %if.else, %if.then7
  %__ret.0 = phi i8* [ %call8, %if.then7 ], [ %add.ptr, %if.else ]
  %cmp14 = icmp uge i64 4, 64
  %arraydecay16 = getelementptr inbounds [13 x i8], [13 x i8]* %signature, i32 0, i32 0
  %add.ptr17 = getelementptr inbounds i8, i8* %arraydecay16, i64 4
  %7 = bitcast i32* %ecx to i8*
  br i1 %cmp14, label %if.then15, label %if.else19

if.then15:                                        ; preds = %if.end11
  %call18 = call i8* @__memcpy(i8* %add.ptr17, i8* %7, i64 4)
  br label %if.end22

if.else19:                                        ; preds = %if.end11
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr17, i8* %7, i64 4, i32 1, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %if.else19, %if.then15
  %__ret13.0 = phi i8* [ %call18, %if.then15 ], [ %add.ptr17, %if.else19 ]
  %cmp26 = icmp uge i64 4, 64
  %arraydecay28 = getelementptr inbounds [13 x i8], [13 x i8]* %signature, i32 0, i32 0
  %add.ptr29 = getelementptr inbounds i8, i8* %arraydecay28, i64 8
  %8 = bitcast i32* %edx to i8*
  br i1 %cmp26, label %if.then27, label %if.else31

if.then27:                                        ; preds = %if.end22
  %call30 = call i8* @__memcpy(i8* %add.ptr29, i8* %8, i64 4)
  br label %if.end34

if.else31:                                        ; preds = %if.end22
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr29, i8* %8, i64 4, i32 1, i1 false)
  br label %if.end34

if.end34:                                         ; preds = %if.else31, %if.then27
  %__ret25.0 = phi i8* [ %call30, %if.then27 ], [ %add.ptr29, %if.else31 ]
  %arrayidx = getelementptr inbounds [13 x i8], [13 x i8]* %signature, i64 0, i64 12
  store i8 0, i8* %arrayidx, align 1, !tbaa !146
  %arraydecay36 = getelementptr inbounds [13 x i8], [13 x i8]* %signature, i32 0, i32 0
  %call37 = call i32 @strcmp(i8* %arraydecay36, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.44, i32 0, i32 0))
  %cmp38 = icmp eq i32 %call37, 0
  br i1 %cmp38, label %cleanup, label %if.end41

if.end41:                                         ; preds = %if.end34, %cond.true1
  br label %cleanup

cleanup:                                          ; preds = %if.end41, %if.end34, %entry
  %retval.0 = phi i1 [ false, %if.end41 ], [ false, %entry ], [ true, %if.end34 ]
  %9 = bitcast [13 x i8]* %signature to i8*
  call void @llvm.lifetime.end.p0i8(i64 13, i8* %9) #7
  %10 = bitcast i32* %edx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %10) #7
  %11 = bitcast i32* %ecx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #7
  %12 = bitcast i32* %ebx to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #7
  %13 = bitcast i32* %eax to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #7
  ret i1 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @constant_test_bit(i32 %nr, i64* %addr) #6 {
entry:
  %rem = urem i32 %nr, 64
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %div = udiv i32 %nr, 64
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds i64, i64* %addr, i64 %idxprom
  %0 = load volatile i64, i64* %arrayidx, align 8, !tbaa !95
  %and = and i64 %shl, %0
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @cpuid(i32 %op, i32* %eax, i32* %ebx, i32* %ecx, i32* %edx) #3 {
entry:
  store i32 %op, i32* %eax, align 4, !tbaa !2
  store i32 0, i32* %ecx, align 4, !tbaa !2
  call void @__cpuid(i32* %eax, i32* %ebx, i32* %ecx, i32* %edx)
  ret void
}

declare i8* @__memcpy(i8*, i8*, i64) #1

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__cpuid(i32* %eax, i32* %ebx, i32* %ecx, i32* %edx) #3 {
entry:
  %0 = load void (i32*, i32*, i32*, i32*)*, void (i32*, i32*, i32*, i32*)** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 27), align 8, !tbaa !184
  %cmp = icmp eq void (i32*, i32*, i32*, i32*)* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.45, i32 0, i32 0), i32 32, i64 12) #7, !srcloc !186
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = ptrtoint i32* %eax to i64
  %2 = ptrtoint i32* %ebx to i64
  %3 = ptrtoint i32* %ecx to i64
  %4 = ptrtoint i32* %edx to i64
  %5 = call { i64, i64, i64, i64 } asm sideeffect "771:\0A\09call *${5:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${4:c}\0A  .byte 772b-771b\0A  .short ${6:c}\0A.popsection\0A", "={di},={si},={dx},={cx},i,i,i,{di},{si},{dx},{cx},~{memory},~{cc},~{rax},~{r8},~{r9},~{r10},~{r11},~{dirflag},~{fpsr},~{flags}"(i64 31, void (i32*, i32*, i32*, i32*)** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 27), i32 511, i64 %1, i64 %2, i64 %3, i64 %4) #7, !srcloc !187
  %asmresult = extractvalue { i64, i64, i64, i64 } %5, 0
  %asmresult8 = extractvalue { i64, i64, i64, i64 } %5, 1
  %asmresult9 = extractvalue { i64, i64, i64, i64 } %5, 2
  %asmresult10 = extractvalue { i64, i64, i64, i64 } %5, 3
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #6 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define internal void @intel8x0_driver_exit() #0 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @intel8x0_driver)
  ret void
}

declare void @pci_unregister_driver(%struct.pci_driver*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { nounwind readnone }
attributes #6 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }

!llvm.ident = !{!0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"int", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"any pointer", !4, i64 0}
!8 = !{!9, !10, i64 24}
!9 = !{!"pci_device_id", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !10, i64 24}
!10 = !{!"long", !4, i64 0}
!11 = !{!12, !3, i64 0}
!12 = !{!"shortname_table", !3, i64 0, !7, i64 8}
!13 = !{!14, !16, i64 62}
!14 = !{!"pci_dev", !15, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !3, i64 56, !16, i64 60, !16, i64 62, !16, i64 64, !16, i64 66, !3, i64 68, !4, i64 72, !4, i64 73, !4, i64 74, !4, i64 75, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !16, i64 80, !7, i64 88, !17, i64 96, !18, i64 104, !3, i64 120, !4, i64 124, !3, i64 125, !3, i64 125, !3, i64 125, !3, i64 125, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 126, !3, i64 128, !3, i64 132, !7, i64 136, !3, i64 144, !19, i64 152, !3, i64 1288, !3, i64 1292, !4, i64 1296, !28, i64 2248, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2249, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2250, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !3, i64 2251, !16, i64 2252, !22, i64 2256, !4, i64 2260, !37, i64 2328, !7, i64 2336, !3, i64 2344, !4, i64 2352, !4, i64 2488, !15, i64 2624, !7, i64 2640, !7, i64 2648, !4, i64 2656, !7, i64 2664, !17, i64 2672, !10, i64 2680}
!15 = !{!"list_head", !7, i64 0, !7, i64 8}
!16 = !{!"short", !4, i64 0}
!17 = !{!"long long", !4, i64 0}
!18 = !{!"device_dma_parameters", !3, i64 0, !10, i64 8}
!19 = !{!"device", !7, i64 0, !7, i64 8, !20, i64 16, !7, i64 80, !7, i64 88, !23, i64 96, !7, i64 264, !7, i64 272, !7, i64 280, !26, i64 288, !7, i64 880, !3, i64 888, !7, i64 896, !17, i64 904, !7, i64 912, !15, i64 920, !7, i64 936, !34, i64 944, !7, i64 960, !35, i64 968, !3, i64 976, !3, i64 980, !24, i64 984, !15, i64 1056, !36, i64 1072, !7, i64 1104, !7, i64 1112, !7, i64 1120, !7, i64 1128}
!20 = !{!"kobject", !7, i64 0, !15, i64 8, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !21, i64 56, !3, i64 60, !3, i64 60, !3, i64 60, !3, i64 60, !3, i64 60}
!21 = !{!"kref", !22, i64 0}
!22 = !{!"", !3, i64 0}
!23 = !{!"mutex", !22, i64 0, !24, i64 8, !15, i64 80, !7, i64 96, !7, i64 104, !7, i64 112, !25, i64 120}
!24 = !{!"spinlock", !4, i64 0}
!25 = !{!"lockdep_map", !7, i64 0, !4, i64 8, !7, i64 24, !3, i64 32, !10, i64 40}
!26 = !{!"dev_pm_info", !27, i64 0, !3, i64 4, !3, i64 4, !28, i64 4, !28, i64 4, !28, i64 4, !28, i64 4, !24, i64 8, !15, i64 80, !29, i64 96, !7, i64 192, !28, i64 200, !28, i64 200, !31, i64 208, !10, i64 336, !32, i64 344, !30, i64 424, !22, i64 512, !22, i64 516, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 520, !3, i64 521, !3, i64 521, !3, i64 521, !3, i64 521, !3, i64 521, !4, i64 524, !4, i64 528, !3, i64 532, !3, i64 536, !10, i64 544, !10, i64 552, !10, i64 560, !10, i64 568, !7, i64 576, !7, i64 584}
!27 = !{!"pm_message", !3, i64 0}
!28 = !{!"_Bool", !4, i64 0}
!29 = !{!"completion", !3, i64 0, !30, i64 8}
!30 = !{!"__wait_queue_head", !24, i64 0, !15, i64 72}
!31 = !{!"timer_list", !15, i64 0, !10, i64 16, !7, i64 24, !7, i64 32, !10, i64 40, !3, i64 48, !3, i64 52, !7, i64 56, !4, i64 64, !25, i64 80}
!32 = !{!"work_struct", !33, i64 0, !15, i64 8, !7, i64 24, !25, i64 32}
!33 = !{!"", !10, i64 0}
!34 = !{!"dev_archdata", !7, i64 0, !7, i64 8}
!35 = !{!"acpi_dev_node", !7, i64 0}
!36 = !{!"klist_node", !7, i64 0, !15, i64 8, !21, i64 24}
!37 = !{!"hlist_head", !7, i64 0}
!38 = !{!12, !7, i64 8}
!39 = !{!40, !7, i64 368}
!40 = !{!"snd_card", !3, i64 0, !4, i64 4, !4, i64 20, !4, i64 36, !4, i64 68, !4, i64 148, !4, i64 228, !7, i64 360, !7, i64 368, !7, i64 376, !15, i64 384, !3, i64 400, !41, i64 408, !44, i64 552, !3, i64 624, !3, i64 628, !15, i64 632, !15, i64 648, !7, i64 664, !7, i64 672, !7, i64 680, !15, i64 688, !7, i64 704, !24, i64 712, !3, i64 784, !3, i64 788, !30, i64 792, !22, i64 880, !7, i64 888, !7, i64 896, !3, i64 904, !23, i64 912, !30, i64 1080, !7, i64 1168, !3, i64 1176}
!41 = !{!"rw_semaphore", !10, i64 0, !42, i64 8, !15, i64 80, !25, i64 96}
!42 = !{!"raw_spinlock", !43, i64 0, !3, i64 4, !3, i64 8, !7, i64 16, !25, i64 24}
!43 = !{!"arch_spinlock", !4, i64 0}
!44 = !{!"", !4, i64 0, !3, i64 8, !3, i64 12, !7, i64 16, !25, i64 24}
!45 = !{!46, !3, i64 4}
!46 = !{!"intel8x0", !3, i64 0, !3, i64 4, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !3, i64 40, !4, i64 48, !4, i64 96, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 864, !3, i64 865, !3, i64 865, !3, i64 865, !3, i64 865, !3, i64 865, !3, i64 868, !3, i64 872, !7, i64 880, !4, i64 888, !4, i64 912, !3, i64 924, !3, i64 928, !7, i64 936, !3, i64 944, !3, i64 948, !24, i64 952, !3, i64 1024, !47, i64 1032, !3, i64 1080, !3, i64 1084}
!47 = !{!"snd_dma_buffer", !48, i64 0, !7, i64 16, !17, i64 24, !10, i64 32, !7, i64 40}
!48 = !{!"snd_dma_device", !3, i64 0, !7, i64 8}
!49 = !{!46, !3, i64 40}
!50 = !{!46, !3, i64 1024}
!51 = !{!52, !7, i64 32}
!52 = !{!"ichdev", !3, i64 0, !10, i64 8, !7, i64 16, !3, i64 24, !7, i64 32, !3, i64 40, !3, i64 44, !3, i64 48, !3, i64 52, !3, i64 56, !3, i64 60, !3, i64 64, !3, i64 68, !3, i64 72, !3, i64 76, !3, i64 80, !3, i64 84, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !3, i64 108, !7, i64 112, !3, i64 120, !3, i64 124, !3, i64 124}
!53 = !{!54, !7, i64 416}
!54 = !{!"snd_pcm_substream", !7, i64 0, !7, i64 8, !7, i64 16, !3, i64 24, !4, i64 28, !3, i64 60, !55, i64 64, !10, i64 336, !47, i64 344, !3, i64 392, !10, i64 400, !7, i64 408, !7, i64 416, !7, i64 424, !3, i64 432, !7, i64 440, !15, i64 448, !58, i64 464, !7, i64 560, !7, i64 568, !3, i64 576, !22, i64 580, !3, i64 584, !7, i64 592, !7, i64 600, !59, i64 608, !7, i64 648, !7, i64 656, !7, i64 664, !7, i64 672, !7, i64 680, !7, i64 688, !7, i64 696, !3, i64 704}
!55 = !{!"pm_qos_request", !56, i64 0, !3, i64 40, !57, i64 48}
!56 = !{!"plist_node", !3, i64 0, !15, i64 8, !15, i64 24}
!57 = !{!"delayed_work", !32, i64 0, !31, i64 80, !7, i64 208, !3, i64 216}
!58 = !{!"snd_pcm_group", !24, i64 0, !15, i64 72, !3, i64 88}
!59 = !{!"snd_pcm_oss_substream", !3, i64 0, !60, i64 8}
!60 = !{!"snd_pcm_oss_setup", !7, i64 0, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 12, !3, i64 16, !7, i64 24}
!61 = !{!62, !7, i64 840}
!62 = !{!"snd_pcm_runtime", !7, i64 0, !63, i64 8, !3, i64 24, !10, i64 32, !10, i64 40, !10, i64 48, !10, i64 56, !10, i64 64, !10, i64 72, !17, i64 80, !3, i64 88, !3, i64 92, !3, i64 96, !3, i64 100, !3, i64 104, !10, i64 112, !3, i64 120, !10, i64 128, !10, i64 136, !10, i64 144, !3, i64 152, !3, i64 156, !3, i64 160, !3, i64 164, !3, i64 168, !3, i64 172, !3, i64 176, !3, i64 180, !10, i64 184, !10, i64 192, !10, i64 200, !10, i64 208, !10, i64 216, !10, i64 224, !10, i64 232, !4, i64 240, !7, i64 256, !7, i64 264, !10, i64 272, !30, i64 280, !30, i64 368, !7, i64 456, !7, i64 464, !7, i64 472, !64, i64 480, !65, i64 560, !7, i64 816, !7, i64 824, !3, i64 832, !3, i64 836, !7, i64 840, !17, i64 848, !10, i64 856, !7, i64 864, !66, i64 872, !7, i64 1168}
!63 = !{!"timespec", !10, i64 0, !10, i64 8}
!64 = !{!"snd_pcm_hardware", !3, i64 0, !17, i64 8, !3, i64 16, !3, i64 20, !3, i64 24, !3, i64 28, !3, i64 32, !10, i64 40, !10, i64 48, !10, i64 56, !3, i64 64, !3, i64 68, !10, i64 72}
!65 = !{!"snd_pcm_hw_constraints", !4, i64 0, !4, i64 96, !3, i64 240, !3, i64 244, !7, i64 248}
!66 = !{!"snd_pcm_oss_runtime", !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 12, !3, i64 16, !3, i64 20, !3, i64 24, !10, i64 32, !10, i64 40, !10, i64 48, !3, i64 56, !10, i64 64, !10, i64 72, !10, i64 80, !7, i64 88, !10, i64 96, !23, i64 104, !7, i64 272, !7, i64 280, !3, i64 288}
!67 = !{!46, !3, i64 928}
!68 = !{!46, !3, i64 0}
!69 = !{!46, !3, i64 872}
!70 = !{!14, !3, i64 1292}
!71 = !{!52, !10, i64 8}
!72 = !{!52, !3, i64 0}
!73 = !{!52, !3, i64 24}
!74 = !{!52, !3, i64 72}
!75 = !{!52, !3, i64 80}
!76 = !{!52, !3, i64 96}
!77 = !{!46, !3, i64 1080}
!78 = !{!46, !3, i64 1084}
!79 = !{!52, !3, i64 104}
!80 = !{!46, !7, i64 16}
!81 = !{!62, !3, i64 100}
!82 = !{!62, !3, i64 104}
!83 = !{!62, !3, i64 156}
!84 = !{!40, !3, i64 904}
!85 = !{!52, !3, i64 52}
!86 = !{!52, !3, i64 56}
!87 = !{!52, !3, i64 44}
!88 = !{!52, !3, i64 76}
!89 = !{!52, !3, i64 68}
!90 = !{!52, !3, i64 40}
!91 = !{!52, !7, i64 16}
!92 = !{!52, !3, i64 84}
!93 = !{!52, !3, i64 88}
!94 = !{!46, !7, i64 24}
!95 = !{!10, !10, i64 0}
!96 = !{!46, !3, i64 944}
!97 = !{!46, !7, i64 936}
!98 = !{!46, !7, i64 8}
!99 = !{!14, !7, i64 16}
!100 = !{!14, !3, i64 56}
!101 = !{!102, !3, i64 8}
!102 = !{!"snd_pci_quirk", !16, i64 0, !16, i64 2, !16, i64 4, !3, i64 8, !7, i64 16}
!103 = !{!102, !7, i64 16}
!104 = !{!28, !28, i64 0}
!105 = !{i8 0, i8 2}
!106 = !{!46, !3, i64 868}
!107 = !{!108, !7, i64 0}
!108 = !{!"snd_ac97_template", !7, i64 0, !7, i64 8, !7, i64 16, !16, i64 24, !16, i64 26, !3, i64 28, !7, i64 32}
!109 = !{!108, !7, i64 8}
!110 = !{!108, !3, i64 28}
!111 = !{!46, !3, i64 924}
!112 = !{!46, !7, i64 32}
!113 = !{!114, !7, i64 16}
!114 = !{!"snd_ac97_bus", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !16, i64 32, !16, i64 34, !16, i64 34, !16, i64 34, !3, i64 36, !24, i64 40, !4, i64 112, !16, i64 128, !7, i64 136, !4, i64 144, !7, i64 176}
!115 = !{!114, !3, i64 36}
!116 = !{!46, !7, i64 880}
!117 = !{!108, !7, i64 16}
!118 = !{!108, !16, i64 24}
!119 = !{!114, !7, i64 136}
!120 = !{!52, !7, i64 112}
!121 = !{!122, !16, i64 400}
!122 = !{!"snd_ac97", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !16, i64 56, !16, i64 58, !23, i64 64, !23, i64 232, !16, i64 400, !16, i64 402, !3, i64 404, !16, i64 408, !16, i64 410, !16, i64 412, !7, i64 416, !3, i64 424, !3, i64 428, !4, i64 432, !3, i64 456, !4, i64 460, !4, i64 720, !4, i64 736, !4, i64 768, !4, i64 769, !3, i64 772, !57, i64 776, !19, i64 1000, !4, i64 2136}
!123 = !{!124, !16, i64 0}
!124 = !{!"", !16, i64 0, !4, i64 2, !4, i64 10, !4, i64 16}
!125 = !{!122, !3, i64 428}
!126 = !{!16, !16, i64 0}
!127 = !{!128, !3, i64 16}
!128 = !{!"ac97_pcm", !7, i64 0, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8, !16, i64 10, !16, i64 12, !3, i64 16, !4, i64 24, !10, i64 120}
!129 = !{!130, !3, i64 40}
!130 = !{!"ich_pcm_table", !7, i64 0, !7, i64 8, !7, i64 16, !10, i64 24, !10, i64 32, !3, i64 40}
!131 = !{!14, !16, i64 64}
!132 = !{!14, !16, i64 66}
!133 = !{!134, !7, i64 24}
!134 = !{!"snd_pcm_str", !3, i64 0, !7, i64 8, !3, i64 16, !3, i64 20, !7, i64 24, !135, i64 32, !7, i64 216, !7, i64 224, !3, i64 232, !7, i64 240, !7, i64 248}
!135 = !{!"snd_pcm_oss_stream", !7, i64 0, !23, i64 8, !7, i64 176}
!136 = !{!54, !10, i64 376}
!137 = !{!54, !17, i64 368}
!138 = !{!52, !3, i64 48}
!139 = !{!52, !3, i64 108}
!140 = !{!52, !3, i64 100}
!141 = !{!52, !3, i64 60}
!142 = !{!63, !10, i64 0}
!143 = !{!63, !10, i64 8}
!144 = !{!145, !7, i64 72}
!145 = !{!"snd_info_entry", !7, i64 0, !16, i64 8, !10, i64 16, !16, i64 24, !4, i64 32, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !23, i64 96, !15, i64 264, !15, i64 280}
!146 = !{!4, !4, i64 0}
!147 = !{!130, !7, i64 0}
!148 = !{!130, !7, i64 8}
!149 = !{!130, !7, i64 16}
!150 = !{!151, !7, i64 952}
!151 = !{!"snd_pcm", !7, i64 0, !15, i64 8, !3, i64 24, !3, i64 28, !16, i64 32, !16, i64 34, !4, i64 36, !4, i64 100, !4, i64 184, !23, i64 696, !30, i64 864, !7, i64 952, !7, i64 960, !7, i64 968, !28, i64 976, !152, i64 980}
!152 = !{!"snd_pcm_oss", !3, i64 0, !3, i64 4}
!153 = !{!151, !3, i64 28}
!154 = !{!130, !10, i64 24}
!155 = !{!130, !10, i64 32}
!156 = !{!157, !3, i64 36}
!157 = !{!"snd_pcm_chmap", !7, i64 0, !3, i64 8, !7, i64 16, !7, i64 24, !3, i64 32, !3, i64 36, !7, i64 40}
!158 = !{!54, !7, i64 16}
!159 = !{!62, !7, i64 464}
!160 = !{!161, !3, i64 0}
!161 = !{!"snd_interval", !3, i64 0, !3, i64 4, !3, i64 8, !3, i64 8, !3, i64 8, !3, i64 8}
!162 = !{!52, !3, i64 120}
!163 = !{!62, !17, i64 848}
!164 = !{!54, !3, i64 60}
!165 = !{!52, !3, i64 64}
!166 = !{!62, !3, i64 152}
!167 = !{!62, !10, i64 128}
!168 = !{!62, !10, i64 112}
!169 = !{i64 0, i64 4, !2, i64 8, i64 8, !170, i64 16, i64 4, !2, i64 20, i64 4, !2, i64 24, i64 4, !2, i64 28, i64 4, !2, i64 32, i64 4, !2, i64 40, i64 8, !95, i64 48, i64 8, !95, i64 56, i64 8, !95, i64 64, i64 4, !2, i64 68, i64 4, !2, i64 72, i64 8, !95}
!170 = !{!17, !17, i64 0}
!171 = !{!62, !3, i64 496}
!172 = !{!62, !10, i64 520}
!173 = !{!62, !10, i64 536}
!174 = !{!62, !3, i64 512}
!175 = !{!62, !17, i64 488}
!176 = !{!122, !7, i64 8}
!177 = !{!46, !3, i64 948}
!178 = !{!114, !7, i64 8}
!179 = !{!46, !7, i64 1048}
!180 = !{!181, !7, i64 32}
!181 = !{!"snd_device", !15, i64 0, !7, i64 16, !3, i64 24, !3, i64 28, !7, i64 32, !7, i64 40}
!182 = !{!183, !3, i64 16}
!183 = !{!"cpuinfo_x86", !4, i64 0, !4, i64 1, !4, i64 2, !4, i64 3, !3, i64 4, !4, i64 8, !4, i64 9, !4, i64 10, !3, i64 12, !3, i64 16, !4, i64 20, !4, i64 64, !4, i64 80, !3, i64 144, !3, i64 148, !3, i64 152, !10, i64 160, !16, i64 168, !16, i64 170, !16, i64 172, !16, i64 174, !16, i64 176, !16, i64 178, !16, i64 180, !4, i64 182, !16, i64 184, !3, i64 188}
!184 = !{!185, !7, i64 216}
!185 = !{!"pv_cpu_ops", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !7, i64 200, !7, i64 208, !7, i64 216, !7, i64 224, !7, i64 232, !7, i64 240, !7, i64 248, !7, i64 256, !7, i64 264, !7, i64 272, !7, i64 280, !7, i64 288, !7, i64 296, !7, i64 304, !7, i64 312}
!186 = !{i32 -2146586180, i32 -2146586155, i32 -2146585885, i32 -2146586088, i32 -2146586057, i32 -2146586027}
!187 = !{i32 -2146586852, i32 -2146585634, i32 -2146585612, i32 -2146585599, i32 -2146585276, i32 -2146585209, i32 -2146585507, i32 -2146585480, i32 -2146585452, i32 -2146585422}
