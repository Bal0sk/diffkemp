; ModuleID = '/diffkemp/kernel/linux-3.10/sound/core/sound.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_symbol = type { i64, i8* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.42 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.42 = type { i8* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.kref, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.cpumask, %struct.cpumask, %struct.cpumask, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.cpumask*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.36, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.cpumask, %struct.atomic_t, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.mod_arch_specific }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.cpumask*, %struct.cpumask*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.page = type { i64, %struct.address_space*, %struct.anon.22, %union.anon.36, %struct.pgprot, [8 x i8] }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %struct.atomic_t, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.33, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.35, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.atomic_t, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.36, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type opaque
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.mod_arch_specific, %struct.mod_arch_specific, %struct.mod_arch_specific, [3 x %struct.mod_arch_specific], %struct.mod_arch_specific, %struct.mod_arch_specific, %struct.mod_arch_specific }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %struct.atomic_t, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.shrink_control = type { i32, i64 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%union.anon.33 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.40 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.40 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.35 = type { %struct.pipe_inode_info* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.42, i32 }
%struct.swap_info_struct = type opaque
%struct.anon.22 = type { %struct.pgprot, %struct.pgprot }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.file = type { %union.anon.36, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%struct.fown_struct = type { %struct.kref, %struct.pid*, i32, i32, i32, i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.load_weight = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.2, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.36, %struct.pgprot }
%union.anon.2 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.6 }
%union.anon.6 = type { %struct.exception_table_entry }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.9, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.12 }
%union.anon.9 = type { %struct.load_weight }
%union.anon.12 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type { %struct.kref, %struct.new_utsname, %struct.user_namespace*, i32 }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.net = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.cpumask }
%struct.sigpending = type { %struct.list_head, %struct.cpumask }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%union.anon.36 = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.14 }
%union.anon.14 = type { %struct.anon.18, [80 x i8] }
%struct.anon.18 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.cpumask = type { [1 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.snd_minor = type { i32, i32, i32, %struct.file_operations*, i8*, %struct.device*, %struct.snd_card* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.42, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.mod_arch_specific }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.atomic_t, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.snd_card = type { i32, [16 x i8], [16 x i8], [32 x i8], [80 x i8], [80 x i8], [128 x i8], %struct.module*, i8*, void (%struct.snd_card*)*, %struct.list_head, i32, %struct.rw_semaphore, %struct.kref, i32, i32, %struct.list_head, %struct.list_head, %struct.snd_info_entry*, %struct.snd_info_entry*, %struct.proc_dir_entry*, %struct.list_head, %struct.snd_shutdown_f_ops*, %struct.spinlock, i32, i32, %struct.__wait_queue_head, %struct.atomic_t, %struct.device*, %struct.device*, i32, %struct.mutex, %struct.__wait_queue_head, %struct.snd_mixer_oss*, i32 }
%struct.snd_info_entry = type { i8*, i16, i64, i16, %union.anon.43, %struct.snd_info_entry*, %struct.snd_card*, %struct.module*, i8*, void (%struct.snd_info_entry*)*, %struct.proc_dir_entry*, %struct.mutex, %struct.list_head, %struct.list_head }
%union.anon.43 = type { %struct.snd_info_entry_text }
%struct.snd_info_entry_text = type { void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* }
%struct.snd_info_buffer = type { i8*, i32, i32, i32, i32, i32 }
%struct.proc_dir_entry = type opaque
%struct.snd_shutdown_f_ops = type opaque
%struct.snd_mixer_oss = type opaque
%struct.snd_device_ops = type { i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)*, i32 (%struct.snd_device*)* }
%struct.snd_device = type { %struct.list_head, %struct.snd_card*, i32, i32, i8*, %struct.snd_device_ops* }
%struct.snd_info_private_data = type { %struct.snd_info_buffer*, %struct.snd_info_buffer*, %struct.snd_info_entry*, i8* }
%struct.snd_info_entry_ops = type { i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8*)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }

@snd_major = common global i32 0, align 4
@snd_ecards_limit = common global i32 0, align 4
@llvm.used = appending global [25 x i8*] [i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_major to i8*), i8* bitcast (%struct.kernel_param* @__param_major to i8*), i8* bitcast (%struct.kernel_param* @__param_cards_limit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_ecards_limit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_request_card to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_lookup_minor_data to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_register_device_for_dev to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_unregister_device to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_add_device_sysfs_file to i8*), i8* bitcast (i32 ()* @snd_minor_info_done to i8*), i8* bitcast (void ()* @alsa_sound_exit to i8*), i8* bitcast (i32 ()** @__initcall_alsa_sound_init4 to i8*), i8* bitcast (void ()** @__exitcall_alsa_sound_exit to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_iprintf to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_seq_root to i8*), i8* bitcast (i32 ()* @snd_info_done to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_get_line to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_get_str to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_create_module_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_create_card_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_card_proc_new to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_free_entry to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_info_register to i8*), i8* bitcast (i32 ()* @snd_info_version_done to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_snd_oss_info_register to i8*)], section "llvm.metadata"
@__ksymtab_snd_major = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @snd_major to i64), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__kstrtab_snd_major, i32 0, i32 0) }, section "___ksymtab+snd_major", align 8
@__param_major = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_major, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.42 { i8* bitcast (i32* @major to i8*) } }, section "__param", align 8
@__param_cards_limit = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_cards_limit, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.42 { i8* bitcast (i32* @cards_limit to i8*) } }, section "__param", align 8
@__ksymtab_snd_ecards_limit = internal constant %struct.kernel_symbol { i64 ptrtoint (i32* @snd_ecards_limit to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_ecards_limit, i32 0, i32 0) }, section "___ksymtab+snd_ecards_limit", align 8
@__ksymtab_snd_request_card = internal constant %struct.kernel_symbol { i64 ptrtoint (void (i32)* @snd_request_card to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_request_card, i32 0, i32 0) }, section "___ksymtab+snd_request_card", align 8
@__ksymtab_snd_lookup_minor_data = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i32, i32)* @snd_lookup_minor_data to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_lookup_minor_data, i32 0, i32 0) }, section "___ksymtab+snd_lookup_minor_data", align 8
@__ksymtab_snd_register_device_for_dev = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32, %struct.file_operations*, i8*, i8*, %struct.device*)* @snd_register_device_for_dev to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_snd_register_device_for_dev, i32 0, i32 0) }, section "___ksymtab+snd_register_device_for_dev", align 8
@__ksymtab_snd_unregister_device = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32)* @snd_unregister_device to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_unregister_device, i32 0, i32 0) }, section "___ksymtab+snd_unregister_device", align 8
@__ksymtab_snd_add_device_sysfs_file = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, %struct.snd_card*, i32, %struct.device_attribute*)* @snd_add_device_sysfs_file to i64), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__kstrtab_snd_add_device_sysfs_file, i32 0, i32 0) }, section "___ksymtab+snd_add_device_sysfs_file", align 8
@__initcall_alsa_sound_init4 = internal global i32 ()* @alsa_sound_init, section ".initcall4.init", align 8
@__exitcall_alsa_sound_exit = internal global void ()* @alsa_sound_exit, section ".exitcall.exit", align 8
@major = internal global i32 116, align 4
@cards_limit = internal global i32 1, align 4
@.str.3 = private unnamed_addr constant [5 x i8] c"alsa\00", align 1
@snd_fops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @noop_llseek, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* null, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.15 = private unnamed_addr constant [52 x i8] c"\013unable to register native major device number %d\0A\00", align 1
@.str.16 = private unnamed_addr constant [57 x i8] c"\016Advanced Linux Sound Architecture Driver Initialized.\0A\00", align 1
@sound_mutex = internal global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_mutex to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @sound_mutex to i8*), i64 8) to %struct.list_head*) }, %struct.task_struct* null, i8* null }, align 8
@snd_minors = internal global [256 x %struct.snd_minor*] zeroinitializer, align 16
@snd_cards = external global [32 x %struct.snd_card*], align 16
@.str.18 = private unnamed_addr constant [10 x i8] c"snd-timer\00", align 1
@.str.17 = private unnamed_addr constant [8 x i8] c"snd-seq\00", align 1
@.str = private unnamed_addr constant [12 x i8] c"snd-card-%i\00", align 1
@snd_minor_info_entry = internal global %struct.snd_info_entry* null, align 8
@__kstrtab_snd_add_device_sysfs_file = internal constant [26 x i8] c"snd_add_device_sysfs_file\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_unregister_device = internal constant [22 x i8] c"snd_unregister_device\00", section "__ksymtab_strings", align 1
@sound_class = external global %struct.class*, align 8
@__kstrtab_snd_register_device_for_dev = internal constant [28 x i8] c"snd_register_device_for_dev\00", section "__ksymtab_strings", align 1
@.str.1 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@__kstrtab_snd_lookup_minor_data = internal constant [22 x i8] c"snd_lookup_minor_data\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_request_card = internal constant [17 x i8] c"snd_request_card\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_ecards_limit = internal constant [17 x i8] c"snd_ecards_limit\00", section "__ksymtab_strings", align 1
@__param_str_cards_limit = internal constant [16 x i8] c"snd.cards_limit\00", align 16
@param_ops_int = external global %struct.kernel_param_ops, align 8
@__param_str_major = internal constant [10 x i8] c"snd.major\00", align 1
@__kstrtab_snd_major = internal constant [10 x i8] c"snd_major\00", section "__ksymtab_strings", align 1
@.str.4 = private unnamed_addr constant [20 x i8] c"%3i: [%2i-%2i]: %s\0A\00", align 1
@.str.5 = private unnamed_addr constant [19 x i8] c"%3i: [%2i]   : %s\0A\00", align 1
@.str.6 = private unnamed_addr constant [18 x i8] c"%3i:        : %s\0A\00", align 1
@.str.14 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.13 = private unnamed_addr constant [6 x i8] c"timer\00", align 1
@.str.12 = private unnamed_addr constant [10 x i8] c"sequencer\00", align 1
@.str.11 = private unnamed_addr constant [22 x i8] c"digital audio capture\00", align 1
@.str.10 = private unnamed_addr constant [23 x i8] c"digital audio playback\00", align 1
@.str.9 = private unnamed_addr constant [9 x i8] c"raw midi\00", align 1
@.str.8 = private unnamed_addr constant [19 x i8] c"hardware dependent\00", align 1
@.str.7 = private unnamed_addr constant [8 x i8] c"control\00", align 1
@snd_seq_root = common global %struct.snd_info_entry* null, align 8
@snd_oss_root = common global %struct.snd_info_entry* null, align 8
@__ksymtab_snd_iprintf = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_buffer*, i8*, ...)* @snd_iprintf to i64), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__kstrtab_snd_iprintf, i32 0, i32 0) }, section "___ksymtab+snd_iprintf", align 8
@__ksymtab_snd_seq_root = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry** @snd_seq_root to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_snd_seq_root, i32 0, i32 0) }, section "___ksymtab+snd_seq_root", align 8
@__ksymtab_snd_info_get_line = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_buffer*, i8*, i32)* @snd_info_get_line to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_info_get_line, i32 0, i32 0) }, section "___ksymtab+snd_info_get_line", align 8
@__ksymtab_snd_info_get_str = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (i8*, i8*, i32)* @snd_info_get_str to i64), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__kstrtab_snd_info_get_str, i32 0, i32 0) }, section "___ksymtab+snd_info_get_str", align 8
@__ksymtab_snd_info_create_module_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry* (%struct.module*, i8*, %struct.snd_info_entry*)* @snd_info_create_module_entry to i64), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__kstrtab_snd_info_create_module_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_create_module_entry", align 8
@__ksymtab_snd_info_create_card_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.snd_info_entry* (%struct.snd_card*, i8*, %struct.snd_info_entry*)* @snd_info_create_card_entry to i64), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__kstrtab_snd_info_create_card_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_create_card_entry", align 8
@__ksymtab_snd_card_proc_new = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_card*, i8*, %struct.snd_info_entry**)* @snd_card_proc_new to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_card_proc_new, i32 0, i32 0) }, section "___ksymtab+snd_card_proc_new", align 8
@__ksymtab_snd_info_free_entry = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.snd_info_entry*)* @snd_info_free_entry to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_snd_info_free_entry, i32 0, i32 0) }, section "___ksymtab+snd_info_free_entry", align 8
@__ksymtab_snd_info_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.snd_info_entry*)* @snd_info_register to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_snd_info_register, i32 0, i32 0) }, section "___ksymtab+snd_info_register", align 8
@snd_info_version_entry = internal global %struct.snd_info_entry* null, align 8
@info_mutex = internal global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @info_mutex to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @info_mutex to i8*), i64 8) to %struct.list_head*) }, %struct.task_struct* null, i8* null }, align 8
@snd_proc_root = internal global %struct.proc_dir_entry* null, align 8
@__kstrtab_snd_info_register = internal constant [18 x i8] c"snd_info_register\00", section "__ksymtab_strings", align 1
@snd_info_entry_operations = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @snd_info_entry_llseek, i64 (%struct.file*, i8*, i64, i64*)* @snd_info_entry_read, i64 (%struct.file*, i8*, i64, i64*)* @snd_info_entry_write, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @snd_info_entry_poll, i64 (%struct.file*, i32, i64)* @snd_info_entry_ioctl, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* @snd_info_entry_mmap, i32 (%struct.inode*, %struct.file*)* @snd_info_entry_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @snd_info_entry_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@.str.15.8 = private unnamed_addr constant [31 x i8] c"\014data write error to %s (%i)\0A\00", align 1
@__kstrtab_snd_info_free_entry = internal constant [20 x i8] c"snd_info_free_entry\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_card_proc_new = internal constant [18 x i8] c"snd_card_proc_new\00", section "__ksymtab_strings", align 1
@snd_card_proc_new.ops = internal global %struct.snd_device_ops { i32 (%struct.snd_device*)* @snd_info_dev_free_entry, i32 (%struct.snd_device*)* @snd_info_dev_register_entry, i32 (%struct.snd_device*)* null }, align 8
@.str.14.10 = private unnamed_addr constant [15 x i8] c"&entry->access\00", align 1
@snd_info_create_entry.__key = internal global %struct.mod_arch_specific zeroinitializer, align 1
@__kstrtab_snd_info_create_card_entry = internal constant [27 x i8] c"snd_info_create_card_entry\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_info_create_module_entry = internal constant [29 x i8] c"snd_info_create_module_entry\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_info_get_str = internal constant [17 x i8] c"snd_info_get_str\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_info_get_line = internal constant [18 x i8] c"snd_info_get_line\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_seq_root = internal constant [13 x i8] c"snd_seq_root\00", section "__ksymtab_strings", align 1
@__kstrtab_snd_iprintf = internal constant [12 x i8] c"snd_iprintf\00", section "__ksymtab_strings", align 1
@snd_info_check_reserved_words.reserved = internal global [12 x i8*] [i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1.20, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.2.21, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.3.22, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.4.23, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.24, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6.25, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.7.26, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8.27, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9.28, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.29, i32 0, i32 0), i8* null], align 16
@.str.11.15 = private unnamed_addr constant [5 x i8] c"card\00", align 1
@.str.19 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.1.20 = private unnamed_addr constant [8 x i8] c"meminfo\00", align 1
@.str.2.21 = private unnamed_addr constant [9 x i8] c"memdebug\00", align 1
@.str.3.22 = private unnamed_addr constant [7 x i8] c"detect\00", align 1
@.str.4.23 = private unnamed_addr constant [8 x i8] c"devices\00", align 1
@.str.5.24 = private unnamed_addr constant [4 x i8] c"oss\00", align 1
@.str.6.25 = private unnamed_addr constant [6 x i8] c"cards\00", align 1
@.str.7.26 = private unnamed_addr constant [7 x i8] c"timers\00", align 1
@.str.8.27 = private unnamed_addr constant [6 x i8] c"synth\00", align 1
@.str.9.28 = private unnamed_addr constant [4 x i8] c"pcm\00", align 1
@.str.10.29 = private unnamed_addr constant [4 x i8] c"seq\00", align 1
@.str.12.32 = private unnamed_addr constant [7 x i8] c"asound\00", align 1
@.str.16.33 = private unnamed_addr constant [55 x i8] c"Advanced Linux Sound Architecture Driver Version k%s.\0A\00", align 1
@init_uts_ns = external global %struct.uts_namespace, align 8
@.str.13.34 = private unnamed_addr constant [7 x i8] c"card%i\00", align 1
@__ksymtab_snd_oss_info_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (i32, i32, i8*)* @snd_oss_info_register to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_snd_oss_info_register, i32 0, i32 0) }, section "___ksymtab+snd_oss_info_register", align 8
@__kstrtab_snd_oss_info_register = internal constant [22 x i8] c"snd_oss_info_register\00", section "__ksymtab_strings", align 1
@strings = internal global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @strings to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @strings to i8*), i64 8) to %struct.list_head*) }, %struct.task_struct* null, i8* null }, align 8
@snd_sndstat_strings = internal global [32 x [6 x i8*]] zeroinitializer, align 16
@.str.38 = private unnamed_addr constant [8 x i8] c"sndstat\00", align 1
@snd_sndstat_proc_entry = internal global %struct.snd_info_entry* null, align 8
@.str.1.39 = private unnamed_addr constant [50 x i8] c"Sound Driver:3.8.1a-980706 (ALSA emulation code)\0A\00", align 1
@.str.2.41 = private unnamed_addr constant [24 x i8] c"Kernel: %s %s %s %s %s\0A\00", align 1
@.str.3.42 = private unnamed_addr constant [19 x i8] c"Config options: 0\0A\00", align 1
@.str.4.43 = private unnamed_addr constant [22 x i8] c"\0AInstalled drivers: \0A\00", align 1
@.str.5.44 = private unnamed_addr constant [25 x i8] c"Type 10: ALSA emulation\0A\00", align 1
@.str.6.45 = private unnamed_addr constant [16 x i8] c"\0ACard config: \0A\00", align 1
@.str.7.46 = private unnamed_addr constant [14 x i8] c"Audio devices\00", align 1
@.str.8.47 = private unnamed_addr constant [14 x i8] c"Synth devices\00", align 1
@.str.9.48 = private unnamed_addr constant [13 x i8] c"Midi devices\00", align 1
@.str.10.49 = private unnamed_addr constant [7 x i8] c"Timers\00", align 1
@.str.11.50 = private unnamed_addr constant [7 x i8] c"Mixers\00", align 1
@.str.12.51 = private unnamed_addr constant [5 x i8] c"\0A%s:\00", align 1
@.str.13.52 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.14.53 = private unnamed_addr constant [8 x i8] c"%i: %s\0A\00", align 1
@.str.15.54 = private unnamed_addr constant [24 x i8] c" NOT ENABLED IN CONFIG\0A\00", align 1

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_done() #0 section ".exit.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_minor_info_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @alsa_sound_exit() #0 section ".exit.text" {
entry:
  %call = call i32 @snd_info_minor_unregister()
  %call1 = call i32 @snd_info_done()
  %0 = load i32, i32* @major, align 4, !tbaa !6
  call void @unregister_chrdev(i32 %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @alsa_sound_init() #0 section ".init.text" {
entry:
  %0 = load i32, i32* @major, align 4, !tbaa !6
  store i32 %0, i32* @snd_major, align 4, !tbaa !6
  %1 = load i32, i32* @cards_limit, align 4, !tbaa !6
  store i32 %1, i32* @snd_ecards_limit, align 4, !tbaa !6
  %2 = load i32, i32* @major, align 4, !tbaa !6
  %call = call i32 @register_chrdev(i32 %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0), %struct.file_operations* @snd_fops)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* @major, align 4, !tbaa !6
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.15, i32 0, i32 0), i32 %3)
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i32 @snd_info_init()
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %4 = load i32, i32* @major, align 4, !tbaa !6
  call void @unregister_chrdev(i32 %4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0))
  br label %return

if.end4:                                          ; preds = %if.end
  %call5 = call i32 @snd_info_minor_register()
  %call6 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.16, i32 0, i32 0))
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %retval.0 = phi i32 [ -5, %if.then ], [ -12, %if.then3 ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @register_chrdev(i32 %major, i8* %name, %struct.file_operations* %fops) #1 {
entry:
  %call = call i32 @__register_chrdev(i32 %major, i32 0, i32 256, i8* %name, %struct.file_operations* %fops)
  ret i32 %call
}

declare i32 @printk(i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @unregister_chrdev(i32 %major, i8* %name) #1 {
entry:
  call void @__unregister_chrdev(i32 %major, i32 0, i32 256, i8* %name)
  ret void
}

declare void @__unregister_chrdev(i32, i32, i32, i8*) #2

declare i32 @__register_chrdev(i32, i32, i32, i8*, %struct.file_operations*) #2

declare i64 @noop_llseek(%struct.file*, i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @snd_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i32 @iminor(%struct.inode* %inode)
  %conv = zext i32 %call to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @sound_mutex)
  %idxprom = zext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp eq %struct.snd_minor* %0, null
  br i1 %cmp2, label %if.then4, label %if.end8

if.then4:                                         ; preds = %if.end
  %call5 = call %struct.snd_minor* @autoload_device(i32 %call)
  %tobool = icmp ne %struct.snd_minor* %call5, null
  br i1 %tobool, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.then4
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

if.end8:                                          ; preds = %if.then4, %if.end
  %mptr.0 = phi %struct.snd_minor* [ %0, %if.end ], [ %call5, %if.then4 ]
  %f_op = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %1 = load %struct.file_operations*, %struct.file_operations** %f_op, align 8, !tbaa !8
  %f_ops = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %2 = load %struct.file_operations*, %struct.file_operations** %f_ops, align 8, !tbaa !19
  %tobool9 = icmp ne %struct.file_operations* %2, null
  br i1 %tobool9, label %land.lhs.true, label %cond.end

land.lhs.true:                                    ; preds = %if.end8
  %f_ops10 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %3 = load %struct.file_operations*, %struct.file_operations** %f_ops10, align 8, !tbaa !19
  %owner = getelementptr inbounds %struct.file_operations, %struct.file_operations* %3, i32 0, i32 0
  %4 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !21
  %call11 = call zeroext i1 @try_module_get(%struct.module* %4)
  br i1 %call11, label %cond.true, label %cond.end

cond.true:                                        ; preds = %land.lhs.true
  %f_ops13 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %mptr.0, i32 0, i32 3
  %5 = load %struct.file_operations*, %struct.file_operations** %f_ops13, align 8, !tbaa !19
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %land.lhs.true, %if.end8
  %cond = phi %struct.file_operations* [ %5, %cond.true ], [ null, %land.lhs.true ], [ null, %if.end8 ]
  %f_op14 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %cond, %struct.file_operations** %f_op14, align 8, !tbaa !8
  %f_op15 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %6 = load %struct.file_operations*, %struct.file_operations** %f_op15, align 8, !tbaa !8
  %cmp16 = icmp eq %struct.file_operations* %6, null
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %cond.end
  %f_op19 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %1, %struct.file_operations** %f_op19, align 8, !tbaa !8
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %cond.end
  %err.0 = phi i32 [ -19, %if.then18 ], [ 0, %cond.end ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %cmp21 = icmp slt i32 %err.0, 0
  br i1 %cmp21, label %cleanup, label %if.end24

if.end24:                                         ; preds = %if.end20
  %f_op25 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %7 = load %struct.file_operations*, %struct.file_operations** %f_op25, align 8, !tbaa !8
  %open = getelementptr inbounds %struct.file_operations, %struct.file_operations* %7, i32 0, i32 11
  %8 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open, align 8, !tbaa !23
  %tobool26 = icmp ne i32 (%struct.inode*, %struct.file*)* %8, null
  br i1 %tobool26, label %if.then27, label %do.body51

if.then27:                                        ; preds = %if.end24
  %f_op28 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %9 = load %struct.file_operations*, %struct.file_operations** %f_op28, align 8, !tbaa !8
  %open29 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %9, i32 0, i32 11
  %10 = load i32 (%struct.inode*, %struct.file*)*, i32 (%struct.inode*, %struct.file*)** %open29, align 8, !tbaa !23
  %call30 = call i32 %10(%struct.inode* %inode, %struct.file* %file)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %do.body, label %do.body51

do.body:                                          ; preds = %if.then27
  %f_op33 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %11 = load %struct.file_operations*, %struct.file_operations** %f_op33, align 8, !tbaa !8
  %tobool34 = icmp ne %struct.file_operations* %11, null
  br i1 %tobool34, label %if.then35, label %do.end

if.then35:                                        ; preds = %do.body
  %f_op36 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  %12 = load %struct.file_operations*, %struct.file_operations** %f_op36, align 8, !tbaa !8
  %owner37 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %12, i32 0, i32 0
  %13 = load %struct.module*, %struct.module** %owner37, align 8, !tbaa !21
  call void @module_put(%struct.module* %13)
  br label %do.end

do.end:                                           ; preds = %if.then35, %do.body
  %tobool39 = icmp ne %struct.file_operations* %1, null
  br i1 %tobool39, label %land.lhs.true40, label %cond.false45

land.lhs.true40:                                  ; preds = %do.end
  %owner41 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %1, i32 0, i32 0
  %14 = load %struct.module*, %struct.module** %owner41, align 8, !tbaa !21
  %call42 = call zeroext i1 @try_module_get(%struct.module* %14)
  br i1 %call42, label %cond.end46, label %cond.false45

cond.false45:                                     ; preds = %land.lhs.true40, %do.end
  br label %cond.end46

cond.end46:                                       ; preds = %cond.false45, %land.lhs.true40
  %cond47 = phi %struct.file_operations* [ null, %cond.false45 ], [ %1, %land.lhs.true40 ]
  %f_op48 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 3
  store %struct.file_operations* %cond47, %struct.file_operations** %f_op48, align 8, !tbaa !8
  br label %do.body51

do.body51:                                        ; preds = %cond.end46, %if.then27, %if.end24
  %err.1 = phi i32 [ %err.0, %if.end24 ], [ %call30, %cond.end46 ], [ %call30, %if.then27 ]
  %tobool52 = icmp ne %struct.file_operations* %1, null
  br i1 %tobool52, label %if.then53, label %cleanup

if.then53:                                        ; preds = %do.body51
  %owner54 = getelementptr inbounds %struct.file_operations, %struct.file_operations* %1, i32 0, i32 0
  %15 = load %struct.module*, %struct.module** %owner54, align 8, !tbaa !21
  call void @module_put(%struct.module* %15)
  br label %cleanup

cleanup:                                          ; preds = %if.then53, %do.body51, %if.end20, %if.then6, %entry
  %retval.0 = phi i32 [ -19, %if.then6 ], [ -19, %entry ], [ %err.0, %if.end20 ], [ %err.1, %if.then53 ], [ %err.1, %do.body51 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @iminor(%struct.inode* %inode) #1 {
entry:
  %i_rdev = getelementptr inbounds %struct.inode, %struct.inode* %inode, i32 0, i32 13
  %0 = load i32, i32* %i_rdev, align 4, !tbaa !24
  %and = and i32 %0, 1048575
  ret i32 %and
}

declare void @mutex_lock(%struct.mutex*) #2

; Function Attrs: nounwind uwtable
define internal %struct.snd_minor* @autoload_device(i32 %minor) #0 {
entry:
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %and = and i32 %minor, 31
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %and, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 1
  br i1 %SwitchLeaf2, label %if.then4, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and, 0
  br i1 %SwitchLeaf, label %if.then, label %NewDefault

if.then:                                          ; preds = %LeafBlock
  %shr = lshr i32 %minor, 5
  %idxprom = sext i32 %shr to i64
  %arrayidx = getelementptr inbounds [32 x %struct.snd_card*], [32 x %struct.snd_card*]* @snd_cards, i64 0, i64 %idxprom
  %0 = load %struct.snd_card*, %struct.snd_card** %arrayidx, align 8, !tbaa !2
  %cmp1 = icmp eq %struct.snd_card* %0, null
  br i1 %cmp1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.then
  call void @snd_request_card(i32 %shr)
  br label %if.end6

if.then4:                                         ; preds = %LeafBlock1
  call void @snd_request_other(i32 %minor)
  br label %if.end6

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %if.end6

if.end6:                                          ; preds = %NewDefault, %if.then4, %if.then2, %if.then
  call void @mutex_lock(%struct.mutex* @sound_mutex)
  %idxprom7 = zext i32 %minor to i64
  %arrayidx8 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom7
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx8, align 8, !tbaa !2
  ret %struct.snd_minor* %1
}

declare void @mutex_unlock(%struct.mutex*) #2

declare zeroext i1 @try_module_get(%struct.module*) #2

declare void @module_put(%struct.module*) #2

; Function Attrs: nounwind uwtable
define void @snd_request_card(i32 %card) #0 {
entry:
  %call = call i32 @snd_card_locked(i32 %card)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp slt i32 %card, 0
  %0 = load i32, i32* @cards_limit, align 4
  %cmp1 = icmp sge i32 %card, %0
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %call4 = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i32 %card)
  br label %return

return:                                           ; preds = %if.end3, %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_request_other(i32 %minor) #0 {
entry:
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %minor, 33
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %minor, 33
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %minor, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb1:                                           ; preds = %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb1, %LeafBlock
  %str.0 = phi i8* [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18, i32 0, i32 0), %sw.bb1 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.17, i32 0, i32 0), %LeafBlock ]
  %call = call i32 (i1, i8*, ...) @__request_module(i1 zeroext true, i8* %str.0)
  br label %cleanup.cont

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %NewDefault, %sw.epilog
  ret void
}

declare i32 @__request_module(i1 zeroext, i8*, ...) #2

declare i32 @snd_card_locked(i32) #2

; Function Attrs: nounwind uwtable
define i32 @snd_add_device_sysfs_file(i32 %type, %struct.snd_card* %card, i32 %dev, %struct.device_attribute* %attr) #0 {
entry:
  call void @mutex_lock(%struct.mutex* @sound_mutex)
  %call = call i32 @find_snd_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %cmp = icmp sge i32 %call, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %dev1 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  %1 = load %struct.device*, %struct.device** %dev1, align 8, !tbaa !35
  %cmp2 = icmp ne %struct.device* %1, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call3 = call i32 @device_create_file(%struct.device* %1, %struct.device_attribute* %attr)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %ret.0 = phi i32 [ %call3, %if.then ], [ -22, %land.lhs.true ], [ -22, %entry ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i32 @find_snd_minor(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %entry
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %0 = load i32, i32* %number, align 8, !tbaa !36
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %entry
  %cond = phi i32 [ %0, %cond.true ], [ -1, %entry ]
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %minor.0 = phi i32 [ 0, %cond.end ], [ %inc, %for.inc ]
  %conv = sext i32 %minor.0 to i64
  %cmp = icmp ult i64 %conv, 256
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %1 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %cmp2 = icmp ne %struct.snd_minor* %1, null
  br i1 %cmp2, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %type4 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 0
  %2 = load i32, i32* %type4, align 8, !tbaa !42
  %cmp5 = icmp eq i32 %2, %type
  br i1 %cmp5, label %land.lhs.true7, label %for.inc

land.lhs.true7:                                   ; preds = %land.lhs.true
  %card8 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 1
  %3 = load i32, i32* %card8, align 4, !tbaa !43
  %cmp9 = icmp eq i32 %3, %cond
  br i1 %cmp9, label %land.lhs.true11, label %for.inc

land.lhs.true11:                                  ; preds = %land.lhs.true7
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %1, i32 0, i32 2
  %4 = load i32, i32* %device, align 8, !tbaa !44
  %cmp12 = icmp eq i32 %4, %dev
  br i1 %cmp12, label %cleanup, label %for.inc

for.inc:                                          ; preds = %land.lhs.true11, %land.lhs.true7, %land.lhs.true, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

cleanup:                                          ; preds = %land.lhs.true11, %for.cond
  %retval.0 = phi i32 [ %minor.0, %land.lhs.true11 ], [ -1, %for.cond ]
  ret i32 %retval.0
}

declare i32 @device_create_file(%struct.device*, %struct.device_attribute*) #2

; Function Attrs: nounwind uwtable
define i32 @snd_unregister_device(i32 %type, %struct.snd_card* %card, i32 %dev) #0 {
entry:
  call void @mutex_lock(%struct.mutex* @sound_mutex)
  %call = call i32 @find_snd_minor(i32 %type, %struct.snd_card* %card, i32 %dev)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

if.end:                                           ; preds = %entry
  %0 = load %struct.class*, %struct.class** @sound_class, align 8, !tbaa !2
  %1 = load i32, i32* @major, align 4, !tbaa !6
  %shl = shl i32 %1, 20
  %or = or i32 %shl, %call
  call void @device_destroy(%struct.class* %0, i32 %or)
  %idxprom = sext i32 %call to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %2 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %3 = bitcast %struct.snd_minor* %2 to i8*
  call void @kfree(i8* %3)
  %idxprom1 = sext i32 %call to i64
  %arrayidx2 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom1
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx2, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ -22, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare void @device_destroy(%struct.class*, i32) #2

declare void @kfree(i8*) #2

; Function Attrs: nounwind uwtable
define i32 @snd_register_device_for_dev(i32 %type, %struct.snd_card* %card, i32 %dev, %struct.file_operations* %f_ops, i8* %private_data, i8* %name, %struct.device* %device) #0 {
entry:
  %tobool = icmp ne i8* %name, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call = call i8* @kmalloc(i64 48, i32 208)
  %0 = bitcast i8* %call to %struct.snd_minor*
  %cmp = icmp eq %struct.snd_minor* %0, null
  br i1 %cmp, label %cleanup, label %if.end11

if.end11:                                         ; preds = %if.end
  %type12 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  store i32 %type, i32* %type12, align 8, !tbaa !42
  %tobool13 = icmp ne %struct.snd_card* %card, null
  br i1 %tobool13, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end11
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !36
  br label %cond.end

cond.end:                                         ; preds = %cond.true, %if.end11
  %cond = phi i32 [ %1, %cond.true ], [ -1, %if.end11 ]
  %card14 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  store i32 %cond, i32* %card14, align 4, !tbaa !43
  %device15 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  store i32 %dev, i32* %device15, align 8, !tbaa !44
  %f_ops16 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 3
  store %struct.file_operations* %f_ops, %struct.file_operations** %f_ops16, align 8, !tbaa !19
  %private_data17 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 4
  store i8* %private_data, i8** %private_data17, align 8, !tbaa !45
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  store %struct.snd_card* %card, %struct.snd_card** %card_ptr, align 8, !tbaa !46
  call void @mutex_lock(%struct.mutex* @sound_mutex)
  %call18 = call i32 @snd_find_free_minor(i32 %type)
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %cond.end
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %2 = bitcast %struct.snd_minor* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end22:                                         ; preds = %cond.end
  %idxprom = sext i32 %call18 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  store %struct.snd_minor* %0, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %3 = load %struct.class*, %struct.class** @sound_class, align 8, !tbaa !2
  %4 = load i32, i32* @major, align 4, !tbaa !6
  %shl = shl i32 %4, 20
  %or = or i32 %shl, %call18
  %call23 = call %struct.device* (%struct.class*, %struct.device*, i32, i8*, i8*, ...) @device_create(%struct.class* %3, %struct.device* %device, i32 %or, i8* %private_data, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8* %name)
  %dev24 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  store %struct.device* %call23, %struct.device** %dev24, align 8, !tbaa !35
  %dev25 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  %5 = load %struct.device*, %struct.device** %dev25, align 8, !tbaa !35
  %6 = bitcast %struct.device* %5 to i8*
  %call26 = call i64 @IS_ERR(i8* %6)
  %tobool27 = icmp ne i64 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.end34

if.then28:                                        ; preds = %if.end22
  %idxprom29 = sext i32 %call18 to i64
  %arrayidx30 = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom29
  store %struct.snd_minor* null, %struct.snd_minor** %arrayidx30, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  %dev31 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 5
  %7 = load %struct.device*, %struct.device** %dev31, align 8, !tbaa !35
  %8 = bitcast %struct.device* %7 to i8*
  %call32 = call i64 @PTR_ERR(i8* %8)
  %conv33 = trunc i64 %call32 to i32
  %9 = bitcast %struct.snd_minor* %0 to i8*
  call void @kfree(i8* %9)
  br label %cleanup

if.end34:                                         ; preds = %if.end22
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end34, %if.then28, %if.then21, %if.end, %entry
  %retval.0 = phi i32 [ %call18, %if.then21 ], [ %conv33, %if.then28 ], [ 0, %if.end34 ], [ -22, %entry ], [ -12, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #4 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_find_free_minor(i32 %type) #0 {
entry:
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %type, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %type, 2
  br i1 %SwitchLeaf2, label %if.then2, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %type, 1
  br i1 %SwitchLeaf, label %cleanup, label %NewDefault

if.then2:                                         ; preds = %LeafBlock1
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %if.end3

if.end3:                                          ; preds = %NewDefault
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %minor.0 = phi i32 [ 0, %if.end3 ], [ %inc, %for.inc ]
  %conv = sext i32 %minor.0 to i64
  %cmp4 = icmp ult i64 %conv, 256
  br i1 %cmp4, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %and = and i32 %minor.0, 31
  %cmp6 = icmp eq i32 %and, 0
  br i1 %cmp6, label %for.inc, label %if.end9

if.end9:                                          ; preds = %for.body
  br label %NodeBlock8

NodeBlock8:                                       ; preds = %if.end9
  %Pivot9 = icmp slt i32 %minor.0, 33
  br i1 %Pivot9, label %LeafBlock4, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock8
  %SwitchLeaf7 = icmp eq i32 %minor.0, 33
  br i1 %SwitchLeaf7, label %for.inc, label %NewDefault3

LeafBlock4:                                       ; preds = %NodeBlock8
  %SwitchLeaf5 = icmp eq i32 %minor.0, 1
  br i1 %SwitchLeaf5, label %for.inc, label %NewDefault3

NewDefault3:                                      ; preds = %LeafBlock4, %LeafBlock6
  br label %if.end15

if.end15:                                         ; preds = %NewDefault3
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %for.inc, label %cleanup

for.inc:                                          ; preds = %if.end15, %LeafBlock4, %LeafBlock6, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

cleanup:                                          ; preds = %if.end15, %for.cond, %if.then2, %LeafBlock
  %retval.0 = phi i32 [ 33, %if.then2 ], [ 1, %LeafBlock ], [ %minor.0, %if.end15 ], [ -16, %for.cond ]
  ret i32 %retval.0
}

declare %struct.device* @device_create(%struct.class*, %struct.device*, i32, i8*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #1 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare i8* @__kmalloc(i64, i32) #2

; Function Attrs: nounwind uwtable
define i8* @snd_lookup_minor_data(i32 %minor, i32 %type) #0 {
entry:
  %conv = zext i32 %minor to i64
  %cmp = icmp uge i64 %conv, 256
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @sound_mutex)
  %idxprom = zext i32 %minor to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end13

land.lhs.true:                                    ; preds = %if.end
  %type2 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %1 = load i32, i32* %type2, align 8, !tbaa !42
  %cmp3 = icmp eq i32 %1, %type
  br i1 %cmp3, label %if.then5, label %if.end13

if.then5:                                         ; preds = %land.lhs.true
  %private_data6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 4
  %2 = load i8*, i8** %private_data6, align 8, !tbaa !45
  %tobool7 = icmp ne i8* %2, null
  br i1 %tobool7, label %land.lhs.true8, label %if.end13

land.lhs.true8:                                   ; preds = %if.then5
  %card_ptr = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %3 = load %struct.snd_card*, %struct.snd_card** %card_ptr, align 8, !tbaa !46
  %tobool9 = icmp ne %struct.snd_card* %3, null
  br i1 %tobool9, label %if.then10, label %if.end13

if.then10:                                        ; preds = %land.lhs.true8
  %card_ptr11 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 6
  %4 = load %struct.snd_card*, %struct.snd_card** %card_ptr11, align 8, !tbaa !46
  %refcount = getelementptr inbounds %struct.snd_card, %struct.snd_card* %4, i32 0, i32 27
  call void @atomic_inc(%struct.atomic_t* %refcount)
  br label %if.end13

if.end13:                                         ; preds = %if.then10, %land.lhs.true8, %if.then5, %land.lhs.true, %if.end
  %private_data.0 = phi i8* [ %2, %if.then10 ], [ %2, %land.lhs.true8 ], [ %2, %if.then5 ], [ null, %land.lhs.true ], [ null, %if.end ]
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %entry
  %retval.0 = phi i8* [ %private_data.0, %if.end13 ], [ null, %entry ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #1 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #7, !srcloc !47
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_minor_info_init() #0 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* null, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.4.23, i32 0, i32 0), %struct.snd_info_entry* null)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.43* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_minor_info_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !48
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.then
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.then, %entry
  %entry1.1 = phi %struct.snd_info_entry* [ %call, %entry ], [ null, %if.then3 ], [ %call, %if.then ]
  store %struct.snd_info_entry* %entry1.1, %struct.snd_info_entry** @snd_minor_info_entry, align 8, !tbaa !2
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal void @snd_minor_info_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  call void @mutex_lock(%struct.mutex* @sound_mutex)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %minor.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %minor.0, 256
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %minor.0 to i64
  %arrayidx = getelementptr inbounds [256 x %struct.snd_minor*], [256 x %struct.snd_minor*]* @snd_minors, i64 0, i64 %idxprom
  %0 = load %struct.snd_minor*, %struct.snd_minor** %arrayidx, align 8, !tbaa !2
  %tobool = icmp ne %struct.snd_minor* %0, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %card = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %1 = load i32, i32* %card, align 4, !tbaa !43
  %cmp2 = icmp sge i32 %1, 0
  br i1 %cmp2, label %if.then3, label %if.else14

if.then3:                                         ; preds = %if.end
  %device = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %2 = load i32, i32* %device, align 8, !tbaa !44
  %cmp4 = icmp sge i32 %2, 0
  %card6 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 1
  %3 = load i32, i32* %card6, align 4, !tbaa !43
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  %device7 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 2
  %4 = load i32, i32* %device7, align 8, !tbaa !44
  %type = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %5 = load i32, i32* %type, align 8, !tbaa !42
  %call = call i8* @snd_device_type_name(i32 %5)
  %call8 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.4, i32 0, i32 0), i32 %minor.0, i32 %3, i32 %4, i8* %call)
  br label %for.inc

if.else:                                          ; preds = %if.then3
  %type10 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %6 = load i32, i32* %type10, align 8, !tbaa !42
  %call11 = call i8* @snd_device_type_name(i32 %6)
  %call12 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.5, i32 0, i32 0), i32 %minor.0, i32 %3, i8* %call11)
  br label %for.inc

if.else14:                                        ; preds = %if.end
  %type15 = getelementptr inbounds %struct.snd_minor, %struct.snd_minor* %0, i32 0, i32 0
  %7 = load i32, i32* %type15, align 8, !tbaa !42
  %call16 = call i8* @snd_device_type_name(i32 %7)
  %call17 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.6, i32 0, i32 0), i32 %minor.0, i8* %call16)
  br label %for.inc

for.inc:                                          ; preds = %if.else14, %if.else, %if.then5, %for.body
  %inc = add nsw i32 %minor.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @sound_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @snd_device_type_name(i32 %type) #0 {
entry:
  br label %NodeBlock11

NodeBlock11:                                      ; preds = %entry
  %Pivot12 = icmp slt i32 %type, 3
  br i1 %Pivot12, label %NodeBlock1, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %type, 5
  br i1 %Pivot10, label %NodeBlock3, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %type, 6
  br i1 %Pivot8, label %sw.bb3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %type, 6
  br i1 %SwitchLeaf6, label %sw.bb4, label %NewDefault

NodeBlock3:                                       ; preds = %NodeBlock9
  %Pivot4 = icmp slt i32 %type, 4
  br i1 %Pivot4, label %sw.bb1, label %sw.bb2

NodeBlock1:                                       ; preds = %NodeBlock11
  %Pivot2 = icmp slt i32 %type, 1
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %type, 2
  br i1 %Pivot, label %sw.bb5, label %sw.bb6

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %type, 0
  br i1 %SwitchLeaf, label %return, label %NewDefault

sw.bb1:                                           ; preds = %NodeBlock3
  br label %return

sw.bb2:                                           ; preds = %NodeBlock3
  br label %return

sw.bb3:                                           ; preds = %NodeBlock7
  br label %return

sw.bb4:                                           ; preds = %LeafBlock5
  br label %return

sw.bb5:                                           ; preds = %NodeBlock
  br label %return

sw.bb6:                                           ; preds = %NodeBlock
  br label %return

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock5
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  br label %return

return:                                           ; preds = %sw.default, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %LeafBlock
  %retval.0 = phi i8* [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.14, i32 0, i32 0), %sw.default ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.13, i32 0, i32 0), %sw.bb6 ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), %sw.bb5 ], [ getelementptr inbounds ([22 x i8], [22 x i8]* @.str.11, i32 0, i32 0), %sw.bb4 ], [ getelementptr inbounds ([23 x i8], [23 x i8]* @.str.10, i32 0, i32 0), %sw.bb3 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0), %sw.bb2 ], [ getelementptr inbounds ([19 x i8], [19 x i8]* @.str.8, i32 0, i32 0), %sw.bb1 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.7, i32 0, i32 0), %LeafBlock ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_done() #0 section ".exit.text" {
entry:
  %call = call i32 @snd_card_info_done()
  %call1 = call i32 @snd_minor_info_oss_done()
  %call2 = call i32 @snd_minor_info_done()
  %call3 = call i32 @snd_info_version_done()
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_seq_root, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %1)
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %2)
  %3 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  call void @proc_remove(%struct.proc_dir_entry* %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_version_done() #0 section ".exit.text" {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_info_version_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @snd_info_free_entry(%struct.snd_info_entry* %entry1) #0 {
entry:
  %cmp = icmp eq %struct.snd_info_entry* %entry1, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %p = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p, align 8, !tbaa !49
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @mutex_lock(%struct.mutex* @info_mutex)
  call void @snd_info_disconnect(%struct.snd_info_entry* %entry1)
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !51
  call void @kfree(i8* %1)
  %private_free = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 9
  %2 = load void (%struct.snd_info_entry*)*, void (%struct.snd_info_entry*)** %private_free, align 8, !tbaa !52
  %tobool4 = icmp ne void (%struct.snd_info_entry*)* %2, null
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %private_free6 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 9
  %3 = load void (%struct.snd_info_entry*)*, void (%struct.snd_info_entry*)** %private_free6, align 8, !tbaa !52
  call void %3(%struct.snd_info_entry* %entry1)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %4 = bitcast %struct.snd_info_entry* %entry1 to i8*
  call void @kfree(i8* %4)
  br label %return

return:                                           ; preds = %if.end7, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @snd_info_disconnect(%struct.snd_info_entry* %entry1) #0 {
entry:
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %children, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !53
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.list_head* [ %1, %for.body ], [ %0, %entry ]
  %p.0 = phi %struct.list_head* [ %0, %entry ], [ %1, %for.body ]
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next4, align 8, !tbaa !53
  %children3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %p.0, %children3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = bitcast %struct.list_head* %p.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr to %struct.snd_info_entry*
  call void @snd_info_disconnect(%struct.snd_info_entry* %3)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %p5 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p5, align 8, !tbaa !49
  %tobool = icmp ne %struct.proc_dir_entry* %4, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %for.end
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 13
  call void @list_del_init(%struct.list_head* %list)
  %parent = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %5 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent, align 8, !tbaa !54
  %cmp6 = icmp eq %struct.snd_info_entry* %5, null
  br i1 %cmp6, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  %parent7 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %6 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent7, align 8, !tbaa !54
  %p8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %6, i32 0, i32 10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end
  %p8.sink = phi %struct.proc_dir_entry** [ %p8, %cond.false ], [ @snd_proc_root, %if.end ]
  %7 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p8.sink, align 8, !tbaa !2
  %tobool9 = icmp ne %struct.proc_dir_entry* %7, null
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot11 = xor i1 %lnot10, true
  %lnot.ext = zext i1 %lnot11 to i32
  %tobool13 = icmp ne i32 %lnot.ext, 0
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext17 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %p18 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  %8 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p18, align 8, !tbaa !49
  call void @proc_remove(%struct.proc_dir_entry* %8)
  %p19 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %p19, align 8, !tbaa !49
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %cond.end, %for.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #1 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

declare void @proc_remove(%struct.proc_dir_entry*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !55
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !53
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #1 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !53
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !55
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !55
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_register(%struct.snd_info_entry* %entry1) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_entry* %entry1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %parent = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent, align 8, !tbaa !54
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  br i1 %cmp, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end
  %parent11 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent11, align 8, !tbaa !54
  %p12 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %1, i32 0, i32 10
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end
  %p12.sink = phi %struct.proc_dir_entry** [ %p12, %cond.false ], [ @snd_proc_root, %if.end ]
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p12.sink, align 8, !tbaa !2
  call void @mutex_lock(%struct.mutex* @info_mutex)
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 1
  %3 = load i16, i16* %mode, align 8, !tbaa !56
  %conv13 = zext i16 %3 to i32
  %and = and i32 %conv13, 61440
  %cmp14 = icmp eq i32 %and, 16384
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 0
  %4 = load i8*, i8** %name, align 8, !tbaa !51
  %mode17 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 1
  %5 = load i16, i16* %mode17, align 8, !tbaa !56
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %cond.end
  %call = call %struct.proc_dir_entry* @proc_mkdir_mode(i8* %4, i16 zeroext %5, %struct.proc_dir_entry* %2)
  %tobool18 = icmp ne %struct.proc_dir_entry* %call, null
  br i1 %tobool18, label %if.end27, label %if.then19

if.then19:                                        ; preds = %if.then16
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

if.else:                                          ; preds = %cond.end
  %6 = bitcast %struct.snd_info_entry* %entry1 to i8*
  %call23 = call %struct.proc_dir_entry* @proc_create_data(i8* %4, i16 zeroext %5, %struct.proc_dir_entry* %2, %struct.file_operations* @snd_info_entry_operations, i8* %6)
  %tobool24 = icmp ne %struct.proc_dir_entry* %call23, null
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %if.else
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

if.end26:                                         ; preds = %if.else
  %size = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 2
  %7 = load i64, i64* %size, align 8, !tbaa !57
  call void @proc_set_size(%struct.proc_dir_entry* %call23, i64 %7)
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.then16
  %p.0 = phi %struct.proc_dir_entry* [ %call23, %if.end26 ], [ %call, %if.then16 ]
  %p28 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 10
  store %struct.proc_dir_entry* %p.0, %struct.proc_dir_entry** %p28, align 8, !tbaa !49
  %parent29 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %8 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent29, align 8, !tbaa !54
  %tobool30 = icmp ne %struct.snd_info_entry* %8, null
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end27
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 13
  %parent32 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %entry1, i32 0, i32 5
  %9 = load %struct.snd_info_entry*, %struct.snd_info_entry** %parent32, align 8, !tbaa !54
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %9, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %children)
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end27
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end33, %if.then25, %if.then19, %entry
  %retval.0 = phi i32 [ 0, %if.end33 ], [ -12, %if.then19 ], [ -12, %if.then25 ], [ -6, %entry ]
  ret i32 %retval.0
}

declare %struct.proc_dir_entry* @proc_mkdir_mode(i8*, i16 zeroext, %struct.proc_dir_entry*) #2

declare %struct.proc_dir_entry* @proc_create_data(i8*, i16 zeroext, %struct.proc_dir_entry*, %struct.file_operations*, i8*) #2

declare void @proc_set_size(%struct.proc_dir_entry*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #1 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !55
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #1 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !55
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !53
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !55
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %new, %struct.list_head** %next4, align 8, !tbaa !53
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_llseek(%struct.file* %file, i64 %offset, i32 %orig) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !58
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !59
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_lock(%struct.mutex* %access)
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !61
  %conv = zext i16 %3 to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %llseek = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 4
  %5 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)** %llseek, align 8, !tbaa !62
  %tobool = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)* %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.43* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !48
  %llseek6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 4
  %7 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i64, i32)** %llseek6, align 8, !tbaa !62
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !64
  %call = call i64 %7(%struct.snd_info_entry* %2, i8* %8, %struct.file* %file, i64 %offset, i32 %orig)
  br label %out

if.end:                                           ; preds = %land.lhs.true, %entry
  %content7 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %9 = load i16, i16* %content7, align 8, !tbaa !61
  %conv8 = zext i16 %9 to i32
  %cmp9 = icmp eq i32 %conv8, 1
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end
  %size12 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %10 = load i64, i64* %size12, align 8, !tbaa !57
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end
  %size.0 = phi i64 [ %10, %if.then11 ], [ 0, %if.end ]
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end13
  %Pivot4 = icmp slt i32 %orig, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %orig, 2
  br i1 %Pivot, label %sw.bb, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %orig, 2
  br i1 %SwitchLeaf2, label %sw.bb14, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %orig, 0
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb:                                            ; preds = %NodeBlock
  %f_pos = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  %11 = load i64, i64* %f_pos, align 8, !tbaa !65
  %add = add nsw i64 %offset, %11
  br label %sw.epilog

sw.bb14:                                          ; preds = %LeafBlock1
  %tobool15 = icmp ne i64 %size.0, 0
  br i1 %tobool15, label %if.end17, label %out

if.end17:                                         ; preds = %sw.bb14
  %add18 = add nsw i64 %offset, %size.0
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end17, %sw.bb, %LeafBlock
  %offset.addr.0 = phi i64 [ %add18, %if.end17 ], [ %add, %sw.bb ], [ %offset, %LeafBlock ]
  %cmp19 = icmp slt i64 %offset.addr.0, 0
  br i1 %cmp19, label %out, label %if.end22

if.end22:                                         ; preds = %sw.epilog
  %tobool23 = icmp ne i64 %size.0, 0
  %cmp25 = icmp sgt i64 %offset.addr.0, %size.0
  %or.cond = and i1 %tobool23, %cmp25
  %offset.addr.1 = select i1 %or.cond, i64 %size.0, i64 %offset.addr.0
  %f_pos29 = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 9
  store i64 %offset.addr.1, i64* %f_pos29, align 8, !tbaa !65
  br label %out

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %out

out:                                              ; preds = %NewDefault, %if.end22, %sw.epilog, %sw.bb14, %if.then
  %ret.0 = phi i64 [ -22, %if.then ], [ %offset.addr.1, %if.end22 ], [ -22, %sw.bb14 ], [ -22, %NewDefault ], [ -22, %sw.epilog ]
  %access30 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access30)
  ret i64 %ret.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_read(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %_min156 = alloca i64, align 8
  %_min257 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !58
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %tobool = icmp ne %struct.snd_info_private_data* %1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %offset, align 8, !tbaa !66
  %cmp = icmp slt i64 %2, 0
  %cmp11 = icmp ne i64 %2, %2
  %or.cond = or i1 %cmp, %cmp11
  %cmp14 = icmp slt i64 %count, 0
  %or.cond1 = or i1 %or.cond, %cmp14
  %add = add i64 %2, %count
  %cmp18 = icmp ult i64 %add, %2
  %or.cond2 = or i1 %or.cond1, %cmp18
  br i1 %or.cond2, label %cleanup, label %if.end21

if.end21:                                         ; preds = %if.end
  %entry22 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry22, align 8, !tbaa !59
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !61
  %conv23 = zext i16 %4 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end21
  %Pivot = icmp slt i32 %conv23, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv23, 1
  br i1 %SwitchLeaf4, label %sw.bb46, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv23, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 0
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !67
  %cmp24 = icmp eq %struct.snd_info_buffer* %5, null
  br i1 %cmp24, label %cleanup, label %if.end27

if.end27:                                         ; preds = %sw.bb
  %size28 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 2
  %6 = load i32, i32* %size28, align 4, !tbaa !68
  %conv29 = zext i32 %6 to i64
  %cmp30 = icmp sge i64 %2, %conv29
  br i1 %cmp30, label %cleanup, label %if.end33

if.end33:                                         ; preds = %if.end27
  %size34 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 2
  %7 = load i32, i32* %size34, align 4, !tbaa !68
  %conv35 = zext i32 %7 to i64
  %sub = sub nsw i64 %conv35, %2
  %8 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #7
  store i64 %count, i64* %_min1, align 8, !tbaa !70
  %9 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #7
  store i64 %sub, i64* %_min2, align 8, !tbaa !70
  %cmp36 = icmp eq i64* %_min1, %_min2
  %conv37 = zext i1 %cmp36 to i32
  %10 = load i64, i64* %_min1, align 8, !tbaa !70
  %11 = load i64, i64* %_min2, align 8, !tbaa !70
  %cmp39 = icmp ult i64 %10, %11
  %12 = load i64, i64* %_min1, align 8
  %13 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp39, i64 %12, i64 %13
  %14 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #7
  %15 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #7
  %buffer41 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 0
  %16 = load i8*, i8** %buffer41, align 8, !tbaa !71
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 %2
  %conv42 = trunc i64 %cond to i32
  %call = call i32 @copy_to_user(i8* %buffer, i8* %add.ptr, i32 %conv42)
  %tobool43 = icmp ne i32 %call, 0
  br i1 %tobool43, label %cleanup, label %sw.epilog

sw.bb46:                                          ; preds = %LeafBlock3
  %size47 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 2
  %17 = load i64, i64* %size47, align 8, !tbaa !57
  %cmp48 = icmp sge i64 %2, %17
  br i1 %cmp48, label %cleanup, label %if.end51

if.end51:                                         ; preds = %sw.bb46
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c to %struct.snd_info_entry_ops**
  %18 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %18, i32 0, i32 2
  %19 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !72
  %tobool52 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %19, null
  br i1 %tobool52, label %if.then53, label %sw.epilog

if.then53:                                        ; preds = %if.end51
  %size54 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 2
  %20 = load i64, i64* %size54, align 8, !tbaa !57
  %sub55 = sub nsw i64 %20, %2
  %21 = bitcast i64* %_min156 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) #7
  store i64 %count, i64* %_min156, align 8, !tbaa !70
  %22 = bitcast i64* %_min257 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %22) #7
  store i64 %sub55, i64* %_min257, align 8, !tbaa !70
  %cmp58 = icmp eq i64* %_min156, %_min257
  %conv59 = zext i1 %cmp58 to i32
  %23 = load i64, i64* %_min156, align 8, !tbaa !70
  %24 = load i64, i64* %_min257, align 8, !tbaa !70
  %cmp61 = icmp ult i64 %23, %24
  %25 = load i64, i64* %_min156, align 8
  %26 = load i64, i64* %_min257, align 8
  %cond66 = select i1 %cmp61, i64 %25, i64 %26
  %27 = bitcast i64* %_min257 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %27) #7
  %28 = bitcast i64* %_min156 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #7
  %c67 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops68 = bitcast %union.anon.43* %c67 to %struct.snd_info_entry_ops**
  %29 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops68, align 8, !tbaa !48
  %read69 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %29, i32 0, i32 2
  %30 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read69, align 8, !tbaa !72
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %31 = load i8*, i8** %file_private_data, align 8, !tbaa !64
  %call70 = call i64 %30(%struct.snd_info_entry* %3, i8* %31, %struct.file* %file, i8* %buffer, i64 %cond66, i64 %2)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock3
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %if.then53, %if.end51, %if.end33
  %size.1 = phi i64 [ 0, %NewDefault ], [ %cond, %if.end33 ], [ %call70, %if.then53 ], [ 0, %if.end51 ]
  %cmp72 = icmp sgt i64 %size.1, 0
  br i1 %cmp72, label %if.then74, label %cleanup

if.then74:                                        ; preds = %sw.epilog
  %add75 = add i64 %2, %size.1
  store i64 %add75, i64* %offset, align 8, !tbaa !66
  br label %cleanup

cleanup:                                          ; preds = %if.then74, %sw.epilog, %sw.bb46, %if.end33, %if.end27, %sw.bb, %if.end, %entry
  %retval.0 = phi i64 [ -6, %entry ], [ -5, %if.end ], [ -5, %sw.bb ], [ 0, %if.end27 ], [ -14, %if.end33 ], [ 0, %sw.bb46 ], [ %size.1, %if.then74 ], [ %size.1, %sw.epilog ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_write(%struct.file* %file, i8* %buffer, i64 %count, i64* %offset) #0 {
entry:
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !58
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %tobool = icmp ne %struct.snd_info_private_data* %1, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry10 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry10, align 8, !tbaa !59
  %3 = load i64, i64* %offset, align 8, !tbaa !66
  %cmp = icmp slt i64 %3, 0
  %cmp12 = icmp ne i64 %3, %3
  %or.cond = or i1 %cmp, %cmp12
  %cmp15 = icmp slt i64 %count, 0
  %or.cond1 = or i1 %or.cond, %cmp15
  %add = add i64 %3, %count
  %cmp19 = icmp ult i64 %add, %3
  %or.cond3 = or i1 %or.cond1, %cmp19
  br i1 %or.cond3, label %cleanup, label %if.end22

if.end22:                                         ; preds = %if.end
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !61
  %conv23 = zext i16 %4 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end22
  %Pivot = icmp slt i32 %conv23, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock4

LeafBlock4:                                       ; preds = %NodeBlock
  %SwitchLeaf5 = icmp eq i32 %conv23, 1
  br i1 %SwitchLeaf5, label %sw.bb50, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv23, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 1
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !73
  %cmp24 = icmp eq %struct.snd_info_buffer* %5, null
  br i1 %cmp24, label %cleanup, label %if.end27

if.end27:                                         ; preds = %sw.bb
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_lock(%struct.mutex* %access)
  %add28 = add i64 %3, %count
  %len = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 3
  %6 = load i32, i32* %len, align 8, !tbaa !74
  %conv29 = zext i32 %6 to i64
  %cmp30 = icmp uge i64 %add28, %conv29
  br i1 %cmp30, label %if.then32, label %if.end39

if.then32:                                        ; preds = %if.end27
  %add33 = add i64 %3, %count
  %conv34 = trunc i64 %add33 to i32
  %call = call i32 @resize_info_buffer(%struct.snd_info_buffer* %5, i32 %conv34)
  %tobool35 = icmp ne i32 %call, 0
  br i1 %tobool35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.then32
  %access37 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access37)
  br label %cleanup

if.end39:                                         ; preds = %if.then32, %if.end27
  %buffer40 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 0
  %7 = load i8*, i8** %buffer40, align 8, !tbaa !71
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 %3
  %call41 = call i64 @copy_from_user(i8* %add.ptr, i8* %buffer, i64 %count)
  %tobool42 = icmp ne i64 %call41, 0
  br i1 %tobool42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %if.end39
  %access44 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access44)
  br label %cleanup

if.end45:                                         ; preds = %if.end39
  %add46 = add i64 %3, %count
  %conv47 = trunc i64 %add46 to i32
  %size48 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %5, i32 0, i32 2
  store i32 %conv47, i32* %size48, align 4, !tbaa !68
  %access49 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access49)
  br label %sw.epilog

sw.bb50:                                          ; preds = %LeafBlock4
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c to %struct.snd_info_entry_ops**
  %8 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %8, i32 0, i32 3
  %9 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !75
  %tobool51 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %9, null
  %cmp52 = icmp ugt i64 %count, 0
  %or.cond2 = and i1 %tobool51, %cmp52
  br i1 %or.cond2, label %if.then54, label %sw.epilog

if.then54:                                        ; preds = %sw.bb50
  %size55 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 2
  %10 = load i64, i64* %size55, align 8, !tbaa !57
  %sub = sub nsw i64 %10, %3
  %11 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #7
  store i64 %count, i64* %_min1, align 8, !tbaa !70
  %12 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %12) #7
  store i64 %sub, i64* %_min2, align 8, !tbaa !70
  %cmp56 = icmp eq i64* %_min1, %_min2
  %conv57 = zext i1 %cmp56 to i32
  %13 = load i64, i64* %_min1, align 8, !tbaa !70
  %14 = load i64, i64* %_min2, align 8, !tbaa !70
  %cmp59 = icmp ult i64 %13, %14
  %15 = load i64, i64* %_min1, align 8
  %16 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp59, i64 %15, i64 %16
  %17 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %17) #7
  %18 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #7
  %c61 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops62 = bitcast %union.anon.43* %c61 to %struct.snd_info_entry_ops**
  %19 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops62, align 8, !tbaa !48
  %write63 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %19, i32 0, i32 3
  %20 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write63, align 8, !tbaa !75
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %21 = load i8*, i8** %file_private_data, align 8, !tbaa !64
  %call64 = call i64 %20(%struct.snd_info_entry* %2, i8* %21, %struct.file* %file, i8* %buffer, i64 %cond, i64 %3)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock4
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %if.then54, %sw.bb50, %if.end45
  %size.1 = phi i64 [ 0, %NewDefault ], [ %count, %if.end45 ], [ %call64, %if.then54 ], [ 0, %sw.bb50 ]
  %cmp66 = icmp sgt i64 %size.1, 0
  br i1 %cmp66, label %if.then68, label %cleanup

if.then68:                                        ; preds = %sw.epilog
  %add69 = add nsw i64 %3, %size.1
  store i64 %add69, i64* %offset, align 8, !tbaa !66
  br label %cleanup

cleanup:                                          ; preds = %if.then68, %sw.epilog, %if.then43, %if.then36, %sw.bb, %if.end, %entry
  %retval.0 = phi i64 [ -12, %if.then36 ], [ -14, %if.then43 ], [ -6, %entry ], [ -5, %if.end ], [ -5, %sw.bb ], [ %size.1, %if.then68 ], [ %size.1, %sw.epilog ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !58
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %cmp = icmp eq %struct.snd_info_private_data* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !59
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !61
  %conv = zext i16 %3 to i32
  %cond = icmp eq i32 %conv, 1
  br i1 %cond, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %poll = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 5
  %5 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)** %poll, align 8, !tbaa !76
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)* %5, null
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.43* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !48
  br i1 %tobool, label %if.then3, label %if.end7

if.then3:                                         ; preds = %sw.bb
  %poll6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 5
  %7 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, %struct.poll_table_struct*)** %poll6, align 8, !tbaa !76
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !64
  %call = call i32 %7(%struct.snd_info_entry* %2, i8* %8, %struct.file* %file, %struct.poll_table_struct* %wait)
  br label %cleanup

if.end7:                                          ; preds = %sw.bb
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 2
  %9 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !72
  %tobool10 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %9, null
  %or = or i32 0, 65
  %or. = select i1 %tobool10, i32 %or, i32 0
  %c13 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops14 = bitcast %union.anon.43* %c13 to %struct.snd_info_entry_ops**
  %10 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops14, align 8, !tbaa !48
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %10, i32 0, i32 3
  %11 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !75
  %tobool15 = icmp ne i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %11, null
  %or17 = or i32 %or., 260
  %mask.1 = select i1 %tobool15, i32 %or17, i32 %or.
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then3, %if.end, %entry
  %retval.0 = phi i32 [ %call, %if.then3 ], [ 0, %entry ], [ 0, %if.end ], [ %mask.1, %if.end7 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @snd_info_entry_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !58
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %cmp = icmp eq %struct.snd_info_private_data* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !59
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !61
  %conv = zext i16 %3 to i32
  %cond = icmp eq i32 %conv, 1
  br i1 %cond, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %ioctl = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 6
  %5 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)** %ioctl, align 8, !tbaa !77
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)* %5, null
  br i1 %tobool, label %if.then3, label %cleanup

if.then3:                                         ; preds = %sw.bb
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.43* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !48
  %ioctl6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 6
  %7 = load i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)*, i32 (%struct.snd_info_entry*, i8*, %struct.file*, i32, i64)** %ioctl6, align 8, !tbaa !77
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !64
  %call = call i32 %7(%struct.snd_info_entry* %2, i8* %8, %struct.file* %file, i32 %cmd, i64 %arg)
  %conv7 = sext i32 %call to i64
  br label %cleanup

cleanup:                                          ; preds = %if.then3, %sw.bb, %if.end, %entry
  %retval.0 = phi i64 [ %conv7, %if.then3 ], [ 0, %entry ], [ -25, %sw.bb ], [ -25, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_mmap(%struct.file* %file, %struct.vm_area_struct* %vma) #0 {
entry:
  %call = call %struct.inode* @file_inode(%struct.file* %file)
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !58
  %1 = bitcast i8* %0 to %struct.snd_info_private_data*
  %cmp = icmp eq %struct.snd_info_private_data* %1, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 2
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !59
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 3
  %3 = load i16, i16* %content, align 8, !tbaa !61
  %conv = zext i16 %3 to i32
  %cond = icmp eq i32 %conv, 1
  br i1 %cond, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c to %struct.snd_info_entry_ops**
  %4 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %mmap = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %4, i32 0, i32 7
  %5 = load i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)** %mmap, align 8, !tbaa !78
  %tobool = icmp ne i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)* %5, null
  br i1 %tobool, label %if.then3, label %cleanup

if.then3:                                         ; preds = %sw.bb
  %c4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 4
  %ops5 = bitcast %union.anon.43* %c4 to %struct.snd_info_entry_ops**
  %6 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops5, align 8, !tbaa !48
  %mmap6 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %6, i32 0, i32 7
  %7 = load i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)*, i32 (%struct.snd_info_entry*, i8*, %struct.inode*, %struct.file*, %struct.vm_area_struct*)** %mmap6, align 8, !tbaa !78
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %1, i32 0, i32 3
  %8 = load i8*, i8** %file_private_data, align 8, !tbaa !64
  %call7 = call i32 %7(%struct.snd_info_entry* %2, i8* %8, %struct.inode* %call, %struct.file* %file, %struct.vm_area_struct* %vma)
  br label %cleanup

cleanup:                                          ; preds = %if.then3, %sw.bb, %if.end, %entry
  %retval.0 = phi i32 [ %call7, %if.then3 ], [ 0, %entry ], [ -6, %sw.bb ], [ -6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  call void @mutex_lock(%struct.mutex* @info_mutex)
  %call = call i8* @PDE_DATA(%struct.inode* %inode)
  %0 = bitcast i8* %call to %struct.snd_info_entry*
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %p = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 10
  %1 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %p, align 8, !tbaa !49
  %tobool = icmp ne %struct.proc_dir_entry* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 7
  %2 = load %struct.module*, %struct.module** %module, align 8, !tbaa !79
  %call2 = call zeroext i1 @try_module_get(%struct.module* %2)
  br i1 %call2, label %if.end4, label %__error1

if.end4:                                          ; preds = %if.end
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %3 = load i32, i32* %f_flags, align 8, !tbaa !80
  %and = and i32 %3, 3
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end4
  %Pivot6 = icmp slt i32 %and, 1
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %and, 2
  br i1 %Pivot, label %if.then21, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %and, 2
  br i1 %SwitchLeaf4, label %if.then8, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %and, 0
  br i1 %SwitchLeaf, label %if.then8, label %NewDefault

if.then8:                                         ; preds = %LeafBlock, %LeafBlock3
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !61
  %conv = zext i16 %4 to i32
  %cmp9 = icmp eq i32 %conv, 1
  br i1 %cmp9, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.then8
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c to %struct.snd_info_entry_ops**
  %5 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %read = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %5, i32 0, i32 2
  %6 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %read, align 8, !tbaa !72
  %cmp11 = icmp eq i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %6, null
  br i1 %cmp11, label %__error, label %if.end15

if.end15:                                         ; preds = %land.lhs.true, %if.then8
  %and.off = add i32 %and, -1
  %switch = icmp ult i32 %and.off, 2
  br i1 %switch, label %if.then21, label %if.end33

if.then21:                                        ; preds = %if.end15, %NodeBlock
  %content22 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %7 = load i16, i16* %content22, align 8, !tbaa !61
  %conv23 = zext i16 %7 to i32
  %cmp24 = icmp eq i32 %conv23, 1
  br i1 %cmp24, label %land.lhs.true26, label %if.end33

land.lhs.true26:                                  ; preds = %if.then21
  %c27 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops28 = bitcast %union.anon.43* %c27 to %struct.snd_info_entry_ops**
  %8 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops28, align 8, !tbaa !48
  %write = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %8, i32 0, i32 3
  %9 = load i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)*, i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)** %write, align 8, !tbaa !75
  %cmp29 = icmp eq i64 (%struct.snd_info_entry*, i8*, %struct.file*, i8*, i64, i64)* %9, null
  br i1 %cmp29, label %__error, label %if.end33

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock3
  br label %if.end33

if.end33:                                         ; preds = %NewDefault, %land.lhs.true26, %if.then21, %if.end15
  %call34 = call i8* @kzalloc(i64 32, i32 208)
  %10 = bitcast i8* %call34 to %struct.snd_info_private_data*
  %cmp35 = icmp eq %struct.snd_info_private_data* %10, null
  br i1 %cmp35, label %__error, label %if.end38

if.end38:                                         ; preds = %if.end33
  %entry39 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 2
  store %struct.snd_info_entry* %0, %struct.snd_info_entry** %entry39, align 8, !tbaa !59
  %content40 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %11 = load i16, i16* %content40, align 8, !tbaa !61
  %conv41 = zext i16 %11 to i32
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %if.end38
  %Pivot13 = icmp slt i32 %conv41, 1
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %conv41, 1
  br i1 %SwitchLeaf11, label %sw.bb85, label %NewDefault7

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp eq i32 %conv41, 0
  br i1 %SwitchLeaf9, label %sw.bb, label %NewDefault7

sw.bb:                                            ; preds = %LeafBlock8
  br label %NodeBlock21

NodeBlock21:                                      ; preds = %sw.bb
  %Pivot22 = icmp slt i32 %and, 1
  br i1 %Pivot22, label %LeafBlock15, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %and, 2
  br i1 %Pivot20, label %if.then68, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %and, 2
  br i1 %SwitchLeaf18, label %if.then47, label %NewDefault14

LeafBlock15:                                      ; preds = %NodeBlock21
  %SwitchLeaf16 = icmp eq i32 %and, 0
  br i1 %SwitchLeaf16, label %if.then47, label %NewDefault14

if.then47:                                        ; preds = %LeafBlock15, %LeafBlock17
  %call48 = call i8* @kzalloc(i64 32, i32 208)
  %12 = bitcast i8* %call48 to %struct.snd_info_buffer*
  %cmp49 = icmp eq %struct.snd_info_buffer* %12, null
  br i1 %cmp49, label %__nomem, label %if.end52

if.end52:                                         ; preds = %if.then47
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  store %struct.snd_info_buffer* %12, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !67
  %len = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 3
  store i32 4096, i32* %len, align 8, !tbaa !74
  %len53 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 3
  %13 = load i32, i32* %len53, align 8, !tbaa !74
  %conv54 = zext i32 %13 to i64
  %call55 = call i8* @kzalloc(i64 %conv54, i32 208)
  %buffer56 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 0
  store i8* %call55, i8** %buffer56, align 8, !tbaa !71
  %buffer57 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %12, i32 0, i32 0
  %14 = load i8*, i8** %buffer57, align 8, !tbaa !71
  %cmp58 = icmp eq i8* %14, null
  br i1 %cmp58, label %__nomem, label %if.end62

if.end62:                                         ; preds = %if.end52
  %and.off1 = add i32 %and, -1
  %switch2 = icmp ult i32 %and.off1, 2
  br i1 %switch2, label %if.then68, label %sw.epilog

if.then68:                                        ; preds = %if.end62, %NodeBlock19
  %call69 = call i8* @kzalloc(i64 32, i32 208)
  %15 = bitcast i8* %call69 to %struct.snd_info_buffer*
  %cmp70 = icmp eq %struct.snd_info_buffer* %15, null
  br i1 %cmp70, label %__nomem, label %if.end73

if.end73:                                         ; preds = %if.then68
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  store %struct.snd_info_buffer* %15, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !73
  %len74 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 3
  store i32 4096, i32* %len74, align 8, !tbaa !74
  %len75 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 3
  %16 = load i32, i32* %len75, align 8, !tbaa !74
  %conv76 = zext i32 %16 to i64
  %call77 = call i8* @kmalloc.9(i64 %conv76, i32 208)
  %buffer78 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 0
  store i8* %call77, i8** %buffer78, align 8, !tbaa !71
  %buffer79 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %15, i32 0, i32 0
  %17 = load i8*, i8** %buffer79, align 8, !tbaa !71
  %cmp80 = icmp eq i8* %17, null
  br i1 %cmp80, label %__nomem, label %sw.epilog

sw.bb85:                                          ; preds = %LeafBlock10
  %c86 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops87 = bitcast %union.anon.43* %c86 to %struct.snd_info_entry_ops**
  %18 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops87, align 8, !tbaa !48
  %open = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %18, i32 0, i32 0
  %19 = load i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8**)** %open, align 8, !tbaa !81
  %tobool88 = icmp ne i32 (%struct.snd_info_entry*, i16, i8**)* %19, null
  br i1 %tobool88, label %if.then89, label %sw.epilog

if.then89:                                        ; preds = %sw.bb85
  %c90 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %ops91 = bitcast %union.anon.43* %c90 to %struct.snd_info_entry_ops**
  %20 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops91, align 8, !tbaa !48
  %open92 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %20, i32 0, i32 0
  %21 = load i32 (%struct.snd_info_entry*, i16, i8**)*, i32 (%struct.snd_info_entry*, i16, i8**)** %open92, align 8, !tbaa !81
  %conv93 = trunc i32 %and to i16
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 3
  %call94 = call i32 %21(%struct.snd_info_entry* %0, i16 zeroext %conv93, i8** %file_private_data)
  %cmp95 = icmp slt i32 %call94, 0
  br i1 %cmp95, label %if.then97, label %sw.epilog

if.then97:                                        ; preds = %if.then89
  %22 = bitcast %struct.snd_info_private_data* %10 to i8*
  call void @kfree(i8* %22)
  br label %__error

NewDefault7:                                      ; preds = %LeafBlock8, %LeafBlock10
  br label %sw.epilog

NewDefault14:                                     ; preds = %LeafBlock15, %LeafBlock17
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault14, %NewDefault7, %if.then89, %sw.bb85, %if.end73, %if.end62
  %23 = bitcast %struct.snd_info_private_data* %10 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %23, i8** %private_data, align 8, !tbaa !58
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  %content100 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  %24 = load i16, i16* %content100, align 8, !tbaa !61
  %conv101 = zext i16 %24 to i32
  %cmp102 = icmp eq i32 %conv101, 0
  br i1 %cmp102, label %land.lhs.true104, label %cleanup

land.lhs.true104:                                 ; preds = %sw.epilog
  br label %NodeBlock28

NodeBlock28:                                      ; preds = %land.lhs.true104
  %Pivot29 = icmp slt i32 %and, 2
  br i1 %Pivot29, label %LeafBlock24, label %LeafBlock26

LeafBlock26:                                      ; preds = %NodeBlock28
  %SwitchLeaf27 = icmp eq i32 %and, 2
  br i1 %SwitchLeaf27, label %if.then110, label %NewDefault23

LeafBlock24:                                      ; preds = %NodeBlock28
  %SwitchLeaf25 = icmp eq i32 %and, 0
  br i1 %SwitchLeaf25, label %if.then110, label %NewDefault23

if.then110:                                       ; preds = %LeafBlock24, %LeafBlock26
  %c111 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %text = bitcast %union.anon.43* %c111 to %struct.snd_info_entry_text*
  %read112 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  %25 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read112, align 8, !tbaa !48
  %tobool113 = icmp ne void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %25, null
  br i1 %tobool113, label %if.then114, label %cleanup

if.then114:                                       ; preds = %if.then110
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 11
  call void @mutex_lock(%struct.mutex* %access)
  %c115 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 4
  %text116 = bitcast %union.anon.43* %c115 to %struct.snd_info_entry_text*
  %read117 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text116, i32 0, i32 0
  %26 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read117, align 8, !tbaa !48
  %rbuffer118 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %27 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer118, align 8, !tbaa !67
  call void %26(%struct.snd_info_entry* %0, %struct.snd_info_buffer* %27)
  %access119 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 11
  call void @mutex_unlock(%struct.mutex* %access119)
  br label %cleanup

__nomem:                                          ; preds = %if.end73, %if.then68, %if.end52, %if.then47
  %rbuffer122 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %28 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer122, align 8, !tbaa !67
  %tobool123 = icmp ne %struct.snd_info_buffer* %28, null
  br i1 %tobool123, label %if.then124, label %if.end128

if.then124:                                       ; preds = %__nomem
  %rbuffer125 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %29 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer125, align 8, !tbaa !67
  %buffer126 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %29, i32 0, i32 0
  %30 = load i8*, i8** %buffer126, align 8, !tbaa !71
  call void @kfree(i8* %30)
  %rbuffer127 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 0
  %31 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer127, align 8, !tbaa !67
  %32 = bitcast %struct.snd_info_buffer* %31 to i8*
  call void @kfree(i8* %32)
  br label %if.end128

if.end128:                                        ; preds = %if.then124, %__nomem
  %wbuffer129 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  %33 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer129, align 8, !tbaa !73
  %tobool130 = icmp ne %struct.snd_info_buffer* %33, null
  br i1 %tobool130, label %if.then131, label %if.end135

if.then131:                                       ; preds = %if.end128
  %wbuffer132 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  %34 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer132, align 8, !tbaa !73
  %buffer133 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %34, i32 0, i32 0
  %35 = load i8*, i8** %buffer133, align 8, !tbaa !71
  call void @kfree(i8* %35)
  %wbuffer134 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %10, i32 0, i32 1
  %36 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer134, align 8, !tbaa !73
  %37 = bitcast %struct.snd_info_buffer* %36 to i8*
  call void @kfree(i8* %37)
  br label %if.end135

if.end135:                                        ; preds = %if.then131, %if.end128
  %38 = bitcast %struct.snd_info_private_data* %10 to i8*
  call void @kfree(i8* %38)
  br label %__error

__error:                                          ; preds = %if.end135, %if.then97, %if.end33, %land.lhs.true26, %land.lhs.true
  %err.0 = phi i32 [ %call94, %if.then97 ], [ -12, %if.end135 ], [ -19, %land.lhs.true ], [ -19, %land.lhs.true26 ], [ -12, %if.end33 ]
  %module136 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 7
  %39 = load %struct.module*, %struct.module** %module136, align 8, !tbaa !79
  call void @module_put(%struct.module* %39)
  br label %__error1

__error1:                                         ; preds = %__error, %if.end
  %err.1 = phi i32 [ %err.0, %__error ], [ -14, %if.end ]
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %cleanup

NewDefault23:                                     ; preds = %LeafBlock24, %LeafBlock26
  br label %cleanup

cleanup:                                          ; preds = %NewDefault23, %__error1, %if.then114, %if.then110, %sw.epilog, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ %err.1, %__error1 ], [ 0, %if.then110 ], [ 0, %if.then114 ], [ 0, %NewDefault23 ], [ 0, %sw.epilog ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_entry_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %0 = load i32, i32* %f_flags, align 8, !tbaa !80
  %and = and i32 %0, 3
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %1 = load i8*, i8** %private_data, align 8, !tbaa !58
  %2 = bitcast i8* %1 to %struct.snd_info_private_data*
  %entry2 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 2
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** %entry2, align 8, !tbaa !59
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 3
  %4 = load i16, i16* %content, align 8, !tbaa !61
  %conv = zext i16 %4 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %conv, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf2, label %sw.bb24, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %rbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 0
  %5 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer, align 8, !tbaa !67
  %tobool = icmp ne %struct.snd_info_buffer* %5, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %rbuffer3 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 0
  %6 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer3, align 8, !tbaa !67
  %buffer = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %6, i32 0, i32 0
  %7 = load i8*, i8** %buffer, align 8, !tbaa !71
  call void @kfree(i8* %7)
  %rbuffer4 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 0
  %8 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %rbuffer4, align 8, !tbaa !67
  %9 = bitcast %struct.snd_info_buffer* %8 to i8*
  call void @kfree(i8* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %wbuffer = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %10 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer, align 8, !tbaa !73
  %tobool5 = icmp ne %struct.snd_info_buffer* %10, null
  br i1 %tobool5, label %if.then6, label %sw.epilog

if.then6:                                         ; preds = %if.end
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %text = bitcast %union.anon.43* %c to %struct.snd_info_entry_text*
  %write = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 1
  %11 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %write, align 8, !tbaa !48
  %tobool7 = icmp ne void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* %11, null
  br i1 %tobool7, label %if.then8, label %if.end19

if.then8:                                         ; preds = %if.then6
  %c9 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %text10 = bitcast %union.anon.43* %c9 to %struct.snd_info_entry_text*
  %write11 = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text10, i32 0, i32 1
  %12 = load void (%struct.snd_info_entry*, %struct.snd_info_buffer*)*, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %write11, align 8, !tbaa !48
  %wbuffer12 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %13 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer12, align 8, !tbaa !73
  call void %12(%struct.snd_info_entry* %3, %struct.snd_info_buffer* %13)
  %wbuffer13 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %14 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer13, align 8, !tbaa !73
  %error = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %14, i32 0, i32 5
  %15 = load i32, i32* %error, align 8, !tbaa !82
  %tobool14 = icmp ne i32 %15, 0
  br i1 %tobool14, label %if.then15, label %if.end19

if.then15:                                        ; preds = %if.then8
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 0
  %16 = load i8*, i8** %name, align 8, !tbaa !51
  %wbuffer16 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %17 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer16, align 8, !tbaa !73
  %error17 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %17, i32 0, i32 5
  %18 = load i32, i32* %error17, align 8, !tbaa !82
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.15.8, i32 0, i32 0), i8* %16, i32 %18)
  br label %if.end19

if.end19:                                         ; preds = %if.then15, %if.then8, %if.then6
  %wbuffer20 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %19 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer20, align 8, !tbaa !73
  %buffer21 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %19, i32 0, i32 0
  %20 = load i8*, i8** %buffer21, align 8, !tbaa !71
  call void @kfree(i8* %20)
  %wbuffer22 = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 1
  %21 = load %struct.snd_info_buffer*, %struct.snd_info_buffer** %wbuffer22, align 8, !tbaa !73
  %22 = bitcast %struct.snd_info_buffer* %21 to i8*
  call void @kfree(i8* %22)
  br label %sw.epilog

sw.bb24:                                          ; preds = %LeafBlock1
  %c25 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops = bitcast %union.anon.43* %c25 to %struct.snd_info_entry_ops**
  %23 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops, align 8, !tbaa !48
  %release = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %23, i32 0, i32 1
  %24 = load i32 (%struct.snd_info_entry*, i16, i8*)*, i32 (%struct.snd_info_entry*, i16, i8*)** %release, align 8, !tbaa !83
  %tobool26 = icmp ne i32 (%struct.snd_info_entry*, i16, i8*)* %24, null
  br i1 %tobool26, label %if.then27, label %sw.epilog

if.then27:                                        ; preds = %sw.bb24
  %c28 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 4
  %ops29 = bitcast %union.anon.43* %c28 to %struct.snd_info_entry_ops**
  %25 = load %struct.snd_info_entry_ops*, %struct.snd_info_entry_ops** %ops29, align 8, !tbaa !48
  %release30 = getelementptr inbounds %struct.snd_info_entry_ops, %struct.snd_info_entry_ops* %25, i32 0, i32 1
  %26 = load i32 (%struct.snd_info_entry*, i16, i8*)*, i32 (%struct.snd_info_entry*, i16, i8*)** %release30, align 8, !tbaa !83
  %conv31 = trunc i32 %and to i16
  %file_private_data = getelementptr inbounds %struct.snd_info_private_data, %struct.snd_info_private_data* %2, i32 0, i32 3
  %27 = load i8*, i8** %file_private_data, align 8, !tbaa !64
  %call32 = call i32 %26(%struct.snd_info_entry* %3, i16 zeroext %conv31, i8* %27)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock, %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %if.then27, %sw.bb24, %if.end19, %if.end
  %module = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 7
  %28 = load %struct.module*, %struct.module** %module, align 8, !tbaa !79
  call void @module_put(%struct.module* %28)
  %29 = bitcast %struct.snd_info_private_data* %2 to i8*
  call void @kfree(i8* %29)
  ret i32 0
}

declare i8* @PDE_DATA(%struct.inode*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #1 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.9(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.9(i64 %size, i32 %flags) #4 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.inode* @file_inode(%struct.file* %f) #1 {
entry:
  %f_inode = getelementptr inbounds %struct.file, %struct.file* %f, i32 0, i32 2
  %0 = load %struct.inode*, %struct.inode** %f_inode, align 8, !tbaa !84
  ret %struct.inode* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @resize_info_buffer(%struct.snd_info_buffer* %buffer, i32 %nsize) #0 {
entry:
  %add = add i32 %nsize, 4095
  %and = and i32 %add, -4096
  %buffer1 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer1, align 8, !tbaa !71
  %conv = zext i32 %and to i64
  %call = call i8* @krealloc(i8* %0, i64 %conv, i32 32976)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %buffer2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  store i8* %call, i8** %buffer2, align 8, !tbaa !71
  %len = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  store i32 %and, i32* %len, align 8, !tbaa !74
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #1 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %entry ]
  ret i64 %n.addr.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #5

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #5

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

; Function Attrs: inlinehint nounwind uwtable
define internal void @might_fault() #1 {
entry:
  %call = call i32 @_cond_resched()
  ret void
}

declare i64 @_copy_from_user(i8*, i8*, i32) #2

declare i32 @_cond_resched() #2

declare i8* @krealloc(i8*, i64, i32) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @copy_to_user(i8* %dst, i8* %src, i32 %size) #4 {
entry:
  call void @might_fault()
  %call = call i64 @_copy_to_user(i8* %dst, i8* %src, i32 %size)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare i64 @_copy_to_user(i8*, i8*, i32) #2

; Function Attrs: nounwind uwtable
define i32 @snd_card_proc_new(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry** %entryp) #0 {
entry:
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !85
  %call = call %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry* %0)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = bitcast %struct.snd_info_entry* %call to i8*
  %call2 = call i32 @snd_device_new(%struct.snd_card* %card, i32 4102, i8* %1, %struct.snd_device_ops* @snd_card_proc_new.ops)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %cleanup

if.end4:                                          ; preds = %if.end
  %tobool5 = icmp ne %struct.snd_info_entry** %entryp, null
  br i1 %tobool5, label %if.then6, label %cleanup

if.then6:                                         ; preds = %if.end4
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** %entryp, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.end4, %if.then3, %entry
  %retval.0 = phi i32 [ %call2, %if.then3 ], [ -12, %entry ], [ 0, %if.then6 ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.snd_info_entry* @snd_info_create_card_entry(%struct.snd_card* %card, i8* %name, %struct.snd_info_entry* %parent) #0 {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_entry(i8* %name)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %0 = load %struct.module*, %struct.module** %module, align 8, !tbaa !86
  %module2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 7
  store %struct.module* %0, %struct.module** %module2, align 8, !tbaa !79
  %card3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 6
  store %struct.snd_card* %card, %struct.snd_card** %card3, align 8, !tbaa !87
  %parent4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 5
  store %struct.snd_info_entry* %parent, %struct.snd_info_entry** %parent4, align 8, !tbaa !54
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.snd_info_entry* %call
}

declare i32 @snd_device_new(%struct.snd_card*, i32, i8*, %struct.snd_device_ops*) #2

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_dev_free_entry(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.snd_info_entry*
  call void @snd_info_free_entry(%struct.snd_info_entry* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_dev_register_entry(%struct.snd_device* %device) #0 {
entry:
  %device_data = getelementptr inbounds %struct.snd_device, %struct.snd_device* %device, i32 0, i32 4
  %0 = load i8*, i8** %device_data, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.snd_info_entry*
  %call = call i32 @snd_info_register(%struct.snd_info_entry* %1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal %struct.snd_info_entry* @snd_info_create_entry(i8* %name) #0 {
entry:
  %call = call i8* @kzalloc(i64 168, i32 208)
  %0 = bitcast i8* %call to %struct.snd_info_entry*
  %cmp = icmp eq %struct.snd_info_entry* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call2 = call i8* @kstrdup(i8* %name, i32 208)
  %name3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  store i8* %call2, i8** %name3, align 8, !tbaa !51
  %name4 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  %1 = load i8*, i8** %name4, align 8, !tbaa !51
  %cmp5 = icmp eq i8* %1, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %2 = bitcast %struct.snd_info_entry* %0 to i8*
  call void @kfree(i8* %2)
  br label %cleanup

if.end7:                                          ; preds = %if.end
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 1
  store i16 -32476, i16* %mode, align 8, !tbaa !56
  %content = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 3
  store i16 0, i16* %content, align 8, !tbaa !61
  %access = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 11
  call void @__mutex_init(%struct.mutex* %access, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.14.10, i32 0, i32 0), %struct.mod_arch_specific* @snd_info_create_entry.__key)
  %children = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 12
  call void @INIT_LIST_HEAD(%struct.list_head* %children)
  %list = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 13
  call void @INIT_LIST_HEAD(%struct.list_head* %list)
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then6, %entry
  %retval.0 = phi %struct.snd_info_entry* [ null, %if.then6 ], [ %0, %if.end7 ], [ null, %entry ]
  ret %struct.snd_info_entry* %retval.0
}

declare i8* @kstrdup(i8*, i32) #2

declare void @__mutex_init(%struct.mutex*, i8*, %struct.mod_arch_specific*) #2

; Function Attrs: nounwind uwtable
define %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* %module, i8* %name, %struct.snd_info_entry* %parent) #0 {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_entry(i8* %name)
  %tobool = icmp ne %struct.snd_info_entry* %call, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %module2 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 7
  store %struct.module* %module, %struct.module** %module2, align 8, !tbaa !79
  %parent3 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 5
  store %struct.snd_info_entry* %parent, %struct.snd_info_entry** %parent3, align 8, !tbaa !54
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret %struct.snd_info_entry* %call
}

; Function Attrs: nounwind uwtable
define i8* @snd_info_get_str(i8* %dest, i8* %src, i32 %len) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %src.addr.0 = phi i8* [ %src, %entry ], [ %incdec.ptr, %while.body ]
  %0 = load i8, i8* %src.addr.0, align 1, !tbaa !48
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %while.body, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond
  %1 = load i8, i8* %src.addr.0, align 1, !tbaa !48
  %conv2 = sext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv2, 9
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %lor.rhs, %while.cond
  %incdec.ptr = getelementptr inbounds i8, i8* %src.addr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %lor.rhs
  %2 = load i8, i8* %src.addr.0, align 1, !tbaa !48
  %conv5 = sext i8 %2 to i32
  %cmp6 = icmp eq i32 %conv5, 34
  br i1 %cmp6, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %3 = load i8, i8* %src.addr.0, align 1, !tbaa !48
  %conv8 = sext i8 %3 to i32
  %cmp9 = icmp eq i32 %conv8, 39
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.end
  %incdec.ptr11 = getelementptr inbounds i8, i8* %src.addr.0, i32 1
  %4 = load i8, i8* %src.addr.0, align 1, !tbaa !48
  %conv12 = sext i8 %4 to i32
  br label %while.cond13

while.cond13:                                     ; preds = %while.body20, %if.then
  %len.addr.0 = phi i32 [ %len, %if.then ], [ %dec, %while.body20 ]
  %src.addr.1 = phi i8* [ %incdec.ptr11, %if.then ], [ %incdec.ptr21, %while.body20 ]
  %dest.addr.0 = phi i8* [ %dest, %if.then ], [ %incdec.ptr22, %while.body20 ]
  %dec = add nsw i32 %len.addr.0, -1
  %cmp14 = icmp sgt i32 %dec, 0
  br i1 %cmp14, label %land.lhs.true, label %while.end23

land.lhs.true:                                    ; preds = %while.cond13
  %5 = load i8, i8* %src.addr.1, align 1, !tbaa !48
  %conv16 = sext i8 %5 to i32
  %tobool = icmp ne i32 %conv16, 0
  br i1 %tobool, label %land.rhs, label %while.end23

land.rhs:                                         ; preds = %land.lhs.true
  %6 = load i8, i8* %src.addr.1, align 1, !tbaa !48
  %conv17 = sext i8 %6 to i32
  %cmp18 = icmp ne i32 %conv17, %conv12
  br i1 %cmp18, label %while.body20, label %while.end23

while.body20:                                     ; preds = %land.rhs
  %incdec.ptr21 = getelementptr inbounds i8, i8* %src.addr.1, i32 1
  %7 = load i8, i8* %src.addr.1, align 1, !tbaa !48
  %incdec.ptr22 = getelementptr inbounds i8, i8* %dest.addr.0, i32 1
  store i8 %7, i8* %dest.addr.0, align 1, !tbaa !48
  br label %while.cond13

while.end23:                                      ; preds = %land.rhs, %land.lhs.true, %while.cond13
  %8 = load i8, i8* %src.addr.1, align 1, !tbaa !48
  %conv24 = sext i8 %8 to i32
  %cmp25 = icmp eq i32 %conv24, %conv12
  %incdec.ptr28 = getelementptr inbounds i8, i8* %src.addr.1, i32 1
  %incdec.ptr28.src.addr.1 = select i1 %cmp25, i8* %incdec.ptr28, i8* %src.addr.1
  br label %if.end49

if.else:                                          ; preds = %lor.lhs.false
  br label %while.cond29

while.cond29:                                     ; preds = %while.body45, %if.else
  %len.addr.1 = phi i32 [ %len, %if.else ], [ %dec30, %while.body45 ]
  %src.addr.3 = phi i8* [ %src.addr.0, %if.else ], [ %incdec.ptr46, %while.body45 ]
  %dest.addr.1 = phi i8* [ %dest, %if.else ], [ %incdec.ptr47, %while.body45 ]
  %dec30 = add nsw i32 %len.addr.1, -1
  %cmp31 = icmp sgt i32 %dec30, 0
  br i1 %cmp31, label %land.lhs.true33, label %if.end49

land.lhs.true33:                                  ; preds = %while.cond29
  %9 = load i8, i8* %src.addr.3, align 1, !tbaa !48
  %conv34 = sext i8 %9 to i32
  %tobool35 = icmp ne i32 %conv34, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end49

land.lhs.true36:                                  ; preds = %land.lhs.true33
  %10 = load i8, i8* %src.addr.3, align 1, !tbaa !48
  %conv37 = sext i8 %10 to i32
  %cmp38 = icmp ne i32 %conv37, 32
  br i1 %cmp38, label %land.rhs40, label %if.end49

land.rhs40:                                       ; preds = %land.lhs.true36
  %11 = load i8, i8* %src.addr.3, align 1, !tbaa !48
  %conv41 = sext i8 %11 to i32
  %cmp42 = icmp ne i32 %conv41, 9
  br i1 %cmp42, label %while.body45, label %if.end49

while.body45:                                     ; preds = %land.rhs40
  %incdec.ptr46 = getelementptr inbounds i8, i8* %src.addr.3, i32 1
  %12 = load i8, i8* %src.addr.3, align 1, !tbaa !48
  %incdec.ptr47 = getelementptr inbounds i8, i8* %dest.addr.1, i32 1
  store i8 %12, i8* %dest.addr.1, align 1, !tbaa !48
  br label %while.cond29

if.end49:                                         ; preds = %land.rhs40, %land.lhs.true36, %land.lhs.true33, %while.cond29, %while.end23
  %src.addr.4 = phi i8* [ %incdec.ptr28.src.addr.1, %while.end23 ], [ %src.addr.3, %while.cond29 ], [ %src.addr.3, %land.lhs.true33 ], [ %src.addr.3, %land.lhs.true36 ], [ %src.addr.3, %land.rhs40 ]
  %dest.addr.2 = phi i8* [ %dest.addr.0, %while.end23 ], [ %dest.addr.1, %while.cond29 ], [ %dest.addr.1, %land.lhs.true33 ], [ %dest.addr.1, %land.lhs.true36 ], [ %dest.addr.1, %land.rhs40 ]
  store i8 0, i8* %dest.addr.2, align 1, !tbaa !48
  br label %while.cond50

while.cond50:                                     ; preds = %while.body59, %if.end49
  %src.addr.5 = phi i8* [ %src.addr.4, %if.end49 ], [ %incdec.ptr60, %while.body59 ]
  %13 = load i8, i8* %src.addr.5, align 1, !tbaa !48
  %conv51 = sext i8 %13 to i32
  %cmp52 = icmp eq i32 %conv51, 32
  br i1 %cmp52, label %while.body59, label %lor.rhs54

lor.rhs54:                                        ; preds = %while.cond50
  %14 = load i8, i8* %src.addr.5, align 1, !tbaa !48
  %conv55 = sext i8 %14 to i32
  %cmp56 = icmp eq i32 %conv55, 9
  br i1 %cmp56, label %while.body59, label %while.end61

while.body59:                                     ; preds = %lor.rhs54, %while.cond50
  %incdec.ptr60 = getelementptr inbounds i8, i8* %src.addr.5, i32 1
  br label %while.cond50

while.end61:                                      ; preds = %lor.rhs54
  ret i8* %src.addr.5
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_get_line(%struct.snd_info_buffer* %buffer, i8* %line, i32 %len) #0 {
entry:
  %tobool = icmp ne %struct.snd_info_buffer* %buffer, null
  br i1 %tobool, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %buffer1 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %0 = load i8*, i8** %buffer1, align 8, !tbaa !71
  %tobool2 = icmp ne i8* %0, null
  %lnot = xor i1 %tobool2, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lnot3 = xor i1 %1, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %tobool5 = icmp ne i32 %lnot.ext, 0
  %lnot6 = xor i1 %tobool5, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  %cmp = icmp sle i32 %len, 0
  %or.cond = or i1 %tobool10, %cmp
  br i1 %or.cond, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %lor.end
  %stop = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %2 = load i32, i32* %stop, align 4, !tbaa !90
  %tobool12 = icmp ne i32 %2, 0
  br i1 %tobool12, label %cleanup, label %lor.lhs.false13

lor.lhs.false13:                                  ; preds = %lor.lhs.false
  %error = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 5
  %3 = load i32, i32* %error, align 8, !tbaa !82
  %tobool14 = icmp ne i32 %3, 0
  br i1 %tobool14, label %cleanup, label %if.end16

if.end16:                                         ; preds = %lor.lhs.false13
  br label %while.cond

while.cond:                                       ; preds = %if.end36, %if.end16
  %len.addr.0 = phi i32 [ %len, %if.end16 ], [ %len.addr.1, %if.end36 ]
  %line.addr.0 = phi i8* [ %line, %if.end16 ], [ %line.addr.1, %if.end36 ]
  %stop17 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %4 = load i32, i32* %stop17, align 4, !tbaa !90
  %tobool18 = icmp ne i32 %4, 0
  %lnot19 = xor i1 %tobool18, true
  br i1 %lnot19, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %buffer21 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %5 = load i8*, i8** %buffer21, align 8, !tbaa !71
  %curr = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %6 = load i32, i32* %curr, align 8, !tbaa !91
  %inc = add i32 %6, 1
  store i32 %inc, i32* %curr, align 8, !tbaa !91
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !48
  %conv22 = sext i8 %7 to i32
  %curr23 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %8 = load i32, i32* %curr23, align 8, !tbaa !91
  %size = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %9 = load i32, i32* %size, align 4, !tbaa !68
  %cmp24 = icmp uge i32 %8, %9
  br i1 %cmp24, label %if.then26, label %if.end28

if.then26:                                        ; preds = %while.body
  %stop27 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  store i32 1, i32* %stop27, align 4, !tbaa !90
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %while.body
  %cmp29 = icmp eq i32 %conv22, 10
  br i1 %cmp29, label %while.end, label %if.end32

if.end32:                                         ; preds = %if.end28
  %tobool33 = icmp ne i32 %len.addr.0, 0
  br i1 %tobool33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end32
  %dec = add nsw i32 %len.addr.0, -1
  %conv35 = trunc i32 %conv22 to i8
  %incdec.ptr = getelementptr inbounds i8, i8* %line.addr.0, i32 1
  store i8 %conv35, i8* %line.addr.0, align 1, !tbaa !48
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end32
  %len.addr.1 = phi i32 [ %dec, %if.then34 ], [ %len.addr.0, %if.end32 ]
  %line.addr.1 = phi i8* [ %incdec.ptr, %if.then34 ], [ %line.addr.0, %if.end32 ]
  br label %while.cond

while.end:                                        ; preds = %if.end28, %while.cond
  store i8 0, i8* %line.addr.0, align 1, !tbaa !48
  br label %cleanup

cleanup:                                          ; preds = %while.end, %lor.lhs.false13, %lor.lhs.false, %lor.end
  %retval.0 = phi i32 [ 0, %while.end ], [ 1, %lor.end ], [ 1, %lor.lhs.false13 ], [ 1, %lor.lhs.false ]
  ret i32 %retval.0
}

declare i32 @snd_card_info_done() #2

declare i32 @snd_minor_info_oss_done() #2

; Function Attrs: nounwind uwtable
define i32 @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* %fmt, ...) #0 {
entry:
  %args = alloca [1 x %struct.__va_list_tag], align 16
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  %0 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %0) #7
  %call = call i32 @_cond_resched()
  %stop = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 4
  %1 = load i32, i32* %stop, align 4, !tbaa !90
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %cleanup35, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %error = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 5
  %2 = load i32, i32* %error, align 8, !tbaa !82
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %cleanup35, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %len2 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  %3 = load i32, i32* %len2, align 8, !tbaa !74
  %size = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %4 = load i32, i32* %size, align 4, !tbaa !68
  %sub = sub i32 %3, %4
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay3 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay3)
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %if.end
  %len.0 = phi i32 [ %sub, %if.end ], [ %len.1, %cleanup.cont ]
  %err.0 = phi i32 [ 0, %if.end ], [ %err.1, %cleanup.cont ]
  %5 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* %5) #7
  %arraydecay4 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %6 = bitcast %struct.__va_list_tag* %arraydecay4 to i8*
  %7 = bitcast %struct.__va_list_tag* %arraydecay5 to i8*
  call void @llvm.va_copy(i8* %6, i8* %7)
  %buffer6 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 0
  %8 = load i8*, i8** %buffer6, align 8, !tbaa !71
  %curr = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %9 = load i32, i32* %curr, align 8, !tbaa !91
  %idx.ext = zext i32 %9 to i64
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 %idx.ext
  %conv = sext i32 %len.0 to i64
  %arraydecay7 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  %call8 = call i32 @vsnprintf(i8* %add.ptr, i64 %conv, i8* %fmt, %struct.__va_list_tag* %arraydecay7)
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  %arraydecay910 = bitcast %struct.__va_list_tag* %arraydecay9 to i8*
  call void @llvm.va_end(i8* %arraydecay910)
  %cmp = icmp slt i32 %call8, %len.0
  br i1 %cmp, label %cleanup, label %if.end13

if.end13:                                         ; preds = %for.cond
  %len14 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  %10 = load i32, i32* %len14, align 8, !tbaa !74
  %conv15 = zext i32 %10 to i64
  %add = add i64 %conv15, 4096
  %conv16 = trunc i64 %add to i32
  %call17 = call i32 @resize_info_buffer(%struct.snd_info_buffer* %buffer, i32 %conv16)
  %cmp18 = icmp slt i32 %call17, 0
  br i1 %cmp18, label %cleanup, label %if.end21

if.end21:                                         ; preds = %if.end13
  %len22 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 3
  %11 = load i32, i32* %len22, align 8, !tbaa !74
  %size23 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %12 = load i32, i32* %size23, align 4, !tbaa !68
  %sub24 = sub i32 %11, %12
  br label %cleanup

cleanup:                                          ; preds = %if.end21, %if.end13, %for.cond
  %len.1 = phi i32 [ %sub24, %if.end21 ], [ %len.0, %for.cond ], [ %len.0, %if.end13 ]
  %err.1 = phi i32 [ %call17, %if.end21 ], [ %err.0, %for.cond ], [ %call17, %if.end13 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end21 ], [ 4, %for.cond ], [ 4, %if.end13 ]
  %13 = bitcast [1 x %struct.__va_list_tag]* %ap to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %13) #7
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %cleanup.cont, label %for.end

cleanup.cont:                                     ; preds = %cleanup
  br label %for.cond

for.end:                                          ; preds = %cleanup
  %arraydecay25 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay2526 = bitcast %struct.__va_list_tag* %arraydecay25 to i8*
  call void @llvm.va_end(i8* %arraydecay2526)
  %cmp27 = icmp slt i32 %err.1, 0
  br i1 %cmp27, label %cleanup35, label %if.end30

if.end30:                                         ; preds = %for.end
  %curr31 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 1
  %14 = load i32, i32* %curr31, align 8, !tbaa !91
  %add32 = add i32 %14, %call8
  store i32 %add32, i32* %curr31, align 8, !tbaa !91
  %size33 = getelementptr inbounds %struct.snd_info_buffer, %struct.snd_info_buffer* %buffer, i32 0, i32 2
  %15 = load i32, i32* %size33, align 4, !tbaa !68
  %add34 = add i32 %15, %call8
  store i32 %add34, i32* %size33, align 4, !tbaa !68
  br label %cleanup35

cleanup35:                                        ; preds = %if.end30, %for.end, %lor.lhs.false, %entry
  %retval.0 = phi i32 [ %call8, %if.end30 ], [ 0, %lor.lhs.false ], [ 0, %entry ], [ %err.1, %for.end ]
  %16 = bitcast [1 x %struct.__va_list_tag]* %args to i8*
  call void @llvm.lifetime.end.p0i8(i64 24, i8* %16) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #7

; Function Attrs: nounwind
declare void @llvm.va_copy(i8*, i8*) #7

declare i32 @vsnprintf(i8*, i64, i8*, %struct.__va_list_tag*) #2

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #7

; Function Attrs: nounwind uwtable
define i32 @snd_info_check_reserved_words(i8* %str) #0 {
entry:
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %xstr.0 = phi i8** [ getelementptr inbounds ([12 x i8*], [12 x i8*]* @snd_info_check_reserved_words.reserved, i32 0, i32 0), %entry ], [ %incdec.ptr, %if.end ]
  %0 = load i8*, i8** %xstr.0, align 8, !tbaa !2
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i8*, i8** %xstr.0, align 8, !tbaa !2
  %call = call i32 @strcmp(i8* %1, i8* %str)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.end, label %cleanup

if.end:                                           ; preds = %while.body
  %incdec.ptr = getelementptr inbounds i8*, i8** %xstr.0, i32 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call2 = call i32 @strncmp(i8* %str, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11.15, i32 0, i32 0), i64 4)
  %tobool3 = icmp ne i32 %call2, 0
  %. = select i1 %tobool3, i32 1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %while.end, %while.body
  %retval.0 = phi i32 [ 0, %while.body ], [ %., %while.end ]
  ret i32 %retval.0
}

declare i32 @strcmp(i8*, i8*) #2

declare i32 @strncmp(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define i32 @snd_info_init() #0 section ".init.text" {
entry:
  %call = call %struct.proc_dir_entry* @proc_mkdir(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.12.32, i32 0, i32 0), %struct.proc_dir_entry* null)
  %cmp = icmp eq %struct.proc_dir_entry* %call, null
  br i1 %cmp, label %cleanup27, label %if.end

if.end:                                           ; preds = %entry
  store %struct.proc_dir_entry* %call, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %call2 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.5.24, i32 0, i32 0), %struct.snd_info_entry* null)
  %cmp3 = icmp eq %struct.snd_info_entry* %call2, null
  br i1 %cmp3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call2, i32 0, i32 1
  store i16 16749, i16* %mode, align 8, !tbaa !56
  %call6 = call i32 @snd_info_register(%struct.snd_info_entry* %call2)
  %cmp7 = icmp slt i32 %call6, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  call void @snd_info_free_entry(%struct.snd_info_entry* %call2)
  br label %cleanup

if.end9:                                          ; preds = %if.end5
  store %struct.snd_info_entry* %call2, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.end9, %if.then8, %if.end
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then8 ], [ 0, %if.end9 ], [ 1, %if.end ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %cleanup.cont, label %cleanup27

cleanup.cont:                                     ; preds = %cleanup
  %call11 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10.29, i32 0, i32 0), %struct.snd_info_entry* null)
  %cmp12 = icmp eq %struct.snd_info_entry* %call11, null
  br i1 %cmp12, label %cleanup20, label %if.end14

if.end14:                                         ; preds = %cleanup.cont
  %mode15 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call11, i32 0, i32 1
  store i16 16749, i16* %mode15, align 8, !tbaa !56
  %call16 = call i32 @snd_info_register(%struct.snd_info_entry* %call11)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  call void @snd_info_free_entry(%struct.snd_info_entry* %call11)
  br label %cleanup20

if.end19:                                         ; preds = %if.end14
  store %struct.snd_info_entry* %call11, %struct.snd_info_entry** @snd_seq_root, align 8, !tbaa !2
  br label %cleanup20

cleanup20:                                        ; preds = %if.end19, %if.then18, %cleanup.cont
  %cleanup.dest.slot.1 = phi i32 [ 1, %if.then18 ], [ 0, %if.end19 ], [ 1, %cleanup.cont ]
  %cond1 = icmp eq i32 %cleanup.dest.slot.1, 0
  br i1 %cond1, label %cleanup.cont22, label %cleanup27

cleanup.cont22:                                   ; preds = %cleanup20
  %call23 = call i32 @snd_info_version_init()
  %call24 = call i32 @snd_minor_info_init()
  %call25 = call i32 @snd_minor_info_oss_init()
  %call26 = call i32 @snd_card_info_init()
  br label %cleanup27

cleanup27:                                        ; preds = %cleanup.cont22, %cleanup20, %cleanup, %entry
  %retval.2 = phi i32 [ -12, %cleanup ], [ -12, %cleanup20 ], [ 0, %cleanup.cont22 ], [ -12, %entry ]
  ret i32 %retval.2
}

declare %struct.proc_dir_entry* @proc_mkdir(i8*, %struct.proc_dir_entry*) #2

; Function Attrs: nounwind uwtable
define internal i32 @snd_info_version_init() #0 section ".init.text" {
entry:
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* null, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.19, i32 0, i32 0), %struct.snd_info_entry* null)
  %cmp = icmp eq %struct.snd_info_entry* %call, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.43* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_info_version_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !48
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  store %struct.snd_info_entry* %call, %struct.snd_info_entry** @snd_info_version_entry, align 8, !tbaa !2
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.then4, %entry
  %retval.0 = phi i32 [ -12, %if.then4 ], [ 0, %if.end5 ], [ -12, %entry ]
  ret i32 %retval.0
}

declare i32 @snd_minor_info_oss_init() #2

declare i32 @snd_card_info_init() #2

; Function Attrs: nounwind uwtable
define internal void @snd_info_version_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %call = call %struct.new_utsname* @init_utsname()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call, i32 0, i32 2
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %call2 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.16.33, i32 0, i32 0), i8* %arraydecay)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname() #1 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_create(%struct.snd_card* %card) #0 {
entry:
  %str = alloca [8 x i8], align 1
  %0 = bitcast [8 x i8]* %str to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %tobool4 = icmp ne i32 %lnot.ext, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %arraydecay = getelementptr inbounds [8 x i8], [8 x i8]* %str, i32 0, i32 0
  %number = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 0
  %1 = load i32, i32* %number, align 8, !tbaa !36
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.13.34, i32 0, i32 0), i32 %1)
  %module = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 7
  %2 = load %struct.module*, %struct.module** %module, align 8, !tbaa !86
  %arraydecay10 = getelementptr inbounds [8 x i8], [8 x i8]* %str, i32 0, i32 0
  %call11 = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* %2, i8* %arraydecay10, %struct.snd_info_entry* null)
  %cmp = icmp eq %struct.snd_info_entry* %call11, null
  br i1 %cmp, label %cleanup, label %if.end14

if.end14:                                         ; preds = %if.end
  %mode = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call11, i32 0, i32 1
  store i16 16749, i16* %mode, align 8, !tbaa !56
  %call15 = call i32 @snd_info_register(%struct.snd_info_entry* %call11)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  call void @snd_info_free_entry(%struct.snd_info_entry* %call11)
  br label %cleanup

if.end19:                                         ; preds = %if.end14
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  store %struct.snd_info_entry* %call11, %struct.snd_info_entry** %proc_root, align 8, !tbaa !85
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then18, %if.end, %entry
  %retval.0 = phi i32 [ -12, %if.then18 ], [ 0, %if.end19 ], [ -6, %entry ], [ -12, %if.end ]
  %3 = bitcast [8 x i8]* %str to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  ret i32 %retval.0
}

declare i32 @sprintf(i8*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_register(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !85
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %0, i32 0, i32 0
  %1 = load i8*, i8** %name, align 8, !tbaa !51
  %call = call i32 @strcmp(i8* %arraydecay, i8* %1)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.end11, label %cleanup

if.end11:                                         ; preds = %if.end
  %id12 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay13 = getelementptr inbounds [16 x i8], [16 x i8]* %id12, i32 0, i32 0
  %2 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %proc_root14 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %3 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root14, align 8, !tbaa !85
  %name15 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %3, i32 0, i32 0
  %4 = load i8*, i8** %name15, align 8, !tbaa !51
  %call16 = call %struct.proc_dir_entry* @proc_symlink(i8* %arraydecay13, %struct.proc_dir_entry* %2, i8* %4)
  %cmp = icmp eq %struct.proc_dir_entry* %call16, null
  br i1 %cmp, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end11
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* %call16, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !92
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.end11, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end19 ], [ -6, %entry ], [ 0, %if.end ], [ -12, %if.end11 ]
  ret i32 %retval.0
}

declare %struct.proc_dir_entry* @proc_symlink(i8*, %struct.proc_dir_entry*, i8*) #2

; Function Attrs: nounwind uwtable
define void @snd_info_card_id_change(%struct.snd_card* %card) #0 {
entry:
  call void @mutex_lock(%struct.mutex* @info_mutex)
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !92
  %tobool = icmp ne %struct.proc_dir_entry* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %proc_root_link1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  %1 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link1, align 8, !tbaa !92
  call void @proc_remove(%struct.proc_dir_entry* %1)
  %proc_root_link2 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %proc_root_link2, align 8, !tbaa !92
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %id = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %id, i32 0, i32 0
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !85
  %name = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %2, i32 0, i32 0
  %3 = load i8*, i8** %name, align 8, !tbaa !51
  %call = call i32 @strcmp(i8* %arraydecay, i8* %3)
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.then4, label %if.end11

if.then4:                                         ; preds = %if.end
  %id5 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 1
  %arraydecay6 = getelementptr inbounds [16 x i8], [16 x i8]* %id5, i32 0, i32 0
  %4 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** @snd_proc_root, align 8, !tbaa !2
  %proc_root7 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %5 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root7, align 8, !tbaa !85
  %name8 = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %5, i32 0, i32 0
  %6 = load i8*, i8** %name8, align 8, !tbaa !51
  %call9 = call %struct.proc_dir_entry* @proc_symlink(i8* %arraydecay6, %struct.proc_dir_entry* %4, i8* %6)
  %proc_root_link10 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* %call9, %struct.proc_dir_entry** %proc_root_link10, align 8, !tbaa !92
  br label %if.end11

if.end11:                                         ; preds = %if.then4, %if.end
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define void @snd_info_card_disconnect(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @info_mutex)
  %proc_root_link = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  %0 = load %struct.proc_dir_entry*, %struct.proc_dir_entry** %proc_root_link, align 8, !tbaa !92
  call void @proc_remove(%struct.proc_dir_entry* %0)
  %proc_root_link1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 20
  store %struct.proc_dir_entry* null, %struct.proc_dir_entry** %proc_root_link1, align 8, !tbaa !92
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %1 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !85
  %tobool2 = icmp ne %struct.snd_info_entry* %1, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %proc_root4 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %2 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root4, align 8, !tbaa !85
  call void @snd_info_disconnect(%struct.snd_info_entry* %2)
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  call void @mutex_unlock(%struct.mutex* @info_mutex)
  br label %return

return:                                           ; preds = %if.end5, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_card_free(%struct.snd_card* %card) #0 {
entry:
  %tobool = icmp ne %struct.snd_card* %card, null
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %proc_root = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** %proc_root, align 8, !tbaa !85
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  %proc_root1 = getelementptr inbounds %struct.snd_card, %struct.snd_card* %card, i32 0, i32 18
  store %struct.snd_info_entry* null, %struct.snd_info_entry** %proc_root1, align 8, !tbaa !85
  br label %return

return:                                           ; preds = %if.end, %entry
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @snd_oss_info_register(i32 %dev, i32 %num, i8* %string) #0 {
entry:
  %cmp = icmp slt i32 %dev, 0
  %cmp1 = icmp sge i32 %dev, 6
  %.cmp1 = select i1 %cmp, i1 true, i1 %cmp1
  %lnot = xor i1 %.cmp1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot3 = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %cmp9 = icmp slt i32 %num, 0
  %cmp12 = icmp sge i32 %num, 32
  %.cmp12 = select i1 %cmp9, i1 true, i1 %cmp12
  %lnot15 = xor i1 %.cmp12, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %tobool20 = icmp ne i32 %lnot.ext18, 0
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot.ext24 = zext i1 %lnot23 to i32
  %conv25 = sext i32 %lnot.ext24 to i64
  %expval26 = call i64 @llvm.expect.i64(i64 %conv25, i64 0)
  %tobool27 = icmp ne i64 %expval26, 0
  br i1 %tobool27, label %cleanup, label %if.end29

if.end29:                                         ; preds = %if.end
  call void @mutex_lock(%struct.mutex* @strings)
  %cmp30 = icmp eq i8* %string, null
  br i1 %cmp30, label %if.then32, label %if.else

if.then32:                                        ; preds = %if.end29
  %idxprom = sext i32 %num to i64
  %arrayidx = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom
  %idxprom33 = sext i32 %dev to i64
  %arrayidx34 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx, i64 0, i64 %idxprom33
  %0 = load i8*, i8** %arrayidx34, align 8, !tbaa !2
  %cmp35 = icmp ne i8* %0, null
  br i1 %cmp35, label %if.then37, label %if.end43

if.then37:                                        ; preds = %if.then32
  call void @kfree(i8* %0)
  br label %if.end43

if.else:                                          ; preds = %if.end29
  %call = call i8* @kstrdup(i8* %string, i32 208)
  %cmp39 = icmp eq i8* %call, null
  br i1 %cmp39, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.else
  call void @mutex_unlock(%struct.mutex* @strings)
  br label %cleanup

if.end43:                                         ; preds = %if.else, %if.then37, %if.then32
  %x.1 = phi i8* [ null, %if.then37 ], [ %0, %if.then32 ], [ %call, %if.else ]
  %idxprom44 = sext i32 %num to i64
  %arrayidx45 = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom44
  %idxprom46 = sext i32 %dev to i64
  %arrayidx47 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx45, i64 0, i64 %idxprom46
  store i8* %x.1, i8** %arrayidx47, align 8, !tbaa !2
  call void @mutex_unlock(%struct.mutex* @strings)
  br label %cleanup

cleanup:                                          ; preds = %if.end43, %if.then41, %if.end, %entry
  %retval.0 = phi i32 [ 0, %if.end43 ], [ -12, %if.then41 ], [ -6, %entry ], [ -6, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_minor_register() #0 {
entry:
  call void @llvm.memset.p0i8.i64(i8* bitcast ([32 x [6 x i8*]]* @snd_sndstat_strings to i8*), i8 0, i64 1536, i32 16, i1 false)
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_oss_root, align 8, !tbaa !2
  %call = call %struct.snd_info_entry* @snd_info_create_module_entry(%struct.module* null, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.38, i32 0, i32 0), %struct.snd_info_entry* %0)
  %cmp = icmp ne %struct.snd_info_entry* %call, null
  br i1 %cmp, label %if.then, label %if.end5

if.then:                                          ; preds = %entry
  %c = getelementptr inbounds %struct.snd_info_entry, %struct.snd_info_entry* %call, i32 0, i32 4
  %text = bitcast %union.anon.43* %c to %struct.snd_info_entry_text*
  %read = getelementptr inbounds %struct.snd_info_entry_text, %struct.snd_info_entry_text* %text, i32 0, i32 0
  store void (%struct.snd_info_entry*, %struct.snd_info_buffer*)* @snd_sndstat_proc_read, void (%struct.snd_info_entry*, %struct.snd_info_buffer*)** %read, align 8, !tbaa !48
  %call2 = call i32 @snd_info_register(%struct.snd_info_entry* %call)
  %cmp3 = icmp slt i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then
  call void @snd_info_free_entry(%struct.snd_info_entry* %call)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.then, %entry
  %entry1.1 = phi %struct.snd_info_entry* [ %call, %entry ], [ null, %if.then4 ], [ %call, %if.then ]
  store %struct.snd_info_entry* %entry1.1, %struct.snd_info_entry** @snd_sndstat_proc_entry, align 8, !tbaa !2
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #5

; Function Attrs: nounwind uwtable
define internal void @snd_sndstat_proc_read(%struct.snd_info_entry* %entry1, %struct.snd_info_buffer* %buffer) #0 {
entry:
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.1.39, i32 0, i32 0))
  %call2 = call %struct.new_utsname* @init_utsname.40()
  %sysname = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %sysname, i32 0, i32 0
  %call3 = call %struct.new_utsname* @init_utsname.40()
  %nodename = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call3, i32 0, i32 1
  %arraydecay4 = getelementptr inbounds [65 x i8], [65 x i8]* %nodename, i32 0, i32 0
  %call5 = call %struct.new_utsname* @init_utsname.40()
  %release = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call5, i32 0, i32 2
  %arraydecay6 = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %call7 = call %struct.new_utsname* @init_utsname.40()
  %version = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call7, i32 0, i32 3
  %arraydecay8 = getelementptr inbounds [65 x i8], [65 x i8]* %version, i32 0, i32 0
  %call9 = call %struct.new_utsname* @init_utsname.40()
  %machine = getelementptr inbounds %struct.new_utsname, %struct.new_utsname* %call9, i32 0, i32 4
  %arraydecay10 = getelementptr inbounds [65 x i8], [65 x i8]* %machine, i32 0, i32 0
  %call11 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2.41, i32 0, i32 0), i8* %arraydecay, i8* %arraydecay4, i8* %arraydecay6, i8* %arraydecay8, i8* %arraydecay10)
  %call12 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.3.42, i32 0, i32 0))
  %call13 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.4.43, i32 0, i32 0))
  %call14 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.5.44, i32 0, i32 0))
  %call15 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.6.45, i32 0, i32 0))
  call void @snd_card_info_read_oss(%struct.snd_info_buffer* %buffer)
  %call16 = call i32 @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.7.46, i32 0, i32 0), i32 0)
  %call17 = call i32 @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.8.47, i32 0, i32 0), i32 1)
  %call18 = call i32 @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.9.48, i32 0, i32 0), i32 2)
  %call19 = call i32 @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.10.49, i32 0, i32 0), i32 4)
  %call20 = call i32 @snd_sndstat_show_strings(%struct.snd_info_buffer* %buffer, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.11.50, i32 0, i32 0), i32 5)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.new_utsname* @init_utsname.40() #1 {
entry:
  ret %struct.new_utsname* getelementptr inbounds (%struct.uts_namespace, %struct.uts_namespace* @init_uts_ns, i32 0, i32 1)
}

declare void @snd_card_info_read_oss(%struct.snd_info_buffer*) #2

; Function Attrs: nounwind uwtable
define internal i32 @snd_sndstat_show_strings(%struct.snd_info_buffer* %buf, i8* %id, i32 %dev) #0 {
entry:
  %call = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12.51, i32 0, i32 0), i8* %id)
  call void @mutex_lock(%struct.mutex* @strings)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %idx.0 = phi i32 [ 0, %entry ], [ %inc8, %for.inc ]
  %ok.0 = phi i32 [ -1, %entry ], [ %ok.2, %for.inc ]
  %cmp = icmp slt i32 %idx.0, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %idx.0 to i64
  %arrayidx = getelementptr inbounds [32 x [6 x i8*]], [32 x [6 x i8*]]* @snd_sndstat_strings, i64 0, i64 %idxprom
  %idxprom1 = sext i32 %dev to i64
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %arrayidx, i64 0, i64 %idxprom1
  %0 = load i8*, i8** %arrayidx2, align 8, !tbaa !2
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %cmp3 = icmp slt i32 %ok.0, 0
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %call5 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.13.52, i32 0, i32 0))
  %inc = add nsw i32 %ok.0, 1
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %ok.1 = phi i32 [ %inc, %if.then4 ], [ %ok.0, %if.then ]
  %call6 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.14.53, i32 0, i32 0), i32 %idx.0, i8* %0)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %ok.2 = phi i32 [ %ok.1, %if.end ], [ %ok.0, %for.body ]
  %inc8 = add nsw i32 %idx.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @strings)
  %cmp9 = icmp slt i32 %ok.0, 0
  br i1 %cmp9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %for.end
  %call11 = call i32 (%struct.snd_info_buffer*, i8*, ...) @snd_iprintf(%struct.snd_info_buffer* %buf, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.15.54, i32 0, i32 0))
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %for.end
  ret i32 %ok.0
}

; Function Attrs: nounwind uwtable
define i32 @snd_info_minor_unregister() #0 {
entry:
  %0 = load %struct.snd_info_entry*, %struct.snd_info_entry** @snd_sndstat_proc_entry, align 8, !tbaa !2
  call void @snd_info_free_entry(%struct.snd_info_entry* %0)
  store %struct.snd_info_entry* null, %struct.snd_info_entry** @snd_sndstat_proc_entry, align 8, !tbaa !2
  ret i32 0
}

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readnone }
attributes #4 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }

!llvm.ident = !{!0, !0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !4, i64 0}
!8 = !{!9, !3, i64 40}
!9 = !{!"file", !4, i64 0, !10, i64 16, !3, i64 32, !3, i64 40, !11, i64 48, !7, i64 52, !12, i64 56, !7, i64 64, !7, i64 68, !14, i64 72, !15, i64 80, !3, i64 112, !17, i64 120, !14, i64 152, !3, i64 160, !3, i64 168, !18, i64 176, !18, i64 192, !3, i64 208}
!10 = !{!"path", !3, i64 0, !3, i64 8}
!11 = !{!"spinlock", !4, i64 0}
!12 = !{!"", !13, i64 0}
!13 = !{!"long", !4, i64 0}
!14 = !{!"long long", !4, i64 0}
!15 = !{!"fown_struct", !16, i64 0, !3, i64 8, !4, i64 16, !7, i64 20, !7, i64 24, !7, i64 28}
!16 = !{!"", !4, i64 0}
!17 = !{!"file_ra_state", !13, i64 0, !7, i64 8, !7, i64 12, !7, i64 16, !7, i64 20, !14, i64 24}
!18 = !{!"list_head", !3, i64 0, !3, i64 8}
!19 = !{!20, !3, i64 16}
!20 = !{!"snd_minor", !7, i64 0, !7, i64 4, !7, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40}
!21 = !{!22, !3, i64 0}
!22 = !{!"file_operations", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112, !3, i64 120, !3, i64 128, !3, i64 136, !3, i64 144, !3, i64 152, !3, i64 160, !3, i64 168, !3, i64 176, !3, i64 184, !3, i64 192, !3, i64 200, !3, i64 208}
!23 = !{!22, !3, i64 88}
!24 = !{!25, !7, i64 76}
!25 = !{!"inode", !26, i64 0, !26, i64 2, !7, i64 4, !7, i64 8, !7, i64 12, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !13, i64 64, !4, i64 72, !7, i64 76, !14, i64 80, !27, i64 88, !27, i64 104, !27, i64 120, !11, i64 136, !26, i64 138, !7, i64 140, !13, i64 144, !13, i64 152, !28, i64 160, !13, i64 200, !30, i64 208, !18, i64 224, !18, i64 240, !18, i64 256, !4, i64 272, !14, i64 288, !29, i64 296, !29, i64 300, !29, i64 304, !3, i64 312, !3, i64 320, !31, i64 328, !4, i64 496, !18, i64 512, !4, i64 528, !7, i64 536, !7, i64 540, !34, i64 544, !3, i64 552}
!26 = !{!"short", !4, i64 0}
!27 = !{!"timespec", !13, i64 0, !13, i64 8}
!28 = !{!"mutex", !29, i64 0, !11, i64 4, !18, i64 8, !3, i64 24, !3, i64 32}
!29 = !{!"", !7, i64 0}
!30 = !{!"hlist_node", !3, i64 0, !3, i64 8}
!31 = !{!"address_space", !3, i64 0, !32, i64 8, !11, i64 24, !7, i64 28, !33, i64 32, !18, i64 40, !28, i64 56, !13, i64 96, !13, i64 104, !3, i64 112, !13, i64 120, !3, i64 128, !11, i64 136, !18, i64 144, !3, i64 160}
!32 = !{!"radix_tree_root", !7, i64 0, !7, i64 4, !3, i64 8}
!33 = !{!"rb_root", !3, i64 0}
!34 = !{!"hlist_head", !3, i64 0}
!35 = !{!20, !3, i64 32}
!36 = !{!37, !7, i64 0}
!37 = !{!"snd_card", !7, i64 0, !4, i64 4, !4, i64 20, !4, i64 36, !4, i64 68, !4, i64 148, !4, i64 228, !3, i64 360, !3, i64 368, !3, i64 376, !18, i64 384, !7, i64 400, !38, i64 408, !16, i64 440, !7, i64 444, !7, i64 448, !18, i64 456, !18, i64 472, !3, i64 488, !3, i64 496, !3, i64 504, !18, i64 512, !3, i64 528, !11, i64 536, !7, i64 540, !7, i64 544, !41, i64 552, !29, i64 576, !3, i64 584, !3, i64 592, !7, i64 600, !28, i64 608, !41, i64 648, !3, i64 672, !7, i64 680}
!38 = !{!"rw_semaphore", !13, i64 0, !39, i64 8, !18, i64 16}
!39 = !{!"raw_spinlock", !40, i64 0}
!40 = !{!"arch_spinlock", !4, i64 0}
!41 = !{!"__wait_queue_head", !11, i64 0, !18, i64 8}
!42 = !{!20, !7, i64 0}
!43 = !{!20, !7, i64 4}
!44 = !{!20, !7, i64 8}
!45 = !{!20, !3, i64 24}
!46 = !{!20, !3, i64 40}
!47 = !{i32 -2146795357, i32 -2146795318, i32 -2146795297, i32 -2146795260, i32 -2146795237, i32 -2146795367}
!48 = !{!4, !4, i64 0}
!49 = !{!50, !3, i64 88}
!50 = !{!"snd_info_entry", !3, i64 0, !26, i64 8, !13, i64 16, !26, i64 24, !4, i64 32, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !28, i64 96, !18, i64 136, !18, i64 152}
!51 = !{!50, !3, i64 0}
!52 = !{!50, !3, i64 80}
!53 = !{!18, !3, i64 0}
!54 = !{!50, !3, i64 48}
!55 = !{!18, !3, i64 8}
!56 = !{!50, !26, i64 8}
!57 = !{!50, !13, i64 16}
!58 = !{!9, !3, i64 168}
!59 = !{!60, !3, i64 16}
!60 = !{!"snd_info_private_data", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24}
!61 = !{!50, !26, i64 24}
!62 = !{!63, !3, i64 32}
!63 = !{!"snd_info_entry_ops", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56}
!64 = !{!60, !3, i64 24}
!65 = !{!9, !14, i64 72}
!66 = !{!14, !14, i64 0}
!67 = !{!60, !3, i64 0}
!68 = !{!69, !7, i64 12}
!69 = !{!"snd_info_buffer", !3, i64 0, !7, i64 8, !7, i64 12, !7, i64 16, !7, i64 20, !7, i64 24}
!70 = !{!13, !13, i64 0}
!71 = !{!69, !3, i64 0}
!72 = !{!63, !3, i64 16}
!73 = !{!60, !3, i64 8}
!74 = !{!69, !7, i64 16}
!75 = !{!63, !3, i64 24}
!76 = !{!63, !3, i64 40}
!77 = !{!63, !3, i64 48}
!78 = !{!63, !3, i64 56}
!79 = !{!50, !3, i64 64}
!80 = !{!9, !7, i64 64}
!81 = !{!63, !3, i64 0}
!82 = !{!69, !7, i64 24}
!83 = !{!63, !3, i64 8}
!84 = !{!9, !3, i64 32}
!85 = !{!37, !3, i64 488}
!86 = !{!37, !3, i64 360}
!87 = !{!50, !3, i64 56}
!88 = !{!89, !3, i64 32}
!89 = !{!"snd_device", !18, i64 0, !3, i64 16, !7, i64 24, !7, i64 28, !3, i64 32, !3, i64 40}
!90 = !{!69, !7, i64 20}
!91 = !{!69, !7, i64 8}
!92 = !{!37, !3, i64 504}
