; ModuleID = 'drivers/hwmon/sis5595.bc'
source_filename = "drivers/hwmon/sis5595.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.46 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.44, %struct.list_head, %struct.list_head, %union.anon.45 }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.42 }
%union.anon.42 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, [56 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.4, i32 }
%union.anon.4 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.5, %union.anon.28, %union.anon.29, %union.anon.33, %union.anon.36, [8 x i8] }
%union.anon.5 = type { %struct.address_space* }
%union.anon.28 = type { i64 }
%union.anon.29 = type { i64 }
%union.anon.33 = type { %struct.list_head }
%union.anon.36 = type { i64 }
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.6, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.6 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.7 }
%union.anon.7 = type { %struct.anon.8 }
%struct.anon.8 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.11 }
%union.anon.11 = type { %struct.anon.15, [80 x i8] }
%struct.anon.15 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.21 }
%union.anon.21 = type { %struct.anon.22 }
%struct.anon.22 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.24, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.27 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i64, i64 }
%union.anon.27 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, [32 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%union.anon.44 = type { %struct.list_head }
%union.anon.45 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.37, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.38, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.41, i32, i32, %struct.hlist_head, i8* }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.37 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.38 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.41 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.39 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.39 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type opaque
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%union.anon.46 = type { i8* }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i16, i8, i8, i8, i8, i8, i8, i16, [4 x i8], i64*, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, [3 x i8], i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [11 x %struct.resource], i8, i32, i8, i16, %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [11 x %struct.bin_attribute*], [11 x %struct.bin_attribute*], %struct.attribute_group**, %struct.pci_vpd*, %union.anon.47, i16, i8, i8, %struct.atomic_t, i64, i64, i8* }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_controller*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*)*, void (%struct.pci_bus*)*, i8* (%struct.pci_bus*, i32, i32)*, i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_controller = type opaque
%struct.proc_dir_entry = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.pcie_link_state = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.pci_vpd = type opaque
%union.anon.47 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, i8*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id*, i8 }
%struct.sensor_device_attribute = type { %struct.device_attribute, i32 }
%struct.sis5595_data = type { i16, i8*, %struct.device*, %struct.mutex, %struct.mutex, i8, i64, i8, i8, [5 x i8], [5 x i8], [5 x i8], [2 x i8], [2 x i8], i8, i8, i8, [2 x i8], i16 }

@__param_str_force_addr = internal constant [19 x i8] c"sis5595.force_addr\00", align 16
@param_ops_ushort = external constant %struct.kernel_param_ops, align 8
@force_addr = internal global i16 0, align 2
@__param_force_addr = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_force_addr, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_ushort, i16 0, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i16* @force_addr to i8*) } }, section "__param", align 8
@sis5595_pci_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([2 x %struct.pci_device_id], [2 x %struct.pci_device_id]* @sis5595_pci_ids, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @sis5595_pci_probe, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.pci_dynids zeroinitializer }, align 8
@s_bridge = internal global %struct.pci_dev* null, align 8
@pdev = internal global %struct.platform_device* null, align 8
@sis5595_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* @sis5595_probe, i32 (%struct.platform_device*)* @sis5595_remove, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null, i8 0 }, align 8
@__initcall_sm_sis5595_init6 = internal global i32 ()* @sm_sis5595_init, section ".initcall6.init", align 8
@__exitcall_sm_sis5595_exit = internal global void ()* @sm_sis5595_exit, section ".exitcall.exit", align 8
@.str = private unnamed_addr constant [8 x i8] c"sis5595\00", align 1
@sis5595_pci_ids = internal constant [2 x %struct.pci_device_id] [%struct.pci_device_id { i32 4153, i32 8, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id zeroinitializer], align 16
@blacklist = internal global [10 x i32] [i32 1344, i32 1360, i32 1584, i32 1605, i32 1840, i32 1845, i32 21777, i32 21911, i32 21912, i32 0], align 16
@.str.1 = private unnamed_addr constant [54 x i8] c"Looked for SIS5595 but found unsupported device %.4x\0A\00", align 1
@.str.2 = private unnamed_addr constant [26 x i8] c"Forcing ISA address 0x%x\0A\00", align 1
@.str.3 = private unnamed_addr constant [28 x i8] c"Failed to read ISA address\0A\00", align 1
@.str.4 = private unnamed_addr constant [62 x i8] c"Base address not set - upgrade BIOS or use force_addr=0xaddr\0A\00", align 1
@.str.5 = private unnamed_addr constant [29 x i8] c"Failed to force ISA address\0A\00", align 1
@.str.6 = private unnamed_addr constant [32 x i8] c"Failed to read enable register\0A\00", align 1
@.str.7 = private unnamed_addr constant [29 x i8] c"Failed to enable HWM device\0A\00", align 1
@.str.8 = private unnamed_addr constant [37 x i8] c"\013sis5595: Device allocation failed\0A\00", align 1
@.str.9 = private unnamed_addr constant [49 x i8] c"\013sis5595: Device resource addition failed (%d)\0A\00", align 1
@.str.10 = private unnamed_addr constant [40 x i8] c"\013sis5595: Device addition failed (%d)\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@sis5595_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.11 = private unnamed_addr constant [12 x i8] c"&data->lock\00", align 1
@sis5595_probe.__key.12 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.13 = private unnamed_addr constant [19 x i8] c"&data->update_lock\00", align 1
@sis5595_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([27 x %struct.attribute*], [27 x %struct.attribute*]* @sis5595_attributes, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@sis5595_group_in4 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_in4, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@sis5595_group_temp1 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_temp1, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@sis5595_attributes = internal global [27 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_alarms, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_name, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in0_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in0_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.16, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 0 }, align 8
@sensor_dev_attr_in0_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.17, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 0 }, align 8
@sensor_dev_attr_in0_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.20, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.21, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 1 }, align 8
@sensor_dev_attr_in1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.22, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 1 }, align 8
@sensor_dev_attr_in1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.23, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.24, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.25, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 2 }, align 8
@sensor_dev_attr_in2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.26, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 2 }, align 8
@sensor_dev_attr_in2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.27, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.28, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_in3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.29, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 3 }, align 8
@sensor_dev_attr_in3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.30, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 3 }, align 8
@sensor_dev_attr_in3_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.31, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_fan1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.32, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_fan1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 0 }, align 8
@sensor_dev_attr_fan1_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.34, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 0 }, align 8
@sensor_dev_attr_fan1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.36, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 6 }, align 8
@sensor_dev_attr_fan2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_fan2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.38, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 1 }, align 8
@sensor_dev_attr_fan2_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 1 }, align 8
@sensor_dev_attr_fan2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 7 }, align 8
@dev_attr_alarms = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.41, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @alarms_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_name = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @name_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.14 = private unnamed_addr constant [10 x i8] c"in0_input\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@jiffies = external global i64, align 8
@.str.16 = private unnamed_addr constant [8 x i8] c"in0_min\00", align 1
@.str.17 = private unnamed_addr constant [8 x i8] c"in0_max\00", align 1
@.str.18 = private unnamed_addr constant [10 x i8] c"in0_alarm\00", align 1
@.str.19 = private unnamed_addr constant [4 x i8] c"%u\0A\00", align 1
@.str.20 = private unnamed_addr constant [10 x i8] c"in1_input\00", align 1
@.str.21 = private unnamed_addr constant [8 x i8] c"in1_min\00", align 1
@.str.22 = private unnamed_addr constant [8 x i8] c"in1_max\00", align 1
@.str.23 = private unnamed_addr constant [10 x i8] c"in1_alarm\00", align 1
@.str.24 = private unnamed_addr constant [10 x i8] c"in2_input\00", align 1
@.str.25 = private unnamed_addr constant [8 x i8] c"in2_min\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"in2_max\00", align 1
@.str.27 = private unnamed_addr constant [10 x i8] c"in2_alarm\00", align 1
@.str.28 = private unnamed_addr constant [10 x i8] c"in3_input\00", align 1
@.str.29 = private unnamed_addr constant [8 x i8] c"in3_min\00", align 1
@.str.30 = private unnamed_addr constant [8 x i8] c"in3_max\00", align 1
@.str.31 = private unnamed_addr constant [10 x i8] c"in3_alarm\00", align 1
@.str.32 = private unnamed_addr constant [11 x i8] c"fan1_input\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"fan1_min\00", align 1
@.str.34 = private unnamed_addr constant [9 x i8] c"fan1_div\00", align 1
@.str.35 = private unnamed_addr constant [62 x i8] c"fan_div value %ld not supported. Choose one of 1, 2, 4 or 8!\0A\00", align 1
@.str.36 = private unnamed_addr constant [11 x i8] c"fan1_alarm\00", align 1
@.str.37 = private unnamed_addr constant [11 x i8] c"fan2_input\00", align 1
@.str.38 = private unnamed_addr constant [9 x i8] c"fan2_min\00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c"fan2_div\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"fan2_alarm\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"alarms\00", align 1
@.str.42 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.43 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@sis5595_attributes_in4 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.44, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 4 }, align 8
@sensor_dev_attr_in4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.45, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 4 }, align 8
@sensor_dev_attr_in4_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 4 }, align 8
@sensor_dev_attr_in4_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.47, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.44 = private unnamed_addr constant [10 x i8] c"in4_input\00", align 1
@.str.45 = private unnamed_addr constant [8 x i8] c"in4_min\00", align 1
@.str.46 = private unnamed_addr constant [8 x i8] c"in4_max\00", align 1
@.str.47 = private unnamed_addr constant [10 x i8] c"in4_alarm\00", align 1
@sis5595_attributes_temp1 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_input, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max_hyst, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_temp1_input = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.48, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @temp1_input_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_temp1_max = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.49, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @temp1_max_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @temp1_max_store }, align 8
@dev_attr_temp1_max_hyst = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.50, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @temp1_max_hyst_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @temp1_max_hyst_store }, align 8
@sensor_dev_attr_temp1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.51, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.48 = private unnamed_addr constant [12 x i8] c"temp1_input\00", align 1
@.str.49 = private unnamed_addr constant [10 x i8] c"temp1_max\00", align 1
@.str.50 = private unnamed_addr constant [15 x i8] c"temp1_max_hyst\00", align 1
@.str.51 = private unnamed_addr constant [12 x i8] c"temp1_alarm\00", align 1
@llvm.used = appending global [4 x i8*] [i8* bitcast (%struct.kernel_param* @__param_force_addr to i8*), i8* bitcast (void ()* @sm_sis5595_exit to i8*), i8* bitcast (i32 ()** @__initcall_sm_sis5595_init6 to i8*), i8* bitcast (void ()** @__exitcall_sm_sis5595_exit to i8*)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define internal void @sm_sis5595_exit() #0 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @sis5595_pci_driver)
  %0 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %cmp = icmp ne %struct.pci_dev* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  call void @platform_device_unregister(%struct.platform_device* %1)
  call void @platform_driver_unregister(%struct.platform_driver* @sis5595_driver)
  %2 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  call void @pci_dev_put(%struct.pci_dev* %2)
  store %struct.pci_dev* null, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @pci_unregister_driver(%struct.pci_driver*) #1

declare void @platform_device_unregister(%struct.platform_device*) #1

declare void @platform_driver_unregister(%struct.platform_driver*) #1

declare void @pci_dev_put(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sm_sis5595_init() #0 section ".init.text" {
entry:
  %call = call i32 @__pci_register_driver(%struct.pci_driver* @sis5595_pci_driver, %struct.module* null, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0))
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_pci_probe(%struct.pci_dev* %dev, %struct.pci_device_id* %id) #0 {
entry:
  %address = alloca i16, align 2
  %enable = alloca i8, align 1
  %0 = bitcast i16* %address to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %0) #5
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %enable) #5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32* [ getelementptr inbounds ([10 x i32], [10 x i32]* @blacklist, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %for.inc ]
  %1 = load i32, i32* %i.0, align 4, !tbaa !6
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i.0, align 4, !tbaa !6
  %call = call %struct.pci_dev* @pci_get_device(i32 4153, i32 %2, %struct.pci_dev* null)
  %tobool = icmp ne %struct.pci_dev* %call, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %for.body
  %dev1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 35
  %3 = load i32, i32* %i.0, align 4, !tbaa !6
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev1, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.1, i32 0, i32 0), i32 %3)
  call void @pci_dev_put(%struct.pci_dev* %call)
  br label %cleanup

cleanup:                                          ; preds = %for.body, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then ], [ 0, %for.body ]
  %retval.1 = phi i32 [ -19, %if.then ], [ %retval.0, %for.body ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %for.inc, label %cleanup66

for.inc:                                          ; preds = %cleanup
  %incdec.ptr = getelementptr inbounds i32, i32* %i.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %4 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv = zext i16 %4 to i32
  %and = and i32 %conv, -8
  %conv2 = trunc i32 %and to i16
  store i16 %conv2, i16* @force_addr, align 2, !tbaa !8
  %5 = load i16, i16* @force_addr, align 2, !tbaa !8
  %tobool3 = icmp ne i16 %5, 0
  br i1 %tobool3, label %if.then4, label %if.end8

if.then4:                                         ; preds = %for.end
  %dev5 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  %6 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv6 = zext i16 %6 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev5, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), i32 %conv6)
  %7 = load i16, i16* @force_addr, align 2, !tbaa !8
  %call7 = call i32 @pci_write_config_word(%struct.pci_dev* %dev, i32 104, i16 zeroext %7)
  br label %if.end8

if.end8:                                          ; preds = %if.then4, %for.end
  %call9 = call i32 @pci_read_config_word(%struct.pci_dev* %dev, i32 104, i16* %address)
  %cmp10 = icmp ne i32 0, %call9
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end8
  %dev13 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev13, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.3, i32 0, i32 0))
  br label %cleanup66

if.end14:                                         ; preds = %if.end8
  %8 = load i16, i16* %address, align 2, !tbaa !8
  %conv15 = zext i16 %8 to i32
  %and16 = and i32 %conv15, -8
  %conv17 = trunc i32 %and16 to i16
  store i16 %conv17, i16* %address, align 2, !tbaa !8
  %9 = load i16, i16* %address, align 2, !tbaa !8
  %tobool18 = icmp ne i16 %9, 0
  br i1 %tobool18, label %if.end21, label %if.then19

if.then19:                                        ; preds = %if.end14
  %dev20 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev20, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.4, i32 0, i32 0))
  br label %cleanup66

if.end21:                                         ; preds = %if.end14
  %10 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv22 = zext i16 %10 to i32
  %tobool23 = icmp ne i32 %conv22, 0
  br i1 %tobool23, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.end21
  %11 = load i16, i16* %address, align 2, !tbaa !8
  %conv24 = zext i16 %11 to i32
  %12 = load i16, i16* @force_addr, align 2, !tbaa !8
  %conv25 = zext i16 %12 to i32
  %cmp26 = icmp ne i32 %conv24, %conv25
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %land.lhs.true
  %dev29 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev29, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.5, i32 0, i32 0))
  br label %cleanup66

if.end30:                                         ; preds = %land.lhs.true, %if.end21
  %call31 = call i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 123, i8* %enable)
  %cmp32 = icmp ne i32 0, %call31
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end30
  %dev35 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev35, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6, i32 0, i32 0))
  br label %cleanup66

if.end36:                                         ; preds = %if.end30
  %13 = load i8, i8* %enable, align 1, !tbaa !10
  %conv37 = zext i8 %13 to i32
  %and38 = and i32 %conv37, 128
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.end56, label %if.then40

if.then40:                                        ; preds = %if.end36
  %14 = load i8, i8* %enable, align 1, !tbaa !10
  %conv41 = zext i8 %14 to i32
  %or = or i32 %conv41, 128
  %conv42 = trunc i32 %or to i8
  %call43 = call i32 @pci_write_config_byte(%struct.pci_dev* %dev, i32 123, i8 zeroext %conv42)
  %cmp44 = icmp ne i32 0, %call43
  br i1 %cmp44, label %if.then53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then40
  %call46 = call i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 123, i8* %enable)
  %cmp47 = icmp ne i32 0, %call46
  br i1 %cmp47, label %if.then53, label %lor.lhs.false49

lor.lhs.false49:                                  ; preds = %lor.lhs.false
  %15 = load i8, i8* %enable, align 1, !tbaa !10
  %conv50 = zext i8 %15 to i32
  %and51 = and i32 %conv50, 128
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %if.end56, label %if.then53

if.then53:                                        ; preds = %lor.lhs.false49, %lor.lhs.false, %if.then40
  %dev54 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 35
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev54, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.7, i32 0, i32 0))
  br label %cleanup66

if.end56:                                         ; preds = %lor.lhs.false49, %if.end36
  %call57 = call i32 @__platform_driver_register(%struct.platform_driver* @sis5595_driver, %struct.module* null)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %cleanup66, label %if.end60

if.end60:                                         ; preds = %if.end56
  %call61 = call %struct.pci_dev* @pci_dev_get(%struct.pci_dev* %dev)
  store %struct.pci_dev* %call61, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %16 = load i16, i16* %address, align 2, !tbaa !8
  %call62 = call i32 @sis5595_device_add(i16 zeroext %16)
  %tobool63 = icmp ne i32 %call62, 0
  br i1 %tobool63, label %exit_unregister, label %cleanup66

exit_unregister:                                  ; preds = %if.end60
  call void @pci_dev_put(%struct.pci_dev* %dev)
  call void @platform_driver_unregister(%struct.platform_driver* @sis5595_driver)
  br label %cleanup66

cleanup66:                                        ; preds = %cleanup, %exit_unregister, %if.end56, %if.end60, %if.then53, %if.then34, %if.then28, %if.then19, %if.then12
  %retval.2 = phi i32 [ -19, %if.then12 ], [ -19, %if.then28 ], [ -19, %if.then34 ], [ -19, %if.then53 ], [ -19, %if.then19 ], [ -19, %if.end60 ], [ -19, %if.end56 ], [ -19, %exit_unregister ], [ %retval.1, %cleanup ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %enable) #5
  %17 = bitcast i16* %address to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %17) #5
  ret i32 %retval.2
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #1

declare void @dev_err(%struct.device*, i8*, ...) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare void @dev_warn(%struct.device*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_write_config_word(%struct.pci_dev* %dev, i32 %where, i16 zeroext %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !38
  %call = call i32 @pci_bus_write_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16 zeroext %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_read_config_word(%struct.pci_dev* %dev, i32 %where, i16* %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !38
  %call = call i32 @pci_bus_read_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16* %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 %where, i8* %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !38
  %call = call i32 @pci_bus_read_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8* %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_write_config_byte(%struct.pci_dev* %dev, i32 %where, i8 zeroext %val) #3 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !11
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !38
  %call = call i32 @pci_bus_write_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8 zeroext %val)
  ret i32 %call
}

declare i32 @__platform_driver_register(%struct.platform_driver*, %struct.module*) #1

declare %struct.pci_dev* @pci_dev_get(%struct.pci_dev*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_device_add(i16 zeroext %address) #0 {
entry:
  %res = alloca %struct.resource, align 8
  %0 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* %0) #5
  %start = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 0
  %conv = zext i16 %address to i64
  store i64 %conv, i64* %start, align 8, !tbaa !39
  %end = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 1
  %conv1 = zext i16 %address to i32
  %add = add nsw i32 %conv1, 8
  %sub = sub nsw i32 %add, 1
  %conv2 = sext i32 %sub to i64
  store i64 %conv2, i64* %end, align 8, !tbaa !41
  %name = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 2
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8** %name, align 8, !tbaa !42
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 3
  store i64 256, i64* %flags, align 8, !tbaa !43
  %desc = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 4
  store i64 0, i64* %desc, align 8, !tbaa !44
  %parent = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 5
  store %struct.resource* null, %struct.resource** %parent, align 8, !tbaa !45
  %sibling = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 6
  store %struct.resource* null, %struct.resource** %sibling, align 8, !tbaa !46
  %child = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 7
  store %struct.resource* null, %struct.resource** %child, align 8, !tbaa !47
  %call = call i32 @acpi_check_resource_conflict(%struct.resource* %res)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv3 = zext i16 %address to i32
  %call4 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i32 %conv3)
  store %struct.platform_device* %call4, %struct.platform_device** @pdev, align 8, !tbaa !2
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  %tobool5 = icmp ne %struct.platform_device* %1, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.8, i32 0, i32 0))
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %2 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  %call9 = call i32 @platform_device_add_resources(%struct.platform_device* %2, %struct.resource* %res, i32 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.9, i32 0, i32 0), i32 %call9)
  br label %exit_device_put

if.end13:                                         ; preds = %if.end8
  %3 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  %call14 = call i32 @platform_device_add(%struct.platform_device* %3)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %cleanup

if.then16:                                        ; preds = %if.end13
  %call17 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.10, i32 0, i32 0), i32 %call14)
  br label %exit_device_put

exit_device_put:                                  ; preds = %if.then16, %if.then11
  %err.0 = phi i32 [ %call9, %if.then11 ], [ %call14, %if.then16 ]
  %4 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !2
  call void @platform_device_put(%struct.platform_device* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %exit_device_put, %entry, %if.end13
  %retval.0 = phi i32 [ 0, %if.end13 ], [ %err.0, %exit_device_put ], [ -12, %if.then6 ], [ %call, %entry ]
  %5 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.end.p0i8(i64 64, i8* %5) #5
  ret i32 %retval.0
}

declare i32 @pci_bus_write_config_word(%struct.pci_bus*, i32, i32, i16 zeroext) #1

declare i32 @pci_bus_read_config_word(%struct.pci_bus*, i32, i32, i16*) #1

declare i32 @pci_bus_read_config_byte(%struct.pci_bus*, i32, i32, i8*) #1

declare i32 @pci_bus_write_config_byte(%struct.pci_bus*, i32, i32, i8 zeroext) #1

declare i32 @acpi_check_resource_conflict(%struct.resource*) #1

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #1

declare i32 @printk(i8*, ...) #1

declare i32 @platform_device_add_resources(%struct.platform_device*, %struct.resource*, i32) #1

declare i32 @platform_device_add(%struct.platform_device*) #1

declare void @platform_device_put(%struct.platform_device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_probe(%struct.platform_device* %pdev) #0 {
entry:
  %val = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %val) #5
  %call = call %struct.resource* @platform_get_resource(%struct.platform_device* %pdev, i32 256, i32 0)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %start = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %0 = load i64, i64* %start, align 8, !tbaa !39
  %1 = load i8*, i8** getelementptr inbounds (%struct.platform_driver, %struct.platform_driver* @sis5595_driver, i32 0, i32 5, i32 0), align 8, !tbaa !48
  %call1 = call %struct.resource* @__devm_request_region(%struct.device* %dev, %struct.resource* @ioport_resource, i64 %0, i64 8, i8* %1)
  %tobool = icmp ne %struct.resource* %call1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call3 = call i8* @devm_kzalloc(%struct.device* %dev2, i64 136, i32 20971712)
  %2 = bitcast i8* %call3 to %struct.sis5595_data*
  %tobool4 = icmp ne %struct.sis5595_data* %2, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 3
  call void @__mutex_init(%struct.mutex* %lock, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.11, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key)
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 4
  call void @__mutex_init(%struct.mutex* %update_lock, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.13, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key.12)
  %start10 = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %3 = load i64, i64* %start10, align 8, !tbaa !39
  %conv = trunc i64 %3 to i16
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 0
  store i16 %conv, i16* %addr, align 8, !tbaa !51
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 1
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8** %name, align 8, !tbaa !53
  %4 = bitcast %struct.sis5595_data* %2 to i8*
  call void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %4)
  %5 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %revision = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %5, i32 0, i32 12
  %6 = load i8, i8* %revision, align 8, !tbaa !54
  %revision11 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  store i8 %6, i8* %revision11, align 1, !tbaa !55
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 3, i8* %maxins, align 8, !tbaa !56
  %revision12 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  %7 = load i8, i8* %revision12, align 1, !tbaa !55
  %conv13 = zext i8 %7 to i32
  %cmp = icmp sge i32 %conv13, 176
  br i1 %cmp, label %if.then15, label %if.end22

if.then15:                                        ; preds = %do.body
  %8 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !2
  %call16 = call i32 @pci_read_config_byte(%struct.pci_dev* %8, i32 122, i8* %val)
  %9 = load i8, i8* %val, align 1, !tbaa !10
  %conv17 = sext i8 %9 to i32
  %and = and i32 %conv17, 128
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.end22, label %if.then19

if.then19:                                        ; preds = %if.then15
  %maxins20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 4, i8* %maxins20, align 8, !tbaa !56
  br label %if.end22

if.end22:                                         ; preds = %if.then15, %if.then19, %do.body
  call void @sis5595_init_device(%struct.sis5595_data* %2)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end22
  %i.0 = phi i32 [ 0, %if.end22 ], [ %inc, %for.body ]
  %cmp23 = icmp slt i32 %i.0, 2
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 59, %i.0
  %conv25 = trunc i32 %add to i8
  %call26 = call i32 @sis5595_read_value(%struct.sis5595_data* %2, i8 zeroext %conv25)
  %conv27 = trunc i32 %call26 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  store i8 %conv27, i8* %arrayidx, align 1, !tbaa !10
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev28 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev28, i32 0, i32 2
  %call29 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %for.end
  %maxins33 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  %10 = load i8, i8* %maxins33, align 8, !tbaa !56
  %conv34 = sext i8 %10 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  %dev38 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj39 = getelementptr inbounds %struct.device, %struct.device* %dev38, i32 0, i32 2
  br i1 %cmp35, label %if.then37, label %if.else

if.then37:                                        ; preds = %if.end32
  %call40 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_in4)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %exit_remove_files, label %if.end50

if.else:                                          ; preds = %if.end32
  %call46 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_temp1)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %exit_remove_files, label %if.end50

if.end50:                                         ; preds = %if.else, %if.then37
  %dev51 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call52 = call %struct.device* @hwmon_device_register(%struct.device* %dev51)
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  store %struct.device* %call52, %struct.device** %hwmon_dev, align 8, !tbaa !57
  %hwmon_dev53 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %11 = load %struct.device*, %struct.device** %hwmon_dev53, align 8, !tbaa !57
  %12 = bitcast %struct.device* %11 to i8*
  %call54 = call zeroext i1 @IS_ERR(i8* %12)
  br i1 %call54, label %if.then55, label %cleanup

if.then55:                                        ; preds = %if.end50
  %hwmon_dev56 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %13 = load %struct.device*, %struct.device** %hwmon_dev56, align 8, !tbaa !57
  %14 = bitcast %struct.device* %13 to i8*
  %call57 = call i64 @PTR_ERR(i8* %14)
  %conv58 = trunc i64 %call57 to i32
  br label %exit_remove_files

exit_remove_files:                                ; preds = %if.else, %if.then37, %if.then55
  %err.0 = phi i32 [ %conv58, %if.then55 ], [ %call40, %if.then37 ], [ %call46, %if.else ]
  %dev60 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj61 = getelementptr inbounds %struct.device, %struct.device* %dev60, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj61, %struct.attribute_group* @sis5595_group)
  %dev62 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj63 = getelementptr inbounds %struct.device, %struct.device* %dev62, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj63, %struct.attribute_group* @sis5595_group_in4)
  %dev64 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj65 = getelementptr inbounds %struct.device, %struct.device* %dev64, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj65, %struct.attribute_group* @sis5595_group_temp1)
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %for.end, %if.end, %entry, %exit_remove_files
  %retval.0 = phi i32 [ %err.0, %exit_remove_files ], [ -16, %entry ], [ -12, %if.end ], [ %call29, %for.end ], [ 0, %if.end50 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %val) #5
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_remove(%struct.platform_device* %pdev) #0 {
entry:
  %call = call i8* @platform_get_drvdata(%struct.platform_device* %pdev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 2
  %1 = load %struct.device*, %struct.device** %hwmon_dev, align 8, !tbaa !57
  call void @hwmon_device_unregister(%struct.device* %1)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj2 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj2, %struct.attribute_group* @sis5595_group_in4)
  %dev3 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj4 = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj4, %struct.attribute_group* @sis5595_group_temp1)
  ret i32 0
}

declare %struct.resource* @platform_get_resource(%struct.platform_device*, i32, i32) #1

declare %struct.resource* @__devm_request_region(%struct.device*, %struct.resource*, i64, i64, i8*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @devm_kzalloc(%struct.device* %dev, i64 %size, i32 %gfp) #3 {
entry:
  %or = or i32 %gfp, 32768
  %call = call noalias i8* @devm_kmalloc(%struct.device* %dev, i64 %size, i32 %or)
  ret i8* %call
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %data) #3 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sis5595_init_device(%struct.sis5595_data* %data) #0 {
entry:
  %call = call i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext 64)
  %conv = trunc i32 %call to i8
  %conv1 = zext i8 %conv to i32
  %and = and i32 %conv1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %conv to i32
  %and3 = and i32 %conv2, 247
  %or = or i32 %and3, 1
  %conv4 = trunc i32 %or to i8
  call void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext 64, i8 zeroext %conv4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext %reg) #0 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock(%struct.mutex* %lock)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !51
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !51
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  %call = call zeroext i8 @inb_p(i32 %add3)
  %conv4 = zext i8 %call to i32
  %lock5 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock5)
  ret i32 %conv4
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #1

declare %struct.device* @hwmon_device_register(%struct.device*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #1

declare noalias i8* @devm_kmalloc(%struct.device*, i64, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !58
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext %reg, i8 zeroext %value) #0 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock(%struct.mutex* %lock)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !51
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !51
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  call void @outb_p(i8 zeroext %value, i32 %add3)
  %lock4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock4)
  ret void
}

declare void @mutex_lock(%struct.mutex*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb_p(i8 zeroext %value, i32 %port) #3 {
entry:
  call void @outb(i8 zeroext %value, i32 %port)
  call void @slow_down_io()
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #3 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #5, !srcloc !59
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #3 {
entry:
  call void @native_io_delay()
  ret void
}

declare void @native_io_delay() #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #3 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #3 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #5, !srcloc !60
  ret i8 %0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_in(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 9
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy1 = alloca i64, align 8
  %__dummy22 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #5
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #5
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %5 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %6 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %cmp3 = icmp eq i64* %__dummy1, %__dummy22
  %conv4 = zext i1 %cmp3 to i32
  %7 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  %last_updated = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  %9 = load i64, i64* %last_updated, align 8, !tbaa !65
  %add = add i64 %9, 1000
  %add8 = add i64 %add, 500
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %sub = sub i64 %add8, %10
  %cmp9 = icmp slt i64 %sub, 0
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %valid = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  %11 = load i8, i8* %valid, align 8, !tbaa !67
  %tobool11 = icmp ne i8 %11, 0
  br i1 %tobool11, label %if.end90, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %12 = load i8, i8* %maxins, align 8, !tbaa !56
  %conv12 = sext i8 %12 to i32
  %cmp13 = icmp sle i32 %i.0, %conv12
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add15 = add nsw i32 32, %i.0
  %conv16 = trunc i32 %add15 to i8
  %call17 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv16)
  %conv18 = trunc i32 %call17 to i8
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 9
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  store i8 %conv18, i8* %arrayidx, align 1, !tbaa !10
  %mul = mul nsw i32 %i.0, 2
  %add19 = add nsw i32 44, %mul
  %conv20 = trunc i32 %add19 to i8
  %call21 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv20)
  %conv22 = trunc i32 %call21 to i8
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom23 = sext i32 %i.0 to i64
  %arrayidx24 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom23
  store i8 %conv22, i8* %arrayidx24, align 1, !tbaa !10
  %mul25 = mul nsw i32 %i.0, 2
  %add26 = add nsw i32 43, %mul25
  %conv27 = trunc i32 %add26 to i8
  %call28 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv27)
  %conv29 = trunc i32 %call28 to i8
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom30
  store i8 %conv29, i8* %arrayidx31, align 1, !tbaa !10
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond32

for.cond32:                                       ; preds = %for.body35, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc49, %for.body35 ]
  %cmp33 = icmp slt i32 %i.1, 2
  br i1 %cmp33, label %for.body35, label %for.end50

for.body35:                                       ; preds = %for.cond32
  %add36 = add nsw i32 40, %i.1
  %conv37 = trunc i32 %add36 to i8
  %call38 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv37)
  %conv39 = trunc i32 %call38 to i8
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 12
  %idxprom40 = sext i32 %i.1 to i64
  %arrayidx41 = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom40
  store i8 %conv39, i8* %arrayidx41, align 1, !tbaa !10
  %add42 = add nsw i32 59, %i.1
  %conv43 = trunc i32 %add42 to i8
  %call44 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv43)
  %conv45 = trunc i32 %call44 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom46 = sext i32 %i.1 to i64
  %arrayidx47 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom46
  store i8 %conv45, i8* %arrayidx47, align 1, !tbaa !10
  %inc49 = add nsw i32 %i.1, 1
  br label %for.cond32

for.end50:                                        ; preds = %for.cond32
  %maxins51 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %13 = load i8, i8* %maxins51, align 8, !tbaa !56
  %conv52 = sext i8 %13 to i32
  %cmp53 = icmp eq i32 %conv52, 3
  br i1 %cmp53, label %if.then55, label %if.end

if.then55:                                        ; preds = %for.end50
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %14 = load i8, i8* %revision, align 1, !tbaa !55
  %conv56 = zext i8 %14 to i32
  %cmp57 = icmp sge i32 %conv56, 176
  %15 = zext i1 %cmp57 to i64
  %cond = select i1 %cmp57, i32 36, i32 39
  %conv59 = trunc i32 %cond to i8
  %call60 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv59)
  %conv61 = trunc i32 %call60 to i8
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 14
  store i8 %conv61, i8* %temp, align 1, !tbaa !68
  %revision62 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %16 = load i8, i8* %revision62, align 1, !tbaa !55
  %conv63 = zext i8 %16 to i32
  %cmp64 = icmp sge i32 %conv63, 176
  %17 = zext i1 %cmp64 to i64
  %cond66 = select i1 %cmp64, i32 51, i32 57
  %conv67 = trunc i32 %cond66 to i8
  %call68 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv67)
  %conv69 = trunc i32 %call68 to i8
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %conv69, i8* %temp_over, align 2, !tbaa !69
  %revision70 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %18 = load i8, i8* %revision70, align 1, !tbaa !55
  %conv71 = zext i8 %18 to i32
  %cmp72 = icmp sge i32 %conv71, 176
  %19 = zext i1 %cmp72 to i64
  %cond74 = select i1 %cmp72, i32 52, i32 58
  %conv75 = trunc i32 %cond74 to i8
  %call76 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv75)
  %conv77 = trunc i32 %call76 to i8
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %conv77, i8* %temp_hyst, align 1, !tbaa !70
  br label %if.end

if.end:                                           ; preds = %if.then55, %for.end50
  %call78 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %shr = ashr i32 %call78, 4
  %and = and i32 %shr, 3
  %conv79 = trunc i32 %and to i8
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx80 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 0
  store i8 %conv79, i8* %arrayidx80, align 8, !tbaa !10
  %shr81 = ashr i32 %call78, 6
  %conv82 = trunc i32 %shr81 to i8
  %fan_div83 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx84 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div83, i64 0, i64 1
  store i8 %conv82, i8* %arrayidx84, align 1, !tbaa !10
  %call85 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 65)
  %call86 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 66)
  %shl = shl i32 %call86, 8
  %or = or i32 %call85, %shl
  %conv87 = trunc i32 %or to i16
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 18
  store i16 %conv87, i16* %alarms, align 2, !tbaa !71
  %20 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %last_updated88 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  store i64 %20, i64* %last_updated88, align 8, !tbaa !65
  %valid89 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  store i8 1, i8* %valid89, align 8, !tbaa !67
  br label %if.end90

if.end90:                                         ; preds = %if.end, %lor.lhs.false
  %update_lock91 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock91)
  ret %struct.sis5595_data* %0
}

declare i32 @sprintf(i8*, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !58
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 11
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !61
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %5 = load i64, i64* %val, align 8, !tbaa !66
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !10
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 44, %mul
  %conv3 = trunc i32 %add to i8
  %in_min4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #3 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @IN_TO_REG(i64 %val) #3 {
entry:
  %__UNIQUE_ID_min1_16 = alloca i64, align 8
  %__UNIQUE_ID_min1_14 = alloca i64, align 8
  %__UNIQUE_ID_min2_15 = alloca i64, align 8
  %__UNIQUE_ID_min2_17 = alloca i64, align 8
  %0 = bitcast i64* %__UNIQUE_ID_min1_16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = bitcast i64* %__UNIQUE_ID_min1_14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  store i64 %val, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !66
  %2 = bitcast i64* %__UNIQUE_ID_min2_15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  store i64 0, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !66
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_14, %__UNIQUE_ID_min2_15
  %conv = zext i1 %cmp to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_14, align 8, !tbaa !66
  %4 = load i64, i64* %__UNIQUE_ID_min2_15, align 8, !tbaa !66
  %cmp1 = icmp ugt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_14, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_15, align 8
  %cond = select i1 %cmp1, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_15 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__UNIQUE_ID_min1_14 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_17 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 4080, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !66
  %cmp3 = icmp eq i64* %__UNIQUE_ID_min1_16, %__UNIQUE_ID_min2_17
  %conv4 = zext i1 %cmp3 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_16, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_17, align 8, !tbaa !66
  %cmp6 = icmp ult i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_16, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_17, align 8
  %cond11 = select i1 %cmp6, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_17 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_16 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  %add = add i64 %cond11, 8
  %div = udiv i64 %add, 16
  %conv12 = trunc i64 %div to i8
  ret i8 %conv12
}

declare i32 @kstrtoull(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @show_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !61
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %5 = load i64, i64* %val, align 8, !tbaa !66
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !10
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 43, %mul
  %conv3 = trunc i32 %add to i8
  %in_max4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarm(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %3 = load i16, i16* %alarms, align 2, !tbaa !71
  %conv = zext i16 %3 to i32
  %shr = ashr i32 %conv, %2
  %and = and i32 %shr, 1
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 %and)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !10
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @FAN_FROM_REG(i8 zeroext %val, i32 %div) #3 {
entry:
  %conv = zext i8 %val to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.end9, label %cond.false

cond.false:                                       ; preds = %entry
  %conv2 = zext i8 %val to i32
  %cmp3 = icmp eq i32 %conv2, 255
  br i1 %cmp3, label %cond.end9, label %cond.false6

cond.false6:                                      ; preds = %cond.false
  %conv7 = zext i8 %val to i32
  %mul = mul nsw i32 %conv7, %div
  %div8 = sdiv i32 1350000, %mul
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false6, %cond.false, %entry
  %cond10 = phi i32 [ -1, %entry ], [ %div8, %cond.false6 ], [ 0, %cond.false ]
  ret i32 %cond10
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !10
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !61
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %5 = load i64, i64* %val, align 8, !tbaa !66
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv2 = zext i8 %6 to i32
  %shl = shl i32 1, %conv2
  %call3 = call zeroext i8 @FAN_TO_REG(i64 %5, i32 %shl)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom4 = sext i32 %3 to i64
  %arrayidx5 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom4
  store i8 %call3, i8* %arrayidx5, align 1, !tbaa !10
  %add = add nsw i32 59, %3
  %conv6 = trunc i32 %add to i8
  %fan_min7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom8 = sext i32 %3 to i64
  %arrayidx9 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min7, i64 0, i64 %idxprom8
  %7 = load i8, i8* %arrayidx9, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %7)
  %update_lock10 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @FAN_TO_REG(i64 %rpm, i32 %div) #3 {
entry:
  %__UNIQUE_ID_min1_20 = alloca i64, align 8
  %__UNIQUE_ID_min1_18 = alloca i64, align 8
  %__UNIQUE_ID_min2_19 = alloca i64, align 8
  %__UNIQUE_ID_min2_21 = alloca i64, align 8
  %cmp = icmp sle i64 %rpm, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp sgt i64 %rpm, 1350000
  br i1 %cmp1, label %return, label %if.end3

if.end3:                                          ; preds = %if.end
  %0 = bitcast i64* %__UNIQUE_ID_min1_20 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = bitcast i64* %__UNIQUE_ID_min1_18 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  %conv = sext i32 %div to i64
  %mul = mul nsw i64 %rpm, %conv
  %div4 = sdiv i64 %mul, 2
  %add = add nsw i64 1350000, %div4
  %conv5 = sext i32 %div to i64
  %mul6 = mul nsw i64 %rpm, %conv5
  %div7 = sdiv i64 %add, %mul6
  store i64 %div7, i64* %__UNIQUE_ID_min1_18, align 8, !tbaa !66
  %2 = bitcast i64* %__UNIQUE_ID_min2_19 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  store i64 1, i64* %__UNIQUE_ID_min2_19, align 8, !tbaa !66
  %cmp8 = icmp eq i64* %__UNIQUE_ID_min1_18, %__UNIQUE_ID_min2_19
  %conv9 = zext i1 %cmp8 to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_18, align 8, !tbaa !66
  %4 = load i64, i64* %__UNIQUE_ID_min2_19, align 8, !tbaa !66
  %cmp10 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_18, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_19, align 8
  %cond = select i1 %cmp10, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_19 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__UNIQUE_ID_min1_18 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_20, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_21 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 254, i64* %__UNIQUE_ID_min2_21, align 8, !tbaa !66
  %cmp12 = icmp eq i64* %__UNIQUE_ID_min1_20, %__UNIQUE_ID_min2_21
  %conv13 = zext i1 %cmp12 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_20, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_21, align 8, !tbaa !66
  %cmp15 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_20, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_21, align 8
  %cond20 = select i1 %cmp15, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_21 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_20 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  %conv21 = trunc i64 %cond20 to i8
  br label %return

return:                                           ; preds = %if.end, %entry, %if.end3
  %retval.0 = phi i8 [ %conv21, %if.end3 ], [ -1, %entry ], [ 1, %if.end ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %conv
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %shl)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !61
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !10
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom2 = sext i32 %3 to i64
  %arrayidx3 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom2
  %6 = load i8, i8* %arrayidx3, align 1, !tbaa !10
  %conv4 = zext i8 %6 to i32
  %shl = shl i32 1, %conv4
  %call5 = call i32 @FAN_FROM_REG(i8 zeroext %5, i32 %shl)
  %conv6 = sext i32 %call5 to i64
  %call7 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %7 = load i64, i64* %val, align 8, !tbaa !66
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %if.end
  %Pivot13 = icmp slt i64 %7, 4
  br i1 %Pivot13, label %NodeBlock, label %NodeBlock10

NodeBlock10:                                      ; preds = %NodeBlock12
  %Pivot11 = icmp slt i64 %7, 8
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i64 %7, 8
  br i1 %SwitchLeaf9, label %sw.bb19, label %NewDefault

LeafBlock6:                                       ; preds = %NodeBlock10
  %SwitchLeaf7 = icmp eq i64 %7, 4
  br i1 %SwitchLeaf7, label %sw.bb15, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock12
  %Pivot = icmp slt i64 %7, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock4

LeafBlock4:                                       ; preds = %NodeBlock
  %SwitchLeaf5 = icmp eq i64 %7, 2
  br i1 %SwitchLeaf5, label %sw.epilog, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i64 %7, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  br label %sw.epilog

sw.bb15:                                          ; preds = %LeafBlock6
  br label %sw.epilog

sw.bb19:                                          ; preds = %LeafBlock8
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock8, %LeafBlock6, %LeafBlock4, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %8 = load i64, i64* %val, align 8, !tbaa !66
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.35, i32 0, i32 0), i64 %8)
  %update_lock23 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock23)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock4, %sw.bb19, %sw.bb15, %sw.bb
  %.sink = phi i8 [ 3, %sw.bb19 ], [ 2, %sw.bb15 ], [ 0, %sw.bb ], [ 1, %LeafBlock4 ]
  %fan_div20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom21 = sext i32 %3 to i64
  %arrayidx22 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div20, i64 0, i64 %idxprom21
  store i8 %.sink, i8* %arrayidx22, align 1, !tbaa !10
  br label %NodeBlock19

NodeBlock19:                                      ; preds = %sw.epilog
  %Pivot20 = icmp slt i32 %3, 1
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %3, 1
  br i1 %SwitchLeaf18, label %sw.epilog38.sink.split, label %NewDefault14

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %3, 0
  br i1 %SwitchLeaf16, label %sw.bb24, label %NewDefault14

sw.bb24:                                          ; preds = %LeafBlock15
  br label %sw.epilog38.sink.split

sw.epilog38.sink.split:                           ; preds = %LeafBlock17, %sw.bb24
  %.sink3 = phi i32 [ 207, %sw.bb24 ], [ 63, %LeafBlock17 ]
  %.sink1 = phi i32 [ 4, %sw.bb24 ], [ 6, %LeafBlock17 ]
  %and31 = and i32 %call7, %.sink3
  %fan_div32 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom33 = sext i32 %3 to i64
  %arrayidx34 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div32, i64 0, i64 %idxprom33
  %9 = load i8, i8* %arrayidx34, align 1, !tbaa !10
  %conv35 = zext i8 %9 to i32
  %shl36 = shl i32 %conv35, %.sink1
  %or37 = or i32 %and31, %shl36
  br label %sw.epilog38

NewDefault14:                                     ; preds = %LeafBlock17, %LeafBlock15
  br label %sw.epilog38

sw.epilog38:                                      ; preds = %NewDefault14, %sw.epilog38.sink.split
  %reg.0 = phi i32 [ %call7, %NewDefault14 ], [ %or37, %sw.epilog38.sink.split ]
  %conv39 = trunc i32 %reg.0 to i8
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext 71, i8 zeroext %conv39)
  %fan_div40 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom41 = sext i32 %3 to i64
  %arrayidx42 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div40, i64 0, i64 %idxprom41
  %10 = load i8, i8* %arrayidx42, align 1, !tbaa !10
  %conv43 = zext i8 %10 to i32
  %shl44 = shl i32 1, %conv43
  %call45 = call zeroext i8 @FAN_TO_REG(i64 %conv6, i32 %shl44)
  %fan_min46 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom47 = sext i32 %3 to i64
  %arrayidx48 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min46, i64 0, i64 %idxprom47
  store i8 %call45, i8* %arrayidx48, align 1, !tbaa !10
  %add = add nsw i32 59, %3
  %conv49 = trunc i32 %add to i8
  %fan_min50 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom51 = sext i32 %3 to i64
  %arrayidx52 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min50, i64 0, i64 %idxprom51
  %11 = load i8, i8* %arrayidx52, align 1, !tbaa !10
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv49, i8 zeroext %11)
  %update_lock53 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock53)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog38, %sw.default, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ -22, %sw.default ], [ %count, %sw.epilog38 ]
  %12 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @alarms_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %0 = load i16, i16* %alarms, align 2, !tbaa !71
  %conv = zext i16 %0 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @name_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 1
  %1 = load i8*, i8** %name, align 8, !tbaa !53
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43, i32 0, i32 0), i8* %1)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_input_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 14
  %0 = load i8, i8* %temp, align 1, !tbaa !68
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @TEMP_FROM_REG(i8 signext %val) #3 {
entry:
  %conv = sext i8 %val to i32
  %mul = mul nsw i32 %conv, 830
  %add = add nsw i32 %mul, 52120
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 15
  %0 = load i8, i8* %temp_over, align 2, !tbaa !69
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %2 = load i64, i64* %val, align 8, !tbaa !66
  %call2 = call signext i8 @TEMP_TO_REG(i64 %2)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %call2, i8* %temp_over, align 2, !tbaa !69
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !55
  %conv3 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv3, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 51, i32 57
  %conv5 = trunc i32 %cond to i8
  %temp_over6 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  %5 = load i8, i8* %temp_over6, align 2, !tbaa !69
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv5, i8 zeroext %5)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #5
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtol(i8* %s, i32 %base, i64* %res) #3 {
entry:
  %call = call i32 @kstrtoll(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal signext i8 @TEMP_TO_REG(i64 %val) #3 {
entry:
  %__UNIQUE_ID_min1_24 = alloca i64, align 8
  %__UNIQUE_ID_min1_22 = alloca i64, align 8
  %__UNIQUE_ID_min2_23 = alloca i64, align 8
  %__UNIQUE_ID_min2_25 = alloca i64, align 8
  %0 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = bitcast i64* %__UNIQUE_ID_min1_22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  store i64 %val, i64* %__UNIQUE_ID_min1_22, align 8, !tbaa !66
  %2 = bitcast i64* %__UNIQUE_ID_min2_23 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  store i64 -54120, i64* %__UNIQUE_ID_min2_23, align 8, !tbaa !66
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_22, %__UNIQUE_ID_min2_23
  %conv = zext i1 %cmp to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_22, align 8, !tbaa !66
  %4 = load i64, i64* %__UNIQUE_ID_min2_23, align 8, !tbaa !66
  %cmp1 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_22, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_23, align 8
  %cond = select i1 %cmp1, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_23 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__UNIQUE_ID_min1_22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 157530, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !66
  %cmp3 = icmp eq i64* %__UNIQUE_ID_min1_24, %__UNIQUE_ID_min2_25
  %conv4 = zext i1 %cmp3 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !66
  %cmp6 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_24, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_25, align 8
  %cond11 = select i1 %cmp6, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  %conv12 = trunc i64 %cond11 to i32
  %cmp13 = icmp slt i32 %conv12, 0
  %sub = sub nsw i32 %conv12, 5212
  %add = add nsw i32 %sub, 415
  %sub16 = sub nsw i32 %sub, 415
  %add.sink = select i1 %cmp13, i32 %sub16, i32 %add
  %div19 = sdiv i32 %add.sink, 830
  %conv22 = trunc i32 %div19 to i8
  ret i8 %conv22
}

declare i32 @kstrtoll(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_hyst_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 16
  %0 = load i8, i8* %temp_hyst, align 1, !tbaa !70
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @temp1_max_hyst_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %2 = load i64, i64* %val, align 8, !tbaa !66
  %call2 = call signext i8 @TEMP_TO_REG(i64 %2)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %call2, i8* %temp_hyst, align 1, !tbaa !70
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !55
  %conv3 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv3, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 52, i32 58
  %conv5 = trunc i32 %cond to i8
  %temp_hyst6 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  %5 = load i8, i8* %temp_hyst6, align 1, !tbaa !70
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv5, i8 zeroext %5)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @platform_get_drvdata(%struct.platform_device* %pdev) #3 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare void @hwmon_device_unregister(%struct.device*) #1

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"any pointer", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!7, !7, i64 0}
!7 = !{!"int", !4, i64 0}
!8 = !{!9, !9, i64 0}
!9 = !{!"short", !4, i64 0}
!10 = !{!4, !4, i64 0}
!11 = !{!12, !3, i64 16}
!12 = !{!"pci_dev", !13, i64 0, !3, i64 16, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !7, i64 56, !9, i64 60, !9, i64 62, !9, i64 64, !9, i64 66, !7, i64 68, !4, i64 72, !4, i64 73, !9, i64 74, !4, i64 76, !4, i64 77, !4, i64 78, !4, i64 79, !4, i64 80, !4, i64 81, !9, i64 82, !3, i64 88, !3, i64 96, !14, i64 104, !15, i64 112, !7, i64 128, !4, i64 132, !7, i64 133, !7, i64 133, !7, i64 133, !7, i64 133, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 134, !7, i64 135, !7, i64 135, !7, i64 136, !7, i64 140, !3, i64 144, !7, i64 152, !17, i64 160, !7, i64 888, !7, i64 892, !4, i64 896, !29, i64 1600, !7, i64 1601, !7, i64 1601, !7, i64 1601, !7, i64 1601, !7, i64 1601, !7, i64 1601, !7, i64 1601, !7, i64 1601, !7, i64 1602, !7, i64 1602, !7, i64 1602, !7, i64 1602, !7, i64 1602, !7, i64 1602, !7, i64 1602, !7, i64 1603, !7, i64 1603, !7, i64 1603, !7, i64 1603, !7, i64 1603, !7, i64 1603, !7, i64 1603, !7, i64 1603, !7, i64 1604, !7, i64 1604, !7, i64 1604, !7, i64 1604, !9, i64 1606, !21, i64 1608, !4, i64 1612, !37, i64 1680, !3, i64 1688, !7, i64 1696, !4, i64 1704, !4, i64 1792, !3, i64 1880, !3, i64 1888, !4, i64 1896, !9, i64 1904, !4, i64 1906, !21, i64 1908, !14, i64 1912, !16, i64 1920, !3, i64 1928}
!13 = !{!"list_head", !3, i64 0, !3, i64 8}
!14 = !{!"long long", !4, i64 0}
!15 = !{!"device_dma_parameters", !7, i64 0, !16, i64 8}
!16 = !{!"long", !4, i64 0}
!17 = !{!"device", !3, i64 0, !3, i64 8, !18, i64 16, !3, i64 80, !3, i64 88, !22, i64 96, !3, i64 128, !3, i64 136, !3, i64 144, !3, i64 152, !26, i64 160, !27, i64 200, !3, i64 488, !3, i64 496, !13, i64 504, !7, i64 520, !3, i64 528, !3, i64 536, !14, i64 544, !16, i64 552, !3, i64 560, !13, i64 568, !3, i64 584, !35, i64 592, !3, i64 600, !3, i64 608, !7, i64 616, !7, i64 620, !24, i64 624, !13, i64 632, !36, i64 648, !3, i64 680, !3, i64 688, !3, i64 696, !3, i64 704, !3, i64 712, !29, i64 720, !29, i64 720}
!18 = !{!"kobject", !3, i64 0, !13, i64 8, !3, i64 24, !3, i64 32, !3, i64 40, !3, i64 48, !19, i64 56, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60}
!19 = !{!"kref", !20, i64 0}
!20 = !{!"refcount_struct", !21, i64 0}
!21 = !{!"", !7, i64 0}
!22 = !{!"mutex", !23, i64 0, !24, i64 8, !25, i64 12, !13, i64 16}
!23 = !{!"", !16, i64 0}
!24 = !{!"spinlock", !4, i64 0}
!25 = !{!"optimistic_spin_queue", !21, i64 0}
!26 = !{!"dev_links_info", !13, i64 0, !13, i64 16, !4, i64 32}
!27 = !{!"dev_pm_info", !28, i64 0, !7, i64 4, !7, i64 4, !29, i64 4, !29, i64 4, !29, i64 4, !29, i64 4, !29, i64 4, !29, i64 4, !29, i64 5, !24, i64 8, !13, i64 16, !30, i64 32, !3, i64 64, !29, i64 72, !29, i64 72, !29, i64 72, !32, i64 80, !16, i64 128, !34, i64 136, !31, i64 168, !3, i64 192, !21, i64 200, !21, i64 204, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !29, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 212, !4, i64 216, !4, i64 220, !7, i64 224, !7, i64 228, !16, i64 232, !16, i64 240, !16, i64 248, !16, i64 256, !3, i64 264, !3, i64 272, !3, i64 280}
!28 = !{!"pm_message", !7, i64 0}
!29 = !{!"_Bool", !4, i64 0}
!30 = !{!"completion", !7, i64 0, !31, i64 8}
!31 = !{!"__wait_queue_head", !24, i64 0, !13, i64 8}
!32 = !{!"timer_list", !33, i64 0, !16, i64 16, !3, i64 24, !16, i64 32, !7, i64 40}
!33 = !{!"hlist_node", !3, i64 0, !3, i64 8}
!34 = !{!"work_struct", !23, i64 0, !13, i64 8, !3, i64 24}
!35 = !{!"dev_archdata", !3, i64 0}
!36 = !{!"klist_node", !3, i64 0, !13, i64 8, !19, i64 24}
!37 = !{!"hlist_head", !3, i64 0}
!38 = !{!12, !7, i64 56}
!39 = !{!40, !14, i64 0}
!40 = !{!"resource", !14, i64 0, !14, i64 8, !3, i64 16, !16, i64 24, !16, i64 32, !3, i64 40, !3, i64 48, !3, i64 56}
!41 = !{!40, !14, i64 8}
!42 = !{!40, !3, i64 16}
!43 = !{!40, !16, i64 24}
!44 = !{!40, !16, i64 32}
!45 = !{!40, !3, i64 40}
!46 = !{!40, !3, i64 48}
!47 = !{!40, !3, i64 56}
!48 = !{!49, !3, i64 40}
!49 = !{!"platform_driver", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !3, i64 32, !50, i64 40, !3, i64 160, !29, i64 168}
!50 = !{!"device_driver", !3, i64 0, !3, i64 8, !3, i64 16, !3, i64 24, !29, i64 32, !4, i64 36, !3, i64 40, !3, i64 48, !3, i64 56, !3, i64 64, !3, i64 72, !3, i64 80, !3, i64 88, !3, i64 96, !3, i64 104, !3, i64 112}
!51 = !{!52, !9, i64 0}
!52 = !{!"sis5595_data", !9, i64 0, !3, i64 8, !3, i64 16, !22, i64 24, !22, i64 56, !4, i64 88, !16, i64 96, !4, i64 104, !4, i64 105, !4, i64 106, !4, i64 111, !4, i64 116, !4, i64 121, !4, i64 123, !4, i64 125, !4, i64 126, !4, i64 127, !4, i64 128, !9, i64 130}
!53 = !{!52, !3, i64 8}
!54 = !{!12, !4, i64 72}
!55 = !{!52, !4, i64 105}
!56 = !{!52, !4, i64 104}
!57 = !{!52, !3, i64 16}
!58 = !{!17, !3, i64 152}
!59 = !{i32 -2145833284}
!60 = !{i32 -2145833082}
!61 = !{!62, !7, i64 32}
!62 = !{!"sensor_device_attribute", !63, i64 0, !7, i64 32}
!63 = !{!"device_attribute", !64, i64 0, !3, i64 16, !3, i64 24}
!64 = !{!"attribute", !3, i64 0, !9, i64 8}
!65 = !{!52, !16, i64 96}
!66 = !{!16, !16, i64 0}
!67 = !{!52, !4, i64 88}
!68 = !{!52, !4, i64 125}
!69 = !{!52, !4, i64 126}
!70 = !{!52, !4, i64 127}
!71 = !{!52, !9, i64 130}
