; ModuleID = 'drivers/hwmon/sis5595.bc'
source_filename = "drivers/hwmon/sis5595.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.42 }
%union.anon.42 = type { i8* }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [11 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [11 x %struct.bin_attribute*], [11 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.43, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.proc_dir_entry = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.device_dma_parameters = type { i32, i64 }
%struct.pcie_link_state = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.page = type { i64, %struct.address_space*, %struct.anon.0, %union.anon.6, %union.anon.8, [8 x i8] }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.33, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.35, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.39, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.37, i8* }
%union.anon.37 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type opaque
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%union.anon.39 = type { %struct.list_head }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.34, i32 }
%union.anon.34 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%struct.atomic64_t = type { i64 }
%union.anon.32 = type { i32 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%union.anon.33 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.40 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.40 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.35 = type { %struct.pipe_inode_info* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.31, i32 }
%union.anon.31 = type { i8* }
%struct.swap_info_struct = type opaque
%struct.anon.0 = type { %union.anon.1, %union.anon.2 }
%union.anon.1 = type { i64 }
%union.anon.2 = type { i64 }
%union.anon.6 = type { %struct.list_head }
%union.anon.8 = type { i64 }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.file = type { %union.anon.36, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.36 = type { %struct.list_head }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.11, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.12, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.13, %union.anon.14 }
%union.anon.11 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.12 = type { i64 }
%union.anon.13 = type { %struct.list_head }
%union.anon.14 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.15 }
%union.anon.15 = type { %struct.anon.16 }
%struct.anon.16 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.18, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.21 }
%union.anon.18 = type { %struct.anon.19 }
%struct.anon.19 = type { i64, i64 }
%union.anon.21 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.10 }
%union.anon.10 = type { i16 }
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.23 }
%union.anon.23 = type { %struct.anon.27, [80 x i8] }
%struct.anon.27 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.dma_attrs = type { [1 x i64] }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.spinlock = type { %union.anon.9 }
%union.anon.9 = type { %struct.raw_spinlock }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.atomic_t = type { i32 }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.pci_vpd = type opaque
%union.anon.43 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id* }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.sensor_device_attribute = type { %struct.device_attribute, i32 }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, i32, [64 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page* }
%struct.kmem_cache_order_objects = type { i64 }
%struct.kmem_cache_node = type opaque
%struct.sis5595_data = type { i16, i8*, %struct.device*, %struct.mutex, %struct.mutex, i8, i64, i8, i8, [5 x i8], [5 x i8], [5 x i8], [2 x i8], [2 x i8], i8, i8, i8, [2 x i8], i16 }

@__param_str_force_addr = internal constant [19 x i8] c"sis5595.force_addr\00", align 16
@param_ops_ushort = external global %struct.kernel_param_ops, align 8
@force_addr = internal global i16 0, align 2
@__param_force_addr = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_force_addr, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_ushort, i16 0, i16 -1, %union.anon.42 { i8* bitcast (i16* @force_addr to i8*) } }, section "__param", align 8
@sis5595_pci_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([2 x %struct.pci_device_id], [2 x %struct.pci_device_id]* @sis5595_pci_ids, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @sis5595_pci_probe, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.pci_dynids zeroinitializer }, align 8
@s_bridge = internal global %struct.pci_dev* null, align 8
@pdev = internal global %struct.platform_device* null, align 8
@sis5595_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* @sis5595_probe, i32 (%struct.platform_device*)* @sis5595_remove, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null }, align 8
@__initcall_sm_sis5595_init6 = internal global i32 ()* @sm_sis5595_init, section ".initcall6.init", align 8
@__exitcall_sm_sis5595_exit = internal global void ()* @sm_sis5595_exit, section ".exitcall.exit", align 8
@smp_ops = external global %struct.smp_ops, align 8
@current_task = external global %struct.task_struct*, align 8
@.str = private unnamed_addr constant [8 x i8] c"sis5595\00", align 1
@sis5595_pci_ids = internal constant [2 x %struct.pci_device_id] [%struct.pci_device_id { i32 4153, i32 8, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id zeroinitializer], align 16
@blacklist = internal global [10 x i32] [i32 1344, i32 1360, i32 1584, i32 1605, i32 1840, i32 1845, i32 21777, i32 21911, i32 21912, i32 0], align 16
@.str.1 = private unnamed_addr constant [54 x i8] c"Looked for SIS5595 but found unsupported device %.4x\0A\00", align 1
@.str.2 = private unnamed_addr constant [26 x i8] c"Forcing ISA address 0x%x\0A\00", align 1
@.str.3 = private unnamed_addr constant [28 x i8] c"Failed to read ISA address\0A\00", align 1
@.str.4 = private unnamed_addr constant [62 x i8] c"Base address not set - upgrade BIOS or use force_addr=0xaddr\0A\00", align 1
@.str.5 = private unnamed_addr constant [29 x i8] c"Failed to force ISA address\0A\00", align 1
@.str.6 = private unnamed_addr constant [32 x i8] c"Failed to read enable register\0A\00", align 1
@.str.7 = private unnamed_addr constant [29 x i8] c"Failed to enable HWM device\0A\00", align 1
@.str.8 = private unnamed_addr constant [37 x i8] c"\013sis5595: Device allocation failed\0A\00", align 1
@.str.9 = private unnamed_addr constant [49 x i8] c"\013sis5595: Device resource addition failed (%d)\0A\00", align 1
@.str.10 = private unnamed_addr constant [40 x i8] c"\013sis5595: Device addition failed (%d)\0A\00", align 1
@ioport_resource = external global %struct.resource, align 8
@sis5595_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.11 = private unnamed_addr constant [12 x i8] c"&data->lock\00", align 1
@sis5595_probe.__key.12 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.13 = private unnamed_addr constant [19 x i8] c"&data->update_lock\00", align 1
@sis5595_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([27 x %struct.attribute*], [27 x %struct.attribute*]* @sis5595_attributes, i32 0, i32 0) }, align 8
@sis5595_group_in4 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_in4, i32 0, i32 0) }, align 8
@sis5595_group_temp1 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_temp1, i32 0, i32 0) }, align 8
@sis5595_attributes = internal global [27 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_alarms, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_name, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in0_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in0_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.16, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 0 }, align 8
@sensor_dev_attr_in0_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.17, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 0 }, align 8
@sensor_dev_attr_in0_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.20, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.21, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 1 }, align 8
@sensor_dev_attr_in1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.22, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 1 }, align 8
@sensor_dev_attr_in1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.23, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.24, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.25, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 2 }, align 8
@sensor_dev_attr_in2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.26, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 2 }, align 8
@sensor_dev_attr_in2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.27, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.28, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_in3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.29, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 3 }, align 8
@sensor_dev_attr_in3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.30, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 3 }, align 8
@sensor_dev_attr_in3_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.31, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_fan1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.32, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_fan1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 0 }, align 8
@sensor_dev_attr_fan1_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.34, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 0 }, align 8
@sensor_dev_attr_fan1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.36, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 6 }, align 8
@sensor_dev_attr_fan2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_fan2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.38, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 1 }, align 8
@sensor_dev_attr_fan2_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 1 }, align 8
@sensor_dev_attr_fan2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.40, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 7 }, align 8
@dev_attr_alarms = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.41, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarms, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_name = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.42, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_name, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.14 = private unnamed_addr constant [10 x i8] c"in0_input\00", align 1
@.str.15 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@jiffies = external global i64, align 8
@.str.16 = private unnamed_addr constant [8 x i8] c"in0_min\00", align 1
@.str.17 = private unnamed_addr constant [8 x i8] c"in0_max\00", align 1
@.str.18 = private unnamed_addr constant [10 x i8] c"in0_alarm\00", align 1
@.str.19 = private unnamed_addr constant [4 x i8] c"%u\0A\00", align 1
@.str.20 = private unnamed_addr constant [10 x i8] c"in1_input\00", align 1
@.str.21 = private unnamed_addr constant [8 x i8] c"in1_min\00", align 1
@.str.22 = private unnamed_addr constant [8 x i8] c"in1_max\00", align 1
@.str.23 = private unnamed_addr constant [10 x i8] c"in1_alarm\00", align 1
@.str.24 = private unnamed_addr constant [10 x i8] c"in2_input\00", align 1
@.str.25 = private unnamed_addr constant [8 x i8] c"in2_min\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"in2_max\00", align 1
@.str.27 = private unnamed_addr constant [10 x i8] c"in2_alarm\00", align 1
@.str.28 = private unnamed_addr constant [10 x i8] c"in3_input\00", align 1
@.str.29 = private unnamed_addr constant [8 x i8] c"in3_min\00", align 1
@.str.30 = private unnamed_addr constant [8 x i8] c"in3_max\00", align 1
@.str.31 = private unnamed_addr constant [10 x i8] c"in3_alarm\00", align 1
@.str.32 = private unnamed_addr constant [11 x i8] c"fan1_input\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"fan1_min\00", align 1
@.str.34 = private unnamed_addr constant [9 x i8] c"fan1_div\00", align 1
@.str.35 = private unnamed_addr constant [62 x i8] c"fan_div value %ld not supported. Choose one of 1, 2, 4 or 8!\0A\00", align 1
@.str.36 = private unnamed_addr constant [11 x i8] c"fan1_alarm\00", align 1
@.str.37 = private unnamed_addr constant [11 x i8] c"fan2_input\00", align 1
@.str.38 = private unnamed_addr constant [9 x i8] c"fan2_min\00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c"fan2_div\00", align 1
@.str.40 = private unnamed_addr constant [11 x i8] c"fan2_alarm\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"alarms\00", align 1
@.str.42 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.43 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@sis5595_attributes_in4 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.44, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 4 }, align 8
@sensor_dev_attr_in4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.45, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 4 }, align 8
@sensor_dev_attr_in4_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 4 }, align 8
@sensor_dev_attr_in4_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.47, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.44 = private unnamed_addr constant [10 x i8] c"in4_input\00", align 1
@.str.45 = private unnamed_addr constant [8 x i8] c"in4_min\00", align 1
@.str.46 = private unnamed_addr constant [8 x i8] c"in4_max\00", align 1
@.str.47 = private unnamed_addr constant [10 x i8] c"in4_alarm\00", align 1
@sis5595_attributes_temp1 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_input, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max_hyst, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_temp1_input = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.48, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_temp1_max = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.49, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_over, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_temp_over }, align 8
@dev_attr_temp1_max_hyst = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.50, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_temp_hyst }, align 8
@sensor_dev_attr_temp1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.51, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.48 = private unnamed_addr constant [12 x i8] c"temp1_input\00", align 1
@.str.49 = private unnamed_addr constant [10 x i8] c"temp1_max\00", align 1
@.str.50 = private unnamed_addr constant [15 x i8] c"temp1_max_hyst\00", align 1
@.str.51 = private unnamed_addr constant [12 x i8] c"temp1_alarm\00", align 1
@llvm.used = appending global [4 x i8*] [i8* bitcast (%struct.kernel_param* @__param_force_addr to i8*), i8* bitcast (void ()* @sm_sis5595_exit to i8*), i8* bitcast (i32 ()** @__initcall_sm_sis5595_init6 to i8*), i8* bitcast (void ()** @__exitcall_sm_sis5595_exit to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_os_allocate(i64 %size) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #6
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #6
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #6
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #6
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmalloc(i64 %size, i32 %cond)
  ret i8* %call10
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @acpi_os_acquire_object(%struct.kmem_cache* %cache) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #6
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #6
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #6
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #6
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  %call10 = call i8* @kmem_cache_zalloc(%struct.kmem_cache* %cache, i32 %cond)
  ret i8* %call10
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @acpi_os_get_thread_id() #0 {
entry:
  %call = call %struct.task_struct* @get_current()
  %0 = ptrtoint %struct.task_struct* %call to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal void @sm_sis5595_exit() #1 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @sis5595_pci_driver)
  %0 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  %cmp = icmp ne %struct.pci_dev* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  call void @platform_device_unregister(%struct.platform_device* %1)
  call void @platform_driver_unregister(%struct.platform_driver* @sis5595_driver)
  %2 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  call void @pci_dev_put(%struct.pci_dev* %2)
  store %struct.pci_dev* null, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @pci_unregister_driver(%struct.pci_driver*) #2

declare void @platform_device_unregister(%struct.platform_device*) #2

declare void @platform_driver_unregister(%struct.platform_driver*) #2

declare void @pci_dev_put(%struct.pci_dev*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sm_sis5595_init() #1 section ".init.text" {
entry:
  %call = call i32 @__pci_register_driver(%struct.pci_driver* @sis5595_pci_driver, %struct.module* null, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0))
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #3 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #0 {
entry:
  %call = call i64 @native_save_fl()
  ret i64 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #0 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i8* @__kmalloc(i64, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @native_save_fl() #0 {
entry:
  %flags = alloca i64, align 8
  %0 = bitcast i64* %flags to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #6
  call void asm sideeffect "# __raw_save_flags\0A\09pushf ; pop $0", "=*rm,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags) #6, !srcloc !13
  %1 = load i64, i64* %flags, align 8, !tbaa !14
  %2 = bitcast i64* %flags to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #6
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kmem_cache_zalloc(%struct.kmem_cache* %k, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmem_cache_alloc(%struct.kmem_cache* %k, i32 %or)
  ret i8* %call
}

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #3 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !16
  ret %struct.task_struct* %0
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_pci_probe(%struct.pci_dev* %dev, %struct.pci_device_id* %id) #1 {
entry:
  %address = alloca i16, align 2
  %enable = alloca i8, align 1
  %0 = bitcast i16* %address to i8*
  call void @llvm.lifetime.start.p0i8(i64 2, i8* %0) #6
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %enable) #6
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32* [ getelementptr inbounds ([10 x i32], [10 x i32]* @blacklist, i32 0, i32 0), %entry ], [ %incdec.ptr, %for.inc ]
  %retval.0 = phi i32 [ undef, %entry ], [ %retval.1, %for.inc ]
  %1 = load i32, i32* %i.0, align 4, !tbaa !17
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i.0, align 4, !tbaa !17
  %call = call %struct.pci_dev* @pci_get_device(i32 4153, i32 %2, %struct.pci_dev* null)
  %tobool = icmp ne %struct.pci_dev* %call, null
  br i1 %tobool, label %if.then, label %cleanup

if.then:                                          ; preds = %for.body
  %dev1 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %call, i32 0, i32 34
  %3 = load i32, i32* %i.0, align 4, !tbaa !17
  %call2 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev1, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.1, i32 0, i32 0), i32 %3)
  call void @pci_dev_put(%struct.pci_dev* %call)
  br label %cleanup

cleanup:                                          ; preds = %for.body, %if.then
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then ], [ 0, %for.body ]
  %retval.1 = phi i32 [ -19, %if.then ], [ %retval.0, %for.body ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %for.inc, label %cleanup73

for.inc:                                          ; preds = %cleanup
  %incdec.ptr = getelementptr inbounds i32, i32* %i.0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %4 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv = zext i16 %4 to i32
  %and = and i32 %conv, -8
  %conv3 = trunc i32 %and to i16
  store i16 %conv3, i16* @force_addr, align 2, !tbaa !19
  %5 = load i16, i16* @force_addr, align 2, !tbaa !19
  %tobool4 = icmp ne i16 %5, 0
  br i1 %tobool4, label %if.then5, label %if.end10

if.then5:                                         ; preds = %for.end
  %dev6 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %6 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv7 = zext i16 %6 to i32
  %call8 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev6, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), i32 %conv7)
  %7 = load i16, i16* @force_addr, align 2, !tbaa !19
  %call9 = call i32 @pci_write_config_word(%struct.pci_dev* %dev, i32 104, i16 zeroext %7)
  br label %if.end10

if.end10:                                         ; preds = %if.then5, %for.end
  %call11 = call i32 @pci_read_config_word(%struct.pci_dev* %dev, i32 104, i16* %address)
  %cmp12 = icmp ne i32 0, %call11
  br i1 %cmp12, label %if.then14, label %if.end17

if.then14:                                        ; preds = %if.end10
  %dev15 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call16 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev15, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.3, i32 0, i32 0))
  br label %cleanup73

if.end17:                                         ; preds = %if.end10
  %8 = load i16, i16* %address, align 2, !tbaa !19
  %conv18 = zext i16 %8 to i32
  %and19 = and i32 %conv18, -8
  %conv20 = trunc i32 %and19 to i16
  store i16 %conv20, i16* %address, align 2, !tbaa !19
  %9 = load i16, i16* %address, align 2, !tbaa !19
  %tobool21 = icmp ne i16 %9, 0
  br i1 %tobool21, label %if.end25, label %if.then22

if.then22:                                        ; preds = %if.end17
  %dev23 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call24 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev23, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.4, i32 0, i32 0))
  br label %cleanup73

if.end25:                                         ; preds = %if.end17
  %10 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv26 = zext i16 %10 to i32
  %tobool27 = icmp ne i32 %conv26, 0
  br i1 %tobool27, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.end25
  %11 = load i16, i16* %address, align 2, !tbaa !19
  %conv28 = zext i16 %11 to i32
  %12 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv29 = zext i16 %12 to i32
  %cmp30 = icmp ne i32 %conv28, %conv29
  br i1 %cmp30, label %if.then32, label %if.end35

if.then32:                                        ; preds = %land.lhs.true
  %dev33 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call34 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev33, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.5, i32 0, i32 0))
  br label %cleanup73

if.end35:                                         ; preds = %land.lhs.true, %if.end25
  %call36 = call i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 123, i8* %enable)
  %cmp37 = icmp ne i32 0, %call36
  br i1 %cmp37, label %if.then39, label %if.end42

if.then39:                                        ; preds = %if.end35
  %dev40 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call41 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev40, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.6, i32 0, i32 0))
  br label %cleanup73

if.end42:                                         ; preds = %if.end35
  %13 = load i8, i8* %enable, align 1, !tbaa !21
  %conv43 = zext i8 %13 to i32
  %and44 = and i32 %conv43, 128
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.end63, label %if.then46

if.then46:                                        ; preds = %if.end42
  %14 = load i8, i8* %enable, align 1, !tbaa !21
  %conv47 = zext i8 %14 to i32
  %or = or i32 %conv47, 128
  %conv48 = trunc i32 %or to i8
  %call49 = call i32 @pci_write_config_byte(%struct.pci_dev* %dev, i32 123, i8 zeroext %conv48)
  %cmp50 = icmp ne i32 0, %call49
  br i1 %cmp50, label %if.then59, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then46
  %call52 = call i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 123, i8* %enable)
  %cmp53 = icmp ne i32 0, %call52
  br i1 %cmp53, label %if.then59, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %lor.lhs.false
  %15 = load i8, i8* %enable, align 1, !tbaa !21
  %conv56 = zext i8 %15 to i32
  %and57 = and i32 %conv56, 128
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.end63, label %if.then59

if.then59:                                        ; preds = %lor.lhs.false55, %lor.lhs.false, %if.then46
  %dev60 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call61 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev60, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.7, i32 0, i32 0))
  br label %cleanup73

if.end63:                                         ; preds = %lor.lhs.false55, %if.end42
  %call64 = call i32 @platform_driver_register(%struct.platform_driver* @sis5595_driver)
  %tobool65 = icmp ne i32 %call64, 0
  br i1 %tobool65, label %cleanup73, label %if.end67

if.end67:                                         ; preds = %if.end63
  %call68 = call %struct.pci_dev* @pci_dev_get(%struct.pci_dev* %dev)
  store %struct.pci_dev* %call68, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  %16 = load i16, i16* %address, align 2, !tbaa !19
  %call69 = call i32 @sis5595_device_add(i16 zeroext %16)
  %tobool70 = icmp ne i32 %call69, 0
  br i1 %tobool70, label %exit_unregister, label %cleanup73

exit_unregister:                                  ; preds = %if.end67
  call void @pci_dev_put(%struct.pci_dev* %dev)
  call void @platform_driver_unregister(%struct.platform_driver* @sis5595_driver)
  br label %cleanup73

cleanup73:                                        ; preds = %cleanup, %exit_unregister, %if.end63, %if.end67, %if.then59, %if.then39, %if.then32, %if.then22, %if.then14
  %retval.2 = phi i32 [ -19, %if.then14 ], [ -19, %if.then32 ], [ -19, %if.then39 ], [ -19, %if.then59 ], [ -19, %if.then22 ], [ -19, %if.end67 ], [ -19, %if.end63 ], [ -19, %exit_unregister ], [ %retval.1, %cleanup ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %enable) #6
  %17 = bitcast i16* %address to i8*
  call void @llvm.lifetime.end.p0i8(i64 2, i8* %17) #6
  ret i32 %retval.2
}

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #2

declare i32 @dev_err(%struct.device*, i8*, ...) #2

declare i32 @dev_warn(%struct.device*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_write_config_word(%struct.pci_dev* %dev, i32 %where, i16 zeroext %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !22
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !42
  %call = call i32 @pci_bus_write_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16 zeroext %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_read_config_word(%struct.pci_dev* %dev, i32 %where, i16* %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !22
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !42
  %call = call i32 @pci_bus_read_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16* %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_read_config_byte(%struct.pci_dev* %dev, i32 %where, i8* %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !22
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !42
  %call = call i32 @pci_bus_read_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8* %val)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @pci_write_config_byte(%struct.pci_dev* %dev, i32 %where, i8 zeroext %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !22
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !42
  %call = call i32 @pci_bus_write_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8 zeroext %val)
  ret i32 %call
}

declare i32 @platform_driver_register(%struct.platform_driver*) #2

declare %struct.pci_dev* @pci_dev_get(%struct.pci_dev*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_device_add(i16 zeroext %address) #1 {
entry:
  %res = alloca %struct.resource, align 8
  %0 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* %0) #6
  %start = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 0
  %conv = zext i16 %address to i64
  store i64 %conv, i64* %start, align 8, !tbaa !43
  %end = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 1
  %conv1 = zext i16 %address to i32
  %add = add nsw i32 %conv1, 8
  %sub = sub nsw i32 %add, 1
  %conv2 = sext i32 %sub to i64
  store i64 %conv2, i64* %end, align 8, !tbaa !45
  %name = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 2
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8** %name, align 8, !tbaa !46
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 3
  store i64 256, i64* %flags, align 8, !tbaa !47
  %parent = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 4
  store %struct.resource* null, %struct.resource** %parent, align 8, !tbaa !48
  %sibling = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 5
  store %struct.resource* null, %struct.resource** %sibling, align 8, !tbaa !49
  %child = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 6
  store %struct.resource* null, %struct.resource** %child, align 8, !tbaa !50
  %call = call i32 @acpi_check_resource_conflict(%struct.resource* %res)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv3 = zext i16 %address to i32
  %call4 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i32 %conv3)
  store %struct.platform_device* %call4, %struct.platform_device** @pdev, align 8, !tbaa !12
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  %tobool5 = icmp ne %struct.platform_device* %1, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.8, i32 0, i32 0))
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %2 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  %call9 = call i32 @platform_device_add_resources(%struct.platform_device* %2, %struct.resource* %res, i32 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.9, i32 0, i32 0), i32 %call9)
  br label %exit_device_put

if.end13:                                         ; preds = %if.end8
  %3 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  %call14 = call i32 @platform_device_add(%struct.platform_device* %3)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %cleanup

if.then16:                                        ; preds = %if.end13
  %call17 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.10, i32 0, i32 0), i32 %call14)
  br label %exit_device_put

exit_device_put:                                  ; preds = %if.then16, %if.then11
  %err.0 = phi i32 [ %call9, %if.then11 ], [ %call14, %if.then16 ]
  %4 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  call void @platform_device_put(%struct.platform_device* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %exit_device_put, %entry, %if.end13
  %retval.0 = phi i32 [ 0, %if.end13 ], [ %err.0, %exit_device_put ], [ -12, %if.then6 ], [ %call, %entry ]
  %5 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.end.p0i8(i64 56, i8* %5) #6
  ret i32 %retval.0
}

declare i32 @pci_bus_write_config_word(%struct.pci_bus*, i32, i32, i16 zeroext) #2

declare i32 @pci_bus_read_config_word(%struct.pci_bus*, i32, i32, i16*) #2

declare i32 @pci_bus_read_config_byte(%struct.pci_bus*, i32, i32, i8*) #2

declare i32 @pci_bus_write_config_byte(%struct.pci_bus*, i32, i32, i8 zeroext) #2

declare i32 @acpi_check_resource_conflict(%struct.resource*) #2

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #2

declare i32 @printk(i8*, ...) #2

declare i32 @platform_device_add_resources(%struct.platform_device*, %struct.resource*, i32) #2

declare i32 @platform_device_add(%struct.platform_device*) #2

declare void @platform_device_put(%struct.platform_device*) #2

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_probe(%struct.platform_device* %pdev) #1 {
entry:
  %val = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %val) #6
  %call = call %struct.resource* @platform_get_resource(%struct.platform_device* %pdev, i32 256, i32 0)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %start = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %0 = load i64, i64* %start, align 8, !tbaa !43
  %1 = load i8*, i8** getelementptr inbounds (%struct.platform_driver, %struct.platform_driver* @sis5595_driver, i32 0, i32 5, i32 0), align 8, !tbaa !51
  %call1 = call %struct.resource* @__devm_request_region(%struct.device* %dev, %struct.resource* @ioport_resource, i64 %0, i64 8, i8* %1)
  %tobool = icmp ne %struct.resource* %call1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call3 = call i8* @devm_kzalloc(%struct.device* %dev2, i64 152, i32 208)
  %2 = bitcast i8* %call3 to %struct.sis5595_data*
  %tobool4 = icmp ne %struct.sis5595_data* %2, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 3
  call void @__mutex_init(%struct.mutex* %lock, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.11, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key)
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 4
  call void @__mutex_init(%struct.mutex* %update_lock, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.13, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key.12)
  %start10 = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %3 = load i64, i64* %start10, align 8, !tbaa !43
  %conv = trunc i64 %3 to i16
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 0
  store i16 %conv, i16* %addr, align 8, !tbaa !54
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 1
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str, i32 0, i32 0), i8** %name, align 8, !tbaa !56
  %4 = bitcast %struct.sis5595_data* %2 to i8*
  call void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %4)
  %5 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  %revision = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %5, i32 0, i32 12
  %6 = load i8, i8* %revision, align 8, !tbaa !57
  %revision11 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  store i8 %6, i8* %revision11, align 1, !tbaa !58
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 3, i8* %maxins, align 8, !tbaa !59
  %revision12 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  %7 = load i8, i8* %revision12, align 1, !tbaa !58
  %conv13 = zext i8 %7 to i32
  %cmp = icmp sge i32 %conv13, 176
  br i1 %cmp, label %if.then15, label %if.end22

if.then15:                                        ; preds = %do.body
  %8 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  %call16 = call i32 @pci_read_config_byte(%struct.pci_dev* %8, i32 122, i8* %val)
  %9 = load i8, i8* %val, align 1, !tbaa !21
  %conv17 = sext i8 %9 to i32
  %and = and i32 %conv17, 128
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.end22, label %if.then19

if.then19:                                        ; preds = %if.then15
  %maxins20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 4, i8* %maxins20, align 8, !tbaa !59
  br label %if.end22

if.end22:                                         ; preds = %if.then15, %if.then19, %do.body
  call void @sis5595_init_device(%struct.sis5595_data* %2)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end22
  %i.0 = phi i32 [ 0, %if.end22 ], [ %inc, %for.body ]
  %cmp23 = icmp slt i32 %i.0, 2
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 59, %i.0
  %conv25 = trunc i32 %add to i8
  %call26 = call i32 @sis5595_read_value(%struct.sis5595_data* %2, i8 zeroext %conv25)
  %conv27 = trunc i32 %call26 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  store i8 %conv27, i8* %arrayidx, align 1, !tbaa !21
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev28 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev28, i32 0, i32 2
  %call29 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %for.end
  %maxins33 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  %10 = load i8, i8* %maxins33, align 8, !tbaa !59
  %conv34 = sext i8 %10 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  %dev38 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj39 = getelementptr inbounds %struct.device, %struct.device* %dev38, i32 0, i32 2
  br i1 %cmp35, label %if.then37, label %if.else

if.then37:                                        ; preds = %if.end32
  %call40 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_in4)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %exit_remove_files, label %if.end50

if.else:                                          ; preds = %if.end32
  %call46 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_temp1)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %exit_remove_files, label %if.end50

if.end50:                                         ; preds = %if.else, %if.then37
  %dev51 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call52 = call %struct.device* @hwmon_device_register(%struct.device* %dev51)
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  store %struct.device* %call52, %struct.device** %hwmon_dev, align 8, !tbaa !60
  %hwmon_dev53 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %11 = load %struct.device*, %struct.device** %hwmon_dev53, align 8, !tbaa !60
  %12 = bitcast %struct.device* %11 to i8*
  %call54 = call i64 @IS_ERR(i8* %12)
  %tobool55 = icmp ne i64 %call54, 0
  br i1 %tobool55, label %if.then56, label %cleanup

if.then56:                                        ; preds = %if.end50
  %hwmon_dev57 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %13 = load %struct.device*, %struct.device** %hwmon_dev57, align 8, !tbaa !60
  %14 = bitcast %struct.device* %13 to i8*
  %call58 = call i64 @PTR_ERR(i8* %14)
  %conv59 = trunc i64 %call58 to i32
  br label %exit_remove_files

exit_remove_files:                                ; preds = %if.else, %if.then37, %if.then56
  %err.0 = phi i32 [ %conv59, %if.then56 ], [ %call40, %if.then37 ], [ %call46, %if.else ]
  %dev61 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj62 = getelementptr inbounds %struct.device, %struct.device* %dev61, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj62, %struct.attribute_group* @sis5595_group)
  %dev63 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj64 = getelementptr inbounds %struct.device, %struct.device* %dev63, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj64, %struct.attribute_group* @sis5595_group_in4)
  %dev65 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj66 = getelementptr inbounds %struct.device, %struct.device* %dev65, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj66, %struct.attribute_group* @sis5595_group_temp1)
  br label %cleanup

cleanup:                                          ; preds = %if.end50, %for.end, %if.end, %entry, %exit_remove_files
  %retval.0 = phi i32 [ %err.0, %exit_remove_files ], [ -16, %entry ], [ -12, %if.end ], [ %call29, %for.end ], [ 0, %if.end50 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %val) #6
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_remove(%struct.platform_device* %pdev) #1 {
entry:
  %call = call i8* @platform_get_drvdata(%struct.platform_device* %pdev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 2
  %1 = load %struct.device*, %struct.device** %hwmon_dev, align 8, !tbaa !60
  call void @hwmon_device_unregister(%struct.device* %1)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj2 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj2, %struct.attribute_group* @sis5595_group_in4)
  %dev3 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj4 = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj4, %struct.attribute_group* @sis5595_group_temp1)
  ret i32 0
}

declare %struct.resource* @platform_get_resource(%struct.platform_device*, i32, i32) #2

declare %struct.resource* @__devm_request_region(%struct.device*, %struct.resource*, i64, i64, i8*) #2

declare i8* @devm_kzalloc(%struct.device*, i64, i32) #2

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %data) #0 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sis5595_init_device(%struct.sis5595_data* %data) #1 {
entry:
  %call = call i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext 64)
  %conv = trunc i32 %call to i8
  %conv1 = zext i8 %conv to i32
  %and = and i32 %conv1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %conv to i32
  %and3 = and i32 %conv2, 247
  %or = or i32 %and3, 1
  %conv4 = trunc i32 %or to i8
  call void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext 64, i8 zeroext %conv4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext %reg) #1 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock(%struct.mutex* %lock)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !54
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !54
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  %call = call zeroext i8 @inb_p(i32 %add3)
  %conv4 = zext i8 %call to i32
  %lock5 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock5)
  ret i32 %conv4
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #2

declare %struct.device* @hwmon_device_register(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #2

declare i32 @dev_set_drvdata(%struct.device*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext %reg, i8 zeroext %value) #1 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock(%struct.mutex* %lock)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !54
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !54
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  call void @outb_p(i8 zeroext %value, i32 %add3)
  %lock4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock4)
  ret void
}

declare void @mutex_lock(%struct.mutex*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb_p(i8 zeroext %value, i32 %port) #0 {
entry:
  call void @outb(i8 zeroext %value, i32 %port)
  call void @slow_down_io()
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #0 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #6, !srcloc !61
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #0 {
entry:
  call void @native_io_delay()
  ret void
}

declare void @native_io_delay() #2

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #0 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #0 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #6, !srcloc !62
  ret i8 %0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_in(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 9
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy1 = alloca i64, align 8
  %__dummy22 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #6
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #6
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #6
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %5 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #6
  %6 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #6
  %cmp3 = icmp eq i64* %__dummy1, %__dummy22
  %conv4 = zext i1 %cmp3 to i32
  %7 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  %8 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  %last_updated = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  %9 = load i64, i64* %last_updated, align 8, !tbaa !67
  %add = add i64 %9, 1000
  %add8 = add i64 %add, 500
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !14
  %sub = sub nsw i64 %add8, %10
  %cmp9 = icmp slt i64 %sub, 0
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %valid = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  %11 = load i8, i8* %valid, align 8, !tbaa !68
  %tobool11 = icmp ne i8 %11, 0
  br i1 %tobool11, label %if.end90, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %12 = load i8, i8* %maxins, align 8, !tbaa !59
  %conv12 = sext i8 %12 to i32
  %cmp13 = icmp sle i32 %i.0, %conv12
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add15 = add nsw i32 32, %i.0
  %conv16 = trunc i32 %add15 to i8
  %call17 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv16)
  %conv18 = trunc i32 %call17 to i8
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 9
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  store i8 %conv18, i8* %arrayidx, align 1, !tbaa !21
  %mul = mul nsw i32 %i.0, 2
  %add19 = add nsw i32 44, %mul
  %conv20 = trunc i32 %add19 to i8
  %call21 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv20)
  %conv22 = trunc i32 %call21 to i8
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom23 = sext i32 %i.0 to i64
  %arrayidx24 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom23
  store i8 %conv22, i8* %arrayidx24, align 1, !tbaa !21
  %mul25 = mul nsw i32 %i.0, 2
  %add26 = add nsw i32 43, %mul25
  %conv27 = trunc i32 %add26 to i8
  %call28 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv27)
  %conv29 = trunc i32 %call28 to i8
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom30
  store i8 %conv29, i8* %arrayidx31, align 1, !tbaa !21
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond32

for.cond32:                                       ; preds = %for.body35, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc49, %for.body35 ]
  %cmp33 = icmp slt i32 %i.1, 2
  br i1 %cmp33, label %for.body35, label %for.end50

for.body35:                                       ; preds = %for.cond32
  %add36 = add nsw i32 40, %i.1
  %conv37 = trunc i32 %add36 to i8
  %call38 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv37)
  %conv39 = trunc i32 %call38 to i8
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 12
  %idxprom40 = sext i32 %i.1 to i64
  %arrayidx41 = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom40
  store i8 %conv39, i8* %arrayidx41, align 1, !tbaa !21
  %add42 = add nsw i32 59, %i.1
  %conv43 = trunc i32 %add42 to i8
  %call44 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv43)
  %conv45 = trunc i32 %call44 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom46 = sext i32 %i.1 to i64
  %arrayidx47 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom46
  store i8 %conv45, i8* %arrayidx47, align 1, !tbaa !21
  %inc49 = add nsw i32 %i.1, 1
  br label %for.cond32

for.end50:                                        ; preds = %for.cond32
  %maxins51 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %13 = load i8, i8* %maxins51, align 8, !tbaa !59
  %conv52 = sext i8 %13 to i32
  %cmp53 = icmp eq i32 %conv52, 3
  br i1 %cmp53, label %if.then55, label %if.end

if.then55:                                        ; preds = %for.end50
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %14 = load i8, i8* %revision, align 1, !tbaa !58
  %conv56 = zext i8 %14 to i32
  %cmp57 = icmp sge i32 %conv56, 176
  %15 = zext i1 %cmp57 to i64
  %cond = select i1 %cmp57, i32 36, i32 39
  %conv59 = trunc i32 %cond to i8
  %call60 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv59)
  %conv61 = trunc i32 %call60 to i8
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 14
  store i8 %conv61, i8* %temp, align 1, !tbaa !69
  %revision62 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %16 = load i8, i8* %revision62, align 1, !tbaa !58
  %conv63 = zext i8 %16 to i32
  %cmp64 = icmp sge i32 %conv63, 176
  %17 = zext i1 %cmp64 to i64
  %cond66 = select i1 %cmp64, i32 51, i32 57
  %conv67 = trunc i32 %cond66 to i8
  %call68 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv67)
  %conv69 = trunc i32 %call68 to i8
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %conv69, i8* %temp_over, align 2, !tbaa !70
  %revision70 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %18 = load i8, i8* %revision70, align 1, !tbaa !58
  %conv71 = zext i8 %18 to i32
  %cmp72 = icmp sge i32 %conv71, 176
  %19 = zext i1 %cmp72 to i64
  %cond74 = select i1 %cmp72, i32 52, i32 58
  %conv75 = trunc i32 %cond74 to i8
  %call76 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv75)
  %conv77 = trunc i32 %call76 to i8
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %conv77, i8* %temp_hyst, align 1, !tbaa !71
  br label %if.end

if.end:                                           ; preds = %if.then55, %for.end50
  %call78 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %shr = ashr i32 %call78, 4
  %and = and i32 %shr, 3
  %conv79 = trunc i32 %and to i8
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx80 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 0
  store i8 %conv79, i8* %arrayidx80, align 8, !tbaa !21
  %shr81 = ashr i32 %call78, 6
  %conv82 = trunc i32 %shr81 to i8
  %fan_div83 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx84 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div83, i64 0, i64 1
  store i8 %conv82, i8* %arrayidx84, align 1, !tbaa !21
  %call85 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 65)
  %call86 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 66)
  %shl = shl i32 %call86, 8
  %or = or i32 %call85, %shl
  %conv87 = trunc i32 %or to i16
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 18
  store i16 %conv87, i16* %alarms, align 2, !tbaa !72
  %20 = load volatile i64, i64* @jiffies, align 8, !tbaa !14
  %last_updated88 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  store i64 %20, i64* %last_updated88, align 8, !tbaa !67
  %valid89 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  store i8 1, i8* %valid89, align 8, !tbaa !68
  br label %if.end90

if.end90:                                         ; preds = %if.end, %lor.lhs.false
  %update_lock91 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock91)
  ret %struct.sis5595_data* %0
}

declare i32 @sprintf(i8*, i8*, ...) #2

declare i8* @dev_get_drvdata(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 11
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !63
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %5 = load i64, i64* %val, align 8, !tbaa !14
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !21
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 44, %mul
  %conv3 = trunc i32 %add to i8
  %in_min4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !21
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @IN_TO_REG(i64 %val) #0 {
entry:
  %cmp = icmp ult i64 %val, 0
  %.val = select i1 %cmp, i64 0, i64 %val
  %cmp1 = icmp ugt i64 %.val, 4080
  %cond5 = select i1 %cmp1, i64 4080, i64 %.val
  %add = add i64 %cond5, 8
  %div = udiv i64 %add, 16
  %conv = trunc i64 %div to i8
  ret i8 %conv
}

declare i32 @kstrtoull(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !63
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %5 = load i64, i64* %val, align 8, !tbaa !14
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !21
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 43, %mul
  %conv3 = trunc i32 %add to i8
  %in_max4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !21
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #6
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarm(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %3 = load i16, i16* %alarms, align 2, !tbaa !72
  %conv = zext i16 %3 to i32
  %shr = ashr i32 %conv, %2
  %and = and i32 %shr, 1
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), i32 %and)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !21
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @FAN_FROM_REG(i8 zeroext %val, i32 %div) #0 {
entry:
  %conv = zext i8 %val to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.end9, label %cond.false

cond.false:                                       ; preds = %entry
  %conv2 = zext i8 %val to i32
  %cmp3 = icmp eq i32 %conv2, 255
  br i1 %cmp3, label %cond.end9, label %cond.false6

cond.false6:                                      ; preds = %cond.false
  %conv7 = zext i8 %val to i32
  %mul = mul nsw i32 %conv7, %div
  %div8 = sdiv i32 1350000, %mul
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false6, %cond.false, %entry
  %cond10 = phi i32 [ -1, %entry ], [ %div8, %cond.false6 ], [ 0, %cond.false ]
  ret i32 %cond10
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !21
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !63
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %5 = load i64, i64* %val, align 8, !tbaa !14
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %conv2 = zext i8 %6 to i32
  %shl = shl i32 1, %conv2
  %call3 = call zeroext i8 @FAN_TO_REG(i64 %5, i32 %shl)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom4 = sext i32 %3 to i64
  %arrayidx5 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom4
  store i8 %call3, i8* %arrayidx5, align 1, !tbaa !21
  %add = add nsw i32 59, %3
  %conv6 = trunc i32 %add to i8
  %fan_min7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom8 = sext i32 %3 to i64
  %arrayidx9 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min7, i64 0, i64 %idxprom8
  %7 = load i8, i8* %arrayidx9, align 1, !tbaa !21
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %7)
  %update_lock10 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @FAN_TO_REG(i64 %rpm, i32 %div) #0 {
entry:
  %cmp = icmp sle i64 %rpm, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv = sext i32 %div to i64
  %mul = mul nsw i64 %rpm, %conv
  %div1 = sdiv i64 %mul, 2
  %add = add nsw i64 1350000, %div1
  %conv2 = sext i32 %div to i64
  %mul3 = mul nsw i64 %rpm, %conv2
  %div4 = sdiv i64 %add, %mul3
  %cmp5 = icmp slt i64 %div4, 1
  %.div4 = select i1 %cmp5, i64 1, i64 %div4
  %cmp7 = icmp sgt i64 %.div4, 254
  %cond12 = select i1 %cmp7, i64 254, i64 %.div4
  %conv13 = trunc i64 %cond12 to i8
  br label %return

return:                                           ; preds = %entry, %if.end
  %retval.0 = phi i8 [ %conv13, %if.end ], [ -1, %entry ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %conv
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %shl)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !63
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !21
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom2 = sext i32 %3 to i64
  %arrayidx3 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom2
  %6 = load i8, i8* %arrayidx3, align 1, !tbaa !21
  %conv4 = zext i8 %6 to i32
  %shl = shl i32 1, %conv4
  %call5 = call i32 @FAN_FROM_REG(i8 zeroext %5, i32 %shl)
  %conv6 = sext i32 %call5 to i64
  %call7 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %7 = load i64, i64* %val, align 8, !tbaa !14
  br label %NodeBlock12

NodeBlock12:                                      ; preds = %if.end
  %Pivot13 = icmp slt i64 %7, 4
  br i1 %Pivot13, label %NodeBlock, label %NodeBlock10

NodeBlock10:                                      ; preds = %NodeBlock12
  %Pivot11 = icmp slt i64 %7, 8
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i64 %7, 8
  br i1 %SwitchLeaf9, label %sw.bb19, label %NewDefault

LeafBlock6:                                       ; preds = %NodeBlock10
  %SwitchLeaf7 = icmp eq i64 %7, 4
  br i1 %SwitchLeaf7, label %sw.bb15, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock12
  %Pivot = icmp slt i64 %7, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock4

LeafBlock4:                                       ; preds = %NodeBlock
  %SwitchLeaf5 = icmp eq i64 %7, 2
  br i1 %SwitchLeaf5, label %sw.epilog, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i64 %7, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  br label %sw.epilog

sw.bb15:                                          ; preds = %LeafBlock6
  br label %sw.epilog

sw.bb19:                                          ; preds = %LeafBlock8
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock8, %LeafBlock6, %LeafBlock4, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %8 = load i64, i64* %val, align 8, !tbaa !14
  %call23 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.35, i32 0, i32 0), i64 %8)
  %update_lock24 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock24)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock4, %sw.bb19, %sw.bb15, %sw.bb
  %.sink = phi i8 [ 3, %sw.bb19 ], [ 2, %sw.bb15 ], [ 0, %sw.bb ], [ 1, %LeafBlock4 ]
  %fan_div20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom21 = sext i32 %3 to i64
  %arrayidx22 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div20, i64 0, i64 %idxprom21
  store i8 %.sink, i8* %arrayidx22, align 1, !tbaa !21
  br label %NodeBlock19

NodeBlock19:                                      ; preds = %sw.epilog
  %Pivot20 = icmp slt i32 %3, 1
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %3, 1
  br i1 %SwitchLeaf18, label %sw.epilog39.sink.split, label %NewDefault14

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %3, 0
  br i1 %SwitchLeaf16, label %sw.bb25, label %NewDefault14

sw.bb25:                                          ; preds = %LeafBlock15
  br label %sw.epilog39.sink.split

sw.epilog39.sink.split:                           ; preds = %LeafBlock17, %sw.bb25
  %.sink3 = phi i32 [ 207, %sw.bb25 ], [ 63, %LeafBlock17 ]
  %.sink1 = phi i32 [ 4, %sw.bb25 ], [ 6, %LeafBlock17 ]
  %and32 = and i32 %call7, %.sink3
  %fan_div33 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom34 = sext i32 %3 to i64
  %arrayidx35 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div33, i64 0, i64 %idxprom34
  %9 = load i8, i8* %arrayidx35, align 1, !tbaa !21
  %conv36 = zext i8 %9 to i32
  %shl37 = shl i32 %conv36, %.sink1
  %or38 = or i32 %and32, %shl37
  br label %sw.epilog39

NewDefault14:                                     ; preds = %LeafBlock17, %LeafBlock15
  br label %sw.epilog39

sw.epilog39:                                      ; preds = %NewDefault14, %sw.epilog39.sink.split
  %reg.0 = phi i32 [ %call7, %NewDefault14 ], [ %or38, %sw.epilog39.sink.split ]
  %conv40 = trunc i32 %reg.0 to i8
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext 71, i8 zeroext %conv40)
  %fan_div41 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom42 = sext i32 %3 to i64
  %arrayidx43 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div41, i64 0, i64 %idxprom42
  %10 = load i8, i8* %arrayidx43, align 1, !tbaa !21
  %conv44 = zext i8 %10 to i32
  %shl45 = shl i32 1, %conv44
  %call46 = call zeroext i8 @FAN_TO_REG(i64 %conv6, i32 %shl45)
  %fan_min47 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom48 = sext i32 %3 to i64
  %arrayidx49 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min47, i64 0, i64 %idxprom48
  store i8 %call46, i8* %arrayidx49, align 1, !tbaa !21
  %add = add nsw i32 59, %3
  %conv50 = trunc i32 %add to i8
  %fan_min51 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom52 = sext i32 %3 to i64
  %arrayidx53 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min51, i64 0, i64 %idxprom52
  %11 = load i8, i8* %arrayidx53, align 1, !tbaa !21
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv50, i8 zeroext %11)
  %update_lock54 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock54)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog39, %sw.default, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ -22, %sw.default ], [ %count, %sw.epilog39 ]
  %12 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #6
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarms(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %0 = load i16, i16* %alarms, align 2, !tbaa !72
  %conv = zext i16 %0 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_name(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 1
  %1 = load i8*, i8** %name, align 8, !tbaa !56
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43, i32 0, i32 0), i8* %1)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 14
  %0 = load i8, i8* %temp, align 1, !tbaa !69
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @TEMP_FROM_REG(i8 signext %val) #0 {
entry:
  %conv = sext i8 %val to i32
  %mul = mul nsw i32 %conv, 830
  %add = add nsw i32 %mul, 52120
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_over(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 15
  %0 = load i8, i8* %temp_over, align 2, !tbaa !70
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_temp_over(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %2 = load i64, i64* %val, align 8, !tbaa !14
  %conv2 = trunc i64 %2 to i32
  %call3 = call signext i8 @TEMP_TO_REG(i32 %conv2)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %call3, i8* %temp_over, align 2, !tbaa !70
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !58
  %conv4 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv4, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 51, i32 57
  %conv6 = trunc i32 %cond to i8
  %temp_over7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  %5 = load i8, i8* %temp_over7, align 2, !tbaa !70
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %5)
  %update_lock8 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock8)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #6
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtol(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoll(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal signext i8 @TEMP_TO_REG(i32 %val) #0 {
entry:
  %cmp = icmp slt i32 %val, -54120
  %.val = select i1 %cmp, i32 -54120, i32 %val
  %cmp1 = icmp sgt i32 %.val, 157530
  %cond5 = select i1 %cmp1, i32 157530, i32 %.val
  %cmp6 = icmp slt i32 %cond5, 0
  %sub = sub nsw i32 %cond5, 5212
  %add = add nsw i32 %sub, 415
  %sub8 = sub nsw i32 %sub, 415
  %add.sink = select i1 %cmp6, i32 %sub8, i32 %add
  %div11 = sdiv i32 %add.sink, 830
  %conv = trunc i32 %div11 to i8
  ret i8 %conv
}

declare i32 @kstrtoll(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 16
  %0 = load i8, i8* %temp_hyst, align 1, !tbaa !71
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.15, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_temp_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #6
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock(%struct.mutex* %update_lock)
  %2 = load i64, i64* %val, align 8, !tbaa !14
  %conv2 = trunc i64 %2 to i32
  %call3 = call signext i8 @TEMP_TO_REG(i32 %conv2)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %call3, i8* %temp_hyst, align 1, !tbaa !71
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !58
  %conv4 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv4, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 52, i32 58
  %conv6 = trunc i32 %cond to i8
  %temp_hyst7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  %5 = load i8, i8* %temp_hyst7, align 1, !tbaa !71
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %5)
  %update_lock8 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock8)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #6
  ret i64 %retval.0
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @platform_get_drvdata(%struct.platform_device* %pdev) #0 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare void @hwmon_device_unregister(%struct.device*) #2

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #2

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!4, !4, i64 0}
!13 = !{i32 660498, i32 660519}
!14 = !{!15, !15, i64 0}
!15 = !{!"long", !5, i64 0}
!16 = !{i32 -2146949964}
!17 = !{!18, !18, i64 0}
!18 = !{!"int", !5, i64 0}
!19 = !{!20, !20, i64 0}
!20 = !{!"short", !5, i64 0}
!21 = !{!5, !5, i64 0}
!22 = !{!23, !4, i64 16}
!23 = !{!"pci_dev", !24, i64 0, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !18, i64 56, !20, i64 60, !20, i64 62, !20, i64 64, !20, i64 66, !18, i64 68, !5, i64 72, !5, i64 73, !5, i64 74, !5, i64 75, !5, i64 76, !5, i64 77, !5, i64 78, !5, i64 79, !20, i64 80, !4, i64 88, !25, i64 96, !26, i64 104, !18, i64 120, !5, i64 124, !18, i64 125, !18, i64 125, !18, i64 125, !18, i64 125, !18, i64 126, !18, i64 126, !18, i64 126, !18, i64 126, !18, i64 126, !18, i64 126, !18, i64 126, !18, i64 128, !18, i64 132, !4, i64 136, !18, i64 144, !27, i64 152, !18, i64 592, !18, i64 596, !5, i64 600, !35, i64 1216, !18, i64 1217, !18, i64 1217, !18, i64 1217, !18, i64 1217, !18, i64 1217, !18, i64 1217, !18, i64 1217, !18, i64 1217, !18, i64 1218, !18, i64 1218, !18, i64 1218, !18, i64 1218, !18, i64 1218, !18, i64 1218, !18, i64 1218, !18, i64 1219, !18, i64 1219, !18, i64 1219, !18, i64 1219, !18, i64 1219, !18, i64 1219, !18, i64 1219, !18, i64 1219, !20, i64 1220, !30, i64 1224, !5, i64 1228, !41, i64 1296, !4, i64 1304, !18, i64 1312, !5, i64 1320, !5, i64 1408, !24, i64 1496, !4, i64 1512, !4, i64 1520, !5, i64 1528, !4, i64 1536, !25, i64 1544, !15, i64 1552}
!24 = !{!"list_head", !4, i64 0, !4, i64 8}
!25 = !{!"long long", !5, i64 0}
!26 = !{!"device_dma_parameters", !18, i64 0, !15, i64 8}
!27 = !{!"device", !4, i64 0, !4, i64 8, !28, i64 16, !4, i64 80, !4, i64 88, !31, i64 96, !4, i64 136, !4, i64 144, !4, i64 152, !33, i64 160, !4, i64 248, !18, i64 256, !4, i64 264, !25, i64 272, !4, i64 280, !24, i64 288, !4, i64 304, !38, i64 312, !4, i64 328, !39, i64 336, !18, i64 344, !18, i64 348, !32, i64 352, !24, i64 360, !40, i64 376, !4, i64 408, !4, i64 416, !4, i64 424, !4, i64 432}
!28 = !{!"kobject", !4, i64 0, !24, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !29, i64 56, !18, i64 60, !18, i64 60, !18, i64 60, !18, i64 60, !18, i64 60}
!29 = !{!"kref", !30, i64 0}
!30 = !{!"", !18, i64 0}
!31 = !{!"mutex", !30, i64 0, !32, i64 4, !24, i64 8, !4, i64 24, !4, i64 32}
!32 = !{!"spinlock", !5, i64 0}
!33 = !{!"dev_pm_info", !34, i64 0, !18, i64 4, !18, i64 4, !35, i64 4, !35, i64 4, !35, i64 4, !35, i64 4, !32, i64 6, !24, i64 8, !36, i64 24, !4, i64 56, !35, i64 64, !35, i64 64, !4, i64 72, !4, i64 80}
!34 = !{!"pm_message", !18, i64 0}
!35 = !{!"_Bool", !5, i64 0}
!36 = !{!"completion", !18, i64 0, !37, i64 8}
!37 = !{!"__wait_queue_head", !32, i64 0, !24, i64 8}
!38 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!39 = !{!"acpi_dev_node", !4, i64 0}
!40 = !{!"klist_node", !4, i64 0, !24, i64 8, !29, i64 24}
!41 = !{!"hlist_head", !4, i64 0}
!42 = !{!23, !18, i64 56}
!43 = !{!44, !25, i64 0}
!44 = !{!"resource", !25, i64 0, !25, i64 8, !4, i64 16, !15, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!45 = !{!44, !25, i64 8}
!46 = !{!44, !4, i64 16}
!47 = !{!44, !15, i64 24}
!48 = !{!44, !4, i64 32}
!49 = !{!44, !4, i64 40}
!50 = !{!44, !4, i64 48}
!51 = !{!52, !4, i64 40}
!52 = !{!"platform_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !53, i64 40, !4, i64 160}
!53 = !{!"device_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !35, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112}
!54 = !{!55, !20, i64 0}
!55 = !{!"sis5595_data", !20, i64 0, !4, i64 8, !4, i64 16, !31, i64 24, !31, i64 64, !5, i64 104, !15, i64 112, !5, i64 120, !5, i64 121, !5, i64 122, !5, i64 127, !5, i64 132, !5, i64 137, !5, i64 139, !5, i64 141, !5, i64 142, !5, i64 143, !5, i64 144, !20, i64 146}
!56 = !{!55, !4, i64 8}
!57 = !{!23, !5, i64 72}
!58 = !{!55, !5, i64 121}
!59 = !{!55, !5, i64 120}
!60 = !{!55, !4, i64 16}
!61 = !{i32 -2146141959}
!62 = !{i32 -2146141757}
!63 = !{!64, !18, i64 32}
!64 = !{!"sensor_device_attribute", !65, i64 0, !18, i64 32}
!65 = !{!"device_attribute", !66, i64 0, !4, i64 16, !4, i64 24}
!66 = !{!"attribute", !4, i64 0, !20, i64 8}
!67 = !{!55, !15, i64 112}
!68 = !{!55, !5, i64 104}
!69 = !{!55, !5, i64 141}
!70 = !{!55, !5, i64 142}
!71 = !{!55, !5, i64 143}
!72 = !{!55, !20, i64 146}
