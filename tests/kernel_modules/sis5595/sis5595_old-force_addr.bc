; ModuleID = 'tests/kernel_modules/sis5595/sis5595_old.bc'
source_filename = "drivers/hwmon/sis5595.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.46 }
%union.anon.46 = type { i8* }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, %struct.memcg_batch_info, i32, %struct.atomic_t, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.39, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%union.anon.39 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.42, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.40, i8* }
%union.anon.40 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.37, i32 }
%union.anon.37 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.42 = type { %struct.list_head }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.35, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.36, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.38, i32, i32, %struct.hlist_head, %struct.atomic_t, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.35 = type { i32 }
%union.anon.36 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.34, i32 }
%union.anon.34 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.38 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t, i32, i32, i8*, %struct.lockdep_map }
%union.arch_rwlock_t = type { i64 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.0, %union.anon.6, %union.anon.8, i64 }
%struct.anon.0 = type { %union.anon.1, %union.anon.2 }
%union.anon.1 = type { i64 }
%union.anon.2 = type { i64 }
%union.anon.6 = type { %struct.list_head }
%union.anon.8 = type { i64 }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %struct.atomic_t, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.14, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.15, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.16, %union.anon.17 }
%union.anon.14 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.15 = type { i64 }
%union.anon.16 = type { %struct.list_head }
%union.anon.17 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.18 }
%union.anon.18 = type { %struct.anon.19 }
%struct.anon.19 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.21, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.24 }
%union.anon.21 = type { %struct.anon.22 }
%struct.anon.22 = type { i64, i64 }
%union.anon.24 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.spinlock = type { %union.anon.11 }
%union.anon.11 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.12 }
%union.anon.12 = type { i32 }
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.26 }
%union.anon.26 = type { %struct.anon.30, [80 x i8] }
%struct.anon.30 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.atomic_t = type { i32 }
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.pv_irq_ops = type { %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, %struct.paravirt_callee_save, void ()*, void ()*, void ()* }
%struct.paravirt_callee_save = type { i8* }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_dev = type <{ %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, [6 x i8], %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, i16, i8, i32, i32, %struct.pcie_link_state*, i32, [4 x i8], %struct.device, i32, i32, [17 x %struct.resource], i8, [3 x i8], i16, [2 x i8], %struct.atomic_t, [16 x i32], [4 x i8], %struct.hlist_head, %struct.bin_attribute*, i32, [4 x i8], [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.kset*, %struct.pci_vpd*, %union.anon.47, %struct.pci_ats*, i64, i64 }>
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.proc_dir_entry = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.pcie_link_state = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.dma_attrs = type { [1 x i64] }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.pci_vpd = type opaque
%union.anon.47 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.platform_driver = type { i32 (%struct.platform_device*)*, i32 (%struct.platform_device*)*, void (%struct.platform_device*)*, i32 (%struct.platform_device*, i32)*, i32 (%struct.platform_device*)*, %struct.device_driver, %struct.platform_device_id* }
%struct.platform_device = type { i8*, i32, i8, %struct.device, i32, %struct.resource*, %struct.platform_device_id*, %struct.mfd_cell*, %struct.pdev_archdata }
%struct.mfd_cell = type opaque
%struct.pdev_archdata = type {}
%struct.platform_device_id = type { [20 x i8], i64 }
%struct.pv_cpu_ops = type { i64 (i32)*, void (i32, i64)*, void ()*, i64 ()*, void (i64)*, i64 ()*, i64 ()*, void (i64)*, i64 ()*, void (i64)*, void ()*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (%struct.desc_ptr*)*, void (i8*, i32)*, i64 ()*, void (%struct.thread_struct*, i32)*, void (i32)*, void (%struct.desc_struct*, i32, i8*)*, void (%struct.desc_struct*, i32, i8*, i32)*, void (%struct.gate_struct64*, i32, %struct.gate_struct64*)*, void (%struct.desc_struct*, i32)*, void (%struct.desc_struct*, i32)*, void (%struct.tss_struct*, %struct.thread_struct*)*, void (i32)*, void ()*, void ()*, void (i32*, i32*, i32*, i32*)*, i64 (i32, i32*)*, i32 (i32, i32, i32)*, i64 ()*, i64 (i32)*, i64 (i32*)*, void ()*, void ()*, void ()*, void ()*, void ()*, void (%struct.task_struct*)*, void (%struct.task_struct*)* }
%struct.desc_ptr = type <{ i16, i64 }>
%struct.gate_struct64 = type { i16, i16, i16, i16, i32, i32 }
%struct.tss_struct = type { %struct.x86_hw_tss, [1025 x i64], [64 x i64], [56 x i8] }
%struct.x86_hw_tss = type <{ i32, i64, i64, i64, i64, [7 x i64], i32, i32, i16, i16, [24 x i8] }>
%struct.sensor_device_attribute = type { %struct.device_attribute, i32 }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, %struct.memcg_cache_params*, i32, i32, [1024 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page*, [26 x i32] }
%struct.kmem_cache_order_objects = type { i64 }
%struct.memcg_cache_params = type { i8, %union.anon.9 }
%union.anon.9 = type { %struct.anon.10 }
%struct.anon.10 = type { %struct.mem_cgroup*, %struct.list_head, %struct.kmem_cache*, i8, %struct.atomic_t, %struct.work_struct }
%struct.kmem_cache_node = type opaque
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }
%struct.sis5595_data = type { i16, i8*, %struct.device*, %struct.mutex, %struct.mutex, i8, i64, i8, i8, [5 x i8], [5 x i8], [5 x i8], [2 x i8], [2 x i8], i8, i8, i8, [2 x i8], i16 }

@__param_str_force_addr = internal constant [11 x i8] c"force_addr\00", align 1
@param_ops_ushort = external global %struct.kernel_param_ops, align 8
@force_addr = internal global i16 0, align 2
@__param_force_addr = internal constant %struct.kernel_param { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @__param_str_force_addr, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_ushort, i16 0, i16 -1, %union.anon.46 { i8* bitcast (i16* @force_addr to i8*) } }, section "__param", align 8
@__UNIQUE_ID_force_addrtype76 = internal constant [27 x i8] c"parmtype=force_addr:ushort\00", section ".modinfo", align 1
@__UNIQUE_ID_force_addr78 = internal constant [59 x i8] c"parm=force_addr:Initialize the base address of the sensors\00", section ".modinfo", align 1
@__UNIQUE_ID_author926 = internal constant [45 x i8] c"author=Aurelien Jarno <aurelien@aurel32.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description927 = internal constant [35 x i8] c"description=SiS 5595 Sensor device\00", section ".modinfo", align 1
@__UNIQUE_ID_license928 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@smp_ops = external global %struct.smp_ops, align 8
@pv_irq_ops = external global %struct.pv_irq_ops, align 8
@.str = private unnamed_addr constant [60 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/paravirt.h\00", align 1
@current_task = external global %struct.task_struct*, align 8
@sis5595_pci_ids = internal constant [2 x %struct.pci_device_id] [%struct.pci_device_id { i32 4153, i32 8, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id zeroinitializer], align 16
@sis5595_pci_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([2 x %struct.pci_device_id], [2 x %struct.pci_device_id]* @sis5595_pci_ids, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @sis5595_pci_probe, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* null, i32 (%struct.pci_dev*, i32)* null, %struct.pci_error_handlers* null, %struct.device_driver zeroinitializer, %struct.pci_dynids zeroinitializer }, align 8
@__this_module = external global %struct.module, align 8
@.str.2 = private unnamed_addr constant [8 x i8] c"sis5595\00", align 1
@blacklist = internal global [10 x i32] [i32 1344, i32 1360, i32 1584, i32 1605, i32 1840, i32 1845, i32 21777, i32 21911, i32 21912, i32 0], align 16
@.str.3 = private unnamed_addr constant [54 x i8] c"Looked for SIS5595 but found unsupported device %.4x\0A\00", align 1
@.str.4 = private unnamed_addr constant [26 x i8] c"Forcing ISA address 0x%x\0A\00", align 1
@.str.5 = private unnamed_addr constant [28 x i8] c"Failed to read ISA address\0A\00", align 1
@.str.6 = private unnamed_addr constant [62 x i8] c"Base address not set - upgrade BIOS or use force_addr=0xaddr\0A\00", align 1
@.str.7 = private unnamed_addr constant [29 x i8] c"Failed to force ISA address\0A\00", align 1
@.str.8 = private unnamed_addr constant [32 x i8] c"Failed to read enable register\0A\00", align 1
@.str.9 = private unnamed_addr constant [29 x i8] c"Failed to enable HWM device\0A\00", align 1
@sis5595_driver = internal global %struct.platform_driver { i32 (%struct.platform_device*)* @sis5595_probe, i32 (%struct.platform_device*)* @sis5595_remove, void (%struct.platform_device*)* null, i32 (%struct.platform_device*, i32)* null, i32 (%struct.platform_device*)* null, %struct.device_driver { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), %struct.bus_type* null, %struct.module* @__this_module, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.platform_device_id* null }, align 8
@sis5595_pci_probe.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.sis5595_pci_probe, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.11, i32 0, i32 0), i8 113, i8 3, i8 4, i8 0 }, section "__verbose", align 8
@__func__.sis5595_pci_probe = private unnamed_addr constant [18 x i8] c"sis5595_pci_probe\00", align 1
@.str.10 = private unnamed_addr constant [24 x i8] c"drivers/hwmon/sis5595.c\00", align 1
@.str.11 = private unnamed_addr constant [35 x i8] c"Failed to register sis5595 driver\0A\00", align 1
@s_bridge = internal global %struct.pci_dev* null, align 8
@ioport_resource = external global %struct.resource, align 8
@sis5595_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.12 = private unnamed_addr constant [12 x i8] c"&data->lock\00", align 1
@sis5595_probe.__key.13 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.14 = private unnamed_addr constant [19 x i8] c"&data->update_lock\00", align 1
@sis5595_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([27 x %struct.attribute*], [27 x %struct.attribute*]* @sis5595_attributes, i32 0, i32 0) }, align 8
@sis5595_group_in4 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_in4, i32 0, i32 0) }, align 8
@sis5595_group_temp1 = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([5 x %struct.attribute*], [5 x %struct.attribute*]* @sis5595_attributes_temp1, i32 0, i32 0) }, align 8
@pv_cpu_ops = external global %struct.pv_cpu_ops, align 8
@sis5595_attributes = internal global [27 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in0_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_div, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_alarm, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_alarms, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_name, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in0_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.15, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in0_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.17, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 0 }, align 8
@sensor_dev_attr_in0_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.18, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 0 }, align 8
@sensor_dev_attr_in0_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.19, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.21, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.22, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 1 }, align 8
@sensor_dev_attr_in1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.23, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 1 }, align 8
@sensor_dev_attr_in1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.24, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.25, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.26, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 2 }, align 8
@sensor_dev_attr_in2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.27, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 2 }, align 8
@sensor_dev_attr_in2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.28, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.29, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_in3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.30, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 3 }, align 8
@sensor_dev_attr_in3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.31, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 3 }, align 8
@sensor_dev_attr_in3_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.32, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_fan1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.33, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_fan1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.34, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 0 }, align 8
@sensor_dev_attr_fan1_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.35, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 0 }, align 8
@sensor_dev_attr_fan1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 6 }, align 8
@sensor_dev_attr_fan2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.38, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_fan2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_min }, i32 1 }, align 8
@sensor_dev_attr_fan2_div = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.40, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_div, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_fan_div }, i32 1 }, align 8
@sensor_dev_attr_fan2_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.41, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 7 }, align 8
@dev_attr_alarms = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.42, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarms, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_name = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.43, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_name, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.15 = private unnamed_addr constant [10 x i8] c"in0_input\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@jiffies = external global i64, align 8
@.str.17 = private unnamed_addr constant [8 x i8] c"in0_min\00", align 1
@.str.18 = private unnamed_addr constant [8 x i8] c"in0_max\00", align 1
@.str.19 = private unnamed_addr constant [10 x i8] c"in0_alarm\00", align 1
@.str.20 = private unnamed_addr constant [4 x i8] c"%u\0A\00", align 1
@.str.21 = private unnamed_addr constant [10 x i8] c"in1_input\00", align 1
@.str.22 = private unnamed_addr constant [8 x i8] c"in1_min\00", align 1
@.str.23 = private unnamed_addr constant [8 x i8] c"in1_max\00", align 1
@.str.24 = private unnamed_addr constant [10 x i8] c"in1_alarm\00", align 1
@.str.25 = private unnamed_addr constant [10 x i8] c"in2_input\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"in2_min\00", align 1
@.str.27 = private unnamed_addr constant [8 x i8] c"in2_max\00", align 1
@.str.28 = private unnamed_addr constant [10 x i8] c"in2_alarm\00", align 1
@.str.29 = private unnamed_addr constant [10 x i8] c"in3_input\00", align 1
@.str.30 = private unnamed_addr constant [8 x i8] c"in3_min\00", align 1
@.str.31 = private unnamed_addr constant [8 x i8] c"in3_max\00", align 1
@.str.32 = private unnamed_addr constant [10 x i8] c"in3_alarm\00", align 1
@.str.33 = private unnamed_addr constant [11 x i8] c"fan1_input\00", align 1
@.str.34 = private unnamed_addr constant [9 x i8] c"fan1_min\00", align 1
@.str.35 = private unnamed_addr constant [9 x i8] c"fan1_div\00", align 1
@.str.36 = private unnamed_addr constant [62 x i8] c"fan_div value %ld not supported. Choose one of 1, 2, 4 or 8!\0A\00", align 1
@.str.37 = private unnamed_addr constant [11 x i8] c"fan1_alarm\00", align 1
@.str.38 = private unnamed_addr constant [11 x i8] c"fan2_input\00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c"fan2_min\00", align 1
@.str.40 = private unnamed_addr constant [9 x i8] c"fan2_div\00", align 1
@.str.41 = private unnamed_addr constant [11 x i8] c"fan2_alarm\00", align 1
@.str.42 = private unnamed_addr constant [7 x i8] c"alarms\00", align 1
@.str.43 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.44 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@sis5595_attributes_in4 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.45, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 4 }, align 8
@sensor_dev_attr_in4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_min }, i32 4 }, align 8
@sensor_dev_attr_in4_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_in_max }, i32 4 }, align 8
@sensor_dev_attr_in4_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.48, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.45 = private unnamed_addr constant [10 x i8] c"in4_input\00", align 1
@.str.46 = private unnamed_addr constant [8 x i8] c"in4_min\00", align 1
@.str.47 = private unnamed_addr constant [8 x i8] c"in4_max\00", align 1
@.str.48 = private unnamed_addr constant [10 x i8] c"in4_alarm\00", align 1
@sis5595_attributes_temp1 = internal global [5 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_input, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_temp1_max_hyst, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_alarm, i32 0, i32 0, i32 0), %struct.attribute* null], align 16
@dev_attr_temp1_input = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.49, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_temp1_max = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.50, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_over, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_temp_over }, align 8
@dev_attr_temp1_max_hyst = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.51, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @set_temp_hyst }, align 8
@sensor_dev_attr_temp1_alarm = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.52, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@.str.49 = private unnamed_addr constant [12 x i8] c"temp1_input\00", align 1
@.str.50 = private unnamed_addr constant [10 x i8] c"temp1_max\00", align 1
@.str.51 = private unnamed_addr constant [15 x i8] c"temp1_max_hyst\00", align 1
@.str.52 = private unnamed_addr constant [12 x i8] c"temp1_alarm\00", align 1
@pdev = internal global %struct.platform_device* null, align 8
@.str.53 = private unnamed_addr constant [37 x i8] c"\013sis5595: Device allocation failed\0A\00", align 1
@.str.54 = private unnamed_addr constant [49 x i8] c"\013sis5595: Device resource addition failed (%d)\0A\00", align 1
@.str.55 = private unnamed_addr constant [40 x i8] c"\013sis5595: Device addition failed (%d)\0A\00", align 1
@llvm.used = appending global [6 x i8*] [i8* bitcast (%struct.kernel_param* @__param_force_addr to i8*), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__UNIQUE_ID_force_addrtype76, i32 0, i32 0), i8* getelementptr inbounds ([59 x i8], [59 x i8]* @__UNIQUE_ID_force_addr78, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @__UNIQUE_ID_author926, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @__UNIQUE_ID_description927, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license928, i32 0, i32 0)], section "llvm.metadata"

@__mod_pci_device_table = alias %struct.pci_device_id, getelementptr inbounds ([2 x %struct.pci_device_id], [2 x %struct.pci_device_id]* @sis5595_pci_ids, i32 0, i32 0)
@init_module = alias i32 (), i32 ()* @sm_sis5595_init
@cleanup_module = alias void (), void ()* @sm_sis5595_exit

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_os_allocate(i64 %size) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  call void @kmalloc(i64 %size, i32 %cond)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_os_acquire_object(%struct.kmem_cache* %cache) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %call = call i64 @arch_local_save_flags()
  %4 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %6 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %call9 = call i32 @arch_irqs_disabled_flags(i64 %call)
  %tobool = icmp ne i32 %call9, 0
  %8 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32, i32 208
  call void @kmem_cache_zalloc(%struct.kmem_cache* %cache, i32 %cond)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @acpi_os_get_thread_id() #0 {
entry:
  %call = call %struct.task_struct* @get_current()
  %0 = ptrtoint %struct.task_struct* %call to i64
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sm_sis5595_init() #1 section ".init.text" {
entry:
  %call = call i32 @__pci_register_driver(%struct.pci_driver* @sis5595_pci_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0))
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @sm_sis5595_exit() #1 section ".exit.text" {
entry:
  call void @pci_unregister_driver(%struct.pci_driver* @sis5595_pci_driver)
  %0 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  %cmp = icmp ne %struct.pci_dev* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  call void @platform_device_unregister(%struct.platform_device* %1)
  call void @platform_driver_unregister(%struct.platform_driver* @sis5595_driver)
  %2 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  call void @pci_dev_put(%struct.pci_dev* %2)
  store %struct.pci_dev* null, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @kmalloc(i64 %size, i32 %flags) #2 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @arch_local_save_flags() #0 {
entry:
  %0 = load i8*, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), align 8, !tbaa !13
  %cmp = icmp eq i8* %0, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %do.body2, label %do.end7

do.body2:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str, i32 0, i32 0), i32 824, i64 12) #7, !srcloc !16
  br label %do.body3

do.body3:                                         ; preds = %do.body3, %do.body2
  br label %do.body3

do.end7:                                          ; preds = %entry
  %1 = call i64 asm sideeffect "771:\0A\09call *${2:c};\0A772:\0A.pushsection .parainstructions,\22a\22\0A .balign 8 \0A .quad  771b\0A  .byte ${1:c}\0A  .byte 772b-771b\0A  .short ${3:c}\0A.popsection\0A", "={ax},i,i,i,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i64 44, i8** getelementptr inbounds (%struct.pv_irq_ops, %struct.pv_irq_ops* @pv_irq_ops, i32 0, i32 0, i32 0), i32 1) #7, !srcloc !17
  ret i64 %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @arch_irqs_disabled_flags(i64 %flags) #0 {
entry:
  %and = and i64 %flags, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

declare i8* @__kmalloc(i64, i32) #4

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #5

; Function Attrs: inlinehint nounwind uwtable
define internal void @kmem_cache_zalloc(%struct.kmem_cache* %k, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmem_cache_alloc(%struct.kmem_cache* %k, i32 %or)
  ret void
}

declare i8* @kmem_cache_alloc(%struct.kmem_cache*, i32) #4

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #2 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #5, !srcloc !18
  ret %struct.task_struct* %0
}

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) #4

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_pci_probe(%struct.pci_dev* %dev, %struct.pci_device_id* %id) #6 {
entry:
  %address = alloca i16, align 2
  br label %for.end

for.end:                                          ; preds = %entry
  %0 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, -8
  %conv3 = trunc i32 %and to i16
  store i16 %conv3, i16* @force_addr, align 2, !tbaa !19
  %1 = load i16, i16* @force_addr, align 2, !tbaa !19
  %tobool4 = icmp ne i16 %1, 0
  br i1 %tobool4, label %if.then5, label %if.end10

if.then5:                                         ; preds = %for.end
  %dev6 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %2 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv7 = zext i16 %2 to i32
  %call8 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev6, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.4, i32 0, i32 0), i32 %conv7)
  %3 = load i16, i16* @force_addr, align 2, !tbaa !19
  call void @pci_write_config_word(%struct.pci_dev* %dev, i32 104, i16 zeroext %3)
  br label %if.end10

if.end10:                                         ; preds = %if.then5, %for.end
  call void @pci_read_config_word(%struct.pci_dev* %dev, i32 104, i16* %address)
  br label %if.end17

if.end17:                                         ; preds = %if.end10
  %4 = load i16, i16* %address, align 2, !tbaa !19
  %conv18 = zext i16 %4 to i32
  %and19 = and i32 %conv18, -8
  %conv20 = trunc i32 %and19 to i16
  store i16 %conv20, i16* %address, align 2, !tbaa !19
  br label %if.end25

if.end25:                                         ; preds = %if.end17
  %5 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv26 = zext i16 %5 to i32
  %tobool27 = icmp ne i32 %conv26, 0
  br i1 %tobool27, label %land.lhs.true, label %cleanup85

land.lhs.true:                                    ; preds = %if.end25
  %6 = load i16, i16* %address, align 2, !tbaa !19
  %conv28 = zext i16 %6 to i32
  %7 = load i16, i16* @force_addr, align 2, !tbaa !19
  %conv29 = zext i16 %7 to i32
  %cmp30 = icmp ne i32 %conv28, %conv29
  br i1 %cmp30, label %if.then32, label %cleanup85

if.then32:                                        ; preds = %land.lhs.true
  %dev33 = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 34
  %call34 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev33, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.7, i32 0, i32 0))
  br label %cleanup85

cleanup85:                                        ; preds = %land.lhs.true, %if.end25, %if.then32
  ret i32 0
}

declare %struct.pci_dev* @pci_get_device(i32, i32, %struct.pci_dev*) #4

declare i32 @dev_err(%struct.device*, i8*, ...) #4

declare void @pci_dev_put(%struct.pci_dev*) #4

declare i32 @dev_warn(%struct.device*, i8*, ...) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_write_config_word(%struct.pci_dev* %dev, i32 %where, i16 zeroext %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !21
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !47
  %call = call i32 @pci_bus_write_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16 zeroext %val)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_read_config_word(%struct.pci_dev* %dev, i32 %where, i16* %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !21
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !47
  %call = call i32 @pci_bus_read_config_word(%struct.pci_bus* %0, i32 %1, i32 %where, i16* %val)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_read_config_byte(%struct.pci_dev* %dev, i32 %where, i8* %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !21
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !47
  %call = call i32 @pci_bus_read_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8* %val)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @pci_write_config_byte(%struct.pci_dev* %dev, i32 %where, i8 zeroext %val) #0 {
entry:
  %bus = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 1
  %0 = load %struct.pci_bus*, %struct.pci_bus** %bus, align 8, !tbaa !21
  %devfn = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %dev, i32 0, i32 6
  %1 = load i32, i32* %devfn, align 8, !tbaa !47
  %call = call i32 @pci_bus_write_config_byte(%struct.pci_bus* %0, i32 %1, i32 %where, i8 zeroext %val)
  ret void
}

declare i32 @platform_driver_register(%struct.platform_driver*) #4

declare i32 @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #4

declare %struct.pci_dev* @pci_dev_get(%struct.pci_dev*) #4

; Function Attrs: nounwind uwtable
define internal void @sis5595_device_add(i16 zeroext %address) #6 {
entry:
  %res = alloca %struct.resource, align 8
  %0 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* %0) #7
  %start = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 0
  %conv = zext i16 %address to i64
  store i64 %conv, i64* %start, align 8, !tbaa !48
  %end = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 1
  %conv1 = zext i16 %address to i32
  %add = add nsw i32 %conv1, 8
  %sub = sub nsw i32 %add, 1
  %conv2 = sext i32 %sub to i64
  store i64 %conv2, i64* %end, align 8, !tbaa !50
  %name = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 2
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i8** %name, align 8, !tbaa !51
  %flags = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 3
  store i64 256, i64* %flags, align 8, !tbaa !52
  %parent = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 4
  store %struct.resource* null, %struct.resource** %parent, align 8, !tbaa !53
  %sibling = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 5
  store %struct.resource* null, %struct.resource** %sibling, align 8, !tbaa !54
  %child = getelementptr inbounds %struct.resource, %struct.resource* %res, i32 0, i32 6
  store %struct.resource* null, %struct.resource** %child, align 8, !tbaa !55
  %call = call i32 @acpi_check_resource_conflict(%struct.resource* %res)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %conv3 = zext i16 %address to i32
  %call4 = call %struct.platform_device* @platform_device_alloc(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i32 %conv3)
  store %struct.platform_device* %call4, %struct.platform_device** @pdev, align 8, !tbaa !12
  %1 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  %tobool5 = icmp ne %struct.platform_device* %1, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.53, i32 0, i32 0))
  br label %cleanup

if.end8:                                          ; preds = %if.end
  %2 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  %call9 = call i32 @platform_device_add_resources(%struct.platform_device* %2, %struct.resource* %res, i32 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %call12 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.54, i32 0, i32 0), i32 %call9)
  br label %exit_device_put

if.end13:                                         ; preds = %if.end8
  %3 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  %call14 = call i32 @platform_device_add(%struct.platform_device* %3)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %cleanup

if.then16:                                        ; preds = %if.end13
  %call17 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.55, i32 0, i32 0), i32 %call14)
  br label %exit_device_put

exit_device_put:                                  ; preds = %if.then16, %if.then11
  %err.0 = phi i32 [ %call9, %if.then11 ], [ %call14, %if.then16 ]
  %4 = load %struct.platform_device*, %struct.platform_device** @pdev, align 8, !tbaa !12
  call void @platform_device_put(%struct.platform_device* %4)
  br label %cleanup

cleanup:                                          ; preds = %exit_device_put, %if.end13, %if.then6, %entry
  %retval.0 = phi i32 [ 0, %if.end13 ], [ %err.0, %exit_device_put ], [ -12, %if.then6 ], [ %call, %entry ]
  %5 = bitcast %struct.resource* %res to i8*
  call void @llvm.lifetime.end.p0i8(i64 56, i8* %5) #7
  ret void
}

declare void @platform_driver_unregister(%struct.platform_driver*) #4

declare i32 @pci_bus_write_config_word(%struct.pci_bus*, i32, i32, i16 zeroext) #4

declare i32 @pci_bus_read_config_word(%struct.pci_bus*, i32, i32, i16*) #4

declare i32 @pci_bus_read_config_byte(%struct.pci_bus*, i32, i32, i8*) #4

declare i32 @pci_bus_write_config_byte(%struct.pci_bus*, i32, i32, i8 zeroext) #4

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_probe(%struct.platform_device* %pdev) #6 {
entry:
  %val = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %val) #7
  %call = call %struct.resource* @platform_get_resource(%struct.platform_device* %pdev, i32 256, i32 0)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %start = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %0 = load i64, i64* %start, align 8, !tbaa !48
  %1 = load i8*, i8** getelementptr inbounds (%struct.platform_driver, %struct.platform_driver* @sis5595_driver, i32 0, i32 5, i32 0), align 8, !tbaa !56
  %call1 = call %struct.resource* @__devm_request_region(%struct.device* %dev, %struct.resource* @ioport_resource, i64 %0, i64 8, i8* %1)
  %tobool = icmp ne %struct.resource* %call1, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev2 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call3 = call i8* @devm_kzalloc(%struct.device* %dev2, i64 408, i32 208)
  %2 = bitcast i8* %call3 to %struct.sis5595_data*
  %tobool4 = icmp ne %struct.sis5595_data* %2, null
  br i1 %tobool4, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 3
  call void @__mutex_init(%struct.mutex* %lock, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.12, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key)
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 4
  call void @__mutex_init(%struct.mutex* %update_lock, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.14, i32 0, i32 0), %struct.lock_class_key* @sis5595_probe.__key.13)
  %start10 = getelementptr inbounds %struct.resource, %struct.resource* %call, i32 0, i32 0
  %3 = load i64, i64* %start10, align 8, !tbaa !48
  %conv = trunc i64 %3 to i16
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 0
  store i16 %conv, i16* %addr, align 8, !tbaa !59
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 1
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0), i8** %name, align 8, !tbaa !61
  %4 = bitcast %struct.sis5595_data* %2 to i8*
  call void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %4)
  %5 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  %revision = getelementptr inbounds %struct.pci_dev, %struct.pci_dev* %5, i32 0, i32 12
  %6 = load i8, i8* %revision, align 8, !tbaa !62
  %revision11 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  store i8 %6, i8* %revision11, align 1, !tbaa !63
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 3, i8* %maxins, align 8, !tbaa !64
  %revision12 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 8
  %7 = load i8, i8* %revision12, align 1, !tbaa !63
  %conv13 = zext i8 %7 to i32
  %cmp = icmp sge i32 %conv13, 176
  br i1 %cmp, label %if.then15, label %if.end22

if.then15:                                        ; preds = %do.body
  %8 = load %struct.pci_dev*, %struct.pci_dev** @s_bridge, align 8, !tbaa !12
  call void @pci_read_config_byte(%struct.pci_dev* %8, i32 122, i8* %val)
  %9 = load i8, i8* %val, align 1, !tbaa !65
  %conv17 = sext i8 %9 to i32
  %and = and i32 %conv17, 128
  %tobool18 = icmp ne i32 %and, 0
  br i1 %tobool18, label %if.end22, label %if.then19

if.then19:                                        ; preds = %if.then15
  %maxins20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  store i8 4, i8* %maxins20, align 8, !tbaa !64
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.then15, %do.body
  call void @sis5595_init_device(%struct.sis5595_data* %2)
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end22
  %i.0 = phi i32 [ 0, %if.end22 ], [ %inc, %for.body ]
  %cmp23 = icmp slt i32 %i.0, 2
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 59, %i.0
  %conv25 = trunc i32 %add to i8
  %call26 = call i32 @sis5595_read_value(%struct.sis5595_data* %2, i8 zeroext %conv25)
  %conv27 = trunc i32 %call26 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 13
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  store i8 %conv27, i8* %arrayidx, align 1, !tbaa !65
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev28 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev28, i32 0, i32 2
  %call29 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %cleanup, label %if.end32

if.end32:                                         ; preds = %for.end
  %maxins33 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 7
  %10 = load i8, i8* %maxins33, align 8, !tbaa !64
  %conv34 = sext i8 %10 to i32
  %cmp35 = icmp eq i32 %conv34, 4
  %dev38 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj39 = getelementptr inbounds %struct.device, %struct.device* %dev38, i32 0, i32 2
  br i1 %cmp35, label %if.then37, label %if.else

if.then37:                                        ; preds = %if.end32
  %call40 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_in4)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %exit_remove_files, label %if.end50

if.else:                                          ; preds = %if.end32
  %call46 = call i32 @sysfs_create_group(%struct.kobject* %kobj39, %struct.attribute_group* @sis5595_group_temp1)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %exit_remove_files, label %if.end50

if.end50:                                         ; preds = %if.else, %if.then37
  %dev51 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call52 = call %struct.device* @hwmon_device_register(%struct.device* %dev51)
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  store %struct.device* %call52, %struct.device** %hwmon_dev, align 8, !tbaa !66
  %hwmon_dev53 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %11 = load %struct.device*, %struct.device** %hwmon_dev53, align 8, !tbaa !66
  %12 = bitcast %struct.device* %11 to i8*
  %call54 = call i64 @IS_ERR(i8* %12)
  %tobool55 = icmp ne i64 %call54, 0
  br i1 %tobool55, label %if.then56, label %cleanup

if.then56:                                        ; preds = %if.end50
  %hwmon_dev57 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %2, i32 0, i32 2
  %13 = load %struct.device*, %struct.device** %hwmon_dev57, align 8, !tbaa !66
  %14 = bitcast %struct.device* %13 to i8*
  %call58 = call i64 @PTR_ERR(i8* %14)
  %conv59 = trunc i64 %call58 to i32
  br label %exit_remove_files

exit_remove_files:                                ; preds = %if.then56, %if.else, %if.then37
  %err.0 = phi i32 [ %conv59, %if.then56 ], [ %call40, %if.then37 ], [ %call46, %if.else ]
  %dev61 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj62 = getelementptr inbounds %struct.device, %struct.device* %dev61, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj62, %struct.attribute_group* @sis5595_group)
  %dev63 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj64 = getelementptr inbounds %struct.device, %struct.device* %dev63, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj64, %struct.attribute_group* @sis5595_group_in4)
  %dev65 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj66 = getelementptr inbounds %struct.device, %struct.device* %dev65, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj66, %struct.attribute_group* @sis5595_group_temp1)
  br label %cleanup

cleanup:                                          ; preds = %exit_remove_files, %if.end50, %for.end, %if.end, %entry
  %retval.0 = phi i32 [ %err.0, %exit_remove_files ], [ -16, %entry ], [ -12, %if.end ], [ %call29, %for.end ], [ 0, %if.end50 ]
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %val) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_remove(%struct.platform_device* %pdev) #6 {
entry:
  %call = call i8* @platform_get_drvdata(%struct.platform_device* %pdev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %hwmon_dev = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 2
  %1 = load %struct.device*, %struct.device** %hwmon_dev, align 8, !tbaa !66
  call void @hwmon_device_unregister(%struct.device* %1)
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @sis5595_group)
  %dev1 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj2 = getelementptr inbounds %struct.device, %struct.device* %dev1, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj2, %struct.attribute_group* @sis5595_group_in4)
  %dev3 = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %kobj4 = getelementptr inbounds %struct.device, %struct.device* %dev3, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj4, %struct.attribute_group* @sis5595_group_temp1)
  ret i32 0
}

declare %struct.resource* @platform_get_resource(%struct.platform_device*, i32, i32) #4

declare %struct.resource* @__devm_request_region(%struct.device*, %struct.resource*, i64, i64, i8*) #4

declare i8* @devm_kzalloc(%struct.device*, i64, i32) #4

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @platform_set_drvdata(%struct.platform_device* %pdev, i8* %data) #0 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i32 @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sis5595_init_device(%struct.sis5595_data* %data) #6 {
entry:
  %call = call i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext 64)
  %conv = trunc i32 %call to i8
  %conv1 = zext i8 %conv to i32
  %and = and i32 %conv1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %conv to i32
  %and3 = and i32 %conv2, 247
  %or = or i32 %and3, 1
  %conv4 = trunc i32 %or to i8
  call void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext 64, i8 zeroext %conv4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sis5595_read_value(%struct.sis5595_data* %data, i8 zeroext %reg) #6 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock_nested(%struct.mutex* %lock, i32 0)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !59
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !59
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  %call = call zeroext i8 @inb_p(i32 %add3)
  %conv4 = zext i8 %call to i32
  %lock5 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock5)
  ret i32 %conv4
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #4

declare %struct.device* @hwmon_device_register(%struct.device*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #4

declare i32 @dev_set_drvdata(%struct.device*, i8*) #4

; Function Attrs: nounwind uwtable
define internal void @sis5595_write_value(%struct.sis5595_data* %data, i8 zeroext %reg, i8 zeroext %value) #6 {
entry:
  %lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_lock_nested(%struct.mutex* %lock, i32 0)
  %addr = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %0 = load i16, i16* %addr, align 8, !tbaa !59
  %conv = zext i16 %0 to i32
  %add = add nsw i32 %conv, 5
  call void @outb_p(i8 zeroext %reg, i32 %add)
  %addr1 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 0
  %1 = load i16, i16* %addr1, align 8, !tbaa !59
  %conv2 = zext i16 %1 to i32
  %add3 = add nsw i32 %conv2, 6
  call void @outb_p(i8 zeroext %value, i32 %add3)
  %lock4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %data, i32 0, i32 3
  call void @mutex_unlock(%struct.mutex* %lock4)
  ret void
}

declare void @mutex_lock_nested(%struct.mutex*, i32) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb_p(i8 zeroext %value, i32 %port) #0 {
entry:
  call void @outb(i8 zeroext %value, i32 %port)
  call void @slow_down_io()
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #0 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #7, !srcloc !67
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @slow_down_io() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.pv_cpu_ops, %struct.pv_cpu_ops* @pv_cpu_ops, i32 0, i32 26), align 8, !tbaa !68
  call void %0()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb_p(i32 %port) #0 {
entry:
  %call = call zeroext i8 @inb(i32 %port)
  call void @slow_down_io()
  ret i8 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @inb(i32 %port) #0 {
entry:
  %0 = call i8 asm sideeffect "inb ${1:w}, ${0:b}", "={ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i32 %port) #7, !srcloc !70
  ret i8 %0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_in(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !71
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 9
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev) #6 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy1 = alloca i64, align 8
  %__dummy22 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %5 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %6 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %cmp3 = icmp eq i64* %__dummy1, %__dummy22
  %conv4 = zext i1 %cmp3 to i32
  %7 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %8 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #7
  %last_updated = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  %9 = load i64, i64* %last_updated, align 8, !tbaa !76
  %add = add i64 %9, 250
  %add8 = add i64 %add, 125
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !77
  %sub = sub nsw i64 %add8, %10
  %cmp9 = icmp slt i64 %sub, 0
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %valid = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  %11 = load i8, i8* %valid, align 8, !tbaa !78
  %tobool11 = icmp ne i8 %11, 0
  br i1 %tobool11, label %if.end90, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then
  %i.0 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]
  %maxins = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %12 = load i8, i8* %maxins, align 8, !tbaa !64
  %conv12 = sext i8 %12 to i32
  %cmp13 = icmp sle i32 %i.0, %conv12
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add15 = add nsw i32 32, %i.0
  %conv16 = trunc i32 %add15 to i8
  %call17 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv16)
  %conv18 = trunc i32 %call17 to i8
  %in = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 9
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in, i64 0, i64 %idxprom
  store i8 %conv18, i8* %arrayidx, align 1, !tbaa !65
  %mul = mul nsw i32 %i.0, 2
  %add19 = add nsw i32 44, %mul
  %conv20 = trunc i32 %add19 to i8
  %call21 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv20)
  %conv22 = trunc i32 %call21 to i8
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom23 = sext i32 %i.0 to i64
  %arrayidx24 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom23
  store i8 %conv22, i8* %arrayidx24, align 1, !tbaa !65
  %mul25 = mul nsw i32 %i.0, 2
  %add26 = add nsw i32 43, %mul25
  %conv27 = trunc i32 %add26 to i8
  %call28 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv27)
  %conv29 = trunc i32 %call28 to i8
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom30 = sext i32 %i.0 to i64
  %arrayidx31 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom30
  store i8 %conv29, i8* %arrayidx31, align 1, !tbaa !65
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond32

for.cond32:                                       ; preds = %for.body35, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc49, %for.body35 ]
  %cmp33 = icmp slt i32 %i.1, 2
  br i1 %cmp33, label %for.body35, label %for.end50

for.body35:                                       ; preds = %for.cond32
  %add36 = add nsw i32 40, %i.1
  %conv37 = trunc i32 %add36 to i8
  %call38 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv37)
  %conv39 = trunc i32 %call38 to i8
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 12
  %idxprom40 = sext i32 %i.1 to i64
  %arrayidx41 = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom40
  store i8 %conv39, i8* %arrayidx41, align 1, !tbaa !65
  %add42 = add nsw i32 59, %i.1
  %conv43 = trunc i32 %add42 to i8
  %call44 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv43)
  %conv45 = trunc i32 %call44 to i8
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom46 = sext i32 %i.1 to i64
  %arrayidx47 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom46
  store i8 %conv45, i8* %arrayidx47, align 1, !tbaa !65
  %inc49 = add nsw i32 %i.1, 1
  br label %for.cond32

for.end50:                                        ; preds = %for.cond32
  %maxins51 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 7
  %13 = load i8, i8* %maxins51, align 8, !tbaa !64
  %conv52 = sext i8 %13 to i32
  %cmp53 = icmp eq i32 %conv52, 3
  br i1 %cmp53, label %if.then55, label %if.end

if.then55:                                        ; preds = %for.end50
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %14 = load i8, i8* %revision, align 1, !tbaa !63
  %conv56 = zext i8 %14 to i32
  %cmp57 = icmp sge i32 %conv56, 176
  %15 = zext i1 %cmp57 to i64
  %cond = select i1 %cmp57, i32 36, i32 39
  %conv59 = trunc i32 %cond to i8
  %call60 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv59)
  %conv61 = trunc i32 %call60 to i8
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 14
  store i8 %conv61, i8* %temp, align 1, !tbaa !79
  %revision62 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %16 = load i8, i8* %revision62, align 1, !tbaa !63
  %conv63 = zext i8 %16 to i32
  %cmp64 = icmp sge i32 %conv63, 176
  %17 = zext i1 %cmp64 to i64
  %cond66 = select i1 %cmp64, i32 51, i32 57
  %conv67 = trunc i32 %cond66 to i8
  %call68 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv67)
  %conv69 = trunc i32 %call68 to i8
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %conv69, i8* %temp_over, align 2, !tbaa !80
  %revision70 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %18 = load i8, i8* %revision70, align 1, !tbaa !63
  %conv71 = zext i8 %18 to i32
  %cmp72 = icmp sge i32 %conv71, 176
  %19 = zext i1 %cmp72 to i64
  %cond74 = select i1 %cmp72, i32 52, i32 58
  %conv75 = trunc i32 %cond74 to i8
  %call76 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext %conv75)
  %conv77 = trunc i32 %call76 to i8
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %conv77, i8* %temp_hyst, align 1, !tbaa !81
  br label %if.end

if.end:                                           ; preds = %if.then55, %for.end50
  %call78 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %shr = ashr i32 %call78, 4
  %and = and i32 %shr, 3
  %conv79 = trunc i32 %and to i8
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx80 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 0
  store i8 %conv79, i8* %arrayidx80, align 8, !tbaa !65
  %shr81 = ashr i32 %call78, 6
  %conv82 = trunc i32 %shr81 to i8
  %fan_div83 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %arrayidx84 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div83, i64 0, i64 1
  store i8 %conv82, i8* %arrayidx84, align 1, !tbaa !65
  %call85 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 65)
  %call86 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 66)
  %shl = shl i32 %call86, 8
  %or = or i32 %call85, %shl
  %conv87 = trunc i32 %or to i16
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 18
  store i16 %conv87, i16* %alarms, align 2, !tbaa !82
  %20 = load volatile i64, i64* @jiffies, align 8, !tbaa !77
  %last_updated88 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 6
  store i64 %20, i64* %last_updated88, align 8, !tbaa !76
  %valid89 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 5
  store i8 1, i8* %valid89, align 8, !tbaa !78
  br label %if.end90

if.end90:                                         ; preds = %if.end, %lor.lhs.false
  %update_lock91 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock91)
  ret %struct.sis5595_data* %0
}

declare i32 @sprintf(i8*, i8*, ...) #4

declare i8* @dev_get_drvdata(%struct.device*) #4

; Function Attrs: nounwind uwtable
define internal i64 @show_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !71
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 11
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #6 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !71
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %5 = load i64, i64* %val, align 8, !tbaa !77
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_min, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !65
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 44, %mul
  %conv3 = trunc i32 %add to i8
  %in_min4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 11
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_min4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !65
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @IN_TO_REG(i64 %val) #0 {
entry:
  %cmp = icmp ult i64 %val, 0
  %.val = select i1 %cmp, i64 0, i64 %val
  %cmp1 = icmp ugt i64 %.val, 4080
  %cond5 = select i1 %cmp1, i64 4080, i64 %.val
  %add = add i64 %cond5, 8
  %div = udiv i64 %add, 16
  %conv = trunc i64 %div to i8
  ret i8 %conv
}

declare i32 @kstrtoull(i8*, i32, i64*) #4

; Function Attrs: nounwind uwtable
define internal i64 @show_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !71
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %conv, 16
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %mul)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_in_max(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #6 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !71
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %5 = load i64, i64* %val, align 8, !tbaa !77
  %call2 = call zeroext i8 @IN_TO_REG(i64 %5)
  %in_max = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %in_max, i64 0, i64 %idxprom
  store i8 %call2, i8* %arrayidx, align 1, !tbaa !65
  %mul = mul nsw i32 %3, 2
  %add = add nsw i32 43, %mul
  %conv3 = trunc i32 %add to i8
  %in_max4 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 10
  %idxprom5 = sext i32 %3 to i64
  %arrayidx6 = getelementptr inbounds [5 x i8], [5 x i8]* %in_max4, i64 0, i64 %idxprom5
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !65
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv3, i8 zeroext %6)
  %update_lock7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock7)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarm(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !71
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %3 = load i16, i16* %alarms, align 2, !tbaa !82
  %conv = zext i16 %3 to i32
  %shr = ashr i32 %conv, %2
  %and = and i32 %shr, 1
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0), i32 %and)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !71
  %fan = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !65
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @FAN_FROM_REG(i8 zeroext %val, i32 %div) #0 {
entry:
  %conv = zext i8 %val to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.end9, label %cond.false

cond.false:                                       ; preds = %entry
  %conv2 = zext i8 %val to i32
  %cmp3 = icmp eq i32 %conv2, 255
  br i1 %cmp3, label %cond.end9, label %cond.false6

cond.false6:                                      ; preds = %cond.false
  %conv7 = zext i8 %val to i32
  %mul = mul nsw i32 %conv7, %div
  %div8 = sdiv i32 1350000, %mul
  br label %cond.end9

cond.end9:                                        ; preds = %cond.false6, %cond.false, %entry
  %cond10 = phi i32 [ -1, %entry ], [ %div8, %cond.false6 ], [ 0, %cond.false ]
  ret i32 %cond10
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !71
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom1 = sext i32 %2 to i64
  %arrayidx2 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom1
  %4 = load i8, i8* %arrayidx2, align 1, !tbaa !65
  %conv = zext i8 %4 to i32
  %shl = shl i32 1, %conv
  %call3 = call i32 @FAN_FROM_REG(i8 zeroext %3, i32 %shl)
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %call3)
  %conv5 = sext i32 %call4 to i64
  ret i64 %conv5
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_min(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #6 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !71
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %5 = load i64, i64* %val, align 8, !tbaa !77
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %conv2 = zext i8 %6 to i32
  %shl = shl i32 1, %conv2
  %call3 = call zeroext i8 @FAN_TO_REG(i64 %5, i32 %shl)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom4 = sext i32 %3 to i64
  %arrayidx5 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom4
  store i8 %call3, i8* %arrayidx5, align 1, !tbaa !65
  %add = add nsw i32 59, %3
  %conv6 = trunc i32 %add to i8
  %fan_min7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom8 = sext i32 %3 to i64
  %arrayidx9 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min7, i64 0, i64 %idxprom8
  %7 = load i8, i8* %arrayidx9, align 1, !tbaa !65
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %7)
  %update_lock10 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #7
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i8 @FAN_TO_REG(i64 %rpm, i32 %div) #0 {
entry:
  %cmp = icmp sle i64 %rpm, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %conv = sext i32 %div to i64
  %mul = mul nsw i64 %rpm, %conv
  %div1 = sdiv i64 %mul, 2
  %add = add nsw i64 1350000, %div1
  %conv2 = sext i32 %div to i64
  %mul3 = mul nsw i64 %rpm, %conv2
  %div4 = sdiv i64 %add, %mul3
  %cmp5 = icmp slt i64 %div4, 1
  %.div4 = select i1 %cmp5, i64 1, i64 %div4
  %cmp7 = icmp sgt i64 %.div4, 254
  %cond12 = select i1 %cmp7, i64 254, i64 %.div4
  %conv13 = trunc i64 %cond12 to i8
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i8 [ %conv13, %if.end ], [ -1, %entry ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %0 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !71
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %conv = zext i8 %3 to i32
  %shl = shl i32 1, %conv
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %shl)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @set_fan_div(%struct.device* %dev, %struct.device_attribute* %da, i8* %buf, i64 %count) #6 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast %struct.device_attribute* %da to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %2, i32 0, i32 1
  %3 = load i32, i32* %index, align 8, !tbaa !71
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %fan_min = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min, i64 0, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !65
  %fan_div = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom2 = sext i32 %3 to i64
  %arrayidx3 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div, i64 0, i64 %idxprom2
  %6 = load i8, i8* %arrayidx3, align 1, !tbaa !65
  %conv4 = zext i8 %6 to i32
  %shl = shl i32 1, %conv4
  %call5 = call i32 @FAN_FROM_REG(i8 zeroext %5, i32 %shl)
  %conv6 = sext i32 %call5 to i64
  %call7 = call i32 @sis5595_read_value(%struct.sis5595_data* %0, i8 zeroext 71)
  %7 = load i64, i64* %val, align 8, !tbaa !77
  %Pivot10 = icmp slt i64 %7, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %if.end
  %Pivot8 = icmp slt i64 %7, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i64 %7, 8
  br i1 %SwitchLeaf6, label %sw.epilog, label %sw.default

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i64 %7, 4
  br i1 %SwitchLeaf4, label %sw.epilog, label %sw.default

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i64 %7, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i64 %7, 2
  br i1 %SwitchLeaf2, label %sw.epilog, label %sw.default

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i64 %7, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %sw.default

sw.default:                                       ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %8 = load i64, i64* %val, align 8, !tbaa !77
  %call23 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.36, i32 0, i32 0), i64 %8)
  %update_lock24 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock24)
  br label %cleanup

sw.epilog:                                        ; preds = %LeafBlock, %LeafBlock1, %LeafBlock3, %LeafBlock5
  %.sink = phi i8 [ 1, %LeafBlock1 ], [ 2, %LeafBlock3 ], [ 3, %LeafBlock5 ], [ 0, %LeafBlock ]
  %fan_div20 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom21 = sext i32 %3 to i64
  %arrayidx22 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div20, i64 0, i64 %idxprom21
  store i8 %.sink, i8* %arrayidx22, align 1, !tbaa !65
  %Pivot17 = icmp slt i32 %3, 1
  br i1 %Pivot17, label %LeafBlock12, label %LeafBlock14

LeafBlock14:                                      ; preds = %sw.epilog
  %SwitchLeaf15 = icmp eq i32 %3, 1
  br i1 %SwitchLeaf15, label %sw.bb31, label %sw.epilog39

LeafBlock12:                                      ; preds = %sw.epilog
  %SwitchLeaf13 = icmp eq i32 %3, 0
  br i1 %SwitchLeaf13, label %sw.bb25, label %sw.epilog39

sw.bb25:                                          ; preds = %LeafBlock12
  %and = and i32 %call7, 207
  %fan_div26 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom27 = sext i32 %3 to i64
  %arrayidx28 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div26, i64 0, i64 %idxprom27
  %9 = load i8, i8* %arrayidx28, align 1, !tbaa !65
  %conv29 = zext i8 %9 to i32
  %shl30 = shl i32 %conv29, 4
  %or = or i32 %and, %shl30
  br label %sw.epilog39

sw.bb31:                                          ; preds = %LeafBlock14
  %and32 = and i32 %call7, 63
  %fan_div33 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom34 = sext i32 %3 to i64
  %arrayidx35 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div33, i64 0, i64 %idxprom34
  %10 = load i8, i8* %arrayidx35, align 1, !tbaa !65
  %conv36 = zext i8 %10 to i32
  %shl37 = shl i32 %conv36, 6
  %or38 = or i32 %and32, %shl37
  br label %sw.epilog39

sw.epilog39:                                      ; preds = %sw.bb31, %sw.bb25, %LeafBlock12, %LeafBlock14
  %reg.0 = phi i32 [ %or, %sw.bb25 ], [ %or38, %sw.bb31 ], [ %call7, %LeafBlock14 ], [ %call7, %LeafBlock12 ]
  %conv40 = trunc i32 %reg.0 to i8
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext 71, i8 zeroext %conv40)
  %fan_div41 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 17
  %idxprom42 = sext i32 %3 to i64
  %arrayidx43 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_div41, i64 0, i64 %idxprom42
  %11 = load i8, i8* %arrayidx43, align 1, !tbaa !65
  %conv44 = zext i8 %11 to i32
  %shl45 = shl i32 1, %conv44
  %call46 = call zeroext i8 @FAN_TO_REG(i64 %conv6, i32 %shl45)
  %fan_min47 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom48 = sext i32 %3 to i64
  %arrayidx49 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min47, i64 0, i64 %idxprom48
  store i8 %call46, i8* %arrayidx49, align 1, !tbaa !65
  %add = add nsw i32 59, %3
  %conv50 = trunc i32 %add to i8
  %fan_min51 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 13
  %idxprom52 = sext i32 %3 to i64
  %arrayidx53 = getelementptr inbounds [2 x i8], [2 x i8]* %fan_min51, i64 0, i64 %idxprom52
  %12 = load i8, i8* %arrayidx53, align 1, !tbaa !65
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv50, i8 zeroext %12)
  %update_lock54 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock54)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog39, %sw.default, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %sw.epilog39 ], [ -22, %sw.default ]
  %13 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #7
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarms(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %alarms = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 18
  %0 = load i16, i16* %alarms, align 2, !tbaa !82
  %conv = zext i16 %0 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_name(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #6 {
entry:
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %name = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 1
  %1 = load i8*, i8** %name, align 8, !tbaa !61
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.44, i32 0, i32 0), i8* %1)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 14
  %0 = load i8, i8* %temp, align 1, !tbaa !79
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @TEMP_FROM_REG(i8 signext %val) #0 {
entry:
  %conv = sext i8 %val to i32
  %mul = mul nsw i32 %conv, 830
  %add = add nsw i32 %mul, 52120
  ret i32 %add
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_over(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 15
  %0 = load i8, i8* %temp_over, align 2, !tbaa !80
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_temp_over(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #6 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %2 = load i64, i64* %val, align 8, !tbaa !77
  %conv2 = trunc i64 %2 to i32
  %call3 = call signext i8 @TEMP_TO_REG(i32 %conv2)
  %temp_over = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  store i8 %call3, i8* %temp_over, align 2, !tbaa !80
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !63
  %conv4 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv4, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 51, i32 57
  %conv6 = trunc i32 %cond to i8
  %temp_over7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 15
  %5 = load i8, i8* %temp_over7, align 2, !tbaa !80
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %5)
  %update_lock8 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock8)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtol(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoll(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal signext i8 @TEMP_TO_REG(i32 %val) #0 {
entry:
  %cmp = icmp slt i32 %val, -54120
  %.val = select i1 %cmp, i32 -54120, i32 %val
  %cmp1 = icmp sgt i32 %.val, 157530
  %cond5 = select i1 %cmp1, i32 157530, i32 %.val
  %cmp6 = icmp slt i32 %cond5, 0
  %sub = sub nsw i32 %cond5, 5212
  %add = add nsw i32 %sub, 415
  %sub8 = sub nsw i32 %sub, 415
  %add.sink = select i1 %cmp6, i32 %sub8, i32 %add
  %div11 = sdiv i32 %add.sink, 830
  %conv = trunc i32 %div11 to i8
  ret i8 %conv
}

declare i32 @kstrtoll(i8*, i32, i64*) #4

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #6 {
entry:
  %call = call %struct.sis5595_data* @sis5595_update_device(%struct.device* %dev)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %call, i32 0, i32 16
  %0 = load i8, i8* %temp_hyst, align 1, !tbaa !81
  %call1 = call i32 @TEMP_FROM_REG(i8 signext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @set_temp_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #6 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.sis5595_data*
  %1 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %call1 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_lock_nested(%struct.mutex* %update_lock, i32 0)
  %2 = load i64, i64* %val, align 8, !tbaa !77
  %conv2 = trunc i64 %2 to i32
  %call3 = call signext i8 @TEMP_TO_REG(i32 %conv2)
  %temp_hyst = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  store i8 %call3, i8* %temp_hyst, align 1, !tbaa !81
  %revision = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 8
  %3 = load i8, i8* %revision, align 1, !tbaa !63
  %conv4 = zext i8 %3 to i32
  %cmp = icmp sge i32 %conv4, 176
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 52, i32 58
  %conv6 = trunc i32 %cond to i8
  %temp_hyst7 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 16
  %5 = load i8, i8* %temp_hyst7, align 1, !tbaa !81
  call void @sis5595_write_value(%struct.sis5595_data* %0, i8 zeroext %conv6, i8 zeroext %5)
  %update_lock8 = getelementptr inbounds %struct.sis5595_data, %struct.sis5595_data* %0, i32 0, i32 4
  call void @mutex_unlock(%struct.mutex* %update_lock8)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @platform_get_drvdata(%struct.platform_device* %pdev) #0 {
entry:
  %dev = getelementptr inbounds %struct.platform_device, %struct.platform_device* %pdev, i32 0, i32 3
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare void @hwmon_device_unregister(%struct.device*) #4

declare i32 @acpi_check_resource_conflict(%struct.resource*) #4

declare %struct.platform_device* @platform_device_alloc(i8*, i32) #4

declare i32 @printk(i8*, ...) #4

declare i32 @platform_device_add_resources(%struct.platform_device*, %struct.resource*, i32) #4

declare i32 @platform_device_add(%struct.platform_device*) #4

declare void @platform_device_put(%struct.platform_device*) #4

declare void @pci_unregister_driver(%struct.pci_driver*) #4

declare void @platform_device_unregister(%struct.platform_device*) #4

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }
attributes #6 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!4, !4, i64 0}
!13 = !{!14, !4, i64 0}
!14 = !{!"pv_irq_ops", !15, i64 0, !15, i64 8, !15, i64 16, !15, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!15 = !{!"paravirt_callee_save", !4, i64 0}
!16 = !{i32 -2146268287, i32 -2146268262, i32 -2146267992, i32 -2146268195, i32 -2146268164, i32 -2146268134}
!17 = !{i32 -2146268707, i32 -2146266729, i32 -2146266707, i32 -2146266694, i32 -2146266371, i32 -2146266304, i32 -2146266602, i32 -2146266575, i32 -2146266547, i32 -2146266517}
!18 = !{i32 -2146737350}
!19 = !{!20, !20, i64 0}
!20 = !{!"short", !5, i64 0}
!21 = !{!22, !4, i64 16}
!22 = !{!"pci_dev", !23, i64 0, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !24, i64 56, !20, i64 60, !20, i64 62, !20, i64 64, !20, i64 66, !24, i64 68, !5, i64 72, !5, i64 73, !5, i64 74, !5, i64 75, !5, i64 76, !5, i64 77, !5, i64 78, !5, i64 79, !20, i64 80, !4, i64 88, !25, i64 96, !26, i64 104, !24, i64 120, !5, i64 124, !24, i64 125, !24, i64 125, !24, i64 125, !24, i64 125, !24, i64 126, !24, i64 126, !24, i64 126, !24, i64 126, !24, i64 126, !24, i64 126, !24, i64 126, !24, i64 128, !24, i64 132, !4, i64 136, !24, i64 144, !28, i64 152, !24, i64 1288, !24, i64 1292, !5, i64 1296, !37, i64 2248, !24, i64 2249, !24, i64 2249, !24, i64 2249, !24, i64 2249, !24, i64 2249, !24, i64 2249, !24, i64 2249, !24, i64 2249, !24, i64 2250, !24, i64 2250, !24, i64 2250, !24, i64 2250, !24, i64 2250, !24, i64 2250, !24, i64 2250, !24, i64 2251, !24, i64 2251, !24, i64 2251, !24, i64 2251, !24, i64 2251, !24, i64 2251, !24, i64 2251, !24, i64 2251, !20, i64 2252, !31, i64 2256, !5, i64 2260, !46, i64 2328, !4, i64 2336, !24, i64 2344, !5, i64 2352, !5, i64 2488, !23, i64 2624, !4, i64 2640, !4, i64 2648, !5, i64 2656, !4, i64 2664, !25, i64 2672, !27, i64 2680}
!23 = !{!"list_head", !4, i64 0, !4, i64 8}
!24 = !{!"int", !5, i64 0}
!25 = !{!"long long", !5, i64 0}
!26 = !{!"device_dma_parameters", !24, i64 0, !27, i64 8}
!27 = !{!"long", !5, i64 0}
!28 = !{!"device", !4, i64 0, !4, i64 8, !29, i64 16, !4, i64 80, !4, i64 88, !32, i64 96, !4, i64 264, !4, i64 272, !4, i64 280, !35, i64 288, !4, i64 880, !24, i64 888, !4, i64 896, !25, i64 904, !4, i64 912, !23, i64 920, !4, i64 936, !43, i64 944, !4, i64 960, !44, i64 968, !24, i64 976, !24, i64 980, !33, i64 984, !23, i64 1056, !45, i64 1072, !4, i64 1104, !4, i64 1112, !4, i64 1120, !4, i64 1128}
!29 = !{!"kobject", !4, i64 0, !23, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !30, i64 56, !24, i64 60, !24, i64 60, !24, i64 60, !24, i64 60, !24, i64 60}
!30 = !{!"kref", !31, i64 0}
!31 = !{!"", !24, i64 0}
!32 = !{!"mutex", !31, i64 0, !33, i64 8, !23, i64 80, !4, i64 96, !4, i64 104, !4, i64 112, !34, i64 120}
!33 = !{!"spinlock", !5, i64 0}
!34 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !24, i64 32, !27, i64 40}
!35 = !{!"dev_pm_info", !36, i64 0, !24, i64 4, !24, i64 4, !37, i64 4, !37, i64 4, !37, i64 4, !37, i64 4, !33, i64 8, !23, i64 80, !38, i64 96, !4, i64 192, !37, i64 200, !37, i64 200, !40, i64 208, !27, i64 336, !41, i64 344, !39, i64 424, !31, i64 512, !31, i64 516, !24, i64 520, !24, i64 520, !24, i64 520, !24, i64 520, !24, i64 520, !24, i64 520, !24, i64 521, !24, i64 521, !24, i64 521, !24, i64 521, !24, i64 521, !5, i64 524, !5, i64 528, !24, i64 532, !24, i64 536, !27, i64 544, !27, i64 552, !27, i64 560, !27, i64 568, !4, i64 576, !4, i64 584}
!36 = !{!"pm_message", !24, i64 0}
!37 = !{!"_Bool", !5, i64 0}
!38 = !{!"completion", !24, i64 0, !39, i64 8}
!39 = !{!"__wait_queue_head", !33, i64 0, !23, i64 72}
!40 = !{!"timer_list", !23, i64 0, !27, i64 16, !4, i64 24, !4, i64 32, !27, i64 40, !24, i64 48, !24, i64 52, !4, i64 56, !5, i64 64, !34, i64 80}
!41 = !{!"work_struct", !42, i64 0, !23, i64 8, !4, i64 24, !34, i64 32}
!42 = !{!"", !27, i64 0}
!43 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!44 = !{!"acpi_dev_node", !4, i64 0}
!45 = !{!"klist_node", !4, i64 0, !23, i64 8, !30, i64 24}
!46 = !{!"hlist_head", !4, i64 0}
!47 = !{!22, !24, i64 56}
!48 = !{!49, !25, i64 0}
!49 = !{!"resource", !25, i64 0, !25, i64 8, !4, i64 16, !27, i64 24, !4, i64 32, !4, i64 40, !4, i64 48}
!50 = !{!49, !25, i64 8}
!51 = !{!49, !4, i64 16}
!52 = !{!49, !27, i64 24}
!53 = !{!49, !4, i64 32}
!54 = !{!49, !4, i64 40}
!55 = !{!49, !4, i64 48}
!56 = !{!57, !4, i64 40}
!57 = !{!"platform_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !58, i64 40, !4, i64 160}
!58 = !{!"device_driver", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !37, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112}
!59 = !{!60, !20, i64 0}
!60 = !{!"sis5595_data", !20, i64 0, !4, i64 8, !4, i64 16, !32, i64 24, !32, i64 192, !5, i64 360, !27, i64 368, !5, i64 376, !5, i64 377, !5, i64 378, !5, i64 383, !5, i64 388, !5, i64 393, !5, i64 395, !5, i64 397, !5, i64 398, !5, i64 399, !5, i64 400, !20, i64 402}
!61 = !{!60, !4, i64 8}
!62 = !{!22, !5, i64 72}
!63 = !{!60, !5, i64 377}
!64 = !{!60, !5, i64 376}
!65 = !{!5, !5, i64 0}
!66 = !{!60, !4, i64 16}
!67 = !{i32 -2145550954}
!68 = !{!69, !4, i64 208}
!69 = !{!"pv_cpu_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176, !4, i64 184, !4, i64 192, !4, i64 200, !4, i64 208, !4, i64 216, !4, i64 224, !4, i64 232, !4, i64 240, !4, i64 248, !4, i64 256, !4, i64 264, !4, i64 272, !4, i64 280, !4, i64 288, !4, i64 296, !4, i64 304, !4, i64 312}
!70 = !{i32 -2145550752}
!71 = !{!72, !24, i64 48}
!72 = !{!"sensor_device_attribute", !73, i64 0, !24, i64 48}
!73 = !{!"device_attribute", !74, i64 0, !4, i64 32, !4, i64 40}
!74 = !{!"attribute", !4, i64 0, !20, i64 8, !37, i64 10, !4, i64 16, !75, i64 24}
!75 = !{!"lock_class_key", !5, i64 0}
!76 = !{!60, !27, i64 368}
!77 = !{!27, !27, i64 0}
!78 = !{!60, !5, i64 360}
!79 = !{!60, !5, i64 397}
!80 = !{!60, !5, i64 398}
!81 = !{!60, !5, i64 399}
!82 = !{!60, !20, i64 402}
