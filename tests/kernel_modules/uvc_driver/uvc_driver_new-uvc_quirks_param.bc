; ModuleID = 'drivers/media/usb/uvc/uvc_driver.bc'
source_filename = "drivers/media/usb/uvc/uvc_driver.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.46 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.44, %struct.list_head, %struct.list_head, %union.anon.45 }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.42 }
%union.anon.42 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, [56 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.4, i32 }
%union.anon.4 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.5, %union.anon.28, %union.anon.29, %union.anon.33, %union.anon.36, [8 x i8] }
%union.anon.5 = type { %struct.address_space* }
%union.anon.28 = type { i64 }
%union.anon.29 = type { i64 }
%union.anon.33 = type { %struct.list_head }
%union.anon.36 = type { i64 }
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.6, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.6 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.7 }
%union.anon.7 = type { %struct.anon.8 }
%struct.anon.8 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.11 }
%union.anon.11 = type { %struct.anon.15, [80 x i8] }
%struct.anon.15 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type { %struct.vm_struct*, i8*, i64, i64, %struct.page**, i32, i64, i8* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.21 }
%union.anon.21 = type { %struct.anon.22 }
%struct.anon.22 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.24, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.27 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i64, i64 }
%union.anon.27 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, [32 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%union.anon.44 = type { %struct.list_head }
%union.anon.45 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.37, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.38, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.41, i32, i32, %struct.hlist_head, i8* }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.37 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.38 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.41 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.39 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.39 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type opaque
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%union.anon.46 = type { i8* }
%struct.usb_device_id = type { i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8, i64 }
%struct.uvc_driver = type { %struct.usb_driver }
%struct.usb_driver = type { i8*, i32 (%struct.usb_interface*, %struct.usb_device_id*)*, void (%struct.usb_interface*)*, i32 (%struct.usb_interface*, i32, i8*)*, i32 (%struct.usb_interface*, i32)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, i32 (%struct.usb_interface*)*, %struct.usb_device_id*, %struct.usb_dynids, %struct.usbdrv_wrap, i8 }
%struct.usb_interface = type { %struct.usb_host_interface*, %struct.usb_host_interface*, i32, %struct.usb_interface_assoc_descriptor*, i32, i32, i8, %struct.device, %struct.device*, %struct.atomic_t, %struct.work_struct }
%struct.usb_host_interface = type { %struct.usb_interface_descriptor, i32, i8*, %struct.usb_host_endpoint*, i8* }
%struct.usb_interface_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.usb_host_endpoint = type <{ %struct.usb_endpoint_descriptor, %struct.usb_ss_ep_comp_descriptor, %struct.usb_ssp_isoc_ep_comp_descriptor, i8, %struct.list_head, i8*, %struct.ep_device*, i8*, i32, i32, i32, [4 x i8] }>
%struct.usb_endpoint_descriptor = type <{ i8, i8, i8, i8, i16, i8, i8, i8 }>
%struct.usb_ss_ep_comp_descriptor = type { i8, i8, i8, i8, i16 }
%struct.usb_ssp_isoc_ep_comp_descriptor = type { i8, i8, i16, i32 }
%struct.ep_device = type opaque
%struct.usb_interface_assoc_descriptor = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type opaque
%struct.fwnode_handle = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.usb_dynids = type { %struct.spinlock, %struct.list_head }
%struct.usbdrv_wrap = type { %struct.device_driver, i32 }
%struct.module_version_attribute = type { %struct.module_attribute, i8*, i8* }
%struct.uvc_format_desc = type { i8*, [16 x i8], i32 }
%struct.v4l2_file_operations = type { %struct.module*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.file*)*, i32 (%struct.file*)* }
%struct.v4l2_ioctl_ops = type opaque
%struct.uvc_entity = type { %struct.list_head, %struct.list_head, i32, i8, i16, [64 x i8], %struct.video_device*, %struct.v4l2_subdev, i32, i32, %struct.media_pad*, %union.anon.57, i8, i8*, i32, %struct.uvc_control* }
%struct.video_device = type { %struct.v4l2_file_operations*, i32, %struct.device, %struct.cdev*, %struct.v4l2_device*, %struct.device*, %struct.v4l2_ctrl_handler*, %struct.vb2_queue*, %struct.v4l2_prio_state*, [32 x i8], i32, i32, i32, i16, i64, i32, %struct.spinlock, %struct.list_head, i32, i64, void (%struct.video_device*)*, %struct.v4l2_ioctl_ops*, [3 x i64], [3 x i64], %struct.mutex* }
%struct.cdev = type { %struct.kobject, %struct.module*, %struct.file_operations*, %struct.list_head, i32, i32 }
%struct.v4l2_device = type { %struct.device*, %struct.list_head, %struct.spinlock, [36 x i8], void (%struct.v4l2_subdev*, i32, i8*)*, %struct.v4l2_ctrl_handler*, %struct.v4l2_prio_state, %struct.kref, void (%struct.v4l2_device*)* }
%struct.v4l2_prio_state = type { [4 x %struct.atomic_t] }
%struct.v4l2_ctrl_handler = type opaque
%struct.vb2_queue = type { i32, i32, %struct.device*, i64, i8, %struct.mutex*, i8*, %struct.vb2_ops*, %struct.vb2_mem_ops*, %struct.vb2_buf_ops*, i8*, i32, i32, i32, i32, %struct.mutex, i32, [32 x %struct.vb2_buffer*], i32, %struct.list_head, i32, %struct.atomic_t, %struct.list_head, %struct.spinlock, %struct.__wait_queue_head, [8 x %struct.device*], i8, %struct.vb2_fileio_data*, %struct.vb2_threadio_data* }
%struct.vb2_ops = type { i32 (%struct.vb2_queue*, i32*, i32*, i32*, %struct.device**)*, void (%struct.vb2_queue*)*, void (%struct.vb2_queue*)*, i32 (%struct.vb2_buffer*)*, i32 (%struct.vb2_buffer*)*, void (%struct.vb2_buffer*)*, void (%struct.vb2_buffer*)*, i32 (%struct.vb2_queue*, i32)*, void (%struct.vb2_queue*)*, void (%struct.vb2_buffer*)* }
%struct.vb2_buffer = type { %struct.vb2_queue*, i32, i32, i32, i32, [8 x %struct.vb2_plane], i64, i32, %struct.list_head, %struct.list_head }
%struct.vb2_plane = type { i8*, %struct.dma_buf*, i32, i32, i32, i32, %union.anon.55, i32 }
%struct.dma_buf = type { i64, %struct.file*, %struct.list_head, %struct.dma_buf_ops*, %struct.mutex, i32, i8*, i8*, %struct.module*, %struct.list_head, i8*, %struct.reservation_object*, %struct.__wait_queue_head, %struct.dma_buf_poll_cb_t, %struct.dma_buf_poll_cb_t }
%struct.dma_buf_ops = type { i32 (%struct.dma_buf*, %struct.device*, %struct.dma_buf_attachment*)*, void (%struct.dma_buf*, %struct.dma_buf_attachment*)*, %struct.sg_table* (%struct.dma_buf_attachment*, i32)*, void (%struct.dma_buf_attachment*, %struct.sg_table*, i32)*, void (%struct.dma_buf*)*, i32 (%struct.dma_buf*, i32)*, i32 (%struct.dma_buf*, i32)*, i8* (%struct.dma_buf*, i64)*, void (%struct.dma_buf*, i64, i8*)*, i8* (%struct.dma_buf*, i64)*, void (%struct.dma_buf*, i64, i8*)*, i32 (%struct.dma_buf*, %struct.vm_area_struct*)*, i8* (%struct.dma_buf*)*, void (%struct.dma_buf*, i8*)* }
%struct.dma_buf_attachment = type { %struct.dma_buf*, %struct.device*, %struct.list_head, i8* }
%struct.reservation_object = type opaque
%struct.dma_buf_poll_cb_t = type { %struct.dma_fence_cb, %struct.__wait_queue_head*, i64 }
%struct.dma_fence_cb = type { %struct.list_head, void (%struct.dma_fence*, %struct.dma_fence_cb*)* }
%struct.dma_fence = type { %struct.kref, %struct.dma_fence_ops*, %struct.callback_head, %struct.list_head, %struct.spinlock*, i64, i32, i64, i64, i32 }
%struct.dma_fence_ops = type { i8* (%struct.dma_fence*)*, i8* (%struct.dma_fence*)*, i1 (%struct.dma_fence*)*, i1 (%struct.dma_fence*)*, i64 (%struct.dma_fence*, i1, i64)*, void (%struct.dma_fence*)*, i32 (%struct.dma_fence*, i8*, i32)*, void (%struct.dma_fence*, i8*, i32)*, void (%struct.dma_fence*, i8*, i32)* }
%union.anon.55 = type { i64 }
%struct.vb2_mem_ops = type { i8* (%struct.device*, i64, i64, i32, i32)*, void (i8*)*, %struct.dma_buf* (i8*, i64)*, i8* (%struct.device*, i64, i64, i32)*, void (i8*)*, void (i8*)*, void (i8*)*, i8* (%struct.device*, %struct.dma_buf*, i64, i32)*, void (i8*)*, i32 (i8*)*, void (i8*)*, i8* (i8*)*, i8* (i8*)*, i32 (i8*)*, i32 (i8*, %struct.vm_area_struct*)* }
%struct.vb2_buf_ops = type { i32 (%struct.vb2_buffer*, i8*)*, void (%struct.vb2_buffer*, i8*)*, i32 (%struct.vb2_buffer*, i8*, %struct.vb2_plane*)*, void (%struct.vb2_buffer*, i8*)* }
%struct.vb2_fileio_data = type opaque
%struct.vb2_threadio_data = type opaque
%struct.v4l2_subdev = type { %struct.list_head, %struct.module*, i8, i32, %struct.v4l2_device*, %struct.v4l2_subdev_ops*, %struct.v4l2_subdev_internal_ops*, %struct.v4l2_ctrl_handler*, [32 x i8], i32, i8*, i8*, %struct.video_device*, %struct.device*, %struct.device_node*, %struct.list_head, %struct.v4l2_async_subdev*, %struct.v4l2_async_notifier*, %struct.v4l2_subdev_platform_data* }
%struct.v4l2_subdev_ops = type { %struct.v4l2_subdev_core_ops*, %struct.v4l2_subdev_tuner_ops*, %struct.v4l2_subdev_audio_ops*, %struct.v4l2_subdev_video_ops*, %struct.v4l2_subdev_vbi_ops*, %struct.v4l2_subdev_ir_ops*, %struct.v4l2_subdev_sensor_ops*, %struct.v4l2_subdev_pad_ops* }
%struct.v4l2_subdev_core_ops = type { i32 (%struct.v4l2_subdev*)*, i32 (%struct.v4l2_subdev*, i64, %struct.v4l2_subdev_io_pin_config*)*, i32 (%struct.v4l2_subdev*, i32)*, i32 (%struct.v4l2_subdev*)*, i32 (%struct.v4l2_subdev*, i32)*, i32 (%struct.v4l2_subdev*, i32)*, i64 (%struct.v4l2_subdev*, i32, i8*)*, i64 (%struct.v4l2_subdev*, i32, i64)*, i32 (%struct.v4l2_subdev*, i32)*, i32 (%struct.v4l2_subdev*, i32, i8*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_fh*, %struct.v4l2_event_subscription*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_fh*, %struct.v4l2_event_subscription*)* }
%struct.v4l2_subdev_io_pin_config = type { i32, i8, i8, i8, i8 }
%struct.v4l2_fh = type { %struct.list_head, %struct.video_device*, %struct.v4l2_ctrl_handler*, i32, %struct.__wait_queue_head, %struct.list_head, %struct.list_head, i32, i32 }
%struct.v4l2_event_subscription = type { i32, i32, i32, [5 x i32] }
%struct.v4l2_subdev_tuner_ops = type { i32 (%struct.v4l2_subdev*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_frequency*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_frequency*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_frequency_band*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_tuner*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_tuner*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_modulator*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_modulator*)*, i32 (%struct.v4l2_subdev*, %struct.tuner_setup*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_priv_tun_config*)* }
%struct.v4l2_frequency = type { i32, i32, i32, [8 x i32] }
%struct.v4l2_frequency_band = type { i32, i32, i32, i32, i32, i32, i32, [9 x i32] }
%struct.v4l2_tuner = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, [4 x i32] }
%struct.v4l2_modulator = type { i32, [32 x i8], i32, i32, i32, i32, i32, [3 x i32] }
%struct.tuner_setup = type opaque
%struct.v4l2_priv_tun_config = type { i32, i8* }
%struct.v4l2_subdev_audio_ops = type { i32 (%struct.v4l2_subdev*, i32)*, i32 (%struct.v4l2_subdev*, i32)*, i32 (%struct.v4l2_subdev*, i32, i32, i32)*, i32 (%struct.v4l2_subdev*, i32)* }
%struct.v4l2_subdev_video_ops = type { i32 (%struct.v4l2_subdev*, i32, i32, i32)*, i32 (%struct.v4l2_subdev*, i32, i32)*, i32 (%struct.v4l2_subdev*, i64*)*, i32 (%struct.v4l2_subdev*, i64)*, i32 (%struct.v4l2_subdev*, i64)*, i32 (%struct.v4l2_subdev*, i64*)*, i32 (%struct.v4l2_subdev*, i64*)*, i32 (%struct.v4l2_subdev*, i64*)*, i32 (%struct.v4l2_subdev*, i64*)*, i32 (%struct.v4l2_subdev*, i32*)*, i32 (%struct.v4l2_subdev*, i32)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_fract*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_streamparm*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_streamparm*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_frame_interval*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_frame_interval*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_dv_timings*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_dv_timings*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_dv_timings*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_mbus_config*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_mbus_config*)*, i32 (%struct.v4l2_subdev*, i8*, i32*)* }
%struct.v4l2_fract = type { i32, i32 }
%struct.v4l2_streamparm = type { i32, %union.anon.47 }
%union.anon.47 = type { %struct.v4l2_captureparm, [160 x i8] }
%struct.v4l2_captureparm = type { i32, i32, %struct.v4l2_fract, i32, i32, [4 x i32] }
%struct.v4l2_subdev_frame_interval = type { i32, %struct.v4l2_fract, [9 x i32] }
%struct.v4l2_dv_timings = type { i32, %union.anon.48 }
%union.anon.48 = type { [32 x i32] }
%struct.v4l2_mbus_config = type { i32, i32 }
%struct.v4l2_subdev_vbi_ops = type { i32 (%struct.v4l2_subdev*, %struct.v4l2_decode_vbi_line*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_sliced_vbi_data*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_sliced_vbi_data*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_sliced_vbi_cap*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_vbi_format*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_sliced_vbi_format*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_sliced_vbi_format*)* }
%struct.v4l2_decode_vbi_line = type { i32, i8*, i32, i32 }
%struct.v4l2_sliced_vbi_data = type { i32, i32, i32, i32, [48 x i8] }
%struct.v4l2_sliced_vbi_cap = type { i16, [2 x [24 x i16]], i32, [3 x i32] }
%struct.v4l2_vbi_format = type { i32, i32, i32, i32, [2 x i32], [2 x i32], i32, [2 x i32] }
%struct.v4l2_sliced_vbi_format = type { i16, [2 x [24 x i16]], i32, [2 x i32] }
%struct.v4l2_subdev_ir_ops = type { i32 (%struct.v4l2_subdev*, i8*, i64, i64*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_ir_parameters*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_ir_parameters*)*, i32 (%struct.v4l2_subdev*, i8*, i64, i64*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_ir_parameters*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_ir_parameters*)* }
%struct.v4l2_subdev_ir_parameters = type { i32, i32, i8, i8, i8, i8, i32, i32, i32, i8, i8, i32, i32, i32, i32 }
%struct.v4l2_subdev_sensor_ops = type { i32 (%struct.v4l2_subdev*, i32*)*, i32 (%struct.v4l2_subdev*, i32*)* }
%struct.v4l2_subdev_pad_ops = type { i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*, %struct.v4l2_subdev_mbus_code_enum*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*, %struct.v4l2_subdev_frame_size_enum*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*, %struct.v4l2_subdev_frame_interval_enum*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*, %struct.v4l2_subdev_format*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*, %struct.v4l2_subdev_format*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*, %struct.v4l2_subdev_selection*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_pad_config*, %struct.v4l2_subdev_selection*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_edid*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_edid*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_dv_timings_cap*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_enum_dv_timings*)*, i32 (%struct.v4l2_subdev*, i32, %struct.v4l2_mbus_frame_desc*)*, i32 (%struct.v4l2_subdev*, i32, %struct.v4l2_mbus_frame_desc*)* }
%struct.v4l2_subdev_pad_config = type { %struct.v4l2_mbus_framefmt, %struct.v4l2_rect, %struct.v4l2_rect }
%struct.v4l2_mbus_framefmt = type { i32, i32, i32, i32, i32, i16, i16, i16, [11 x i16] }
%struct.v4l2_rect = type { i32, i32, i32, i32 }
%struct.v4l2_subdev_mbus_code_enum = type { i32, i32, i32, i32, [8 x i32] }
%struct.v4l2_subdev_frame_size_enum = type { i32, i32, i32, i32, i32, i32, i32, i32, [8 x i32] }
%struct.v4l2_subdev_frame_interval_enum = type { i32, i32, i32, i32, i32, %struct.v4l2_fract, i32, [8 x i32] }
%struct.v4l2_subdev_format = type { i32, i32, %struct.v4l2_mbus_framefmt, [8 x i32] }
%struct.v4l2_subdev_selection = type { i32, i32, i32, i32, %struct.v4l2_rect, [8 x i32] }
%struct.v4l2_edid = type { i32, i32, i32, [5 x i32], i8* }
%struct.v4l2_dv_timings_cap = type { i32, i32, [2 x i32], %union.anon.49 }
%union.anon.49 = type { %struct.v4l2_bt_timings_cap, [24 x i8] }
%struct.v4l2_bt_timings_cap = type { i32, i32, i32, i32, i64, i64, i32, i32, [16 x i32] }
%struct.v4l2_enum_dv_timings = type { i32, i32, [2 x i32], %struct.v4l2_dv_timings }
%struct.v4l2_mbus_frame_desc = type { [4 x %struct.v4l2_mbus_frame_desc_entry], i16 }
%struct.v4l2_mbus_frame_desc_entry = type { i16, i32, i32 }
%struct.v4l2_subdev_internal_ops = type { i32 (%struct.v4l2_subdev*)*, void (%struct.v4l2_subdev*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_fh*)*, i32 (%struct.v4l2_subdev*, %struct.v4l2_subdev_fh*)* }
%struct.v4l2_subdev_fh = type { %struct.v4l2_fh }
%struct.v4l2_async_subdev = type { i32, %union.anon.50, %struct.list_head }
%union.anon.50 = type { %struct.anon.54 }
%struct.anon.54 = type { i1 (%struct.device*, %struct.v4l2_async_subdev*)*, i8* }
%struct.v4l2_async_notifier = type { i32, %struct.v4l2_async_subdev**, %struct.v4l2_device*, %struct.list_head, %struct.list_head, %struct.list_head, i32 (%struct.v4l2_async_notifier*, %struct.v4l2_subdev*, %struct.v4l2_async_subdev*)*, i32 (%struct.v4l2_async_notifier*)*, void (%struct.v4l2_async_notifier*, %struct.v4l2_subdev*, %struct.v4l2_async_subdev*)* }
%struct.v4l2_subdev_platform_data = type { %struct.regulator_bulk_data*, i32, i8* }
%struct.regulator_bulk_data = type opaque
%struct.media_pad = type { %struct.media_gobj, %struct.media_entity*, i16, i64 }
%struct.media_gobj = type { %struct.media_device*, i32, %struct.list_head }
%struct.media_device = type { %struct.device*, %struct.media_devnode*, [32 x i8], [32 x i8], [40 x i8], [32 x i8], i32, i32, i64, i32, %struct.ida, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.media_graph, i8*, i32 (%struct.media_entity*, %struct.media_pipeline*)*, void (%struct.media_entity*)*, %struct.media_device_ops* }
%struct.media_devnode = type { %struct.media_device*, %struct.media_file_operations*, %struct.device, %struct.cdev, %struct.device*, i32, i64, void (%struct.media_devnode*)* }
%struct.media_file_operations = type { %struct.module*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*)*, i32 (%struct.file*)* }
%struct.ida = type { %struct.radix_tree_root }
%struct.media_graph = type { [16 x %struct.anon.56], %struct.media_entity_enum, i32 }
%struct.anon.56 = type { %struct.media_entity*, %struct.list_head* }
%struct.media_entity_enum = type { i64*, i32 }
%struct.media_pipeline = type { i32, %struct.media_graph }
%struct.media_device_ops = type { i32 (%struct.media_link*, i32, i32)* }
%struct.media_link = type { %struct.media_gobj, %struct.list_head, %union.anon.64, %union.anon.65, %struct.media_link*, i64, i8 }
%union.anon.64 = type { %struct.media_gobj* }
%union.anon.65 = type { %struct.media_gobj* }
%struct.media_entity = type { %struct.media_gobj, i8*, i32, i32, i64, i16, i16, i16, i32, %struct.media_pad*, %struct.list_head, %struct.media_entity_operations*, i32, i32, %struct.media_pipeline*, %union.anon.66 }
%struct.media_entity_operations = type { i32 (%struct.media_entity*, %struct.media_pad*, %struct.media_pad*, i32)*, i32 (%struct.media_link*)* }
%union.anon.66 = type { %struct.anon.67 }
%struct.anon.67 = type { i32, i32 }
%union.anon.57 = type { %struct.anon.63 }
%struct.anon.63 = type { [16 x i8], i8, i8, i8*, i8* }
%struct.uvc_control = type { %struct.uvc_entity*, %struct.uvc_control_info, i8, i8, i8* }
%struct.uvc_control_info = type { %struct.list_head, [16 x i8], i8, i8, i16, i32 }
%struct.uvc_device = type { %struct.usb_device*, %struct.usb_interface*, i64, i32, i32, [32 x i8], %struct.mutex, i32, %struct.atomic_t, %struct.v4l2_device, i16, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.atomic_t, %struct.usb_host_endpoint*, %struct.urb*, i8*, %struct.input_dev*, [64 x i8] }
%struct.usb_device = type { i32, [16 x i8], i32, i32, i32, %struct.usb_tt*, i32, [2 x i32], %struct.usb_device*, %struct.usb_bus*, %struct.usb_host_endpoint, %struct.device, %struct.usb_device_descriptor, %struct.usb_host_bos*, %struct.usb_host_config*, %struct.usb_host_config*, [16 x %struct.usb_host_endpoint*], [16 x %struct.usb_host_endpoint*], i8**, i16, i8, i8, i16, i32, i8*, i8*, i8*, %struct.list_head, i32, i32, %struct.atomic_t, i64, i64, i8, %struct.wusb_dev*, i32, i32, %struct.usb2_lpm_parameters, %struct.usb3_lpm_parameters, %struct.usb3_lpm_parameters, i32 }
%struct.usb_tt = type opaque
%struct.usb_bus = type { %struct.device*, i32, i8*, i8, i8, i8, i8, i32, i32, %struct.mutex, %struct.usb_devmap, %struct.usb_device*, %struct.usb_bus*, i32, i32, i32, i32, %struct.mon_bus*, i32 }
%struct.usb_devmap = type { [2 x i64] }
%struct.mon_bus = type opaque
%struct.usb_device_descriptor = type { i8, i8, i16, i8, i8, i8, i8, i16, i16, i16, i8, i8, i8, i8 }
%struct.usb_host_bos = type { %struct.usb_bos_descriptor*, %struct.usb_ext_cap_descriptor*, %struct.usb_ss_cap_descriptor*, %struct.usb_ssp_cap_descriptor*, %struct.usb_ss_container_id_descriptor*, %struct.usb_ptm_cap_descriptor* }
%struct.usb_bos_descriptor = type <{ i8, i8, i16, i8 }>
%struct.usb_ext_cap_descriptor = type <{ i8, i8, i8, i32 }>
%struct.usb_ss_cap_descriptor = type { i8, i8, i8, i8, i16, i8, i8, i16 }
%struct.usb_ssp_cap_descriptor = type { i8, i8, i8, i8, i32, i16, i16, [1 x i32] }
%struct.usb_ss_container_id_descriptor = type { i8, i8, i8, i8, [16 x i8] }
%struct.usb_ptm_cap_descriptor = type { i8, i8, i8 }
%struct.usb_host_config = type { %struct.usb_config_descriptor, i8*, [16 x %struct.usb_interface_assoc_descriptor*], [32 x %struct.usb_interface*], [32 x %struct.usb_interface_cache*], i8*, i32 }
%struct.usb_config_descriptor = type <{ i8, i8, i16, i8, i8, i8, i8, i8 }>
%struct.usb_interface_cache = type { i32, %struct.kref, [0 x %struct.usb_host_interface] }
%struct.wusb_dev = type opaque
%struct.usb2_lpm_parameters = type { i32, i32 }
%struct.usb3_lpm_parameters = type { i32, i32, i32, i32 }
%struct.urb = type { %struct.kref, i8*, %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.usb_anchor*, %struct.usb_device*, %struct.usb_host_endpoint*, i32, i32, i32, i32, i8*, i64, %struct.scatterlist*, i32, i32, i32, i32, i8*, i64, i32, i32, i32, i32, i8*, void (%struct.urb*)*, [0 x %struct.usb_iso_packet_descriptor] }
%struct.usb_anchor = type { %struct.list_head, %struct.__wait_queue_head, %struct.spinlock, %struct.atomic_t, i8 }
%struct.usb_iso_packet_descriptor = type { i32, i32, i32, i32 }
%struct.input_dev = type opaque
%struct.uvc_streaming = type { %struct.list_head, %struct.uvc_device*, %struct.video_device, %struct.uvc_video_chain*, %struct.atomic_t, %struct.usb_interface*, i32, i16, %struct.uvc_streaming_header, i32, i32, %struct.uvc_format*, %struct.uvc_streaming_control, %struct.uvc_format*, %struct.uvc_format*, %struct.uvc_frame*, %struct.mutex, i8, %struct.uvc_video_queue, void (%struct.urb*, %struct.uvc_streaming*, %struct.uvc_buffer*)*, %struct.anon.71, [5 x %struct.urb*], [5 x i8*], [5 x i64], i32, i32, i8, %struct.dentry*, %struct.anon.72, %struct.uvc_clock }
%struct.uvc_video_chain = type { %struct.uvc_device*, %struct.list_head, %struct.list_head, %struct.uvc_entity*, %struct.uvc_entity*, %struct.mutex, %struct.v4l2_prio_state, i32 }
%struct.uvc_streaming_header = type { i8, i8, i8, i8, i8*, i8, i8, i8, i8 }
%struct.uvc_streaming_control = type <{ i16, i8, i8, i32, i16, i16, i16, i16, i16, i32, i32, i32, i8, i8, i8, i8 }>
%struct.uvc_format = type { i8, i8, i8, i8, i32, i32, [32 x i8], i32, %struct.uvc_frame* }
%struct.uvc_frame = type { i8, i8, i16, i16, i32, i32, i32, i8, i32, i32* }
%struct.uvc_video_queue = type { %struct.vb2_queue, %struct.mutex, i32, i32, %struct.spinlock, %struct.list_head }
%struct.uvc_buffer = type { %struct.vb2_v4l2_buffer, %struct.list_head, i32, i32, i8*, i32, i32, i32 }
%struct.vb2_v4l2_buffer = type { %struct.vb2_buffer, i32, i32, %struct.v4l2_timecode, i32 }
%struct.v4l2_timecode = type { i32, i32, i8, i8, i8, i8, [4 x i8] }
%struct.anon.71 = type { [256 x i8], i32, i32, i32, i32 }
%struct.anon.72 = type { %struct.uvc_stats_frame, %struct.uvc_stats_stream }
%struct.uvc_stats_frame = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i8, i32, i32, i32, i16, i32 }
%struct.uvc_stats_stream = type { %struct.timespec, %struct.timespec, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.uvc_clock = type { %struct.uvc_clock_sample*, i32, i32, i32, i16, i16, %struct.spinlock }
%struct.uvc_clock_sample = type { i32, i16, %struct.timespec, i16 }
%union.anon.68 = type { %struct.list_head* }
%union.anon.69 = type { i32 }
%struct.anon.58 = type { i16, i16, i16, i8, i8* }
%struct.anon.59 = type { i8, i8*, i8, i8* }
%struct.anon.61 = type { i16, i8, i8*, i8 }
%union.anon.70 = type { %struct.list_head* }
%union.anon.73 = type { %struct.list_head* }

@uvc_clock_param = global i32 1, align 4
@uvc_timeout_param = global i32 5000, align 4
@__param_str_clock = internal constant [17 x i8] c"uvc_driver.clock\00", align 16
@__param_ops_clock = internal constant %struct.kernel_param_ops { i32 0, i32 (i8*, %struct.kernel_param*)* @uvc_clock_param_set, i32 (i8*, %struct.kernel_param*)* @uvc_clock_param_get, void (i8*)* null }, align 8
@__param_clock = internal constant %struct.kernel_param { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__param_str_clock, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @__param_ops_clock, i16 420, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i32* @uvc_clock_param to i8*) } }, section "__param", align 8
@__param_str_hwtimestamps = internal constant [24 x i8] c"uvc_driver.hwtimestamps\00", align 16
@param_ops_uint = external constant %struct.kernel_param_ops, align 8
@uvc_hw_timestamps_param = common global i32 0, align 4
@__param_hwtimestamps = internal constant %struct.kernel_param { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__param_str_hwtimestamps, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i32* @uvc_hw_timestamps_param to i8*) } }, section "__param", align 8
@__param_str_nodrop = internal constant [18 x i8] c"uvc_driver.nodrop\00", align 16
@uvc_no_drop_param = common global i32 0, align 4
@__param_nodrop = internal constant %struct.kernel_param { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__param_str_nodrop, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i32* @uvc_no_drop_param to i8*) } }, section "__param", align 8
@__param_str_quirks = internal constant [18 x i8] c"uvc_driver.quirks\00", align 16
@uvc_quirks_param = internal global i32 -1, align 4
@__param_quirks = internal constant %struct.kernel_param { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__param_str_quirks, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i32* @uvc_quirks_param to i8*) } }, section "__param", align 8
@__param_str_trace = internal constant [17 x i8] c"uvc_driver.trace\00", align 16
@uvc_trace_param = common global i32 0, align 4
@__param_trace = internal constant %struct.kernel_param { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__param_str_trace, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i32* @uvc_trace_param to i8*) } }, section "__param", align 8
@__param_str_timeout = internal constant [19 x i8] c"uvc_driver.timeout\00", align 16
@__param_timeout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_timeout, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_uint, i16 420, i8 -1, i8 0, %union.anon.46 { i8* bitcast (i32* @uvc_timeout_param to i8*) } }, section "__param", align 8
@.str = private unnamed_addr constant [9 x i8] c"uvcvideo\00", align 1
@uvc_ids = internal global [53 x %struct.usb_device_id] [%struct.usb_device_id { i16 899, i16 1046, i16 -22246, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 1112, i16 28782, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 1118, i16 248, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 1118, i16 1825, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 899, i16 1118, i16 1827, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 1133, i16 2241, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 899, i16 1133, i16 2242, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 899, i16 1133, i16 2243, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 899, i16 1133, i16 2245, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 899, i16 1133, i16 2246, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 899, i16 1133, i16 2247, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 899, i16 1133, i16 2093, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 1024 }, %struct.usb_device_id { i16 899, i16 1266, i16 -20367, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 512 }, %struct.usb_device_id { i16 899, i16 1423, i16 14368, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 1449, i16 9792, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 899, i16 1449, i16 9793, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 899, i16 1449, i16 9795, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 899, i16 1449, i16 9802, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 899, i16 1449, i16 30320, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 899, i16 1452, i16 -31487, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 10 }, %struct.usb_device_id { i16 899, i16 1480, i16 1027, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 128 }, %struct.usb_device_id { i16 899, i16 1507, i16 1285, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 1784, i16 12300, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 128 }, %struct.usb_device_id { i16 899, i16 2760, i16 13101, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 128 }, %struct.usb_device_id { i16 899, i16 2760, i16 13328, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 128 }, %struct.usb_device_id { i16 899, i16 2760, i16 13344, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 128 }, %struct.usb_device_id { i16 899, i16 3027, i16 1365, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 3725, i16 4, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 258 }, %struct.usb_device_id { i16 899, i16 5075, i16 20739, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 5421, i16 784, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 5967, i16 21010, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 5967, i16 22833, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 5967, i16 -30190, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 5967, i16 -30159, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 5967, i16 -30157, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 5967, i16 -30156, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 6108, i16 514, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 6127, i16 18443, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 16 }, %struct.usb_device_id { i16 899, i16 6257, i16 774, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 6 }, %struct.usb_device_id { i16 899, i16 6257, i16 1302, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 899, i16 6349, i16 -13570, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 4 }, %struct.usb_device_id { i16 899, i16 6380, i16 12680, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 6380, i16 12936, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 6380, i16 12944, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 256 }, %struct.usb_device_id { i16 899, i16 6558, i16 -32510, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 907, i16 6571, i16 4096, i16 0, i16 294, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 1 }, %struct.usb_device_id { i16 899, i16 6971, i16 10577, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2 }, %struct.usb_device_id { i16 899, i16 7247, i16 12288, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 34 }, %struct.usb_device_id { i16 899, i16 10291, i16 513, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 2048 }, %struct.usb_device_id { i16 899, i16 10291, i16 529, i16 0, i16 0, i8 0, i8 0, i8 0, i8 -1, i8 1, i8 0, i8 0, i64 2048 }, %struct.usb_device_id { i16 896, i16 0, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 0, i8 0, i64 0 }, %struct.usb_device_id { i16 896, i16 0, i16 0, i16 0, i16 0, i8 0, i8 0, i8 0, i8 14, i8 1, i8 1, i8 0, i64 0 }, %struct.usb_device_id zeroinitializer], align 16
@uvc_driver = global %struct.uvc_driver { %struct.usb_driver { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), i32 (%struct.usb_interface*, %struct.usb_device_id*)* @uvc_probe, void (%struct.usb_interface*)* @uvc_disconnect, i32 (%struct.usb_interface*, i32, i8*)* null, i32 (%struct.usb_interface*, i32)* @uvc_suspend, i32 (%struct.usb_interface*)* @uvc_resume, i32 (%struct.usb_interface*)* @uvc_reset_resume, i32 (%struct.usb_interface*)* null, i32 (%struct.usb_interface*)* null, %struct.usb_device_id* getelementptr inbounds ([53 x %struct.usb_device_id], [53 x %struct.usb_device_id]* @uvc_ids, i32 0, i32 0), %struct.usb_dynids zeroinitializer, %struct.usbdrv_wrap zeroinitializer, i8 2 } }, align 8
@__initcall_uvc_init6 = internal global i32 ()* @uvc_init, section ".initcall6.init", align 8
@__exitcall_uvc_cleanup = internal global void ()* @uvc_cleanup, section ".exitcall.exit", align 8
@___modver_attr = internal global %struct.module_version_attribute { %struct.module_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.124, i32 0, i32 0), i16 292 }, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)* @__modver_version_show, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)* null, void (%struct.module*, i8*)* null, i32 (%struct.module*)* null, void (%struct.module*)* null }, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.122, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.125, i32 0, i32 0) }, align 8
@__modver_attr = internal constant %struct.module_version_attribute* @___modver_attr, section "__modver", align 8
@.str.1 = private unnamed_addr constant [7 x i8] c"clock_\00", align 1
@.str.2 = private unnamed_addr constant [10 x i8] c"monotonic\00", align 1
@.str.3 = private unnamed_addr constant [9 x i8] c"realtime\00", align 1
@.str.4 = private unnamed_addr constant [16 x i8] c"CLOCK_MONOTONIC\00", align 1
@.str.5 = private unnamed_addr constant [15 x i8] c"CLOCK_REALTIME\00", align 1
@.str.6 = private unnamed_addr constant [53 x i8] c"\017uvcvideo: Probing known UVC device %s (%04x:%04x)\0A\00", align 1
@.str.7 = private unnamed_addr constant [43 x i8] c"\017uvcvideo: Probing generic UVC device %s\0A\00", align 1
@uvc_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.8 = private unnamed_addr constant [11 x i8] c"&dev->lock\00", align 1
@.str.9 = private unnamed_addr constant [23 x i8] c"UVC Camera (%04x:%04x)\00", align 1
@.str.10 = private unnamed_addr constant [46 x i8] c"\017uvcvideo: Unable to parse UVC descriptors.\0A\00", align 1
@.str.11 = private unnamed_addr constant [53 x i8] c"\016uvcvideo: Found UVC %u.%02x device %s (%04x:%04x)\0A\00", align 1
@.str.12 = private unnamed_addr constant [10 x i8] c"<unnamed>\00", align 1
@.str.13 = private unnamed_addr constant [84 x i8] c"\016uvcvideo: Forcing device quirks to 0x%x by module parameter for testing purpose.\0A\00", align 1
@.str.14 = private unnamed_addr constant [80 x i8] c"\016uvcvideo: Please report required quirks to the linux-uvc-devel mailing list.\0A\00", align 1
@.str.15 = private unnamed_addr constant [100 x i8] c"\016uvcvideo: Unable to initialize the status endpoint (%d), status interrupt will not be supported.\0A\00", align 1
@.str.16 = private unnamed_addr constant [37 x i8] c"\017uvcvideo: UVC device initialized.\0A\00", align 1
@.str.17 = private unnamed_addr constant [50 x i8] c"\017uvcvideo: Found a Status endpoint (addr %02x).\0A\00", align 1
@.str.18 = private unnamed_addr constant [70 x i8] c"\017uvcvideo: device %d videocontrol interface %d EXTENSION_UNIT error\0A\00", align 1
@.str.19 = private unnamed_addr constant [13 x i8] c"Extension %u\00", align 1
@.str.20 = private unnamed_addr constant [62 x i8] c"\017uvcvideo: device %d videocontrol interface %d HEADER error\0A\00", align 1
@.str.21 = private unnamed_addr constant [51 x i8] c"\017uvcvideo: device %d interface %d doesn't exists\0A\00", align 1
@.str.22 = private unnamed_addr constant [70 x i8] c"\017uvcvideo: device %d videocontrol interface %d INPUT_TERMINAL error\0A\00", align 1
@.str.23 = private unnamed_addr constant [101 x i8] c"\017uvcvideo: device %d videocontrol interface %d INPUT_TERMINAL %d has invalid type 0x%04x, skipping\0A\00", align 1
@.str.24 = private unnamed_addr constant [10 x i8] c"Camera %u\00", align 1
@.str.25 = private unnamed_addr constant [9 x i8] c"Media %u\00", align 1
@.str.26 = private unnamed_addr constant [9 x i8] c"Input %u\00", align 1
@.str.27 = private unnamed_addr constant [71 x i8] c"\017uvcvideo: device %d videocontrol interface %d OUTPUT_TERMINAL error\0A\00", align 1
@.str.28 = private unnamed_addr constant [102 x i8] c"\017uvcvideo: device %d videocontrol interface %d OUTPUT_TERMINAL %d has invalid type 0x%04x, skipping\0A\00", align 1
@.str.29 = private unnamed_addr constant [10 x i8] c"Output %u\00", align 1
@.str.30 = private unnamed_addr constant [69 x i8] c"\017uvcvideo: device %d videocontrol interface %d SELECTOR_UNIT error\0A\00", align 1
@.str.31 = private unnamed_addr constant [12 x i8] c"Selector %u\00", align 1
@.str.32 = private unnamed_addr constant [71 x i8] c"\017uvcvideo: device %d videocontrol interface %d PROCESSING_UNIT error\0A\00", align 1
@.str.33 = private unnamed_addr constant [14 x i8] c"Processing %u\00", align 1
@.str.34 = private unnamed_addr constant [59 x i8] c"\017uvcvideo: Found an unknown CS_INTERFACE descriptor (%u)\0A\00", align 1
@.str.35 = private unnamed_addr constant [70 x i8] c"\017uvcvideo: device %d interface %d isn't a video streaming interface\0A\00", align 1
@.str.36 = private unnamed_addr constant [55 x i8] c"\017uvcvideo: device %d interface %d is already claimed\0A\00", align 1
@uvc_parse_streaming.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.37 = private unnamed_addr constant [18 x i8] c"&streaming->mutex\00", align 1
@.str.38 = private unnamed_addr constant [49 x i8] c"\017uvcvideo: trying extra data from endpoint %u.\0A\00", align 1
@.str.39 = private unnamed_addr constant [70 x i8] c"\017uvcvideo: no class-specific streaming interface descriptors found.\0A\00", align 1
@.str.40 = private unnamed_addr constant [80 x i8] c"\017uvcvideo: device %d videostreaming interface %d HEADER descriptor not found.\0A\00", align 1
@.str.41 = private unnamed_addr constant [81 x i8] c"\017uvcvideo: device %d videostreaming interface %d HEADER descriptor is invalid.\0A\00", align 1
@.str.42 = private unnamed_addr constant [79 x i8] c"\017uvcvideo: device %d videostreaming interface %d FORMAT %u is not supported.\0A\00", align 1
@.str.43 = private unnamed_addr constant [85 x i8] c"\017uvcvideo: device %d videostreaming interface %d has no supported formats defined.\0A\00", align 1
@.str.44 = private unnamed_addr constant [96 x i8] c"\017uvcvideo: device %d videostreaming interface %d has %u bytes of trailing descriptor garbage.\0A\00", align 1
@.str.45 = private unnamed_addr constant [64 x i8] c"\017uvcvideo: device %d videostreaming interface %d FORMAT error\0A\00", align 1
@.str.46 = private unnamed_addr constant [39 x i8] c"\016uvcvideo: Unknown video format %pUl\0A\00", align 1
@.str.47 = private unnamed_addr constant [6 x i8] c"%pUl\0A\00", align 1
@.str.48 = private unnamed_addr constant [23 x i8] c"Greyscale 8-bit (Y8  )\00", align 1
@.str.49 = private unnamed_addr constant [6 x i8] c"MJPEG\00", align 1
@.str.50 = private unnamed_addr constant [6 x i8] c"SD-DV\00", align 1
@.str.51 = private unnamed_addr constant [7 x i8] c"SDL-DV\00", align 1
@.str.52 = private unnamed_addr constant [6 x i8] c"HD-DV\00", align 1
@.str.53 = private unnamed_addr constant [73 x i8] c"\017uvcvideo: device %d videostreaming interface %d: unknown DV format %u\0A\00", align 1
@.str.54 = private unnamed_addr constant [6 x i8] c" 60Hz\00", align 1
@.str.55 = private unnamed_addr constant [6 x i8] c" 50Hz\00", align 1
@.str.56 = private unnamed_addr constant [73 x i8] c"\017uvcvideo: device %d videostreaming interface %d unsupported format %u\0A\00", align 1
@.str.57 = private unnamed_addr constant [30 x i8] c"\017uvcvideo: Found format %s.\0A\00", align 1
@.str.58 = private unnamed_addr constant [63 x i8] c"\017uvcvideo: device %d videostreaming interface %d FRAME error\0A\00", align 1
@.str.59 = private unnamed_addr constant [33 x i8] c"\017uvcvideo: - %ux%u (%u.%u fps)\0A\00", align 1
@.str.60 = private unnamed_addr constant [69 x i8] c"\017uvcvideo: device %d videostreaming interface %d COLORFORMAT error\0A\00", align 1
@uvc_fmts = internal global [29 x %struct.uvc_format_desc] [%struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.61, i32 0, i32 0), [16 x i8] c"YUY2\00\00\10\00\80\00\00\AA\008\9Bq", i32 1448695129 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.61, i32 0, i32 0), [16 x i8] c"YUY2\00\00\10\00\80\00\00\00\008\9Bq", i32 1448695129 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.62, i32 0, i32 0), [16 x i8] c"NV12\00\00\10\00\80\00\00\AA\008\9Bq", i32 842094158 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), [16 x i8] c"MJPG\00\00\10\00\80\00\00\AA\008\9Bq", i32 1196444237 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.63, i32 0, i32 0), [16 x i8] c"YV12\00\00\10\00\80\00\00\AA\008\9Bq", i32 842094169 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.64, i32 0, i32 0), [16 x i8] c"I420\00\00\10\00\80\00\00\AA\008\9Bq", i32 842093913 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.65, i32 0, i32 0), [16 x i8] c"M420\00\00\10\00\80\00\00\AA\008\9Bq", i32 808596557 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.66, i32 0, i32 0), [16 x i8] c"UYVY\00\00\10\00\80\00\00\AA\008\9Bq", i32 1498831189 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.67, i32 0, i32 0), [16 x i8] c"Y800\00\00\10\00\80\00\00\AA\008\9Bq", i32 1497715271 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.48, i32 0, i32 0), [16 x i8] c"Y8  \00\00\10\00\80\00\00\AA\008\9Bq", i32 1497715271 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.68, i32 0, i32 0), [16 x i8] c"Y10 \00\00\10\00\80\00\00\AA\008\9Bq", i32 540029273 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.69, i32 0, i32 0), [16 x i8] c"Y12 \00\00\10\00\80\00\00\AA\008\9Bq", i32 540160345 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.70, i32 0, i32 0), [16 x i8] c"Y16 \00\00\10\00\80\00\00\AA\008\9Bq", i32 540422489 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.71, i32 0, i32 0), [16 x i8] c"BY8 \00\00\10\00\80\00\00\AA\008\9Bq", i32 825770306 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.72, i32 0, i32 0), [16 x i8] c"BA81\00\00\10\00\80\00\00\AA\008\9Bq", i32 825770306 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.73, i32 0, i32 0), [16 x i8] c"GBRG\00\00\10\00\80\00\00\AA\008\9Bq", i32 1196573255 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.74, i32 0, i32 0), [16 x i8] c"GRBG\00\00\10\00\80\00\00\AA\008\9Bq", i32 1195528775 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.75, i32 0, i32 0), [16 x i8] c"RGGB\00\00\10\00\80\00\00\AA\008\9Bq", i32 1111967570 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.76, i32 0, i32 0), [16 x i8] c"RGBP\00\00\10\00\80\00\00\AA\008\9Bq", i32 1346520914 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.77, i32 0, i32 0), [16 x i8] c"}\EB6\E4OR\CE\11\9FS\00 \AF\0B\A7p", i32 861030210 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.78, i32 0, i32 0), [16 x i8] c"H264\00\00\10\00\80\00\00\AA\008\9Bq", i32 875967048 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.79, i32 0, i32 0), [16 x i8] c"Y8I \00\00\10\00\80\00\00\AA\008\9Bq", i32 541669465 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.80, i32 0, i32 0), [16 x i8] c"Y12I\00\00\10\00\80\00\00\AA\008\9Bq", i32 1228026201 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.81, i32 0, i32 0), [16 x i8] c"Z16 \00\00\10\00\80\00\00\AA\008\9Bq", i32 540422490 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.82, i32 0, i32 0), [16 x i8] c"RW10\00\00\10\00\80\00\00\AA\008\9Bq", i32 1094799984 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.83, i32 0, i32 0), [16 x i8] c"BG16\00\00\10\00\80\00\00\AA\008\9Bq", i32 844257602 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.84, i32 0, i32 0), [16 x i8] c"GB16\00\00\10\00\80\00\00\AA\008\9Bq", i32 909197895 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.85, i32 0, i32 0), [16 x i8] c"RG16\00\00\10\00\80\00\00\AA\008\9Bq", i32 909199186 }, %struct.uvc_format_desc { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.86, i32 0, i32 0), [16 x i8] c"GR16\00\00\10\00\80\00\00\AA\008\9Bq", i32 909201991 }], align 16
@.str.61 = private unnamed_addr constant [17 x i8] c"YUV 4:2:2 (YUYV)\00", align 1
@.str.62 = private unnamed_addr constant [17 x i8] c"YUV 4:2:0 (NV12)\00", align 1
@.str.63 = private unnamed_addr constant [17 x i8] c"YVU 4:2:0 (YV12)\00", align 1
@.str.64 = private unnamed_addr constant [17 x i8] c"YUV 4:2:0 (I420)\00", align 1
@.str.65 = private unnamed_addr constant [17 x i8] c"YUV 4:2:0 (M420)\00", align 1
@.str.66 = private unnamed_addr constant [17 x i8] c"YUV 4:2:2 (UYVY)\00", align 1
@.str.67 = private unnamed_addr constant [23 x i8] c"Greyscale 8-bit (Y800)\00", align 1
@.str.68 = private unnamed_addr constant [24 x i8] c"Greyscale 10-bit (Y10 )\00", align 1
@.str.69 = private unnamed_addr constant [24 x i8] c"Greyscale 12-bit (Y12 )\00", align 1
@.str.70 = private unnamed_addr constant [24 x i8] c"Greyscale 16-bit (Y16 )\00", align 1
@.str.71 = private unnamed_addr constant [18 x i8] c"BGGR Bayer (BY8 )\00", align 1
@.str.72 = private unnamed_addr constant [18 x i8] c"BGGR Bayer (BA81)\00", align 1
@.str.73 = private unnamed_addr constant [18 x i8] c"GBRG Bayer (GBRG)\00", align 1
@.str.74 = private unnamed_addr constant [18 x i8] c"GRBG Bayer (GRBG)\00", align 1
@.str.75 = private unnamed_addr constant [18 x i8] c"RGGB Bayer (RGGB)\00", align 1
@.str.76 = private unnamed_addr constant [7 x i8] c"RGB565\00", align 1
@.str.77 = private unnamed_addr constant [17 x i8] c"BGR 8:8:8 (BGR3)\00", align 1
@.str.78 = private unnamed_addr constant [6 x i8] c"H.264\00", align 1
@.str.79 = private unnamed_addr constant [22 x i8] c"Greyscale 8 L/R (Y8I)\00", align 1
@.str.80 = private unnamed_addr constant [24 x i8] c"Greyscale 12 L/R (Y12I)\00", align 1
@.str.81 = private unnamed_addr constant [24 x i8] c"Depth data 16-bit (Z16)\00", align 1
@.str.82 = private unnamed_addr constant [24 x i8] c"Bayer 10-bit (SRGGB10P)\00", align 1
@.str.83 = private unnamed_addr constant [23 x i8] c"Bayer 16-bit (SBGGR16)\00", align 1
@.str.84 = private unnamed_addr constant [23 x i8] c"Bayer 16-bit (SGBRG16)\00", align 1
@.str.85 = private unnamed_addr constant [23 x i8] c"Bayer 16-bit (SRGGB16)\00", align 1
@.str.86 = private unnamed_addr constant [23 x i8] c"Bayer 16-bit (SGRBG16)\00", align 1
@uvc_colorspace.colorprimaries = internal constant [6 x i8] c"\00\08\05\06\01\02", align 1
@.str.87 = private unnamed_addr constant [45 x i8] c"\017uvcvideo: Found a valid video chain (%s).\0A\00", align 1
@.str.88 = private unnamed_addr constant [41 x i8] c"\016uvcvideo: No valid video chain found.\0A\00", align 1
@uvc_alloc_chain.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.89 = private unnamed_addr constant [19 x i8] c"&chain->ctrl_mutex\00", align 1
@.str.90 = private unnamed_addr constant [32 x i8] c"\017uvcvideo: Scanning UVC chain:\00", align 1
@.str.91 = private unnamed_addr constant [60 x i8] c"\017uvcvideo: Found reference to entity %d already in chain.\0A\00", align 1
@.str.92 = private unnamed_addr constant [12 x i8] c"\01c <- XU %d\00", align 1
@.str.93 = private unnamed_addr constant [58 x i8] c"\017uvcvideo: Extension unit %d has more than 1 input pin.\0A\00", align 1
@.str.94 = private unnamed_addr constant [12 x i8] c"\01c <- PU %d\00", align 1
@.str.95 = private unnamed_addr constant [55 x i8] c"\017uvcvideo: Found multiple Processing Units in chain.\0A\00", align 1
@.str.96 = private unnamed_addr constant [12 x i8] c"\01c <- SU %d\00", align 1
@.str.97 = private unnamed_addr constant [53 x i8] c"\017uvcvideo: Found multiple Selector Units in chain.\0A\00", align 1
@.str.98 = private unnamed_addr constant [13 x i8] c"\01c <- IT %d\0A\00", align 1
@.str.99 = private unnamed_addr constant [9 x i8] c"\01c OT %d\00", align 1
@.str.100 = private unnamed_addr constant [60 x i8] c"\017uvcvideo: Unsupported entity type 0x%04x found in chain.\0A\00", align 1
@.str.101 = private unnamed_addr constant [7 x i8] c"\01c (->\00", align 1
@.str.102 = private unnamed_addr constant [9 x i8] c"\01c XU %d\00", align 1
@.str.103 = private unnamed_addr constant [44 x i8] c"\017uvcvideo: Unsupported input terminal %u.\0A\00", align 1
@.str.104 = private unnamed_addr constant [4 x i8] c"\01c)\00", align 1
@.str.105 = private unnamed_addr constant [9 x i8] c"\01c <- IT\00", align 1
@.str.106 = private unnamed_addr constant [76 x i8] c"\017uvcvideo: Selector unit %d input %d isn't connected to an input terminal\0A\00", align 1
@.str.107 = private unnamed_addr constant [6 x i8] c"\01c %d\00", align 1
@.str.108 = private unnamed_addr constant [4 x i8] c"\01c\0A\00", align 1
@.str.109 = private unnamed_addr constant [51 x i8] c"\017uvcvideo: Found reference to unknown entity %d.\0A\00", align 1
@uvc_print_chain.buffer = internal global [43 x i8] zeroinitializer, align 16
@.str.110 = private unnamed_addr constant [5 x i8] c" -> \00", align 1
@.str.111 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.112 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.113 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str.114 = private unnamed_addr constant [61 x i8] c"\017uvcvideo: Found a video chain by fallback heuristic (%s).\0A\00", align 1
@.str.115 = private unnamed_addr constant [58 x i8] c"\016uvcvideo: No streaming interface found for terminal %u.\00", align 1
@.str.116 = private unnamed_addr constant [51 x i8] c"\013uvcvideo: Failed to initialize the device (%d).\0A\00", align 1
@uvc_fops = external constant %struct.v4l2_file_operations, align 8
@uvc_ioctl_ops = external constant %struct.v4l2_ioctl_ops, align 1
@.str.117 = private unnamed_addr constant [51 x i8] c"\013uvcvideo: Failed to register video device (%d).\0A\00", align 1
@.str.118 = private unnamed_addr constant [37 x i8] c"\017uvcvideo: Suspending interface %u\0A\00", align 1
@.str.119 = private unnamed_addr constant [62 x i8] c"\017uvcvideo: Suspend: video streaming USB interface mismatch.\0A\00", align 1
@.str.120 = private unnamed_addr constant [35 x i8] c"\017uvcvideo: Resuming interface %u\0A\00", align 1
@.str.121 = private unnamed_addr constant [61 x i8] c"\017uvcvideo: Resume: video streaming USB interface mismatch.\0A\00", align 1
@.str.122 = private unnamed_addr constant [11 x i8] c"uvc_driver\00", align 1
@.str.123 = private unnamed_addr constant [34 x i8] c"\016USB Video Class driver (1.1.1)\0A\00", align 1
@.str.124 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.125 = private unnamed_addr constant [6 x i8] c"1.1.1\00", align 1
@llvm.used = appending global [10 x i8*] [i8* bitcast (%struct.kernel_param* @__param_clock to i8*), i8* bitcast (%struct.kernel_param* @__param_hwtimestamps to i8*), i8* bitcast (%struct.kernel_param* @__param_nodrop to i8*), i8* bitcast (%struct.kernel_param* @__param_quirks to i8*), i8* bitcast (%struct.kernel_param* @__param_trace to i8*), i8* bitcast (%struct.kernel_param* @__param_timeout to i8*), i8* bitcast (void ()* @uvc_cleanup to i8*), i8* bitcast (i32 ()** @__initcall_uvc_init6 to i8*), i8* bitcast (void ()** @__exitcall_uvc_cleanup to i8*), i8* bitcast (%struct.module_version_attribute** @__modver_attr to i8*)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define %struct.usb_host_endpoint* @uvc_find_endpoint(%struct.usb_host_interface* %alts, i8 zeroext %epaddr) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alts, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %0 = load i8, i8* %bNumEndpoints, align 4, !tbaa !2
  %conv = zext i8 %0 to i32
  %cmp = icmp ult i32 %i.0, %conv
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %alts, i32 0, i32 3
  %1 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !9
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %1, i64 %idxprom
  %desc2 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx, i32 0, i32 0
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc2, i32 0, i32 2
  %2 = load i8, i8* %bEndpointAddress, align 2, !tbaa !10
  %conv3 = zext i8 %2 to i32
  %conv4 = zext i8 %epaddr to i32
  %cmp5 = icmp eq i32 %conv3, %conv4
  br i1 %cmp5, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %for.body
  %retval.0 = phi %struct.usb_host_endpoint* [ %arrayidx, %for.body ], [ null, %for.cond ]
  ret %struct.usb_host_endpoint* %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #1

; Function Attrs: nounwind uwtable
define void @uvc_simplify_fraction(i32* %numerator, i32* %denominator, i32 %n_terms, i32 %threshold) #0 {
entry:
  %conv = zext i32 %n_terms to i64
  %mul = mul i64 %conv, 4
  %call = call i8* @kmalloc(i64 %mul, i32 20971712)
  %0 = bitcast i8* %call to i32*
  %cmp = icmp eq i32* %0, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %numerator, align 4, !tbaa !17
  %2 = load i32, i32* %denominator, align 4, !tbaa !17
  br label %for.cond

for.cond:                                         ; preds = %if.end15, %if.end
  %x.0 = phi i32 [ %1, %if.end ], [ %y.0, %if.end15 ]
  %y.0 = phi i32 [ %2, %if.end ], [ %sub, %if.end15 ]
  %n.0 = phi i32 [ 0, %if.end ], [ %inc19, %if.end15 ]
  %cmp2 = icmp ult i32 %n.0, %n_terms
  %cmp4 = icmp ne i32 %y.0, 0
  %cmp4. = select i1 %cmp2, i1 %cmp4, i1 false
  br i1 %cmp4., label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %div = udiv i32 %x.0, %y.0
  %idxprom = zext i32 %n.0 to i64
  %arrayidx = getelementptr inbounds i32, i32* %0, i64 %idxprom
  store i32 %div, i32* %arrayidx, align 4, !tbaa !17
  %idxprom6 = zext i32 %n.0 to i64
  %arrayidx7 = getelementptr inbounds i32, i32* %0, i64 %idxprom6
  %3 = load i32, i32* %arrayidx7, align 4, !tbaa !17
  %cmp8 = icmp uge i32 %3, %threshold
  br i1 %cmp8, label %if.then10, label %if.end15

if.then10:                                        ; preds = %for.body
  %cmp11 = icmp ult i32 %n.0, 2
  %inc = add i32 %n.0, 1
  %inc.n.0 = select i1 %cmp11, i32 %inc, i32 %n.0
  br label %for.end

if.end15:                                         ; preds = %for.body
  %idxprom16 = zext i32 %n.0 to i64
  %arrayidx17 = getelementptr inbounds i32, i32* %0, i64 %idxprom16
  %4 = load i32, i32* %arrayidx17, align 4, !tbaa !17
  %mul18 = mul i32 %4, %y.0
  %sub = sub i32 %x.0, %mul18
  %inc19 = add i32 %n.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then10
  %n.2 = phi i32 [ %inc.n.0, %if.then10 ], [ %n.0, %for.cond ]
  br label %for.cond20

for.cond20:                                       ; preds = %for.body23, %for.end
  %x.1 = phi i32 [ 0, %for.end ], [ %y.1, %for.body23 ]
  %y.1 = phi i32 [ 1, %for.end ], [ %add, %for.body23 ]
  %i.0 = phi i32 [ %n.2, %for.end ], [ %dec, %for.body23 ]
  %cmp21 = icmp ugt i32 %i.0, 0
  br i1 %cmp21, label %for.body23, label %for.end29

for.body23:                                       ; preds = %for.cond20
  %sub24 = sub i32 %i.0, 1
  %idxprom25 = zext i32 %sub24 to i64
  %arrayidx26 = getelementptr inbounds i32, i32* %0, i64 %idxprom25
  %5 = load i32, i32* %arrayidx26, align 4, !tbaa !17
  %mul27 = mul i32 %5, %y.1
  %add = add i32 %mul27, %x.1
  %dec = add i32 %i.0, -1
  br label %for.cond20

for.end29:                                        ; preds = %for.cond20
  store i32 %y.1, i32* %numerator, align 4, !tbaa !17
  store i32 %x.1, i32* %denominator, align 4, !tbaa !17
  %6 = bitcast i32* %0 to i8*
  call void @kfree(i8* %6)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end29, %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #2 {
entry:
  %call = call noalias i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare void @kfree(i8*) #3

; Function Attrs: nounwind uwtable
define i32 @uvc_fraction_to_interval(i32 %numerator, i32 %denominator) #0 {
entry:
  %cmp = icmp eq i32 %denominator, 0
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %div = udiv i32 %numerator, %denominator
  %cmp1 = icmp uge i32 %div, 429
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %multiplier.0 = phi i32 [ 10000000, %if.end ], [ %div4, %while.body ]
  %denominator.addr.0 = phi i32 [ %denominator, %if.end ], [ %div5, %while.body ]
  %div2 = udiv i32 -1, %multiplier.0
  %cmp3 = icmp ugt i32 %numerator, %div2
  br i1 %cmp3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %div4 = udiv i32 %multiplier.0, 2
  %div5 = udiv i32 %denominator.addr.0, 2
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %tobool = icmp ne i32 %denominator.addr.0, 0
  br i1 %tobool, label %cond.true, label %cleanup

cond.true:                                        ; preds = %while.end
  %mul = mul i32 %numerator, %multiplier.0
  %div6 = udiv i32 %mul, %denominator.addr.0
  br label %cleanup

cleanup:                                          ; preds = %cond.true, %while.end, %entry, %lor.lhs.false
  %retval.0 = phi i32 [ -1, %lor.lhs.false ], [ -1, %entry ], [ %div6, %cond.true ], [ 0, %while.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define %struct.uvc_entity* @uvc_entity_by_id(%struct.uvc_device* %dev, i32 %id) #0 {
entry:
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list6.sink = phi %struct.list_head* [ %list6, %for.inc ], [ %entities, %entry ]
  %next7 = getelementptr inbounds %struct.list_head, %struct.list_head* %list6.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next7, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr9 to %struct.uvc_entity*
  %list = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 0
  %entities1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %list, %entities1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %id2 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 3
  %3 = load i8, i8* %id2, align 4, !tbaa !19
  %conv = zext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv, %id
  br i1 %cmp3, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %list6 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %for.body
  %retval.0 = phi %struct.uvc_entity* [ %2, %for.body ], [ null, %for.cond ]
  ret %struct.uvc_entity* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_probe(%struct.usb_interface* %intf, %struct.usb_device_id* %id) #0 {
entry:
  %call = call %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf)
  %idVendor = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 1
  %0 = load i16, i16* %idVendor, align 2, !tbaa !23
  %conv = zext i16 %0 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %do.body10

land.lhs.true:                                    ; preds = %entry
  %idProduct = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 2
  %1 = load i16, i16* %idProduct, align 4, !tbaa !26
  %conv1 = zext i16 %1 to i32
  %tobool2 = icmp ne i32 %conv1, 0
  br i1 %tobool2, label %do.body, label %do.body10

do.body:                                          ; preds = %land.lhs.true
  %2 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %2, 1
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then4, label %if.end20

if.then4:                                         ; preds = %do.body
  %devpath = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %devpath, i32 0, i32 0
  %idVendor5 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 1
  %3 = load i16, i16* %idVendor5, align 2, !tbaa !23
  %conv6 = zext i16 %3 to i32
  %idProduct7 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 2
  %4 = load i16, i16* %idProduct7, align 4, !tbaa !26
  %conv8 = zext i16 %4 to i32
  %call9 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.6, i32 0, i32 0), i8* %arraydecay, i32 %conv6, i32 %conv8)
  br label %if.end20

do.body10:                                        ; preds = %entry, %land.lhs.true
  %5 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and11 = and i32 %5, 1
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end20

if.then13:                                        ; preds = %do.body10
  %devpath14 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 1
  %arraydecay15 = getelementptr inbounds [16 x i8], [16 x i8]* %devpath14, i32 0, i32 0
  %call16 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.7, i32 0, i32 0), i8* %arraydecay15)
  br label %if.end20

if.end20:                                         ; preds = %do.body10, %if.then13, %do.body, %if.then4
  %call21 = call i8* @kzalloc(i64 376, i32 20971712)
  %6 = bitcast i8* %call21 to %struct.uvc_device*
  %cmp = icmp eq %struct.uvc_device* %6, null
  br i1 %cmp, label %cleanup, label %if.end24

if.end24:                                         ; preds = %if.end20
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 12
  call void @INIT_LIST_HEAD(%struct.list_head* %entities)
  %chains = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 13
  call void @INIT_LIST_HEAD(%struct.list_head* %chains)
  %streams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 14
  call void @INIT_LIST_HEAD(%struct.list_head* %streams)
  %nstreams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 15
  call void @atomic_set(%struct.atomic_t* %nstreams, i32 0)
  %nmappings = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 8
  call void @atomic_set(%struct.atomic_t* %nmappings, i32 0)
  %lock = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 6
  call void @__mutex_init(%struct.mutex* %lock, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.8, i32 0, i32 0), %struct.lock_class_key* @uvc_probe.__key)
  %call28 = call %struct.usb_device* @usb_get_dev(%struct.usb_device* %call)
  %udev29 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 0
  store %struct.usb_device* %call28, %struct.usb_device** %udev29, align 8, !tbaa !27
  %call30 = call %struct.usb_interface* @usb_get_intf(%struct.usb_interface* %intf)
  %intf31 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 1
  store %struct.usb_interface* %call30, %struct.usb_interface** %intf31, align 8, !tbaa !38
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %7 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %7, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %8 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !54
  %conv32 = zext i8 %8 to i32
  %intfnum = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 4
  store i32 %conv32, i32* %intfnum, align 4, !tbaa !55
  %9 = load i32, i32* @uvc_quirks_param, align 4, !tbaa !17
  %cmp33 = icmp eq i32 %9, -1
  br i1 %cmp33, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end24
  %driver_info = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 12
  %10 = load i64, i64* %driver_info, align 8, !tbaa !56
  br label %cond.end

cond.false:                                       ; preds = %if.end24
  %11 = load i32, i32* @uvc_quirks_param, align 4, !tbaa !17
  %conv35 = zext i32 %11 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %conv35, %cond.false ]
  %conv36 = trunc i64 %cond to i32
  %quirks = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 3
  store i32 %conv36, i32* %quirks, align 8, !tbaa !57
  %product = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 24
  %12 = load i8*, i8** %product, align 8, !tbaa !58
  %cmp37 = icmp ne i8* %12, null
  %name = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 5
  %arraydecay40 = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  br i1 %cmp37, label %if.then39, label %if.else43

if.then39:                                        ; preds = %cond.end
  %product41 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 24
  %13 = load i8*, i8** %product41, align 8, !tbaa !58
  %call42 = call i64 @strlcpy(i8* %arraydecay40, i8* %13, i64 32)
  br label %if.end52

if.else43:                                        ; preds = %cond.end
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idVendor46 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %14 = load i16, i16* %idVendor46, align 8, !tbaa !63
  %conv47 = zext i16 %14 to i32
  %descriptor48 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idProduct49 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor48, i32 0, i32 8
  %15 = load i16, i16* %idProduct49, align 2, !tbaa !64
  %conv50 = zext i16 %15 to i32
  %call51 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay40, i64 32, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.9, i32 0, i32 0), i32 %conv47, i32 %conv50)
  br label %if.end52

if.end52:                                         ; preds = %if.else43, %if.then39
  %call53 = call i32 @uvc_parse_control(%struct.uvc_device* %6)
  %cmp54 = icmp slt i32 %call53, 0
  br i1 %cmp54, label %do.body57, label %if.end65

do.body57:                                        ; preds = %if.end52
  %16 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and58 = and i32 %16, 1
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then60, label %error

if.then60:                                        ; preds = %do.body57
  %call61 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.10, i32 0, i32 0))
  br label %error

if.end65:                                         ; preds = %if.end52
  %uvc_version = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 10
  %17 = load i16, i16* %uvc_version, align 8, !tbaa !65
  %conv66 = zext i16 %17 to i32
  %shr = ashr i32 %conv66, 8
  %uvc_version67 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 10
  %18 = load i16, i16* %uvc_version67, align 8, !tbaa !65
  %conv68 = zext i16 %18 to i32
  %and69 = and i32 %conv68, 255
  %product70 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 24
  %19 = load i8*, i8** %product70, align 8, !tbaa !58
  %tobool71 = icmp ne i8* %19, null
  br i1 %tobool71, label %cond.true72, label %cond.end75

cond.true72:                                      ; preds = %if.end65
  %product73 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 24
  %20 = load i8*, i8** %product73, align 8, !tbaa !58
  br label %cond.end75

cond.end75:                                       ; preds = %if.end65, %cond.true72
  %cond76 = phi i8* [ %20, %cond.true72 ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), %if.end65 ]
  %descriptor77 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idVendor78 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor77, i32 0, i32 7
  %21 = load i16, i16* %idVendor78, align 8, !tbaa !63
  %conv79 = zext i16 %21 to i32
  %descriptor80 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %call, i32 0, i32 12
  %idProduct81 = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor80, i32 0, i32 8
  %22 = load i16, i16* %idProduct81, align 2, !tbaa !64
  %conv82 = zext i16 %22 to i32
  %call83 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.11, i32 0, i32 0), i32 %shr, i32 %and69, i8* %cond76, i32 %conv79, i32 %conv82)
  %quirks84 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 3
  %23 = load i32, i32* %quirks84, align 8, !tbaa !57
  %conv85 = zext i32 %23 to i64
  %driver_info86 = getelementptr inbounds %struct.usb_device_id, %struct.usb_device_id* %id, i32 0, i32 12
  %24 = load i64, i64* %driver_info86, align 8, !tbaa !56
  %cmp87 = icmp ne i64 %conv85, %24
  br i1 %cmp87, label %if.then89, label %if.end93

if.then89:                                        ; preds = %cond.end75
  %quirks90 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 3
  %25 = load i32, i32* %quirks90, align 8, !tbaa !57
  %call91 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.13, i32 0, i32 0), i32 %25)
  %call92 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([80 x i8], [80 x i8]* @.str.14, i32 0, i32 0))
  br label %if.end93

if.end93:                                         ; preds = %if.then89, %cond.end75
  %dev94 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %vdev = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %6, i32 0, i32 9
  %call95 = call i32 @v4l2_device_register(%struct.device* %dev94, %struct.v4l2_device* %vdev)
  %cmp96 = icmp slt i32 %call95, 0
  br i1 %cmp96, label %error, label %if.end99

if.end99:                                         ; preds = %if.end93
  %call100 = call i32 @uvc_ctrl_init_device(%struct.uvc_device* %6)
  %cmp101 = icmp slt i32 %call100, 0
  br i1 %cmp101, label %error, label %if.end104

if.end104:                                        ; preds = %if.end99
  %call105 = call i32 @uvc_scan_device(%struct.uvc_device* %6)
  %cmp106 = icmp slt i32 %call105, 0
  br i1 %cmp106, label %error, label %if.end109

if.end109:                                        ; preds = %if.end104
  %call110 = call i32 @uvc_register_chains(%struct.uvc_device* %6)
  %cmp111 = icmp slt i32 %call110, 0
  br i1 %cmp111, label %error, label %if.end114

if.end114:                                        ; preds = %if.end109
  %26 = bitcast %struct.uvc_device* %6 to i8*
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %26)
  %call115 = call i32 @uvc_status_init(%struct.uvc_device* %6)
  %cmp116 = icmp slt i32 %call115, 0
  br i1 %cmp116, label %if.then118, label %do.body121

if.then118:                                       ; preds = %if.end114
  %call119 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([100 x i8], [100 x i8]* @.str.15, i32 0, i32 0), i32 %call115)
  br label %do.body121

do.body121:                                       ; preds = %if.end114, %if.then118
  %27 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and122 = and i32 %27, 1
  %tobool123 = icmp ne i32 %and122, 0
  br i1 %tobool123, label %if.then124, label %do.end128

if.then124:                                       ; preds = %do.body121
  %call125 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.16, i32 0, i32 0))
  br label %do.end128

do.end128:                                        ; preds = %if.then124, %do.body121
  call void @usb_enable_autosuspend(%struct.usb_device* %call)
  br label %cleanup

error:                                            ; preds = %if.end109, %if.end104, %if.end99, %if.end93, %do.body57, %if.then60
  call void @uvc_unregister_video(%struct.uvc_device* %6)
  br label %cleanup

cleanup:                                          ; preds = %if.end20, %error, %do.end128
  %retval.0 = phi i32 [ -19, %error ], [ 0, %do.end128 ], [ -12, %if.end20 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @uvc_disconnect(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.uvc_device*
  call void @usb_set_intfdata(%struct.usb_interface* %intf, i8* null)
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 6
  %2 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !66
  %conv = zext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 2
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @uvc_unregister_video(%struct.uvc_device* %0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_suspend(%struct.usb_interface* %intf, i32 %message.coerce) #0 {
entry:
  %message = alloca %struct.pm_message, align 4
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %message, i32 0, i32 0
  store i32 %message.coerce, i32* %coerce.dive, align 4
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.uvc_device*
  %1 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %1, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %3 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !54
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.118, i32 0, i32 0), i32 %conv)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cur_altsetting2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %4 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting2, align 8, !tbaa !39
  %desc3 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %4, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc3, i32 0, i32 6
  %5 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !66
  %conv4 = zext i8 %5 to i32
  %cmp = icmp eq i32 %conv4, 1
  br i1 %cmp, label %if.then6, label %if.end11

if.then6:                                         ; preds = %do.end
  %lock = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 6
  call void @mutex_lock(%struct.mutex* %lock)
  %users = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 7
  %6 = load i32, i32* %users, align 8, !tbaa !67
  %tobool7 = icmp ne i32 %6, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then6
  call void @uvc_status_stop(%struct.uvc_device* %0)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.then6
  %lock10 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %lock10)
  br label %cleanup

if.end11:                                         ; preds = %do.end
  %streams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 14
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %list22.sink = phi %struct.list_head* [ %list22, %for.inc ], [ %streams, %if.end11 ]
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %list22.sink, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !18
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr25 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr25 to %struct.uvc_streaming*
  %list = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 0
  %streams12 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 14
  %cmp13 = icmp ne %struct.list_head* %list, %streams12
  br i1 %cmp13, label %for.body, label %do.body26

for.body:                                         ; preds = %for.cond
  %intf15 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 5
  %10 = load %struct.usb_interface*, %struct.usb_interface** %intf15, align 8, !tbaa !68
  %cmp16 = icmp eq %struct.usb_interface* %10, %intf
  br i1 %cmp16, label %if.then18, label %for.inc

if.then18:                                        ; preds = %for.body
  %call19 = call i32 @uvc_video_suspend(%struct.uvc_streaming* %9)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %list22 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 0
  br label %for.cond

do.body26:                                        ; preds = %for.cond
  %11 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and27 = and i32 %11, 256
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then29, label %cleanup

if.then29:                                        ; preds = %do.body26
  %call30 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.119, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %do.body26, %if.then29, %if.then18, %if.end9
  %retval.0 = phi i32 [ 0, %if.end9 ], [ %call19, %if.then18 ], [ -22, %if.then29 ], [ -22, %do.body26 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i32 @__uvc_resume(%struct.usb_interface* %intf, i32 0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_reset_resume(%struct.usb_interface* %intf) #0 {
entry:
  %call = call i32 @__uvc_resume(%struct.usb_interface* %intf, i32 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @uvc_cleanup() #0 section ".exit.text" {
entry:
  call void @usb_deregister(%struct.usb_driver* getelementptr inbounds (%struct.uvc_driver, %struct.uvc_driver* @uvc_driver, i32 0, i32 0))
  call void @uvc_debugfs_cleanup()
  ret void
}

declare void @usb_deregister(%struct.usb_driver*) #3

declare void @uvc_debugfs_cleanup() #3

; Function Attrs: nounwind uwtable
define internal i32 @uvc_init() #0 section ".init.text" {
entry:
  call void @uvc_debugfs_init()
  %call = call i32 @usb_register_driver(%struct.usb_driver* getelementptr inbounds (%struct.uvc_driver, %struct.uvc_driver* @uvc_driver, i32 0, i32 0), %struct.module* null, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.122, i32 0, i32 0))
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @uvc_debugfs_cleanup()
  br label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.123, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %if.end ]
  ret i32 %retval.0
}

declare noalias i8* @__kmalloc(i64, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @uvc_clock_param_set(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %call = call i32 @strncasecmp(i8* %val, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1, i32 0, i32 0), i64 6)
  %cmp = icmp eq i32 %call, 0
  %add.ptr = getelementptr inbounds i8, i8* %val, i64 6
  %add.ptr.val = select i1 %cmp, i8* %add.ptr, i8* %val
  %call1 = call i32 @strcasecmp(i8* %add.ptr.val, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0))
  %cmp2 = icmp eq i32 %call1, 0
  br i1 %cmp2, label %return.sink.split, label %if.else

if.else:                                          ; preds = %entry
  %call4 = call i32 @strcasecmp(i8* %add.ptr.val, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.3, i32 0, i32 0))
  %cmp5 = icmp eq i32 %call4, 0
  br i1 %cmp5, label %return.sink.split, label %return

return.sink.split:                                ; preds = %entry, %if.else
  %.sink = phi i32 [ 0, %if.else ], [ 1, %entry ]
  store i32 %.sink, i32* @uvc_clock_param, align 4, !tbaa !17
  br label %return

return:                                           ; preds = %return.sink.split, %if.else
  %retval.0 = phi i32 [ -22, %if.else ], [ 0, %return.sink.split ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_clock_param_get(i8* %buffer, %struct.kernel_param* %kp) #0 {
entry:
  %0 = load i32, i32* @uvc_clock_param, align 4, !tbaa !17
  %cmp = icmp eq i32 %0, 1
  %.sink = select i1 %cmp, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.5, i32 0, i32 0)
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buffer, i8* %.sink)
  ret i32 %call1
}

declare i32 @strncasecmp(i8*, i8*, i64) #3

declare i32 @strcasecmp(i8*, i8*) #3

declare i32 @sprintf(i8*, i8*, ...) #3

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.usb_device* @interface_to_usbdev(%struct.usb_interface* %intf) #4 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 0
  %0 = load %struct.device*, %struct.device** %parent, align 8, !tbaa !81
  %1 = bitcast %struct.device* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -152
  %2 = bitcast i8* %add.ptr to %struct.usb_device*
  ret %struct.usb_device* %2
}

declare i32 @printk(i8*, ...) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #4 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #4 {
entry:
  %__u = alloca %union.anon.68, align 8
  %0 = bitcast %union.anon.68* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %__val = bitcast %union.anon.68* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !82
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.68* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.68* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !82
  %3 = bitcast %union.anon.68* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #5
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !83
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic_set(%struct.atomic_t* %v, i32 %i) #2 {
entry:
  %__u = alloca %union.anon.69, align 4
  %0 = bitcast %union.anon.69* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
  %__val = bitcast %union.anon.69* %__u to i32*
  store i32 %i, i32* %__val, align 4, !tbaa !82
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %1 = bitcast i32* %counter to i8*
  %__c = bitcast %union.anon.69* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val1 = bitcast %union.anon.69* %__u to i32*
  %2 = load i32, i32* %__val1, align 4, !tbaa !82
  %3 = bitcast %union.anon.69* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #5
  ret void
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #3

declare %struct.usb_device* @usb_get_dev(%struct.usb_device*) #3

declare %struct.usb_interface* @usb_get_intf(%struct.usb_interface*) #3

declare i64 @strlcpy(i8*, i8*, i64) #3

declare i32 @snprintf(i8*, i64, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal i32 @uvc_parse_control(%struct.uvc_device* %dev) #0 {
entry:
  %intf = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 1
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !38
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 1
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %extra = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 2
  %2 = load i8*, i8** %extra, align 8, !tbaa !84
  %extralen = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 1
  %3 = load i32, i32* %extralen, align 4, !tbaa !85
  br label %while.cond

while.cond:                                       ; preds = %next_descriptor, %entry
  %buffer.0 = phi i8* [ %2, %entry ], [ %add.ptr, %next_descriptor ]
  %buflen.0 = phi i32 [ %3, %entry ], [ %sub, %next_descriptor ]
  %cmp = icmp sgt i32 %buflen.0, 2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call = call i32 @uvc_parse_vendor_control(%struct.uvc_device* %dev, i8* %buffer.0, i32 %buflen.0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %next_descriptor, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %arrayidx = getelementptr inbounds i8, i8* %buffer.0, i64 1
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !82
  %conv = zext i8 %4 to i32
  %cmp1 = icmp ne i32 %conv, 36
  br i1 %cmp1, label %next_descriptor, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %call3 = call i32 @uvc_parse_standard_control(%struct.uvc_device* %dev, i8* %buffer.0, i32 %buflen.0)
  %cmp4 = icmp slt i32 %call3, 0
  br i1 %cmp4, label %cleanup, label %next_descriptor

next_descriptor:                                  ; preds = %if.end, %while.body, %lor.lhs.false
  %arrayidx8 = getelementptr inbounds i8, i8* %buffer.0, i64 0
  %5 = load i8, i8* %arrayidx8, align 1, !tbaa !82
  %conv9 = zext i8 %5 to i32
  %sub = sub nsw i32 %buflen.0, %conv9
  %arrayidx10 = getelementptr inbounds i8, i8* %buffer.0, i64 0
  %6 = load i8, i8* %arrayidx10, align 1, !tbaa !82
  %conv11 = zext i8 %6 to i32
  %idx.ext = sext i32 %conv11 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.0, i64 %idx.ext
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 4
  %7 = load i8, i8* %bNumEndpoints, align 4, !tbaa !2
  %conv12 = zext i8 %7 to i32
  %cmp13 = icmp eq i32 %conv12, 1
  br i1 %cmp13, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %while.end
  %quirks = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 3
  %8 = load i32, i32* %quirks, align 8, !tbaa !57
  %and = and i32 %8, 8
  %tobool15 = icmp ne i32 %and, 0
  br i1 %tobool15, label %cleanup, label %if.then16

if.then16:                                        ; preds = %land.lhs.true
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 3
  %9 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !9
  %arrayidx17 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %9, i64 0
  %desc19 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx17, i32 0, i32 0
  %call20 = call i32 @usb_endpoint_is_int_in(%struct.usb_endpoint_descriptor* %desc19)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %land.lhs.true22, label %cleanup

land.lhs.true22:                                  ; preds = %if.then16
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc19, i32 0, i32 4
  %10 = load i16, i16* %wMaxPacketSize, align 1, !tbaa !86
  %conv23 = zext i16 %10 to i32
  %cmp24 = icmp sge i32 %conv23, 8
  br i1 %cmp24, label %land.lhs.true26, label %cleanup

land.lhs.true26:                                  ; preds = %land.lhs.true22
  %bInterval = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc19, i32 0, i32 5
  %11 = load i8, i8* %bInterval, align 1, !tbaa !87
  %conv27 = zext i8 %11 to i32
  %cmp28 = icmp ne i32 %conv27, 0
  br i1 %cmp28, label %do.body, label %cleanup

do.body:                                          ; preds = %land.lhs.true26
  %12 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and31 = and i32 %12, 2
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then33, label %do.end

if.then33:                                        ; preds = %do.body
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc19, i32 0, i32 2
  %13 = load i8, i8* %bEndpointAddress, align 1, !tbaa !88
  %conv34 = zext i8 %13 to i32
  %call35 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.17, i32 0, i32 0), i32 %conv34)
  br label %do.end

do.end:                                           ; preds = %if.then33, %do.body
  %int_ep = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 16
  store %struct.usb_host_endpoint* %arrayidx17, %struct.usb_host_endpoint** %int_ep, align 8, !tbaa !89
  br label %cleanup

cleanup:                                          ; preds = %while.end, %land.lhs.true, %do.end, %land.lhs.true26, %land.lhs.true22, %if.then16, %if.end
  %retval.0 = phi i32 [ %call3, %if.end ], [ 0, %if.then16 ], [ 0, %land.lhs.true22 ], [ 0, %land.lhs.true26 ], [ 0, %do.end ], [ 0, %land.lhs.true ], [ 0, %while.end ]
  ret i32 %retval.0
}

declare i32 @v4l2_device_register(%struct.device*, %struct.v4l2_device*) #3

declare i32 @uvc_ctrl_init_device(%struct.uvc_device*) #3

; Function Attrs: nounwind uwtable
define internal i32 @uvc_scan_device(%struct.uvc_device* %dev) #0 {
entry:
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list32.sink = phi %struct.list_head* [ %list32, %for.inc ], [ %entities, %entry ]
  %next33 = getelementptr inbounds %struct.list_head, %struct.list_head* %list32.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next33, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr35 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr35 to %struct.uvc_entity*
  %list = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 0
  %entities1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %list, %entities1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %type = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %3 = load i16, i16* %type, align 2, !tbaa !90
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 65280
  %cmp2 = icmp ne i32 %and, 0
  br i1 %cmp2, label %land.lhs.true, label %for.inc

land.lhs.true:                                    ; preds = %for.body
  %type4 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %4 = load i16, i16* %type4, align 2, !tbaa !90
  %conv5 = zext i16 %4 to i32
  %and6 = and i32 %conv5, 32768
  %cmp7 = icmp eq i32 %and6, 32768
  br i1 %cmp7, label %if.end, label %for.inc

if.end:                                           ; preds = %land.lhs.true
  %chain9 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 1
  %next10 = getelementptr inbounds %struct.list_head, %struct.list_head* %chain9, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next10, align 8, !tbaa !91
  %tobool = icmp ne %struct.list_head* %5, null
  br i1 %tobool, label %for.inc, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %chain11 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 1
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %chain11, i32 0, i32 1
  %6 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !92
  %tobool12 = icmp ne %struct.list_head* %6, null
  br i1 %tobool12, label %for.inc, label %if.end14

if.end14:                                         ; preds = %lor.lhs.false
  %call = call %struct.uvc_video_chain* @uvc_alloc_chain(%struct.uvc_device* %dev)
  %cmp15 = icmp eq %struct.uvc_video_chain* %call, null
  br i1 %cmp15, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end14
  %flags = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 2
  %7 = load i32, i32* %flags, align 8, !tbaa !93
  %or = or i32 %7, 1
  store i32 %or, i32* %flags, align 8, !tbaa !93
  %call19 = call i32 @uvc_scan_chain(%struct.uvc_video_chain* %call, %struct.uvc_entity* %2)
  %cmp20 = icmp slt i32 %call19, 0
  br i1 %cmp20, label %if.then22, label %do.body

if.then22:                                        ; preds = %if.end18
  %8 = bitcast %struct.uvc_video_chain* %call to i8*
  call void @kfree(i8* %8)
  br label %for.inc

do.body:                                          ; preds = %if.end18
  %9 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and24 = and i32 %9, 1
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %do.end

if.then26:                                        ; preds = %do.body
  %call27 = call i8* @uvc_print_chain(%struct.uvc_video_chain* %call)
  %call28 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.87, i32 0, i32 0), i8* %call27)
  br label %do.end

do.end:                                           ; preds = %if.then26, %do.body
  %list30 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %call, i32 0, i32 1
  %chains = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  call void @list_add_tail(%struct.list_head* %list30, %struct.list_head* %chains)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %lor.lhs.false, %for.body, %land.lhs.true, %do.end, %if.then22
  %list32 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %chains36 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  %call37 = call i32 @list_empty(%struct.list_head* %chains36)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then39, label %if.end41

if.then39:                                        ; preds = %for.end
  %call40 = call i32 @uvc_scan_fallback(%struct.uvc_device* %dev)
  br label %if.end41

if.end41:                                         ; preds = %if.then39, %for.end
  %chains42 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  %call43 = call i32 @list_empty(%struct.list_head* %chains42)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.then45, label %cleanup

if.then45:                                        ; preds = %if.end41
  %call46 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.88, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.end41, %if.end14, %if.then45
  %retval.0 = phi i32 [ -1, %if.then45 ], [ -12, %if.end14 ], [ 0, %if.end41 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_register_chains(%struct.uvc_device* %dev) #0 {
entry:
  %chains = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list4.sink = phi %struct.list_head* [ %list4, %for.inc ], [ %chains, %entry ]
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %list4.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 -8
  %2 = bitcast i8* %add.ptr7 to %struct.uvc_video_chain*
  %list = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %2, i32 0, i32 1
  %chains1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  %cmp = icmp ne %struct.list_head* %list, %chains1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %call = call i32 @uvc_register_terms(%struct.uvc_device* %dev, %struct.uvc_video_chain* %2)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %list4 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %2, i32 0, i32 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %for.body
  %retval.0 = phi i32 [ %call, %for.body ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @usb_set_intfdata(%struct.usb_interface* %intf, i8* %data) #4 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

declare i32 @uvc_status_init(%struct.uvc_device*) #3

declare void @usb_enable_autosuspend(%struct.usb_device*) #3

; Function Attrs: nounwind uwtable
define internal void @uvc_unregister_video(%struct.uvc_device* %dev) #0 {
entry:
  %nstreams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 15
  call void @atomic_inc(%struct.atomic_t* %nstreams)
  %streams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 14
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list4.sink = phi %struct.list_head* [ %list4, %for.inc ], [ %streams, %entry ]
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %list4.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr7 to %struct.uvc_streaming*
  %list = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %2, i32 0, i32 0
  %streams1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 14
  %cmp = icmp ne %struct.list_head* %list, %streams1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %vdev = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %2, i32 0, i32 2
  %call = call i32 @video_is_registered(%struct.video_device* %vdev)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %vdev2 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %2, i32 0, i32 2
  call void @video_unregister_device(%struct.video_device* %vdev2)
  call void @uvc_debugfs_cleanup_stream(%struct.uvc_streaming* %2)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %list4 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %nstreams8 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 15
  %call9 = call zeroext i1 @atomic_dec_and_test(%struct.atomic_t* %nstreams8)
  br i1 %call9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %for.end
  call void @uvc_delete(%struct.uvc_device* %dev)
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %for.end
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #2 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !82
  store volatile i8 %0, i8* %p, align 1, !tbaa !82
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !94
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !94
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !17
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !17
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !95
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !95
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !96
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !97
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: nounwind uwtable
define internal i32 @uvc_parse_vendor_control(%struct.uvc_device* %dev, i8* %buffer, i32 %buflen) #0 {
entry:
  %udev1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %0 = load %struct.usb_device*, %struct.usb_device** %udev1, align 8, !tbaa !27
  %intf = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 1
  %1 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !38
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %udev2 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %3 = load %struct.usb_device*, %struct.usb_device** %udev2, align 8, !tbaa !27
  %descriptor = getelementptr inbounds %struct.usb_device, %struct.usb_device* %3, i32 0, i32 12
  %idVendor = getelementptr inbounds %struct.usb_device_descriptor, %struct.usb_device_descriptor* %descriptor, i32 0, i32 7
  %4 = load i16, i16* %idVendor, align 8, !tbaa !63
  %conv = zext i16 %4 to i32
  %cond1 = icmp eq i32 %conv, 1133
  br i1 %cond1, label %sw.bb, label %cleanup

sw.bb:                                            ; preds = %entry
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 1
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !82
  %conv3 = zext i8 %5 to i32
  %cmp = icmp ne i32 %conv3, 65
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb
  %arrayidx5 = getelementptr inbounds i8, i8* %buffer, i64 2
  %6 = load i8, i8* %arrayidx5, align 1, !tbaa !82
  %conv6 = zext i8 %6 to i32
  %cmp7 = icmp ne i32 %conv6, 1
  br i1 %cmp7, label %cleanup, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %cmp9 = icmp sge i32 %buflen, 22
  br i1 %cmp9, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %arrayidx11 = getelementptr inbounds i8, i8* %buffer, i64 21
  %7 = load i8, i8* %arrayidx11, align 1, !tbaa !82
  %conv12 = zext i8 %7 to i32
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi i32 [ %conv12, %cond.true ], [ 0, %if.end ]
  %add = add i32 25, %cond
  %cmp13 = icmp uge i32 %buflen, %add
  br i1 %cmp13, label %cond.true15, label %cond.end20

cond.true15:                                      ; preds = %cond.end
  %add16 = add i32 22, %cond
  %idxprom = zext i32 %add16 to i64
  %arrayidx17 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom
  %8 = load i8, i8* %arrayidx17, align 1, !tbaa !82
  %conv18 = zext i8 %8 to i32
  br label %cond.end20

cond.end20:                                       ; preds = %cond.end, %cond.true15
  %cond21 = phi i32 [ %conv18, %cond.true15 ], [ 0, %cond.end ]
  %add22 = add i32 25, %cond
  %mul = mul i32 2, %cond21
  %add23 = add i32 %add22, %mul
  %cmp24 = icmp ult i32 %buflen, %add23
  br i1 %cmp24, label %do.body, label %if.end30

do.body:                                          ; preds = %cond.end20
  %9 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %9, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then27, label %cleanup

if.then27:                                        ; preds = %do.body
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %10 = load i32, i32* %devnum, align 8, !tbaa !98
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %11 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !54
  %conv28 = zext i8 %11 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.18, i32 0, i32 0), i32 %10, i32 %conv28)
  br label %cleanup

if.end30:                                         ; preds = %cond.end20
  %arrayidx31 = getelementptr inbounds i8, i8* %buffer, i64 3
  %12 = load i8, i8* %arrayidx31, align 1, !tbaa !82
  %add32 = add i32 %cond, 1
  %mul33 = mul i32 2, %cond21
  %call34 = call %struct.uvc_entity* @uvc_alloc_entity(i16 zeroext 6, i8 zeroext %12, i32 %add32, i32 %mul33)
  %cmp35 = icmp eq %struct.uvc_entity* %call34, null
  br i1 %cmp35, label %cleanup, label %if.end38

if.end38:                                         ; preds = %if.end30
  %cmp39 = icmp uge i64 16, 64
  %13 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 11
  %extension = bitcast %union.anon.57* %13 to %struct.anon.63*
  %guidExtensionCode = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %guidExtensionCode, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds i8, i8* %buffer, i64 4
  br i1 %cmp39, label %if.then41, label %if.else

if.then41:                                        ; preds = %if.end38
  %call43 = call i8* @__memcpy(i8* %arraydecay, i8* %arrayidx42, i64 16)
  br label %if.end48

if.else:                                          ; preds = %if.end38
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay, i8* %arrayidx42, i64 16, i32 1, i1 false)
  br label %if.end48

if.end48:                                         ; preds = %if.else, %if.then41
  %__ret.0 = phi i8* [ %call43, %if.then41 ], [ %arraydecay, %if.else ]
  %arrayidx49 = getelementptr inbounds i8, i8* %buffer, i64 20
  %14 = load i8, i8* %arrayidx49, align 1, !tbaa !82
  %15 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 11
  %extension50 = bitcast %union.anon.57* %15 to %struct.anon.63*
  %bNumControls = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension50, i32 0, i32 1
  store i8 %14, i8* %bNumControls, align 8, !tbaa !82
  %conv52 = zext i32 %cond to i64
  %baSourceID = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 13
  %16 = load i8*, i8** %baSourceID, align 8, !tbaa !99
  %arrayidx54 = getelementptr inbounds i8, i8* %buffer, i64 22
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %arrayidx54, i64 %conv52, i32 1, i1 false)
  %add56 = add i32 22, %cond
  %idxprom57 = zext i32 %add56 to i64
  %arrayidx58 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom57
  %17 = load i8, i8* %arrayidx58, align 1, !tbaa !82
  %18 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 11
  %extension59 = bitcast %union.anon.57* %18 to %struct.anon.63*
  %bControlSize = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension59, i32 0, i32 2
  store i8 %17, i8* %bControlSize, align 1, !tbaa !82
  %19 = bitcast %struct.uvc_entity* %call34 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %19, i64 384
  %20 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 11
  %extension60 = bitcast %union.anon.57* %20 to %struct.anon.63*
  %bmControls = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension60, i32 0, i32 3
  store i8* %add.ptr, i8** %bmControls, align 8, !tbaa !82
  %21 = bitcast %struct.uvc_entity* %call34 to i8*
  %add.ptr61 = getelementptr inbounds i8, i8* %21, i64 384
  %idx.ext = zext i32 %cond21 to i64
  %add.ptr62 = getelementptr inbounds i8, i8* %add.ptr61, i64 %idx.ext
  %22 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 11
  %extension63 = bitcast %union.anon.57* %22 to %struct.anon.63*
  %bmControlsType = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension63, i32 0, i32 4
  store i8* %add.ptr62, i8** %bmControlsType, align 8, !tbaa !82
  %mul65 = mul i32 2, %cond21
  %conv66 = zext i32 %mul65 to i64
  %23 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 11
  %extension68 = bitcast %union.anon.57* %23 to %struct.anon.63*
  %bmControls69 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension68, i32 0, i32 3
  %24 = load i8*, i8** %bmControls69, align 8, !tbaa !82
  %add70 = add i32 23, %cond
  %idxprom71 = zext i32 %add70 to i64
  %arrayidx72 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom71
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %arrayidx72, i64 %conv66, i32 1, i1 false)
  %add74 = add i32 24, %cond
  %mul75 = mul i32 2, %cond21
  %add76 = add i32 %add74, %mul75
  %idxprom77 = zext i32 %add76 to i64
  %arrayidx78 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom77
  %25 = load i8, i8* %arrayidx78, align 1, !tbaa !82
  %conv79 = zext i8 %25 to i32
  %cmp80 = icmp ne i32 %conv79, 0
  br i1 %cmp80, label %if.then82, label %if.else91

if.then82:                                        ; preds = %if.end48
  %add83 = add i32 24, %cond
  %mul84 = mul i32 2, %cond21
  %add85 = add i32 %add83, %mul84
  %idxprom86 = zext i32 %add85 to i64
  %arrayidx87 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom86
  %26 = load i8, i8* %arrayidx87, align 1, !tbaa !82
  %conv88 = zext i8 %26 to i32
  %name = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 5
  %arraydecay89 = getelementptr inbounds [64 x i8], [64 x i8]* %name, i32 0, i32 0
  %call90 = call i32 @usb_string(%struct.usb_device* %0, i32 %conv88, i8* %arraydecay89, i64 64)
  br label %if.end97

if.else91:                                        ; preds = %if.end48
  %name92 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 5
  %arraydecay93 = getelementptr inbounds [64 x i8], [64 x i8]* %name92, i32 0, i32 0
  %arrayidx94 = getelementptr inbounds i8, i8* %buffer, i64 3
  %27 = load i8, i8* %arrayidx94, align 1, !tbaa !82
  %conv95 = zext i8 %27 to i32
  %call96 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay93, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.19, i32 0, i32 0), i32 %conv95)
  br label %if.end97

if.end97:                                         ; preds = %if.else91, %if.then82
  %list = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call34, i32 0, i32 0
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %entities)
  br label %cleanup

cleanup:                                          ; preds = %if.end97, %entry, %lor.lhs.false, %sw.bb, %if.then27, %do.body, %if.end30
  %retval.0 = phi i32 [ -12, %if.end30 ], [ 0, %entry ], [ 1, %if.end97 ], [ 0, %lor.lhs.false ], [ 0, %sw.bb ], [ 0, %if.then27 ], [ 0, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_parse_standard_control(%struct.uvc_device* %dev, i8* %buffer, i32 %buflen) #0 {
entry:
  %udev1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %0 = load %struct.usb_device*, %struct.usb_device** %udev1, align 8, !tbaa !27
  %intf2 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 1
  %1 = load %struct.usb_interface*, %struct.usb_interface** %intf2, align 8, !tbaa !38
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %1, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 2
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !82
  %conv = zext i8 %3 to i32
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %conv, 4
  br i1 %Pivot10, label %NodeBlock1, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %conv, 5
  br i1 %Pivot8, label %sw.bb315, label %NodeBlock5

NodeBlock5:                                       ; preds = %NodeBlock7
  %Pivot6 = icmp slt i32 %conv, 6
  br i1 %Pivot6, label %sw.bb381, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock5
  %SwitchLeaf4 = icmp eq i32 %conv, 6
  br i1 %SwitchLeaf4, label %sw.bb481, label %NewDefault

NodeBlock1:                                       ; preds = %NodeBlock9
  %Pivot2 = icmp slt i32 %conv, 2
  br i1 %Pivot2, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock1
  %Pivot = icmp slt i32 %conv, 3
  br i1 %Pivot, label %sw.bb35, label %sw.bb236

LeafBlock:                                        ; preds = %NodeBlock1
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %cmp = icmp sge i32 %buflen, 12
  br i1 %cmp, label %cond.true, label %cond.end

cond.true:                                        ; preds = %sw.bb
  %arrayidx4 = getelementptr inbounds i8, i8* %buffer, i64 11
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !82
  %conv5 = zext i8 %4 to i32
  br label %cond.end

cond.end:                                         ; preds = %sw.bb, %cond.true
  %cond = phi i32 [ %conv5, %cond.true ], [ 0, %sw.bb ]
  %add = add i32 12, %cond
  %cmp6 = icmp ult i32 %buflen, %add
  br i1 %cmp6, label %do.body, label %if.end10

do.body:                                          ; preds = %cond.end
  %5 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %5, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then8, label %cleanup

if.then8:                                         ; preds = %do.body
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %6 = load i32, i32* %devnum, align 8, !tbaa !98
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %7 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !54
  %conv9 = zext i8 %7 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.20, i32 0, i32 0), i32 %6, i32 %conv9)
  br label %cleanup

if.end10:                                         ; preds = %cond.end
  %arrayidx11 = getelementptr inbounds i8, i8* %buffer, i64 3
  %call12 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx11)
  %uvc_version = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 10
  store i16 %call12, i16* %uvc_version, align 8, !tbaa !65
  %arrayidx13 = getelementptr inbounds i8, i8* %buffer, i64 7
  %call14 = call i32 @get_unaligned_le32(i8* %arrayidx13)
  %clock_frequency = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 11
  store i32 %call14, i32* %clock_frequency, align 4, !tbaa !100
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %for.inc ]
  %cmp15 = icmp ult i32 %i.0, %cond
  br i1 %cmp15, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %add17 = add i32 12, %i.0
  %idxprom = zext i32 %add17 to i64
  %arrayidx18 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom
  %8 = load i8, i8* %arrayidx18, align 1, !tbaa !82
  %conv19 = zext i8 %8 to i32
  %call20 = call %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device* %0, i32 %conv19)
  %cmp21 = icmp eq %struct.usb_interface* %call20, null
  br i1 %cmp21, label %do.body24, label %if.end33

do.body24:                                        ; preds = %for.body
  %9 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and25 = and i32 %9, 2
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then27, label %for.inc

if.then27:                                        ; preds = %do.body24
  %devnum28 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %10 = load i32, i32* %devnum28, align 8, !tbaa !98
  %call29 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.21, i32 0, i32 0), i32 %10, i32 %i.0)
  br label %for.inc

if.end33:                                         ; preds = %for.body
  %call34 = call i32 @uvc_parse_streaming(%struct.uvc_device* %dev, %struct.usb_interface* %call20)
  br label %for.inc

for.inc:                                          ; preds = %do.body24, %if.then27, %if.end33
  %inc = add i32 %i.0, 1
  br label %for.cond

sw.bb35:                                          ; preds = %NodeBlock
  %cmp36 = icmp slt i32 %buflen, 8
  br i1 %cmp36, label %do.body39, label %if.end51

do.body39:                                        ; preds = %sw.bb35
  %11 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and40 = and i32 %11, 2
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %cleanup

if.then42:                                        ; preds = %do.body39
  %devnum43 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %12 = load i32, i32* %devnum43, align 8, !tbaa !98
  %desc44 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber45 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc44, i32 0, i32 2
  %13 = load i8, i8* %bInterfaceNumber45, align 2, !tbaa !54
  %conv46 = zext i8 %13 to i32
  %call47 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.22, i32 0, i32 0), i32 %12, i32 %conv46)
  br label %cleanup

if.end51:                                         ; preds = %sw.bb35
  %arrayidx52 = getelementptr inbounds i8, i8* %buffer, i64 4
  %call53 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx52)
  %conv54 = zext i16 %call53 to i32
  %and55 = and i32 %conv54, 65280
  %cmp56 = icmp eq i32 %and55, 0
  br i1 %cmp56, label %do.body59, label %if.end74

do.body59:                                        ; preds = %if.end51
  %14 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and60 = and i32 %14, 2
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then62, label %cleanup

if.then62:                                        ; preds = %do.body59
  %devnum63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %15 = load i32, i32* %devnum63, align 8, !tbaa !98
  %desc64 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber65 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc64, i32 0, i32 2
  %16 = load i8, i8* %bInterfaceNumber65, align 2, !tbaa !54
  %conv66 = zext i8 %16 to i32
  %arrayidx67 = getelementptr inbounds i8, i8* %buffer, i64 3
  %17 = load i8, i8* %arrayidx67, align 1, !tbaa !82
  %conv68 = zext i8 %17 to i32
  %conv69 = zext i16 %call53 to i32
  %call70 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([101 x i8], [101 x i8]* @.str.23, i32 0, i32 0), i32 %15, i32 %conv66, i32 %conv68, i32 %conv69)
  br label %cleanup

if.end74:                                         ; preds = %if.end51
  %conv75 = zext i16 %call53 to i32
  %cmp76 = icmp eq i32 %conv75, 513
  br i1 %cmp76, label %if.then78, label %if.else

if.then78:                                        ; preds = %if.end74
  %cmp79 = icmp sge i32 %buflen, 15
  br i1 %cmp79, label %cond.true81, label %if.end111

cond.true81:                                      ; preds = %if.then78
  %arrayidx82 = getelementptr inbounds i8, i8* %buffer, i64 14
  %18 = load i8, i8* %arrayidx82, align 1, !tbaa !82
  %conv83 = zext i8 %18 to i32
  br label %if.end111

if.else:                                          ; preds = %if.end74
  %conv87 = zext i16 %call53 to i32
  %cmp88 = icmp eq i32 %conv87, 514
  br i1 %cmp88, label %if.then90, label %if.end111

if.then90:                                        ; preds = %if.else
  %cmp91 = icmp sge i32 %buflen, 9
  br i1 %cmp91, label %cond.true93, label %cond.end97

cond.true93:                                      ; preds = %if.then90
  %arrayidx94 = getelementptr inbounds i8, i8* %buffer, i64 8
  %19 = load i8, i8* %arrayidx94, align 1, !tbaa !82
  %conv95 = zext i8 %19 to i32
  br label %cond.end97

cond.end97:                                       ; preds = %if.then90, %cond.true93
  %cond98 = phi i32 [ %conv95, %cond.true93 ], [ 0, %if.then90 ]
  %add99 = add i32 10, %cond98
  %cmp100 = icmp uge i32 %buflen, %add99
  br i1 %cmp100, label %cond.true102, label %if.end111

cond.true102:                                     ; preds = %cond.end97
  %add103 = add i32 9, %cond98
  %idxprom104 = zext i32 %add103 to i64
  %arrayidx105 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom104
  %20 = load i8, i8* %arrayidx105, align 1, !tbaa !82
  %conv106 = zext i8 %20 to i32
  br label %if.end111

if.end111:                                        ; preds = %if.else, %cond.end97, %cond.true102, %cond.true81, %if.then78
  %p.1 = phi i32 [ 0, %if.then78 ], [ 0, %cond.true81 ], [ 0, %if.else ], [ %conv106, %cond.true102 ], [ 0, %cond.end97 ]
  %n.1 = phi i32 [ %conv83, %cond.true81 ], [ 0, %if.then78 ], [ 0, %if.else ], [ %cond98, %cond.end97 ], [ %cond98, %cond.true102 ]
  %len.1 = phi i32 [ 15, %if.then78 ], [ 15, %cond.true81 ], [ 8, %if.else ], [ 10, %cond.end97 ], [ 10, %cond.true102 ]
  %add112 = add i32 %len.1, %n.1
  %add113 = add i32 %add112, %p.1
  %cmp114 = icmp ult i32 %buflen, %add113
  br i1 %cmp114, label %do.body117, label %if.end129

do.body117:                                       ; preds = %if.end111
  %21 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and118 = and i32 %21, 2
  %tobool119 = icmp ne i32 %and118, 0
  br i1 %tobool119, label %if.then120, label %cleanup

if.then120:                                       ; preds = %do.body117
  %devnum121 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %22 = load i32, i32* %devnum121, align 8, !tbaa !98
  %desc122 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber123 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc122, i32 0, i32 2
  %23 = load i8, i8* %bInterfaceNumber123, align 2, !tbaa !54
  %conv124 = zext i8 %23 to i32
  %call125 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.22, i32 0, i32 0), i32 %22, i32 %conv124)
  br label %cleanup

if.end129:                                        ; preds = %if.end111
  %conv130 = zext i16 %call53 to i32
  %conv131 = trunc i32 %conv130 to i16
  %arrayidx132 = getelementptr inbounds i8, i8* %buffer, i64 3
  %24 = load i8, i8* %arrayidx132, align 1, !tbaa !82
  %add133 = add i32 %n.1, %p.1
  %call134 = call %struct.uvc_entity* @uvc_alloc_entity(i16 zeroext %conv131, i8 zeroext %24, i32 1, i32 %add133)
  %cmp135 = icmp eq %struct.uvc_entity* %call134, null
  br i1 %cmp135, label %cleanup, label %if.end138

if.end138:                                        ; preds = %if.end129
  %type139 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 4
  %25 = load i16, i16* %type139, align 2, !tbaa !90
  %conv140 = zext i16 %25 to i32
  %and141 = and i32 %conv140, 32767
  %cmp142 = icmp eq i32 %and141, 513
  br i1 %cmp142, label %if.then144, label %if.else160

if.then144:                                       ; preds = %if.end138
  %conv145 = trunc i32 %n.1 to i8
  %26 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %camera = bitcast %union.anon.57* %26 to %struct.anon.58*
  %bControlSize = getelementptr inbounds %struct.anon.58, %struct.anon.58* %camera, i32 0, i32 3
  store i8 %conv145, i8* %bControlSize, align 2, !tbaa !82
  %27 = bitcast %struct.uvc_entity* %call134 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %27, i64 384
  %28 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %camera146 = bitcast %union.anon.57* %28 to %struct.anon.58*
  %bmControls = getelementptr inbounds %struct.anon.58, %struct.anon.58* %camera146, i32 0, i32 4
  store i8* %add.ptr, i8** %bmControls, align 8, !tbaa !82
  %arrayidx147 = getelementptr inbounds i8, i8* %buffer, i64 8
  %call148 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx147)
  %29 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %camera149 = bitcast %union.anon.57* %29 to %struct.anon.58*
  %wObjectiveFocalLengthMin = getelementptr inbounds %struct.anon.58, %struct.anon.58* %camera149, i32 0, i32 0
  store i16 %call148, i16* %wObjectiveFocalLengthMin, align 8, !tbaa !82
  %arrayidx150 = getelementptr inbounds i8, i8* %buffer, i64 10
  %call151 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx150)
  %30 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %camera152 = bitcast %union.anon.57* %30 to %struct.anon.58*
  %wObjectiveFocalLengthMax = getelementptr inbounds %struct.anon.58, %struct.anon.58* %camera152, i32 0, i32 1
  store i16 %call151, i16* %wObjectiveFocalLengthMax, align 2, !tbaa !82
  %arrayidx153 = getelementptr inbounds i8, i8* %buffer, i64 12
  %call154 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx153)
  %31 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %camera155 = bitcast %union.anon.57* %31 to %struct.anon.58*
  %wOcularFocalLength = getelementptr inbounds %struct.anon.58, %struct.anon.58* %camera155, i32 0, i32 2
  store i16 %call154, i16* %wOcularFocalLength, align 4, !tbaa !82
  %conv156 = zext i32 %n.1 to i64
  %32 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %camera157 = bitcast %union.anon.57* %32 to %struct.anon.58*
  %bmControls158 = getelementptr inbounds %struct.anon.58, %struct.anon.58* %camera157, i32 0, i32 4
  %33 = load i8*, i8** %bmControls158, align 8, !tbaa !82
  %arrayidx159 = getelementptr inbounds i8, i8* %buffer, i64 15
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %33, i8* %arrayidx159, i64 %conv156, i32 1, i1 false)
  br label %if.end194

if.else160:                                       ; preds = %if.end138
  %type161 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 4
  %34 = load i16, i16* %type161, align 2, !tbaa !90
  %conv162 = zext i16 %34 to i32
  %and163 = and i32 %conv162, 32767
  %cmp164 = icmp eq i32 %and163, 514
  br i1 %cmp164, label %if.then166, label %if.end194

if.then166:                                       ; preds = %if.else160
  %conv167 = trunc i32 %n.1 to i8
  %35 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %media = bitcast %union.anon.57* %35 to %struct.anon.59*
  %bControlSize168 = getelementptr inbounds %struct.anon.59, %struct.anon.59* %media, i32 0, i32 0
  store i8 %conv167, i8* %bControlSize168, align 8, !tbaa !82
  %36 = bitcast %struct.uvc_entity* %call134 to i8*
  %add.ptr169 = getelementptr inbounds i8, i8* %36, i64 384
  %37 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %media170 = bitcast %union.anon.57* %37 to %struct.anon.59*
  %bmControls171 = getelementptr inbounds %struct.anon.59, %struct.anon.59* %media170, i32 0, i32 1
  store i8* %add.ptr169, i8** %bmControls171, align 8, !tbaa !82
  %conv172 = trunc i32 %p.1 to i8
  %38 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %media173 = bitcast %union.anon.57* %38 to %struct.anon.59*
  %bTransportModeSize = getelementptr inbounds %struct.anon.59, %struct.anon.59* %media173, i32 0, i32 2
  store i8 %conv172, i8* %bTransportModeSize, align 8, !tbaa !82
  %39 = bitcast %struct.uvc_entity* %call134 to i8*
  %add.ptr174 = getelementptr inbounds i8, i8* %39, i64 384
  %idx.ext = zext i32 %n.1 to i64
  %add.ptr175 = getelementptr inbounds i8, i8* %add.ptr174, i64 %idx.ext
  %40 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %media176 = bitcast %union.anon.57* %40 to %struct.anon.59*
  %bmTransportModes = getelementptr inbounds %struct.anon.59, %struct.anon.59* %media176, i32 0, i32 3
  store i8* %add.ptr175, i8** %bmTransportModes, align 8, !tbaa !82
  %conv178 = zext i32 %n.1 to i64
  %41 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %media180 = bitcast %union.anon.57* %41 to %struct.anon.59*
  %bmControls181 = getelementptr inbounds %struct.anon.59, %struct.anon.59* %media180, i32 0, i32 1
  %42 = load i8*, i8** %bmControls181, align 8, !tbaa !82
  %arrayidx182 = getelementptr inbounds i8, i8* %buffer, i64 9
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %42, i8* %arrayidx182, i64 %conv178, i32 1, i1 false)
  %conv185 = zext i32 %p.1 to i64
  %43 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 11
  %media187 = bitcast %union.anon.57* %43 to %struct.anon.59*
  %bmTransportModes188 = getelementptr inbounds %struct.anon.59, %struct.anon.59* %media187, i32 0, i32 3
  %44 = load i8*, i8** %bmTransportModes188, align 8, !tbaa !82
  %add189 = add i32 10, %n.1
  %idxprom190 = zext i32 %add189 to i64
  %arrayidx191 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom190
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %44, i8* %arrayidx191, i64 %conv185, i32 1, i1 false)
  br label %if.end194

if.end194:                                        ; preds = %if.else160, %if.then166, %if.then144
  %arrayidx195 = getelementptr inbounds i8, i8* %buffer, i64 7
  %45 = load i8, i8* %arrayidx195, align 1, !tbaa !82
  %conv196 = zext i8 %45 to i32
  %cmp197 = icmp ne i32 %conv196, 0
  br i1 %cmp197, label %if.then199, label %if.else203

if.then199:                                       ; preds = %if.end194
  %arrayidx200 = getelementptr inbounds i8, i8* %buffer, i64 7
  %46 = load i8, i8* %arrayidx200, align 1, !tbaa !82
  %conv201 = zext i8 %46 to i32
  %name = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 5
  %arraydecay = getelementptr inbounds [64 x i8], [64 x i8]* %name, i32 0, i32 0
  %call202 = call i32 @usb_string(%struct.usb_device* %0, i32 %conv201, i8* %arraydecay, i64 64)
  br label %if.end235

if.else203:                                       ; preds = %if.end194
  %type204 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 4
  %47 = load i16, i16* %type204, align 2, !tbaa !90
  %conv205 = zext i16 %47 to i32
  %and206 = and i32 %conv205, 32767
  %cmp207 = icmp eq i32 %and206, 513
  br i1 %cmp207, label %if.then209, label %if.else215

if.then209:                                       ; preds = %if.else203
  %name210 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 5
  %arraydecay211 = getelementptr inbounds [64 x i8], [64 x i8]* %name210, i32 0, i32 0
  %arrayidx212 = getelementptr inbounds i8, i8* %buffer, i64 3
  %48 = load i8, i8* %arrayidx212, align 1, !tbaa !82
  %conv213 = zext i8 %48 to i32
  %call214 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay211, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.24, i32 0, i32 0), i32 %conv213)
  br label %if.end235

if.else215:                                       ; preds = %if.else203
  %type216 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 4
  %49 = load i16, i16* %type216, align 2, !tbaa !90
  %conv217 = zext i16 %49 to i32
  %and218 = and i32 %conv217, 32767
  %cmp219 = icmp eq i32 %and218, 514
  %name222 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 5
  %arraydecay223 = getelementptr inbounds [64 x i8], [64 x i8]* %name222, i32 0, i32 0
  %arrayidx224 = getelementptr inbounds i8, i8* %buffer, i64 3
  %50 = load i8, i8* %arrayidx224, align 1, !tbaa !82
  %conv225 = zext i8 %50 to i32
  br i1 %cmp219, label %if.then221, label %if.else227

if.then221:                                       ; preds = %if.else215
  %call226 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay223, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.25, i32 0, i32 0), i32 %conv225)
  br label %if.end235

if.else227:                                       ; preds = %if.else215
  %call232 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay223, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.26, i32 0, i32 0), i32 %conv225)
  br label %if.end235

if.end235:                                        ; preds = %if.then209, %if.else227, %if.then221, %if.then199
  %list = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call134, i32 0, i32 0
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %entities)
  br label %cleanup

sw.bb236:                                         ; preds = %NodeBlock
  %cmp237 = icmp slt i32 %buflen, 9
  br i1 %cmp237, label %do.body240, label %if.end252

do.body240:                                       ; preds = %sw.bb236
  %51 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and241 = and i32 %51, 2
  %tobool242 = icmp ne i32 %and241, 0
  br i1 %tobool242, label %if.then243, label %cleanup

if.then243:                                       ; preds = %do.body240
  %devnum244 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %52 = load i32, i32* %devnum244, align 8, !tbaa !98
  %desc245 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber246 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc245, i32 0, i32 2
  %53 = load i8, i8* %bInterfaceNumber246, align 2, !tbaa !54
  %conv247 = zext i8 %53 to i32
  %call248 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([71 x i8], [71 x i8]* @.str.27, i32 0, i32 0), i32 %52, i32 %conv247)
  br label %cleanup

if.end252:                                        ; preds = %sw.bb236
  %arrayidx253 = getelementptr inbounds i8, i8* %buffer, i64 4
  %call254 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx253)
  %conv255 = zext i16 %call254 to i32
  %and256 = and i32 %conv255, 65280
  %cmp257 = icmp eq i32 %and256, 0
  br i1 %cmp257, label %do.body260, label %if.end275

do.body260:                                       ; preds = %if.end252
  %54 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and261 = and i32 %54, 2
  %tobool262 = icmp ne i32 %and261, 0
  br i1 %tobool262, label %if.then263, label %cleanup

if.then263:                                       ; preds = %do.body260
  %devnum264 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %55 = load i32, i32* %devnum264, align 8, !tbaa !98
  %desc265 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber266 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc265, i32 0, i32 2
  %56 = load i8, i8* %bInterfaceNumber266, align 2, !tbaa !54
  %conv267 = zext i8 %56 to i32
  %arrayidx268 = getelementptr inbounds i8, i8* %buffer, i64 3
  %57 = load i8, i8* %arrayidx268, align 1, !tbaa !82
  %conv269 = zext i8 %57 to i32
  %conv270 = zext i16 %call254 to i32
  %call271 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([102 x i8], [102 x i8]* @.str.28, i32 0, i32 0), i32 %55, i32 %conv267, i32 %conv269, i32 %conv270)
  br label %cleanup

if.end275:                                        ; preds = %if.end252
  %conv276 = zext i16 %call254 to i32
  %or = or i32 %conv276, 32768
  %conv277 = trunc i32 %or to i16
  %arrayidx278 = getelementptr inbounds i8, i8* %buffer, i64 3
  %58 = load i8, i8* %arrayidx278, align 1, !tbaa !82
  %call279 = call %struct.uvc_entity* @uvc_alloc_entity(i16 zeroext %conv277, i8 zeroext %58, i32 1, i32 0)
  %cmp280 = icmp eq %struct.uvc_entity* %call279, null
  br i1 %cmp280, label %cleanup, label %if.end283

if.end283:                                        ; preds = %if.end275
  %cmp286 = icmp uge i64 1, 64
  %baSourceID = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call279, i32 0, i32 13
  %59 = load i8*, i8** %baSourceID, align 8, !tbaa !99
  %arrayidx289 = getelementptr inbounds i8, i8* %buffer, i64 7
  br i1 %cmp286, label %if.then288, label %if.else291

if.then288:                                       ; preds = %if.end283
  %call290 = call i8* @__memcpy(i8* %59, i8* %arrayidx289, i64 1)
  br label %if.end294

if.else291:                                       ; preds = %if.end283
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %59, i8* %arrayidx289, i64 1, i32 1, i1 false)
  br label %if.end294

if.end294:                                        ; preds = %if.else291, %if.then288
  %__ret285.0 = phi i8* [ %call290, %if.then288 ], [ %59, %if.else291 ]
  %arrayidx296 = getelementptr inbounds i8, i8* %buffer, i64 8
  %60 = load i8, i8* %arrayidx296, align 1, !tbaa !82
  %conv297 = zext i8 %60 to i32
  %cmp298 = icmp ne i32 %conv297, 0
  br i1 %cmp298, label %if.then300, label %if.else306

if.then300:                                       ; preds = %if.end294
  %arrayidx301 = getelementptr inbounds i8, i8* %buffer, i64 8
  %61 = load i8, i8* %arrayidx301, align 1, !tbaa !82
  %conv302 = zext i8 %61 to i32
  %name303 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call279, i32 0, i32 5
  %arraydecay304 = getelementptr inbounds [64 x i8], [64 x i8]* %name303, i32 0, i32 0
  %call305 = call i32 @usb_string(%struct.usb_device* %0, i32 %conv302, i8* %arraydecay304, i64 64)
  br label %if.end312

if.else306:                                       ; preds = %if.end294
  %name307 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call279, i32 0, i32 5
  %arraydecay308 = getelementptr inbounds [64 x i8], [64 x i8]* %name307, i32 0, i32 0
  %arrayidx309 = getelementptr inbounds i8, i8* %buffer, i64 3
  %62 = load i8, i8* %arrayidx309, align 1, !tbaa !82
  %conv310 = zext i8 %62 to i32
  %call311 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay308, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.29, i32 0, i32 0), i32 %conv310)
  br label %if.end312

if.end312:                                        ; preds = %if.else306, %if.then300
  %list313 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call279, i32 0, i32 0
  %entities314 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list313, %struct.list_head* %entities314)
  br label %cleanup

sw.bb315:                                         ; preds = %NodeBlock7
  %cmp316 = icmp sge i32 %buflen, 5
  br i1 %cmp316, label %cond.true318, label %cond.end322

cond.true318:                                     ; preds = %sw.bb315
  %arrayidx319 = getelementptr inbounds i8, i8* %buffer, i64 4
  %63 = load i8, i8* %arrayidx319, align 1, !tbaa !82
  %conv320 = zext i8 %63 to i32
  br label %cond.end322

cond.end322:                                      ; preds = %sw.bb315, %cond.true318
  %cond323 = phi i32 [ %conv320, %cond.true318 ], [ 0, %sw.bb315 ]
  %cmp324 = icmp slt i32 %buflen, 5
  %add326 = add i32 6, %cond323
  %cmp327 = icmp ult i32 %buflen, %add326
  %or.cond = or i1 %cmp324, %cmp327
  br i1 %or.cond, label %do.body330, label %if.end342

do.body330:                                       ; preds = %cond.end322
  %64 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and331 = and i32 %64, 2
  %tobool332 = icmp ne i32 %and331, 0
  br i1 %tobool332, label %if.then333, label %cleanup

if.then333:                                       ; preds = %do.body330
  %devnum334 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %65 = load i32, i32* %devnum334, align 8, !tbaa !98
  %desc335 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber336 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc335, i32 0, i32 2
  %66 = load i8, i8* %bInterfaceNumber336, align 2, !tbaa !54
  %conv337 = zext i8 %66 to i32
  %call338 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.30, i32 0, i32 0), i32 %65, i32 %conv337)
  br label %cleanup

if.end342:                                        ; preds = %cond.end322
  %arrayidx343 = getelementptr inbounds i8, i8* %buffer, i64 2
  %67 = load i8, i8* %arrayidx343, align 1, !tbaa !82
  %conv344 = zext i8 %67 to i16
  %arrayidx345 = getelementptr inbounds i8, i8* %buffer, i64 3
  %68 = load i8, i8* %arrayidx345, align 1, !tbaa !82
  %add346 = add i32 %cond323, 1
  %call347 = call %struct.uvc_entity* @uvc_alloc_entity(i16 zeroext %conv344, i8 zeroext %68, i32 %add346, i32 0)
  %cmp348 = icmp eq %struct.uvc_entity* %call347, null
  br i1 %cmp348, label %cleanup, label %if.end351

if.end351:                                        ; preds = %if.end342
  %conv353 = zext i32 %cond323 to i64
  %baSourceID355 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call347, i32 0, i32 13
  %69 = load i8*, i8** %baSourceID355, align 8, !tbaa !99
  %arrayidx356 = getelementptr inbounds i8, i8* %buffer, i64 5
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %69, i8* %arrayidx356, i64 %conv353, i32 1, i1 false)
  %add358 = add i32 5, %cond323
  %idxprom359 = zext i32 %add358 to i64
  %arrayidx360 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom359
  %70 = load i8, i8* %arrayidx360, align 1, !tbaa !82
  %conv361 = zext i8 %70 to i32
  %cmp362 = icmp ne i32 %conv361, 0
  br i1 %cmp362, label %if.then364, label %if.else372

if.then364:                                       ; preds = %if.end351
  %add365 = add i32 5, %cond323
  %idxprom366 = zext i32 %add365 to i64
  %arrayidx367 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom366
  %71 = load i8, i8* %arrayidx367, align 1, !tbaa !82
  %conv368 = zext i8 %71 to i32
  %name369 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call347, i32 0, i32 5
  %arraydecay370 = getelementptr inbounds [64 x i8], [64 x i8]* %name369, i32 0, i32 0
  %call371 = call i32 @usb_string(%struct.usb_device* %0, i32 %conv368, i8* %arraydecay370, i64 64)
  br label %if.end378

if.else372:                                       ; preds = %if.end351
  %name373 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call347, i32 0, i32 5
  %arraydecay374 = getelementptr inbounds [64 x i8], [64 x i8]* %name373, i32 0, i32 0
  %arrayidx375 = getelementptr inbounds i8, i8* %buffer, i64 3
  %72 = load i8, i8* %arrayidx375, align 1, !tbaa !82
  %conv376 = zext i8 %72 to i32
  %call377 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay374, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.31, i32 0, i32 0), i32 %conv376)
  br label %if.end378

if.end378:                                        ; preds = %if.else372, %if.then364
  %list379 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call347, i32 0, i32 0
  %entities380 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list379, %struct.list_head* %entities380)
  br label %cleanup

sw.bb381:                                         ; preds = %NodeBlock5
  %cmp382 = icmp sge i32 %buflen, 8
  br i1 %cmp382, label %cond.true384, label %cond.end388

cond.true384:                                     ; preds = %sw.bb381
  %arrayidx385 = getelementptr inbounds i8, i8* %buffer, i64 7
  %73 = load i8, i8* %arrayidx385, align 1, !tbaa !82
  %conv386 = zext i8 %73 to i32
  br label %cond.end388

cond.end388:                                      ; preds = %sw.bb381, %cond.true384
  %cond389 = phi i32 [ %conv386, %cond.true384 ], [ 0, %sw.bb381 ]
  %uvc_version390 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 10
  %74 = load i16, i16* %uvc_version390, align 8, !tbaa !65
  %conv391 = zext i16 %74 to i32
  %cmp392 = icmp sge i32 %conv391, 272
  %75 = zext i1 %cmp392 to i64
  %cond394 = select i1 %cmp392, i32 10, i32 9
  %add395 = add i32 %cond394, %cond389
  %cmp396 = icmp ult i32 %buflen, %add395
  br i1 %cmp396, label %do.body399, label %if.end411

do.body399:                                       ; preds = %cond.end388
  %76 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and400 = and i32 %76, 2
  %tobool401 = icmp ne i32 %and400, 0
  br i1 %tobool401, label %if.then402, label %cleanup

if.then402:                                       ; preds = %do.body399
  %devnum403 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %77 = load i32, i32* %devnum403, align 8, !tbaa !98
  %desc404 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber405 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc404, i32 0, i32 2
  %78 = load i8, i8* %bInterfaceNumber405, align 2, !tbaa !54
  %conv406 = zext i8 %78 to i32
  %call407 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([71 x i8], [71 x i8]* @.str.32, i32 0, i32 0), i32 %77, i32 %conv406)
  br label %cleanup

if.end411:                                        ; preds = %cond.end388
  %arrayidx412 = getelementptr inbounds i8, i8* %buffer, i64 2
  %79 = load i8, i8* %arrayidx412, align 1, !tbaa !82
  %conv413 = zext i8 %79 to i16
  %arrayidx414 = getelementptr inbounds i8, i8* %buffer, i64 3
  %80 = load i8, i8* %arrayidx414, align 1, !tbaa !82
  %call415 = call %struct.uvc_entity* @uvc_alloc_entity(i16 zeroext %conv413, i8 zeroext %80, i32 2, i32 %cond389)
  %cmp416 = icmp eq %struct.uvc_entity* %call415, null
  br i1 %cmp416, label %cleanup, label %if.end419

if.end419:                                        ; preds = %if.end411
  %cmp422 = icmp uge i64 1, 64
  %baSourceID425 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 13
  %81 = load i8*, i8** %baSourceID425, align 8, !tbaa !99
  %arrayidx426 = getelementptr inbounds i8, i8* %buffer, i64 4
  br i1 %cmp422, label %if.then424, label %if.else428

if.then424:                                       ; preds = %if.end419
  %call427 = call i8* @__memcpy(i8* %81, i8* %arrayidx426, i64 1)
  br label %if.end431

if.else428:                                       ; preds = %if.end419
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %81, i8* %arrayidx426, i64 1, i32 1, i1 false)
  br label %if.end431

if.end431:                                        ; preds = %if.else428, %if.then424
  %__ret421.0 = phi i8* [ %call427, %if.then424 ], [ %81, %if.else428 ]
  %arrayidx433 = getelementptr inbounds i8, i8* %buffer, i64 5
  %call434 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx433)
  %82 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 11
  %processing = bitcast %union.anon.57* %82 to %struct.anon.61*
  %wMaxMultiplier = getelementptr inbounds %struct.anon.61, %struct.anon.61* %processing, i32 0, i32 0
  store i16 %call434, i16* %wMaxMultiplier, align 8, !tbaa !82
  %arrayidx435 = getelementptr inbounds i8, i8* %buffer, i64 7
  %83 = load i8, i8* %arrayidx435, align 1, !tbaa !82
  %84 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 11
  %processing436 = bitcast %union.anon.57* %84 to %struct.anon.61*
  %bControlSize437 = getelementptr inbounds %struct.anon.61, %struct.anon.61* %processing436, i32 0, i32 1
  store i8 %83, i8* %bControlSize437, align 2, !tbaa !82
  %85 = bitcast %struct.uvc_entity* %call415 to i8*
  %add.ptr438 = getelementptr inbounds i8, i8* %85, i64 384
  %86 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 11
  %processing439 = bitcast %union.anon.57* %86 to %struct.anon.61*
  %bmControls440 = getelementptr inbounds %struct.anon.61, %struct.anon.61* %processing439, i32 0, i32 2
  store i8* %add.ptr438, i8** %bmControls440, align 8, !tbaa !82
  %conv442 = zext i32 %cond389 to i64
  %87 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 11
  %processing444 = bitcast %union.anon.57* %87 to %struct.anon.61*
  %bmControls445 = getelementptr inbounds %struct.anon.61, %struct.anon.61* %processing444, i32 0, i32 2
  %88 = load i8*, i8** %bmControls445, align 8, !tbaa !82
  %arrayidx446 = getelementptr inbounds i8, i8* %buffer, i64 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %88, i8* %arrayidx446, i64 %conv442, i32 1, i1 false)
  %uvc_version448 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 10
  %89 = load i16, i16* %uvc_version448, align 8, !tbaa !65
  %conv449 = zext i16 %89 to i32
  %cmp450 = icmp sge i32 %conv449, 272
  br i1 %cmp450, label %if.then452, label %if.end457

if.then452:                                       ; preds = %if.end431
  %add453 = add i32 9, %cond389
  %idxprom454 = zext i32 %add453 to i64
  %arrayidx455 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom454
  %90 = load i8, i8* %arrayidx455, align 1, !tbaa !82
  %91 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 11
  %processing456 = bitcast %union.anon.57* %91 to %struct.anon.61*
  %bmVideoStandards = getelementptr inbounds %struct.anon.61, %struct.anon.61* %processing456, i32 0, i32 3
  store i8 %90, i8* %bmVideoStandards, align 8, !tbaa !82
  br label %if.end457

if.end457:                                        ; preds = %if.then452, %if.end431
  %add458 = add i32 8, %cond389
  %idxprom459 = zext i32 %add458 to i64
  %arrayidx460 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom459
  %92 = load i8, i8* %arrayidx460, align 1, !tbaa !82
  %conv461 = zext i8 %92 to i32
  %cmp462 = icmp ne i32 %conv461, 0
  br i1 %cmp462, label %if.then464, label %if.else472

if.then464:                                       ; preds = %if.end457
  %add465 = add i32 8, %cond389
  %idxprom466 = zext i32 %add465 to i64
  %arrayidx467 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom466
  %93 = load i8, i8* %arrayidx467, align 1, !tbaa !82
  %conv468 = zext i8 %93 to i32
  %name469 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 5
  %arraydecay470 = getelementptr inbounds [64 x i8], [64 x i8]* %name469, i32 0, i32 0
  %call471 = call i32 @usb_string(%struct.usb_device* %0, i32 %conv468, i8* %arraydecay470, i64 64)
  br label %if.end478

if.else472:                                       ; preds = %if.end457
  %name473 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 5
  %arraydecay474 = getelementptr inbounds [64 x i8], [64 x i8]* %name473, i32 0, i32 0
  %arrayidx475 = getelementptr inbounds i8, i8* %buffer, i64 3
  %94 = load i8, i8* %arrayidx475, align 1, !tbaa !82
  %conv476 = zext i8 %94 to i32
  %call477 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay474, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.33, i32 0, i32 0), i32 %conv476)
  br label %if.end478

if.end478:                                        ; preds = %if.else472, %if.then464
  %list479 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call415, i32 0, i32 0
  %entities480 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list479, %struct.list_head* %entities480)
  br label %cleanup

sw.bb481:                                         ; preds = %LeafBlock3
  %cmp482 = icmp sge i32 %buflen, 22
  br i1 %cmp482, label %cond.true484, label %cond.end488

cond.true484:                                     ; preds = %sw.bb481
  %arrayidx485 = getelementptr inbounds i8, i8* %buffer, i64 21
  %95 = load i8, i8* %arrayidx485, align 1, !tbaa !82
  %conv486 = zext i8 %95 to i32
  br label %cond.end488

cond.end488:                                      ; preds = %sw.bb481, %cond.true484
  %cond489 = phi i32 [ %conv486, %cond.true484 ], [ 0, %sw.bb481 ]
  %add490 = add i32 24, %cond489
  %cmp491 = icmp uge i32 %buflen, %add490
  br i1 %cmp491, label %cond.true493, label %cond.end499

cond.true493:                                     ; preds = %cond.end488
  %add494 = add i32 22, %cond489
  %idxprom495 = zext i32 %add494 to i64
  %arrayidx496 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom495
  %96 = load i8, i8* %arrayidx496, align 1, !tbaa !82
  %conv497 = zext i8 %96 to i32
  br label %cond.end499

cond.end499:                                      ; preds = %cond.end488, %cond.true493
  %cond500 = phi i32 [ %conv497, %cond.true493 ], [ 0, %cond.end488 ]
  %add501 = add i32 24, %cond489
  %add502 = add i32 %add501, %cond500
  %cmp503 = icmp ult i32 %buflen, %add502
  br i1 %cmp503, label %do.body506, label %if.end518

do.body506:                                       ; preds = %cond.end499
  %97 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and507 = and i32 %97, 2
  %tobool508 = icmp ne i32 %and507, 0
  br i1 %tobool508, label %if.then509, label %cleanup

if.then509:                                       ; preds = %do.body506
  %devnum510 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %0, i32 0, i32 0
  %98 = load i32, i32* %devnum510, align 8, !tbaa !98
  %desc511 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber512 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc511, i32 0, i32 2
  %99 = load i8, i8* %bInterfaceNumber512, align 2, !tbaa !54
  %conv513 = zext i8 %99 to i32
  %call514 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.18, i32 0, i32 0), i32 %98, i32 %conv513)
  br label %cleanup

if.end518:                                        ; preds = %cond.end499
  %arrayidx519 = getelementptr inbounds i8, i8* %buffer, i64 2
  %100 = load i8, i8* %arrayidx519, align 1, !tbaa !82
  %conv520 = zext i8 %100 to i16
  %arrayidx521 = getelementptr inbounds i8, i8* %buffer, i64 3
  %101 = load i8, i8* %arrayidx521, align 1, !tbaa !82
  %add522 = add i32 %cond489, 1
  %call523 = call %struct.uvc_entity* @uvc_alloc_entity(i16 zeroext %conv520, i8 zeroext %101, i32 %add522, i32 %cond500)
  %cmp524 = icmp eq %struct.uvc_entity* %call523, null
  br i1 %cmp524, label %cleanup, label %if.end527

if.end527:                                        ; preds = %if.end518
  %cmp530 = icmp uge i64 16, 64
  %102 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 11
  %extension = bitcast %union.anon.57* %102 to %struct.anon.63*
  %guidExtensionCode = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension, i32 0, i32 0
  %arraydecay533 = getelementptr inbounds [16 x i8], [16 x i8]* %guidExtensionCode, i32 0, i32 0
  %arrayidx534 = getelementptr inbounds i8, i8* %buffer, i64 4
  br i1 %cmp530, label %if.then532, label %if.else536

if.then532:                                       ; preds = %if.end527
  %call535 = call i8* @__memcpy(i8* %arraydecay533, i8* %arrayidx534, i64 16)
  br label %if.end541

if.else536:                                       ; preds = %if.end527
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arraydecay533, i8* %arrayidx534, i64 16, i32 1, i1 false)
  br label %if.end541

if.end541:                                        ; preds = %if.else536, %if.then532
  %__ret529.0 = phi i8* [ %call535, %if.then532 ], [ %arraydecay533, %if.else536 ]
  %arrayidx543 = getelementptr inbounds i8, i8* %buffer, i64 20
  %103 = load i8, i8* %arrayidx543, align 1, !tbaa !82
  %104 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 11
  %extension544 = bitcast %union.anon.57* %104 to %struct.anon.63*
  %bNumControls = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension544, i32 0, i32 1
  store i8 %103, i8* %bNumControls, align 8, !tbaa !82
  %conv546 = zext i32 %cond489 to i64
  %baSourceID548 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 13
  %105 = load i8*, i8** %baSourceID548, align 8, !tbaa !99
  %arrayidx549 = getelementptr inbounds i8, i8* %buffer, i64 22
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %105, i8* %arrayidx549, i64 %conv546, i32 1, i1 false)
  %add551 = add i32 22, %cond489
  %idxprom552 = zext i32 %add551 to i64
  %arrayidx553 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom552
  %106 = load i8, i8* %arrayidx553, align 1, !tbaa !82
  %107 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 11
  %extension554 = bitcast %union.anon.57* %107 to %struct.anon.63*
  %bControlSize555 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension554, i32 0, i32 2
  store i8 %106, i8* %bControlSize555, align 1, !tbaa !82
  %108 = bitcast %struct.uvc_entity* %call523 to i8*
  %add.ptr556 = getelementptr inbounds i8, i8* %108, i64 384
  %109 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 11
  %extension557 = bitcast %union.anon.57* %109 to %struct.anon.63*
  %bmControls558 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension557, i32 0, i32 3
  store i8* %add.ptr556, i8** %bmControls558, align 8, !tbaa !82
  %conv560 = zext i32 %cond500 to i64
  %110 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 11
  %extension562 = bitcast %union.anon.57* %110 to %struct.anon.63*
  %bmControls563 = getelementptr inbounds %struct.anon.63, %struct.anon.63* %extension562, i32 0, i32 3
  %111 = load i8*, i8** %bmControls563, align 8, !tbaa !82
  %add564 = add i32 23, %cond489
  %idxprom565 = zext i32 %add564 to i64
  %arrayidx566 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom565
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %111, i8* %arrayidx566, i64 %conv560, i32 1, i1 false)
  %add568 = add i32 23, %cond489
  %add569 = add i32 %add568, %cond500
  %idxprom570 = zext i32 %add569 to i64
  %arrayidx571 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom570
  %112 = load i8, i8* %arrayidx571, align 1, !tbaa !82
  %conv572 = zext i8 %112 to i32
  %cmp573 = icmp ne i32 %conv572, 0
  br i1 %cmp573, label %if.then575, label %if.else584

if.then575:                                       ; preds = %if.end541
  %add576 = add i32 23, %cond489
  %add577 = add i32 %add576, %cond500
  %idxprom578 = zext i32 %add577 to i64
  %arrayidx579 = getelementptr inbounds i8, i8* %buffer, i64 %idxprom578
  %113 = load i8, i8* %arrayidx579, align 1, !tbaa !82
  %conv580 = zext i8 %113 to i32
  %name581 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 5
  %arraydecay582 = getelementptr inbounds [64 x i8], [64 x i8]* %name581, i32 0, i32 0
  %call583 = call i32 @usb_string(%struct.usb_device* %0, i32 %conv580, i8* %arraydecay582, i64 64)
  br label %if.end590

if.else584:                                       ; preds = %if.end541
  %name585 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 5
  %arraydecay586 = getelementptr inbounds [64 x i8], [64 x i8]* %name585, i32 0, i32 0
  %arrayidx587 = getelementptr inbounds i8, i8* %buffer, i64 3
  %114 = load i8, i8* %arrayidx587, align 1, !tbaa !82
  %conv588 = zext i8 %114 to i32
  %call589 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay586, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.19, i32 0, i32 0), i32 %conv588)
  br label %if.end590

if.end590:                                        ; preds = %if.else584, %if.then575
  %list591 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call523, i32 0, i32 0
  %entities592 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %list591, %struct.list_head* %entities592)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock
  br label %do.body593

do.body593:                                       ; preds = %NewDefault
  %115 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and594 = and i32 %115, 2
  %tobool595 = icmp ne i32 %and594, 0
  br i1 %tobool595, label %if.then596, label %cleanup

if.then596:                                       ; preds = %do.body593
  %arrayidx597 = getelementptr inbounds i8, i8* %buffer, i64 2
  %116 = load i8, i8* %arrayidx597, align 1, !tbaa !82
  %conv598 = zext i8 %116 to i32
  %call599 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.34, i32 0, i32 0), i32 %conv598)
  br label %cleanup

cleanup:                                          ; preds = %if.end235, %if.end312, %if.end378, %if.end478, %if.end590, %for.cond, %if.then596, %do.body593, %if.end518, %do.body506, %if.then509, %if.end411, %do.body399, %if.then402, %if.end342, %do.body330, %if.then333, %if.end275, %do.body260, %if.then263, %do.body240, %if.then243, %if.end129, %do.body117, %if.then120, %do.body59, %if.then62, %do.body39, %if.then42, %do.body, %if.then8
  %retval.0 = phi i32 [ -22, %if.then8 ], [ -22, %do.body ], [ -22, %if.then42 ], [ -22, %do.body39 ], [ 0, %if.then62 ], [ 0, %do.body59 ], [ -22, %if.then120 ], [ -22, %do.body117 ], [ -12, %if.end129 ], [ -22, %if.then243 ], [ -22, %do.body240 ], [ 0, %if.then263 ], [ 0, %do.body260 ], [ -12, %if.end275 ], [ -22, %if.then333 ], [ -22, %do.body330 ], [ -12, %if.end342 ], [ -22, %if.then402 ], [ -22, %do.body399 ], [ -12, %if.end411 ], [ -22, %if.then509 ], [ -22, %do.body506 ], [ -12, %if.end518 ], [ 0, %do.body593 ], [ 0, %if.then596 ], [ 0, %for.cond ], [ 0, %if.end590 ], [ 0, %if.end478 ], [ 0, %if.end378 ], [ 0, %if.end312 ], [ 0, %if.end235 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_is_int_in(%struct.usb_endpoint_descriptor* %epd) #4 {
entry:
  %call = call i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call1 = call i32 @usb_endpoint_dir_in(%struct.usb_endpoint_descriptor* %epd)
  %tobool2 = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %tobool2, %land.rhs ]
  %land.ext = zext i1 %0 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal %struct.uvc_entity* @uvc_alloc_entity(i16 zeroext %type, i8 zeroext %id, i32 %num_pads, i32 %extra_size) #0 {
entry:
  %add = add i32 %extra_size, 55
  %and = and i32 %add, -56
  %conv = zext i16 %type to i32
  %and1 = and i32 %conv, 32768
  %tobool = icmp ne i32 %and1, 0
  %sub = sub i32 %num_pads, 1
  %cond = select i1 %tobool, i32 %num_pads, i32 %sub
  %conv2 = zext i32 %and to i64
  %add3 = add i64 384, %conv2
  %conv4 = zext i32 %num_pads to i64
  %mul = mul i64 56, %conv4
  %add5 = add i64 %add3, %mul
  %conv6 = zext i32 %cond to i64
  %add7 = add i64 %add5, %conv6
  %conv8 = trunc i64 %add7 to i32
  %conv9 = zext i32 %conv8 to i64
  %call = call i8* @kzalloc(i64 %conv9, i32 20971712)
  %0 = bitcast i8* %call to %struct.uvc_entity*
  %cmp = icmp eq %struct.uvc_entity* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %id11 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 3
  store i8 %id, i8* %id11, align 4, !tbaa !19
  %type12 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 4
  store i16 %type, i16* %type12, align 2, !tbaa !90
  %num_links = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 9
  store i32 0, i32* %num_links, align 4, !tbaa !101
  %num_pads13 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 8
  store i32 %num_pads, i32* %num_pads13, align 8, !tbaa !102
  %add.ptr = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i64 1
  %1 = bitcast %struct.uvc_entity* %add.ptr to i8*
  %idx.ext = zext i32 %and to i64
  %add.ptr14 = getelementptr i8, i8* %1, i64 %idx.ext
  %2 = bitcast i8* %add.ptr14 to %struct.media_pad*
  %pads = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 10
  store %struct.media_pad* %2, %struct.media_pad** %pads, align 8, !tbaa !103
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %cmp15 = icmp ult i32 %i.0, %cond
  br i1 %cmp15, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %pads17 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 10
  %3 = load %struct.media_pad*, %struct.media_pad** %pads17, align 8, !tbaa !103
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.media_pad, %struct.media_pad* %3, i64 %idxprom
  %flags = getelementptr inbounds %struct.media_pad, %struct.media_pad* %arrayidx, i32 0, i32 3
  store i64 1, i64* %flags, align 8, !tbaa !104
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %type18 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 4
  %4 = load i16, i16* %type18, align 2, !tbaa !90
  %conv19 = zext i16 %4 to i32
  %and20 = and i32 %conv19, 65280
  %cmp21 = icmp ne i32 %and20, 0
  br i1 %cmp21, label %land.lhs.true, label %if.then28

land.lhs.true:                                    ; preds = %for.end
  %type23 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 4
  %5 = load i16, i16* %type23, align 2, !tbaa !90
  %conv24 = zext i16 %5 to i32
  %and25 = and i32 %conv24, 32768
  %cmp26 = icmp eq i32 %and25, 32768
  br i1 %cmp26, label %if.end34, label %if.then28

if.then28:                                        ; preds = %land.lhs.true, %for.end
  %pads29 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 10
  %6 = load %struct.media_pad*, %struct.media_pad** %pads29, align 8, !tbaa !103
  %sub30 = sub i32 %num_pads, 1
  %idxprom31 = zext i32 %sub30 to i64
  %arrayidx32 = getelementptr inbounds %struct.media_pad, %struct.media_pad* %6, i64 %idxprom31
  %flags33 = getelementptr inbounds %struct.media_pad, %struct.media_pad* %arrayidx32, i32 0, i32 3
  store i64 2, i64* %flags33, align 8, !tbaa !104
  br label %if.end34

if.end34:                                         ; preds = %if.then28, %land.lhs.true
  %conv35 = trunc i32 %cond to i8
  %bNrInPins = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 12
  store i8 %conv35, i8* %bNrInPins, align 8, !tbaa !107
  %pads36 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 10
  %7 = load %struct.media_pad*, %struct.media_pad** %pads36, align 8, !tbaa !103
  %idxprom37 = zext i32 %num_pads to i64
  %arrayidx38 = getelementptr inbounds %struct.media_pad, %struct.media_pad* %7, i64 %idxprom37
  %8 = bitcast %struct.media_pad* %arrayidx38 to i8*
  %baSourceID = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 13
  store i8* %8, i8** %baSourceID, align 8, !tbaa !99
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end34
  %retval.0 = phi %struct.uvc_entity* [ %0, %if.end34 ], [ null, %entry ]
  ret %struct.uvc_entity* %retval.0
}

declare i8* @__memcpy(i8*, i8*, i64) #3

declare i32 @usb_string(%struct.usb_device*, i32, i8*, i64) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #4 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !83
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #4 {
entry:
  %__u = alloca %union.anon.70, align 8
  %call = call zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next)
  br i1 %call, label %if.end, label %return

if.end:                                           ; preds = %entry
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !83
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !108
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !83
  %0 = bitcast %union.anon.70* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %__val = bitcast %union.anon.70* %__u to %struct.list_head**
  store %struct.list_head* %new, %struct.list_head** %__val, align 8, !tbaa !82
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next4 to i8*
  %__c = bitcast %union.anon.70* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val5 = bitcast %union.anon.70* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val5, align 8, !tbaa !82
  %3 = bitcast %union.anon.70* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #5
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @__list_add_valid(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #4 {
entry:
  ret i1 true
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i16 @get_unaligned_le16(i8* %p) #2 {
entry:
  %0 = bitcast i8* %p to i16*
  %call = call zeroext i16 @__le16_to_cpup(i16* %0)
  ret i16 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @get_unaligned_le32(i8* %p) #2 {
entry:
  %0 = bitcast i8* %p to i32*
  %call = call i32 @__le32_to_cpup(i32* %0)
  ret i32 %call
}

declare %struct.usb_interface* @usb_ifnum_to_if(%struct.usb_device*, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @uvc_parse_streaming(%struct.uvc_device* %dev, %struct.usb_interface* %intf) #0 {
entry:
  %interval = alloca i32*, align 8
  %altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %0 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting, align 8, !tbaa !109
  %arrayidx = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %0, i64 0
  %extra = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 2
  %1 = load i8*, i8** %extra, align 8, !tbaa !84
  %extralen = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 1
  %2 = load i32, i32* %extralen, align 4, !tbaa !85
  %3 = bitcast i32** %interval to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %4 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %4, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 6
  %5 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !66
  %conv = zext i8 %5 to i32
  %cmp = icmp ne i32 %conv, 2
  br i1 %cmp, label %do.body, label %if.end7

do.body:                                          ; preds = %entry
  %6 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %6, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %cleanup398

if.then2:                                         ; preds = %do.body
  %udev = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %7 = load %struct.usb_device*, %struct.usb_device** %udev, align 8, !tbaa !27
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %7, i32 0, i32 0
  %8 = load i32, i32* %devnum, align 8, !tbaa !98
  %altsetting3 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %9 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting3, align 8, !tbaa !109
  %arrayidx4 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %9, i64 0
  %desc5 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx4, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc5, i32 0, i32 2
  %10 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !54
  %conv6 = zext i8 %10 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.35, i32 0, i32 0), i32 %8, i32 %conv6)
  br label %cleanup398

if.end7:                                          ; preds = %entry
  %11 = bitcast %struct.uvc_device* %dev to i8*
  %call8 = call i32 @usb_driver_claim_interface(%struct.usb_driver* getelementptr inbounds (%struct.uvc_driver, %struct.uvc_driver* @uvc_driver, i32 0, i32 0), %struct.usb_interface* %intf, i8* %11)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %do.body11, label %if.end26

do.body11:                                        ; preds = %if.end7
  %12 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and12 = and i32 %12, 2
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %cleanup398

if.then14:                                        ; preds = %do.body11
  %udev15 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %13 = load %struct.usb_device*, %struct.usb_device** %udev15, align 8, !tbaa !27
  %devnum16 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %13, i32 0, i32 0
  %14 = load i32, i32* %devnum16, align 8, !tbaa !98
  %altsetting17 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %15 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting17, align 8, !tbaa !109
  %arrayidx18 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %15, i64 0
  %desc19 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx18, i32 0, i32 0
  %bInterfaceNumber20 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc19, i32 0, i32 2
  %16 = load i8, i8* %bInterfaceNumber20, align 2, !tbaa !54
  %conv21 = zext i8 %16 to i32
  %call22 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.36, i32 0, i32 0), i32 %14, i32 %conv21)
  br label %cleanup398

if.end26:                                         ; preds = %if.end7
  %call27 = call i8* @kzalloc(i64 2392, i32 20971712)
  %17 = bitcast i8* %call27 to %struct.uvc_streaming*
  %cmp28 = icmp eq %struct.uvc_streaming* %17, null
  br i1 %cmp28, label %if.then30, label %do.body32

if.then30:                                        ; preds = %if.end26
  call void @usb_driver_release_interface(%struct.usb_driver* getelementptr inbounds (%struct.uvc_driver, %struct.uvc_driver* @uvc_driver, i32 0, i32 0), %struct.usb_interface* %intf)
  br label %cleanup398

do.body32:                                        ; preds = %if.end26
  %mutex = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 16
  call void @__mutex_init(%struct.mutex* %mutex, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.37, i32 0, i32 0), %struct.lock_class_key* @uvc_parse_streaming.__key)
  %dev35 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 1
  store %struct.uvc_device* %dev, %struct.uvc_device** %dev35, align 8, !tbaa !110
  %call36 = call %struct.usb_interface* @usb_get_intf(%struct.usb_interface* %intf)
  %intf37 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 5
  store %struct.usb_interface* %call36, %struct.usb_interface** %intf37, align 8, !tbaa !68
  %cur_altsetting38 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %18 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting38, align 8, !tbaa !39
  %desc39 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %18, i32 0, i32 0
  %bInterfaceNumber40 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc39, i32 0, i32 2
  %19 = load i8, i8* %bInterfaceNumber40, align 2, !tbaa !54
  %conv41 = zext i8 %19 to i32
  %intfnum = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 6
  store i32 %conv41, i32* %intfnum, align 8, !tbaa !111
  %cmp42 = icmp eq i32 %2, 0
  br i1 %cmp42, label %if.then44, label %if.end81

if.then44:                                        ; preds = %do.body32
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then44
  %i.0 = phi i32 [ 0, %if.then44 ], [ %inc, %for.inc ]
  %buflen.0 = phi i32 [ %2, %if.then44 ], [ %buflen.1, %for.inc ]
  %buffer.0 = phi i8* [ %1, %if.then44 ], [ %buffer.1, %for.inc ]
  %desc45 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bNumEndpoints = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc45, i32 0, i32 4
  %20 = load i8, i8* %bNumEndpoints, align 4, !tbaa !2
  %conv46 = zext i8 %20 to i32
  %cmp47 = icmp ult i32 %i.0, %conv46
  br i1 %cmp47, label %for.body, label %if.end81

for.body:                                         ; preds = %for.cond
  %endpoint = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 3
  %21 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint, align 8, !tbaa !9
  %idxprom = zext i32 %i.0 to i64
  %arrayidx49 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %21, i64 %idxprom
  %extralen50 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx49, i32 0, i32 8
  %22 = load i32, i32* %extralen50, align 8, !tbaa !112
  %cmp51 = icmp eq i32 %22, 0
  br i1 %cmp51, label %cleanup, label %if.end54

if.end54:                                         ; preds = %for.body
  %extralen55 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx49, i32 0, i32 8
  %23 = load i32, i32* %extralen55, align 8, !tbaa !112
  %cmp56 = icmp sgt i32 %23, 2
  br i1 %cmp56, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %if.end54
  %extra58 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx49, i32 0, i32 7
  %24 = load i8*, i8** %extra58, align 8, !tbaa !113
  %arrayidx59 = getelementptr inbounds i8, i8* %24, i64 1
  %25 = load i8, i8* %arrayidx59, align 1, !tbaa !82
  %conv60 = zext i8 %25 to i32
  %cmp61 = icmp eq i32 %conv60, 36
  br i1 %cmp61, label %do.body64, label %cleanup

do.body64:                                        ; preds = %land.lhs.true
  %26 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and65 = and i32 %26, 2
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then67, label %do.end71

if.then67:                                        ; preds = %do.body64
  %call68 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.38, i32 0, i32 0), i32 %i.0)
  br label %do.end71

do.end71:                                         ; preds = %if.then67, %do.body64
  %endpoint72 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 3
  %27 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint72, align 8, !tbaa !9
  %idxprom73 = zext i32 %i.0 to i64
  %arrayidx74 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %27, i64 %idxprom73
  %extra75 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx74, i32 0, i32 7
  %28 = load i8*, i8** %extra75, align 8, !tbaa !113
  %endpoint76 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 3
  %29 = load %struct.usb_host_endpoint*, %struct.usb_host_endpoint** %endpoint76, align 8, !tbaa !9
  %idxprom77 = zext i32 %i.0 to i64
  %arrayidx78 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %29, i64 %idxprom77
  %extralen79 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %arrayidx78, i32 0, i32 8
  %30 = load i32, i32* %extralen79, align 8, !tbaa !112
  br label %cleanup

cleanup:                                          ; preds = %if.end54, %land.lhs.true, %for.body, %do.end71
  %buflen.1 = phi i32 [ %30, %do.end71 ], [ %buflen.0, %for.body ], [ %buflen.0, %land.lhs.true ], [ %buflen.0, %if.end54 ]
  %buffer.1 = phi i8* [ %28, %do.end71 ], [ %buffer.0, %for.body ], [ %buffer.0, %land.lhs.true ], [ %buffer.0, %if.end54 ]
  %cleanup.dest.slot.0 = phi i32 [ 8, %do.end71 ], [ 10, %for.body ], [ 0, %land.lhs.true ], [ 0, %if.end54 ]
  %cleanup.dest.slot.0.off = add i32 %cleanup.dest.slot.0, -8
  %switch = icmp ult i32 %cleanup.dest.slot.0.off, 1
  br i1 %switch, label %if.end81, label %for.inc

for.inc:                                          ; preds = %cleanup
  %inc = add i32 %i.0, 1
  br label %for.cond

if.end81:                                         ; preds = %cleanup, %for.cond, %do.body32
  %buflen.3 = phi i32 [ %2, %do.body32 ], [ %buflen.1, %cleanup ], [ %buflen.0, %for.cond ]
  %buffer.3 = phi i8* [ %1, %do.body32 ], [ %buffer.1, %cleanup ], [ %buffer.0, %for.cond ]
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end81
  %buflen.4 = phi i32 [ %buflen.3, %if.end81 ], [ %sub, %while.body ]
  %buffer.4 = phi i8* [ %buffer.3, %if.end81 ], [ %add.ptr, %while.body ]
  %cmp82 = icmp sgt i32 %buflen.4, 2
  br i1 %cmp82, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %while.cond
  %arrayidx84 = getelementptr inbounds i8, i8* %buffer.4, i64 1
  %31 = load i8, i8* %arrayidx84, align 1, !tbaa !82
  %conv85 = zext i8 %31 to i32
  %cmp86 = icmp ne i32 %conv85, 36
  br i1 %cmp86, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %arrayidx88 = getelementptr inbounds i8, i8* %buffer.4, i64 0
  %32 = load i8, i8* %arrayidx88, align 1, !tbaa !82
  %conv89 = zext i8 %32 to i32
  %sub = sub nsw i32 %buflen.4, %conv89
  %arrayidx90 = getelementptr inbounds i8, i8* %buffer.4, i64 0
  %33 = load i8, i8* %arrayidx90, align 1, !tbaa !82
  %conv91 = zext i8 %33 to i32
  %idx.ext = sext i32 %conv91 to i64
  %add.ptr = getelementptr inbounds i8, i8* %buffer.4, i64 %idx.ext
  br label %while.cond

while.end:                                        ; preds = %while.cond, %land.rhs
  %cmp92 = icmp sle i32 %buflen.4, 2
  br i1 %cmp92, label %do.body95, label %if.end103

do.body95:                                        ; preds = %while.end
  %34 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and96 = and i32 %34, 2
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %if.then98, label %error

if.then98:                                        ; preds = %do.body95
  %call99 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.39, i32 0, i32 0))
  br label %error

if.end103:                                        ; preds = %while.end
  %arrayidx104 = getelementptr inbounds i8, i8* %buffer.4, i64 2
  %35 = load i8, i8* %arrayidx104, align 1, !tbaa !82
  %conv105 = zext i8 %35 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end103
  %Pivot = icmp slt i32 %conv105, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock2

LeafBlock2:                                       ; preds = %NodeBlock
  %SwitchLeaf3 = icmp eq i32 %conv105, 2
  br i1 %SwitchLeaf3, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv105, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock2
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock2, %LeafBlock
  br label %do.body108

do.body108:                                       ; preds = %NewDefault
  %36 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and109 = and i32 %36, 2
  %tobool110 = icmp ne i32 %and109, 0
  br i1 %tobool110, label %if.then111, label %error

if.then111:                                       ; preds = %do.body108
  %udev112 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %37 = load %struct.usb_device*, %struct.usb_device** %udev112, align 8, !tbaa !27
  %devnum113 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %37, i32 0, i32 0
  %38 = load i32, i32* %devnum113, align 8, !tbaa !98
  %desc114 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber115 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc114, i32 0, i32 2
  %39 = load i8, i8* %bInterfaceNumber115, align 2, !tbaa !54
  %conv116 = zext i8 %39 to i32
  %call117 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([80 x i8], [80 x i8]* @.str.40, i32 0, i32 0), i32 %38, i32 %conv116)
  br label %error

sw.epilog:                                        ; preds = %LeafBlock, %sw.bb
  %.sink = phi i32 [ 2, %sw.bb ], [ 1, %LeafBlock ]
  %size.0 = phi i32 [ 9, %sw.bb ], [ 13, %LeafBlock ]
  %type107 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 9
  store i32 %.sink, i32* %type107, align 8, !tbaa !114
  %cmp121 = icmp sge i32 %buflen.4, 4
  br i1 %cmp121, label %cond.true, label %cond.end

cond.true:                                        ; preds = %sw.epilog
  %arrayidx123 = getelementptr inbounds i8, i8* %buffer.4, i64 3
  %40 = load i8, i8* %arrayidx123, align 1, !tbaa !82
  %conv124 = zext i8 %40 to i32
  br label %cond.end

cond.end:                                         ; preds = %sw.epilog, %cond.true
  %cond = phi i32 [ %conv124, %cond.true ], [ 0, %sw.epilog ]
  %cmp125 = icmp uge i32 %buflen.4, %size.0
  br i1 %cmp125, label %cond.true127, label %cond.end133

cond.true127:                                     ; preds = %cond.end
  %sub128 = sub i32 %size.0, 1
  %idxprom129 = zext i32 %sub128 to i64
  %arrayidx130 = getelementptr inbounds i8, i8* %buffer.4, i64 %idxprom129
  %41 = load i8, i8* %arrayidx130, align 1, !tbaa !82
  %conv131 = zext i8 %41 to i32
  br label %cond.end133

cond.end133:                                      ; preds = %cond.end, %cond.true127
  %cond134 = phi i32 [ %conv131, %cond.true127 ], [ 0, %cond.end ]
  %mul = mul i32 %cond, %cond134
  %add = add i32 %size.0, %mul
  %cmp135 = icmp ult i32 %buflen.4, %add
  br i1 %cmp135, label %do.body138, label %if.end151

do.body138:                                       ; preds = %cond.end133
  %42 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and139 = and i32 %42, 2
  %tobool140 = icmp ne i32 %and139, 0
  br i1 %tobool140, label %if.then141, label %error

if.then141:                                       ; preds = %do.body138
  %udev142 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %43 = load %struct.usb_device*, %struct.usb_device** %udev142, align 8, !tbaa !27
  %devnum143 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %43, i32 0, i32 0
  %44 = load i32, i32* %devnum143, align 8, !tbaa !98
  %desc144 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber145 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc144, i32 0, i32 2
  %45 = load i8, i8* %bInterfaceNumber145, align 2, !tbaa !54
  %conv146 = zext i8 %45 to i32
  %call147 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.41, i32 0, i32 0), i32 %44, i32 %conv146)
  br label %error

if.end151:                                        ; preds = %cond.end133
  %conv152 = trunc i32 %cond to i8
  %header = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bNumFormats = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header, i32 0, i32 0
  store i8 %conv152, i8* %bNumFormats, align 8, !tbaa !115
  %arrayidx153 = getelementptr inbounds i8, i8* %buffer.4, i64 6
  %46 = load i8, i8* %arrayidx153, align 1, !tbaa !82
  %header154 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bEndpointAddress = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header154, i32 0, i32 1
  store i8 %46, i8* %bEndpointAddress, align 1, !tbaa !116
  %arrayidx155 = getelementptr inbounds i8, i8* %buffer.4, i64 2
  %47 = load i8, i8* %arrayidx155, align 1, !tbaa !82
  %conv156 = zext i8 %47 to i32
  %cmp157 = icmp eq i32 %conv156, 1
  %arrayidx160 = getelementptr inbounds i8, i8* %buffer.4, i64 7
  %48 = load i8, i8* %arrayidx160, align 1, !tbaa !82
  %header161 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  br i1 %cmp157, label %if.then159, label %if.else

if.then159:                                       ; preds = %if.end151
  %bmInfo = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header161, i32 0, i32 5
  store i8 %48, i8* %bmInfo, align 8, !tbaa !117
  %arrayidx162 = getelementptr inbounds i8, i8* %buffer.4, i64 8
  %49 = load i8, i8* %arrayidx162, align 1, !tbaa !82
  %header163 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bTerminalLink = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header163, i32 0, i32 2
  store i8 %49, i8* %bTerminalLink, align 2, !tbaa !118
  %arrayidx164 = getelementptr inbounds i8, i8* %buffer.4, i64 9
  %50 = load i8, i8* %arrayidx164, align 1, !tbaa !82
  %header165 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bStillCaptureMethod = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header165, i32 0, i32 6
  store i8 %50, i8* %bStillCaptureMethod, align 1, !tbaa !119
  %arrayidx166 = getelementptr inbounds i8, i8* %buffer.4, i64 10
  %51 = load i8, i8* %arrayidx166, align 1, !tbaa !82
  %header167 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bTriggerSupport = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header167, i32 0, i32 7
  store i8 %51, i8* %bTriggerSupport, align 2, !tbaa !120
  %arrayidx168 = getelementptr inbounds i8, i8* %buffer.4, i64 11
  %52 = load i8, i8* %arrayidx168, align 1, !tbaa !82
  %header169 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bTriggerUsage = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header169, i32 0, i32 8
  store i8 %52, i8* %bTriggerUsage, align 1, !tbaa !121
  br label %if.end173

if.else:                                          ; preds = %if.end151
  %bTerminalLink172 = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header161, i32 0, i32 2
  store i8 %48, i8* %bTerminalLink172, align 2, !tbaa !118
  br label %if.end173

if.end173:                                        ; preds = %if.else, %if.then159
  %conv174 = trunc i32 %cond134 to i8
  %header175 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bControlSize = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header175, i32 0, i32 3
  store i8 %conv174, i8* %bControlSize, align 1, !tbaa !122
  %idxprom176 = zext i32 %size.0 to i64
  %arrayidx177 = getelementptr inbounds i8, i8* %buffer.4, i64 %idxprom176
  %mul178 = mul i32 %cond, %cond134
  %conv179 = zext i32 %mul178 to i64
  %call180 = call i8* @kmemdup(i8* %arrayidx177, i64 %conv179, i32 20971712)
  %header181 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bmaControls = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header181, i32 0, i32 4
  store i8* %call180, i8** %bmaControls, align 8, !tbaa !123
  %header182 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bmaControls183 = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header182, i32 0, i32 4
  %53 = load i8*, i8** %bmaControls183, align 8, !tbaa !123
  %cmp184 = icmp eq i8* %53, null
  br i1 %cmp184, label %error, label %if.end187

if.end187:                                        ; preds = %if.end173
  %arrayidx188 = getelementptr inbounds i8, i8* %buffer.4, i64 0
  %54 = load i8, i8* %arrayidx188, align 1, !tbaa !82
  %conv189 = zext i8 %54 to i32
  %sub190 = sub nsw i32 %buflen.4, %conv189
  %arrayidx191 = getelementptr inbounds i8, i8* %buffer.4, i64 0
  %55 = load i8, i8* %arrayidx191, align 1, !tbaa !82
  %conv192 = zext i8 %55 to i32
  %idx.ext193 = sext i32 %conv192 to i64
  %add.ptr194 = getelementptr inbounds i8, i8* %buffer.4, i64 %idx.ext193
  br label %while.cond195

while.cond195:                                    ; preds = %sw.epilog261, %if.end187
  %nintervals.0 = phi i32 [ 0, %if.end187 ], [ %nintervals.3, %sw.epilog261 ]
  %nframes.0 = phi i32 [ 0, %if.end187 ], [ %nframes.1, %sw.epilog261 ]
  %nformats.0 = phi i32 [ 0, %if.end187 ], [ %nformats.1, %sw.epilog261 ]
  %_buflen.0 = phi i32 [ %sub190, %if.end187 ], [ %sub264, %sw.epilog261 ]
  %_buffer.0 = phi i8* [ %add.ptr194, %if.end187 ], [ %add.ptr268, %sw.epilog261 ]
  %cmp196 = icmp sgt i32 %_buflen.0, 2
  br i1 %cmp196, label %land.rhs198, label %while.end269

land.rhs198:                                      ; preds = %while.cond195
  %arrayidx199 = getelementptr inbounds i8, i8* %_buffer.0, i64 1
  %56 = load i8, i8* %arrayidx199, align 1, !tbaa !82
  %conv200 = zext i8 %56 to i32
  %cmp201 = icmp eq i32 %conv200, 36
  br i1 %cmp201, label %while.body204, label %while.end269

while.body204:                                    ; preds = %land.rhs198
  %arrayidx205 = getelementptr inbounds i8, i8* %_buffer.0, i64 2
  %57 = load i8, i8* %arrayidx205, align 1, !tbaa !82
  %conv206 = zext i8 %57 to i32
  br label %NodeBlock29

NodeBlock29:                                      ; preds = %while.body204
  %Pivot30 = icmp slt i32 %conv206, 10
  br i1 %Pivot30, label %NodeBlock13, label %NodeBlock27

NodeBlock27:                                      ; preds = %NodeBlock29
  %Pivot28 = icmp slt i32 %conv206, 16
  br i1 %Pivot28, label %NodeBlock19, label %NodeBlock25

NodeBlock25:                                      ; preds = %NodeBlock27
  %Pivot26 = icmp slt i32 %conv206, 17
  br i1 %Pivot26, label %sw.bb207, label %NodeBlock23

NodeBlock23:                                      ; preds = %NodeBlock25
  %Pivot24 = icmp slt i32 %conv206, 18
  br i1 %Pivot24, label %sw.bb245, label %LeafBlock21

LeafBlock21:                                      ; preds = %NodeBlock23
  %SwitchLeaf22 = icmp eq i32 %conv206, 18
  br i1 %SwitchLeaf22, label %do.body214, label %NewDefault4

NodeBlock19:                                      ; preds = %NodeBlock27
  %Pivot20 = icmp slt i32 %conv206, 12
  br i1 %Pivot20, label %LeafBlock15, label %LeafBlock17

LeafBlock17:                                      ; preds = %NodeBlock19
  %SwitchLeaf18 = icmp eq i32 %conv206, 12
  br i1 %SwitchLeaf18, label %sw.bb209, label %NewDefault4

LeafBlock15:                                      ; preds = %NodeBlock19
  %SwitchLeaf16 = icmp eq i32 %conv206, 10
  br i1 %SwitchLeaf16, label %do.body214, label %NewDefault4

NodeBlock13:                                      ; preds = %NodeBlock29
  %Pivot14 = icmp slt i32 %conv206, 6
  br i1 %Pivot14, label %NodeBlock7, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv206, 7
  br i1 %Pivot12, label %sw.bb207, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %conv206, 7
  br i1 %SwitchLeaf10, label %sw.bb229, label %NewDefault4

NodeBlock7:                                       ; preds = %NodeBlock13
  %Pivot8 = icmp slt i32 %conv206, 5
  br i1 %Pivot8, label %LeafBlock5, label %sw.bb229

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %conv206, 4
  br i1 %SwitchLeaf6, label %sw.bb207, label %NewDefault4

sw.bb207:                                         ; preds = %NodeBlock25, %NodeBlock11, %LeafBlock5
  %inc208 = add i32 %nformats.0, 1
  br label %sw.epilog261

sw.bb209:                                         ; preds = %LeafBlock17
  %inc210 = add i32 %nformats.0, 1
  %inc211 = add i32 %nframes.0, 1
  %inc212 = add i32 %nintervals.0, 1
  br label %sw.epilog261

do.body214:                                       ; preds = %LeafBlock21, %LeafBlock15
  %58 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and215 = and i32 %58, 2
  %tobool216 = icmp ne i32 %and215, 0
  br i1 %tobool216, label %if.then217, label %sw.epilog261

if.then217:                                       ; preds = %do.body214
  %udev218 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %59 = load %struct.usb_device*, %struct.usb_device** %udev218, align 8, !tbaa !27
  %devnum219 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %59, i32 0, i32 0
  %60 = load i32, i32* %devnum219, align 8, !tbaa !98
  %desc220 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber221 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc220, i32 0, i32 2
  %61 = load i8, i8* %bInterfaceNumber221, align 2, !tbaa !54
  %conv222 = zext i8 %61 to i32
  %arrayidx223 = getelementptr inbounds i8, i8* %_buffer.0, i64 2
  %62 = load i8, i8* %arrayidx223, align 1, !tbaa !82
  %conv224 = zext i8 %62 to i32
  %call225 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([79 x i8], [79 x i8]* @.str.42, i32 0, i32 0), i32 %60, i32 %conv222, i32 %conv224)
  br label %sw.epilog261

sw.bb229:                                         ; preds = %LeafBlock9, %NodeBlock7
  %inc230 = add i32 %nframes.0, 1
  %cmp231 = icmp sgt i32 %_buflen.0, 25
  br i1 %cmp231, label %if.then233, label %sw.epilog261

if.then233:                                       ; preds = %sw.bb229
  %arrayidx234 = getelementptr inbounds i8, i8* %_buffer.0, i64 25
  %63 = load i8, i8* %arrayidx234, align 1, !tbaa !82
  %conv235 = zext i8 %63 to i32
  %tobool236 = icmp ne i32 %conv235, 0
  br i1 %tobool236, label %cond.true237, label %cond.end241

cond.true237:                                     ; preds = %if.then233
  %arrayidx238 = getelementptr inbounds i8, i8* %_buffer.0, i64 25
  %64 = load i8, i8* %arrayidx238, align 1, !tbaa !82
  %conv239 = zext i8 %64 to i32
  br label %cond.end241

cond.end241:                                      ; preds = %if.then233, %cond.true237
  %cond242 = phi i32 [ %conv239, %cond.true237 ], [ 3, %if.then233 ]
  %add243 = add i32 %nintervals.0, %cond242
  br label %sw.epilog261

sw.bb245:                                         ; preds = %NodeBlock23
  %inc246 = add i32 %nframes.0, 1
  %cmp247 = icmp sgt i32 %_buflen.0, 21
  br i1 %cmp247, label %if.then249, label %sw.epilog261

if.then249:                                       ; preds = %sw.bb245
  %arrayidx250 = getelementptr inbounds i8, i8* %_buffer.0, i64 21
  %65 = load i8, i8* %arrayidx250, align 1, !tbaa !82
  %conv251 = zext i8 %65 to i32
  %tobool252 = icmp ne i32 %conv251, 0
  br i1 %tobool252, label %cond.true253, label %cond.end257

cond.true253:                                     ; preds = %if.then249
  %arrayidx254 = getelementptr inbounds i8, i8* %_buffer.0, i64 21
  %66 = load i8, i8* %arrayidx254, align 1, !tbaa !82
  %conv255 = zext i8 %66 to i32
  br label %cond.end257

cond.end257:                                      ; preds = %if.then249, %cond.true253
  %cond258 = phi i32 [ %conv255, %cond.true253 ], [ 3, %if.then249 ]
  %add259 = add i32 %nintervals.0, %cond258
  br label %sw.epilog261

NewDefault4:                                      ; preds = %LeafBlock21, %LeafBlock17, %LeafBlock15, %LeafBlock9, %LeafBlock5
  br label %sw.epilog261

sw.epilog261:                                     ; preds = %NewDefault4, %sw.bb245, %cond.end257, %sw.bb229, %cond.end241, %do.body214, %if.then217, %sw.bb209, %sw.bb207
  %nintervals.3 = phi i32 [ %nintervals.0, %NewDefault4 ], [ %inc212, %sw.bb209 ], [ %nintervals.0, %sw.bb207 ], [ %nintervals.0, %if.then217 ], [ %nintervals.0, %do.body214 ], [ %add243, %cond.end241 ], [ %nintervals.0, %sw.bb229 ], [ %add259, %cond.end257 ], [ %nintervals.0, %sw.bb245 ]
  %nframes.1 = phi i32 [ %nframes.0, %NewDefault4 ], [ %inc211, %sw.bb209 ], [ %nframes.0, %sw.bb207 ], [ %nframes.0, %if.then217 ], [ %nframes.0, %do.body214 ], [ %inc230, %cond.end241 ], [ %inc230, %sw.bb229 ], [ %inc246, %cond.end257 ], [ %inc246, %sw.bb245 ]
  %nformats.1 = phi i32 [ %nformats.0, %NewDefault4 ], [ %inc210, %sw.bb209 ], [ %inc208, %sw.bb207 ], [ %nformats.0, %if.then217 ], [ %nformats.0, %do.body214 ], [ %nformats.0, %cond.end241 ], [ %nformats.0, %sw.bb229 ], [ %nformats.0, %cond.end257 ], [ %nformats.0, %sw.bb245 ]
  %arrayidx262 = getelementptr inbounds i8, i8* %_buffer.0, i64 0
  %67 = load i8, i8* %arrayidx262, align 1, !tbaa !82
  %conv263 = zext i8 %67 to i32
  %sub264 = sub nsw i32 %_buflen.0, %conv263
  %arrayidx265 = getelementptr inbounds i8, i8* %_buffer.0, i64 0
  %68 = load i8, i8* %arrayidx265, align 1, !tbaa !82
  %conv266 = zext i8 %68 to i32
  %idx.ext267 = sext i32 %conv266 to i64
  %add.ptr268 = getelementptr inbounds i8, i8* %_buffer.0, i64 %idx.ext267
  br label %while.cond195

while.end269:                                     ; preds = %while.cond195, %land.rhs198
  %cmp270 = icmp eq i32 %nformats.0, 0
  br i1 %cmp270, label %do.body273, label %if.end286

do.body273:                                       ; preds = %while.end269
  %69 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and274 = and i32 %69, 2
  %tobool275 = icmp ne i32 %and274, 0
  br i1 %tobool275, label %if.then276, label %error

if.then276:                                       ; preds = %do.body273
  %udev277 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %70 = load %struct.usb_device*, %struct.usb_device** %udev277, align 8, !tbaa !27
  %devnum278 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %70, i32 0, i32 0
  %71 = load i32, i32* %devnum278, align 8, !tbaa !98
  %desc279 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber280 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc279, i32 0, i32 2
  %72 = load i8, i8* %bInterfaceNumber280, align 2, !tbaa !54
  %conv281 = zext i8 %72 to i32
  %call282 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([85 x i8], [85 x i8]* @.str.43, i32 0, i32 0), i32 %71, i32 %conv281)
  br label %error

if.end286:                                        ; preds = %while.end269
  %conv287 = zext i32 %nformats.0 to i64
  %mul288 = mul i64 %conv287, 56
  %conv289 = zext i32 %nframes.0 to i64
  %mul290 = mul i64 %conv289, 40
  %add291 = add i64 %mul288, %mul290
  %conv292 = zext i32 %nintervals.0 to i64
  %mul293 = mul i64 %conv292, 4
  %add294 = add i64 %add291, %mul293
  %conv295 = trunc i64 %add294 to i32
  %conv296 = zext i32 %conv295 to i64
  %call297 = call i8* @kzalloc(i64 %conv296, i32 20971712)
  %73 = bitcast i8* %call297 to %struct.uvc_format*
  %cmp298 = icmp eq %struct.uvc_format* %73, null
  br i1 %cmp298, label %error, label %if.end301

if.end301:                                        ; preds = %if.end286
  %idxprom302 = zext i32 %nformats.0 to i64
  %arrayidx303 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %73, i64 %idxprom302
  %74 = bitcast %struct.uvc_format* %arrayidx303 to %struct.uvc_frame*
  %idxprom304 = zext i32 %nframes.0 to i64
  %arrayidx305 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %74, i64 %idxprom304
  %75 = bitcast %struct.uvc_frame* %arrayidx305 to i32*
  store i32* %75, i32** %interval, align 8, !tbaa !18
  %format306 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 11
  store %struct.uvc_format* %73, %struct.uvc_format** %format306, align 8, !tbaa !124
  %nformats307 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 10
  store i32 %nformats.0, i32* %nformats307, align 4, !tbaa !125
  br label %while.cond308.outer

while.cond308.outer:                              ; preds = %if.end326, %if.end301
  %buflen.5.ph = phi i32 [ %sub330, %if.end326 ], [ %sub190, %if.end301 ]
  %buffer.5.ph = phi i8* [ %add.ptr332, %if.end326 ], [ %add.ptr194, %if.end301 ]
  %frame.0.ph = phi %struct.uvc_frame* [ %add.ptr329, %if.end326 ], [ %74, %if.end301 ]
  %format.0.ph = phi %struct.uvc_format* [ %incdec.ptr, %if.end326 ], [ %73, %if.end301 ]
  br label %while.cond308

while.cond308:                                    ; preds = %while.cond308.outer, %sw.epilog334
  %buflen.5 = phi i32 [ %sub337, %sw.epilog334 ], [ %buflen.5.ph, %while.cond308.outer ]
  %buffer.5 = phi i8* [ %add.ptr341, %sw.epilog334 ], [ %buffer.5.ph, %while.cond308.outer ]
  %cmp309 = icmp sgt i32 %buflen.5, 2
  br i1 %cmp309, label %land.rhs311, label %while.end342

land.rhs311:                                      ; preds = %while.cond308
  %arrayidx312 = getelementptr inbounds i8, i8* %buffer.5, i64 1
  %76 = load i8, i8* %arrayidx312, align 1, !tbaa !82
  %conv313 = zext i8 %76 to i32
  %cmp314 = icmp eq i32 %conv313, 36
  br i1 %cmp314, label %while.body317, label %while.end342

while.body317:                                    ; preds = %land.rhs311
  %arrayidx318 = getelementptr inbounds i8, i8* %buffer.5, i64 2
  %77 = load i8, i8* %arrayidx318, align 1, !tbaa !82
  %conv319 = zext i8 %77 to i32
  %78 = sub i32 %conv319, 4
  %79 = lshr i32 %78, 1
  %80 = shl i32 %78, 31
  %81 = or i32 %79, %80
  br label %NodeBlock40

NodeBlock40:                                      ; preds = %while.body317
  %Pivot41 = icmp slt i32 %81, 4
  br i1 %Pivot41, label %LeafBlock32, label %NodeBlock38

NodeBlock38:                                      ; preds = %NodeBlock40
  %Pivot39 = icmp slt i32 %81, 6
  br i1 %Pivot39, label %LeafBlock34, label %LeafBlock36

LeafBlock36:                                      ; preds = %NodeBlock38
  %SwitchLeaf37 = icmp eq i32 %81, 6
  br i1 %SwitchLeaf37, label %sw.bb320, label %NewDefault31

LeafBlock34:                                      ; preds = %NodeBlock38
  %SwitchLeaf35 = icmp eq i32 %81, 4
  br i1 %SwitchLeaf35, label %sw.bb320, label %NewDefault31

LeafBlock32:                                      ; preds = %NodeBlock40
  %SwitchLeaf33 = icmp ule i32 %81, 1
  br i1 %SwitchLeaf33, label %sw.bb320, label %NewDefault31

sw.bb320:                                         ; preds = %LeafBlock36, %LeafBlock34, %LeafBlock32
  %frame321 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format.0.ph, i32 0, i32 8
  store %struct.uvc_frame* %frame.0.ph, %struct.uvc_frame** %frame321, align 8, !tbaa !126
  %call322 = call i32 @uvc_parse_format(%struct.uvc_device* %dev, %struct.uvc_streaming* %17, %struct.uvc_format* %format.0.ph, i32** %interval, i8* %buffer.5, i32 %buflen.5)
  %cmp323 = icmp slt i32 %call322, 0
  br i1 %cmp323, label %error, label %if.end326

if.end326:                                        ; preds = %sw.bb320
  %nframes327 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format.0.ph, i32 0, i32 7
  %82 = load i32, i32* %nframes327, align 4, !tbaa !128
  %idx.ext328 = zext i32 %82 to i64
  %add.ptr329 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %frame.0.ph, i64 %idx.ext328
  %incdec.ptr = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format.0.ph, i32 1
  %sub330 = sub nsw i32 %buflen.5, %call322
  %idx.ext331 = sext i32 %call322 to i64
  %add.ptr332 = getelementptr inbounds i8, i8* %buffer.5, i64 %idx.ext331
  br label %while.cond308.outer

NewDefault31:                                     ; preds = %LeafBlock36, %LeafBlock34, %LeafBlock32
  br label %sw.epilog334

sw.epilog334:                                     ; preds = %NewDefault31
  %arrayidx335 = getelementptr inbounds i8, i8* %buffer.5, i64 0
  %83 = load i8, i8* %arrayidx335, align 1, !tbaa !82
  %conv336 = zext i8 %83 to i32
  %sub337 = sub nsw i32 %buflen.5, %conv336
  %arrayidx338 = getelementptr inbounds i8, i8* %buffer.5, i64 0
  %84 = load i8, i8* %arrayidx338, align 1, !tbaa !82
  %conv339 = zext i8 %84 to i32
  %idx.ext340 = sext i32 %conv339 to i64
  %add.ptr341 = getelementptr inbounds i8, i8* %buffer.5, i64 %idx.ext340
  br label %while.cond308

while.end342:                                     ; preds = %while.cond308, %land.rhs311
  %tobool343 = icmp ne i32 %buflen.5, 0
  br i1 %tobool343, label %do.body345, label %if.end358

do.body345:                                       ; preds = %while.end342
  %85 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and346 = and i32 %85, 2
  %tobool347 = icmp ne i32 %and346, 0
  br i1 %tobool347, label %if.then348, label %if.end358

if.then348:                                       ; preds = %do.body345
  %udev349 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %86 = load %struct.usb_device*, %struct.usb_device** %udev349, align 8, !tbaa !27
  %devnum350 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %86, i32 0, i32 0
  %87 = load i32, i32* %devnum350, align 8, !tbaa !98
  %desc351 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %arrayidx, i32 0, i32 0
  %bInterfaceNumber352 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc351, i32 0, i32 2
  %88 = load i8, i8* %bInterfaceNumber352, align 2, !tbaa !54
  %conv353 = zext i8 %88 to i32
  %call354 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([96 x i8], [96 x i8]* @.str.44, i32 0, i32 0), i32 %87, i32 %conv353, i32 %buflen.5)
  br label %if.end358

if.end358:                                        ; preds = %do.body345, %if.then348, %while.end342
  br label %for.cond359

for.cond359:                                      ; preds = %for.inc392, %if.end358
  %i.1 = phi i32 [ 0, %if.end358 ], [ %inc393, %for.inc392 ]
  %num_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 2
  %89 = load i32, i32* %num_altsetting, align 8, !tbaa !129
  %cmp360 = icmp ult i32 %i.1, %89
  br i1 %cmp360, label %for.body362, label %for.end394

for.body362:                                      ; preds = %for.cond359
  %altsetting364 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 0
  %90 = load %struct.usb_host_interface*, %struct.usb_host_interface** %altsetting364, align 8, !tbaa !109
  %idxprom365 = zext i32 %i.1 to i64
  %arrayidx366 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %90, i64 %idxprom365
  %header367 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bEndpointAddress368 = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header367, i32 0, i32 1
  %91 = load i8, i8* %bEndpointAddress368, align 1, !tbaa !116
  %call369 = call %struct.usb_host_endpoint* @uvc_find_endpoint(%struct.usb_host_interface* %arrayidx366, i8 zeroext %91)
  %cmp370 = icmp eq %struct.usb_host_endpoint* %call369, null
  br i1 %cmp370, label %for.inc392, label %if.end373

if.end373:                                        ; preds = %for.body362
  %desc374 = getelementptr inbounds %struct.usb_host_endpoint, %struct.usb_host_endpoint* %call369, i32 0, i32 0
  %wMaxPacketSize = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %desc374, i32 0, i32 4
  %92 = load i16, i16* %wMaxPacketSize, align 4, !tbaa !130
  %conv375 = zext i16 %92 to i32
  %and376 = and i32 %conv375, 2047
  %conv377 = zext i16 %92 to i32
  %shr = ashr i32 %conv377, 11
  %and378 = and i32 %shr, 3
  %add379 = add nsw i32 1, %and378
  %mul380 = mul nsw i32 %and376, %add379
  %conv381 = trunc i32 %mul380 to i16
  %conv382 = zext i16 %conv381 to i32
  %maxpsize = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 7
  %93 = load i16, i16* %maxpsize, align 4, !tbaa !131
  %conv383 = zext i16 %93 to i32
  %cmp384 = icmp sgt i32 %conv382, %conv383
  br i1 %cmp384, label %if.then386, label %for.inc392

if.then386:                                       ; preds = %if.end373
  %maxpsize387 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 7
  store i16 %conv381, i16* %maxpsize387, align 4, !tbaa !131
  br label %for.inc392

for.inc392:                                       ; preds = %for.body362, %if.then386, %if.end373
  %inc393 = add i32 %i.1, 1
  br label %for.cond359

for.end394:                                       ; preds = %for.cond359
  %list = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 0
  %streams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 14
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %streams)
  br label %cleanup398

error:                                            ; preds = %sw.bb320, %if.end286, %do.body273, %if.then276, %if.end173, %do.body138, %if.then141, %do.body108, %if.then111, %do.body95, %if.then98
  %ret.0 = phi i32 [ -22, %if.then98 ], [ -22, %do.body95 ], [ -22, %if.then111 ], [ -22, %do.body108 ], [ -22, %if.then141 ], [ -22, %do.body138 ], [ -12, %if.end173 ], [ -22, %if.then276 ], [ -22, %do.body273 ], [ -12, %if.end286 ], [ %call322, %sw.bb320 ]
  call void @usb_driver_release_interface(%struct.usb_driver* getelementptr inbounds (%struct.uvc_driver, %struct.uvc_driver* @uvc_driver, i32 0, i32 0), %struct.usb_interface* %intf)
  call void @usb_put_intf(%struct.usb_interface* %intf)
  %format395 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 11
  %94 = load %struct.uvc_format*, %struct.uvc_format** %format395, align 8, !tbaa !124
  %95 = bitcast %struct.uvc_format* %94 to i8*
  call void @kfree(i8* %95)
  %header396 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %17, i32 0, i32 8
  %bmaControls397 = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header396, i32 0, i32 4
  %96 = load i8*, i8** %bmaControls397, align 8, !tbaa !123
  call void @kfree(i8* %96)
  %97 = bitcast %struct.uvc_streaming* %17 to i8*
  call void @kfree(i8* %97)
  br label %cleanup398

cleanup398:                                       ; preds = %do.body11, %if.then14, %do.body, %if.then2, %error, %for.end394, %if.then30
  %retval.0 = phi i32 [ -22, %if.then30 ], [ %ret.0, %error ], [ 0, %for.end394 ], [ -22, %if.then2 ], [ -22, %do.body ], [ -22, %if.then14 ], [ -22, %do.body11 ]
  %98 = bitcast i32** %interval to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %98) #5
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i16 @__le16_to_cpup(i16* %p) #2 {
entry:
  %0 = load i16, i16* %p, align 2, !tbaa !94
  ret i16 %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @__le32_to_cpup(i32* %p) #2 {
entry:
  %0 = load i32, i32* %p, align 4, !tbaa !17
  ret i32 %0
}

declare i32 @usb_driver_claim_interface(%struct.usb_driver*, %struct.usb_interface*, i8*) #3

declare void @usb_driver_release_interface(%struct.usb_driver*, %struct.usb_interface*) #3

declare i8* @kmemdup(i8*, i64, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @uvc_parse_format(%struct.uvc_device* %dev, %struct.uvc_streaming* %streaming, %struct.uvc_format* %format, i32** %intervals, i8* %buffer, i32 %buflen) #0 {
entry:
  %__UNIQUE_ID_min1_20 = alloca i32, align 4
  %__UNIQUE_ID_min2_21 = alloca i32, align 4
  %__UNIQUE_ID_max1_18 = alloca i32, align 4
  %__UNIQUE_ID_max2_19 = alloca i32, align 4
  %intf1 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %streaming, i32 0, i32 5
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf1, align 8, !tbaa !68
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %0, i32 0, i32 1
  %1 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds i8, i8* %buffer, i64 2
  %2 = load i8, i8* %arrayidx, align 1, !tbaa !82
  %type = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 0
  store i8 %2, i8* %type, align 8, !tbaa !132
  %arrayidx2 = getelementptr inbounds i8, i8* %buffer, i64 3
  %3 = load i8, i8* %arrayidx2, align 1, !tbaa !82
  %index = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 1
  store i8 %3, i8* %index, align 1, !tbaa !133
  %arrayidx3 = getelementptr inbounds i8, i8* %buffer, i64 2
  %4 = load i8, i8* %arrayidx3, align 1, !tbaa !82
  %conv = zext i8 %4 to i32
  %5 = sub i32 %conv, 4
  %6 = lshr i32 %5, 1
  %7 = shl i32 %5, 31
  %8 = or i32 %6, %7
  br label %NodeBlock17

NodeBlock17:                                      ; preds = %entry
  %Pivot18 = icmp slt i32 %8, 4
  br i1 %Pivot18, label %NodeBlock, label %NodeBlock15

NodeBlock15:                                      ; preds = %NodeBlock17
  %Pivot16 = icmp slt i32 %8, 6
  br i1 %Pivot16, label %LeafBlock11, label %LeafBlock13

LeafBlock13:                                      ; preds = %NodeBlock15
  %SwitchLeaf14 = icmp eq i32 %8, 6
  br i1 %SwitchLeaf14, label %sw.bb, label %NewDefault

LeafBlock11:                                      ; preds = %NodeBlock15
  %SwitchLeaf12 = icmp eq i32 %8, 4
  br i1 %SwitchLeaf12, label %sw.bb78, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock17
  %Pivot = icmp slt i32 %8, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock
  %SwitchLeaf10 = icmp eq i32 %8, 1
  br i1 %SwitchLeaf10, label %sw.bb54, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %8, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock13, %LeafBlock
  %arrayidx4 = getelementptr inbounds i8, i8* %buffer, i64 2
  %9 = load i8, i8* %arrayidx4, align 1, !tbaa !82
  %conv5 = zext i8 %9 to i32
  %cmp = icmp eq i32 %conv5, 4
  %10 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 27, i32 28
  %cmp7 = icmp ult i32 %buflen, %cond
  br i1 %cmp7, label %do.body, label %if.end11

do.body:                                          ; preds = %sw.bb
  %11 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %11, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then9, label %cleanup

if.then9:                                         ; preds = %do.body
  %udev = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %12 = load %struct.usb_device*, %struct.usb_device** %udev, align 8, !tbaa !27
  %devnum = getelementptr inbounds %struct.usb_device, %struct.usb_device* %12, i32 0, i32 0
  %13 = load i32, i32* %devnum, align 8, !tbaa !98
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %14 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !54
  %conv10 = zext i8 %14 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.45, i32 0, i32 0), i32 %13, i32 %conv10)
  br label %cleanup

if.end11:                                         ; preds = %sw.bb
  %arrayidx12 = getelementptr inbounds i8, i8* %buffer, i64 5
  %call13 = call %struct.uvc_format_desc* @uvc_format_by_guid(i8* %arrayidx12)
  %cmp14 = icmp ne %struct.uvc_format_desc* %call13, null
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end11
  %name = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %name17 = getelementptr inbounds %struct.uvc_format_desc, %struct.uvc_format_desc* %call13, i32 0, i32 0
  %15 = load i8*, i8** %name17, align 8, !tbaa !134
  %call18 = call i64 @strlcpy(i8* %arraydecay, i8* %15, i64 32)
  %fcc = getelementptr inbounds %struct.uvc_format_desc, %struct.uvc_format_desc* %call13, i32 0, i32 2
  %16 = load i32, i32* %fcc, align 8, !tbaa !136
  br label %if.end27

if.else:                                          ; preds = %if.end11
  %arrayidx20 = getelementptr inbounds i8, i8* %buffer, i64 5
  %call21 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.46, i32 0, i32 0), i8* %arrayidx20)
  %name22 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay23 = getelementptr inbounds [32 x i8], [32 x i8]* %name22, i32 0, i32 0
  %arrayidx24 = getelementptr inbounds i8, i8* %buffer, i64 5
  %call25 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay23, i64 32, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.47, i32 0, i32 0), i8* %arrayidx24)
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.then16
  %.sink = phi i32 [ 0, %if.else ], [ %16, %if.then16 ]
  %fcc26 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 4
  store i32 %.sink, i32* %fcc26, align 4, !tbaa !137
  %arrayidx28 = getelementptr inbounds i8, i8* %buffer, i64 21
  %17 = load i8, i8* %arrayidx28, align 1, !tbaa !82
  %bpp = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 2
  store i8 %17, i8* %bpp, align 2, !tbaa !138
  %quirks = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 3
  %18 = load i32, i32* %quirks, align 8, !tbaa !57
  %and29 = and i32 %18, 2048
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then31, label %if.end42

if.then31:                                        ; preds = %if.end27
  %fcc32 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 4
  %19 = load i32, i32* %fcc32, align 4, !tbaa !137
  %cmp33 = icmp eq i32 %19, 1448695129
  br i1 %cmp33, label %if.then35, label %if.end42

if.then35:                                        ; preds = %if.then31
  %name36 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay37 = getelementptr inbounds [32 x i8], [32 x i8]* %name36, i32 0, i32 0
  %call38 = call i64 @strlcpy(i8* %arraydecay37, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.48, i32 0, i32 0), i64 32)
  %fcc39 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 4
  store i32 1497715271, i32* %fcc39, align 4, !tbaa !137
  %bpp40 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 2
  store i8 8, i8* %bpp40, align 2, !tbaa !138
  br label %if.end42

if.end42:                                         ; preds = %if.then31, %if.then35, %if.end27
  %width_multiplier.1 = phi i32 [ 1, %if.end27 ], [ 2, %if.then35 ], [ 1, %if.then31 ]
  %arrayidx43 = getelementptr inbounds i8, i8* %buffer, i64 2
  %20 = load i8, i8* %arrayidx43, align 1, !tbaa !82
  %conv44 = zext i8 %20 to i32
  %cmp45 = icmp eq i32 %conv44, 4
  br i1 %cmp45, label %do.body159, label %if.else48

if.else48:                                        ; preds = %if.end42
  %arrayidx49 = getelementptr inbounds i8, i8* %buffer, i64 27
  %21 = load i8, i8* %arrayidx49, align 1, !tbaa !82
  %tobool50 = icmp ne i8 %21, 0
  br i1 %tobool50, label %if.then51, label %do.body159

if.then51:                                        ; preds = %if.else48
  %flags = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 5
  store i32 1, i32* %flags, align 8, !tbaa !139
  br label %do.body159

sw.bb54:                                          ; preds = %LeafBlock9
  %cmp55 = icmp slt i32 %buflen, 11
  br i1 %cmp55, label %do.body58, label %if.end71

do.body58:                                        ; preds = %sw.bb54
  %22 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and59 = and i32 %22, 2
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.then61, label %cleanup

if.then61:                                        ; preds = %do.body58
  %udev62 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %23 = load %struct.usb_device*, %struct.usb_device** %udev62, align 8, !tbaa !27
  %devnum63 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %23, i32 0, i32 0
  %24 = load i32, i32* %devnum63, align 8, !tbaa !98
  %desc64 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber65 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc64, i32 0, i32 2
  %25 = load i8, i8* %bInterfaceNumber65, align 2, !tbaa !54
  %conv66 = zext i8 %25 to i32
  %call67 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.45, i32 0, i32 0), i32 %24, i32 %conv66)
  br label %cleanup

if.end71:                                         ; preds = %sw.bb54
  %name72 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay73 = getelementptr inbounds [32 x i8], [32 x i8]* %name72, i32 0, i32 0
  %call74 = call i64 @strlcpy(i8* %arraydecay73, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i64 32)
  %fcc75 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 4
  store i32 1196444237, i32* %fcc75, align 4, !tbaa !137
  %flags76 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 5
  store i32 1, i32* %flags76, align 8, !tbaa !139
  %bpp77 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 2
  store i8 0, i8* %bpp77, align 2, !tbaa !138
  br label %do.body159

sw.bb78:                                          ; preds = %LeafBlock11
  %cmp79 = icmp slt i32 %buflen, 9
  br i1 %cmp79, label %do.body82, label %if.end95

do.body82:                                        ; preds = %sw.bb78
  %26 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and83 = and i32 %26, 2
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.then85, label %cleanup

if.then85:                                        ; preds = %do.body82
  %udev86 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %27 = load %struct.usb_device*, %struct.usb_device** %udev86, align 8, !tbaa !27
  %devnum87 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %27, i32 0, i32 0
  %28 = load i32, i32* %devnum87, align 8, !tbaa !98
  %desc88 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber89 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc88, i32 0, i32 2
  %29 = load i8, i8* %bInterfaceNumber89, align 2, !tbaa !54
  %conv90 = zext i8 %29 to i32
  %call91 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.45, i32 0, i32 0), i32 %28, i32 %conv90)
  br label %cleanup

if.end95:                                         ; preds = %sw.bb78
  %arrayidx96 = getelementptr inbounds i8, i8* %buffer, i64 8
  %30 = load i8, i8* %arrayidx96, align 1, !tbaa !82
  %conv97 = zext i8 %30 to i32
  %and98 = and i32 %conv97, 127
  br label %NodeBlock26

NodeBlock26:                                      ; preds = %if.end95
  %Pivot27 = icmp slt i32 %and98, 1
  br i1 %Pivot27, label %LeafBlock20, label %NodeBlock24

NodeBlock24:                                      ; preds = %NodeBlock26
  %Pivot25 = icmp slt i32 %and98, 2
  br i1 %Pivot25, label %sw.bb103, label %LeafBlock22

LeafBlock22:                                      ; preds = %NodeBlock24
  %SwitchLeaf23 = icmp eq i32 %and98, 2
  br i1 %SwitchLeaf23, label %sw.bb107, label %NewDefault19

LeafBlock20:                                      ; preds = %NodeBlock26
  %SwitchLeaf21 = icmp eq i32 %and98, 0
  br i1 %SwitchLeaf21, label %sw.bb99, label %NewDefault19

sw.bb99:                                          ; preds = %LeafBlock20
  %name100 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay101 = getelementptr inbounds [32 x i8], [32 x i8]* %name100, i32 0, i32 0
  %call102 = call i64 @strlcpy(i8* %arraydecay101, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.50, i32 0, i32 0), i64 32)
  br label %sw.epilog

sw.bb103:                                         ; preds = %NodeBlock24
  %name104 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay105 = getelementptr inbounds [32 x i8], [32 x i8]* %name104, i32 0, i32 0
  %call106 = call i64 @strlcpy(i8* %arraydecay105, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.51, i32 0, i32 0), i64 32)
  br label %sw.epilog

sw.bb107:                                         ; preds = %LeafBlock22
  %name108 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay109 = getelementptr inbounds [32 x i8], [32 x i8]* %name108, i32 0, i32 0
  %call110 = call i64 @strlcpy(i8* %arraydecay109, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.52, i32 0, i32 0), i64 32)
  br label %sw.epilog

NewDefault19:                                     ; preds = %LeafBlock22, %LeafBlock20
  br label %do.body111

do.body111:                                       ; preds = %NewDefault19
  %31 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and112 = and i32 %31, 2
  %tobool113 = icmp ne i32 %and112, 0
  br i1 %tobool113, label %if.then114, label %cleanup

if.then114:                                       ; preds = %do.body111
  %udev115 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %32 = load %struct.usb_device*, %struct.usb_device** %udev115, align 8, !tbaa !27
  %devnum116 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %32, i32 0, i32 0
  %33 = load i32, i32* %devnum116, align 8, !tbaa !98
  %desc117 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber118 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc117, i32 0, i32 2
  %34 = load i8, i8* %bInterfaceNumber118, align 2, !tbaa !54
  %conv119 = zext i8 %34 to i32
  %arrayidx120 = getelementptr inbounds i8, i8* %buffer, i64 8
  %35 = load i8, i8* %arrayidx120, align 1, !tbaa !82
  %conv121 = zext i8 %35 to i32
  %call122 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.53, i32 0, i32 0), i32 %33, i32 %conv119, i32 %conv121)
  br label %cleanup

sw.epilog:                                        ; preds = %sw.bb107, %sw.bb103, %sw.bb99
  %name126 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay127 = getelementptr inbounds [32 x i8], [32 x i8]* %name126, i32 0, i32 0
  %arrayidx128 = getelementptr inbounds i8, i8* %buffer, i64 8
  %36 = load i8, i8* %arrayidx128, align 1, !tbaa !82
  %conv129 = zext i8 %36 to i32
  %and130 = and i32 %conv129, 128
  %tobool131 = icmp ne i32 %and130, 0
  %37 = zext i1 %tobool131 to i64
  %cond132 = select i1 %tobool131, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.54, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.55, i32 0, i32 0)
  %call133 = call i64 @strlcat(i8* %arraydecay127, i8* %cond132, i64 32)
  %fcc134 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 4
  store i32 1685288548, i32* %fcc134, align 4, !tbaa !137
  %flags135 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 5
  store i32 3, i32* %flags135, align 8, !tbaa !139
  %bpp136 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 2
  store i8 0, i8* %bpp136, align 2, !tbaa !138
  %frame137 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 8
  %38 = load %struct.uvc_frame*, %struct.uvc_frame** %frame137, align 8, !tbaa !126
  %arrayidx138 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %38, i64 0
  %frame139 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 8
  %39 = load %struct.uvc_frame*, %struct.uvc_frame** %frame139, align 8, !tbaa !126
  %arrayidx140 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %39, i64 0
  %40 = bitcast %struct.uvc_frame* %arrayidx140 to i8*
  call void @llvm.memset.p0i8.i64(i8* %40, i8 0, i64 40, i32 8, i1 false)
  %bFrameIntervalType = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx138, i32 0, i32 7
  store i8 1, i8* %bFrameIntervalType, align 4, !tbaa !140
  %dwDefaultFrameInterval = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx138, i32 0, i32 8
  store i32 1, i32* %dwDefaultFrameInterval, align 8, !tbaa !142
  %41 = load i32*, i32** %intervals, align 8, !tbaa !18
  %dwFrameInterval = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx138, i32 0, i32 9
  store i32* %41, i32** %dwFrameInterval, align 8, !tbaa !143
  %42 = load i32*, i32** %intervals, align 8, !tbaa !18
  %incdec.ptr = getelementptr inbounds i32, i32* %42, i32 1
  store i32* %incdec.ptr, i32** %intervals, align 8, !tbaa !18
  store i32 1, i32* %42, align 4, !tbaa !17
  %nframes = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 7
  store i32 1, i32* %nframes, align 4, !tbaa !128
  br label %do.body159

NewDefault:                                       ; preds = %LeafBlock13, %LeafBlock11, %LeafBlock9, %LeafBlock
  br label %do.body143

do.body143:                                       ; preds = %NewDefault
  %43 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and144 = and i32 %43, 2
  %tobool145 = icmp ne i32 %and144, 0
  br i1 %tobool145, label %if.then146, label %cleanup

if.then146:                                       ; preds = %do.body143
  %udev147 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %44 = load %struct.usb_device*, %struct.usb_device** %udev147, align 8, !tbaa !27
  %devnum148 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %44, i32 0, i32 0
  %45 = load i32, i32* %devnum148, align 8, !tbaa !98
  %desc149 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber150 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc149, i32 0, i32 2
  %46 = load i8, i8* %bInterfaceNumber150, align 2, !tbaa !54
  %conv151 = zext i8 %46 to i32
  %arrayidx152 = getelementptr inbounds i8, i8* %buffer, i64 2
  %47 = load i8, i8* %arrayidx152, align 1, !tbaa !82
  %conv153 = zext i8 %47 to i32
  %call154 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([73 x i8], [73 x i8]* @.str.56, i32 0, i32 0), i32 %45, i32 %conv151, i32 %conv153)
  br label %cleanup

do.body159:                                       ; preds = %if.end71, %sw.epilog, %if.else48, %if.then51, %if.end42
  %width_multiplier.2 = phi i32 [ 1, %sw.epilog ], [ 1, %if.end71 ], [ %width_multiplier.1, %if.else48 ], [ %width_multiplier.1, %if.then51 ], [ %width_multiplier.1, %if.end42 ]
  %ftype.1 = phi i8 [ 0, %sw.epilog ], [ 7, %if.end71 ], [ 5, %if.end42 ], [ 17, %if.then51 ], [ 17, %if.else48 ]
  %48 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and160 = and i32 %48, 2
  %tobool161 = icmp ne i32 %and160, 0
  br i1 %tobool161, label %if.then162, label %do.end168

if.then162:                                       ; preds = %do.body159
  %name163 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 6
  %arraydecay164 = getelementptr inbounds [32 x i8], [32 x i8]* %name163, i32 0, i32 0
  %call165 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.57, i32 0, i32 0), i8* %arraydecay164)
  br label %do.end168

do.end168:                                        ; preds = %if.then162, %do.body159
  br label %while.cond

while.cond:                                       ; preds = %do.end341, %do.end168
  %add.ptr350.sink3 = phi i8* [ %add.ptr350, %do.end341 ], [ %buffer, %do.end168 ]
  %buflen.addr.0.sink = phi i32 [ %sub346, %do.end341 ], [ %buflen, %do.end168 ]
  %arrayidx344 = getelementptr inbounds i8, i8* %add.ptr350.sink3, i64 0
  %49 = load i8, i8* %arrayidx344, align 1, !tbaa !82
  %conv345 = zext i8 %49 to i32
  %sub346 = sub nsw i32 %buflen.addr.0.sink, %conv345
  %arrayidx347 = getelementptr inbounds i8, i8* %add.ptr350.sink3, i64 0
  %50 = load i8, i8* %arrayidx347, align 1, !tbaa !82
  %conv348 = zext i8 %50 to i32
  %idx.ext349 = sext i32 %conv348 to i64
  %add.ptr350 = getelementptr inbounds i8, i8* %add.ptr350.sink3, i64 %idx.ext349
  %cmp173 = icmp sgt i32 %sub346, 2
  br i1 %cmp173, label %land.lhs.true, label %while.end

land.lhs.true:                                    ; preds = %while.cond
  %arrayidx175 = getelementptr inbounds i8, i8* %add.ptr350, i64 1
  %51 = load i8, i8* %arrayidx175, align 1, !tbaa !82
  %conv176 = zext i8 %51 to i32
  %cmp177 = icmp eq i32 %conv176, 36
  br i1 %cmp177, label %land.rhs, label %while.end

land.rhs:                                         ; preds = %land.lhs.true
  %arrayidx179 = getelementptr inbounds i8, i8* %add.ptr350, i64 2
  %52 = load i8, i8* %arrayidx179, align 1, !tbaa !82
  %conv180 = zext i8 %52 to i32
  %conv181 = zext i8 %ftype.1 to i32
  %cmp182 = icmp eq i32 %conv180, %conv181
  br i1 %cmp182, label %while.body, label %while.end

while.body:                                       ; preds = %land.rhs
  %frame184 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 8
  %53 = load %struct.uvc_frame*, %struct.uvc_frame** %frame184, align 8, !tbaa !126
  %nframes185 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 7
  %54 = load i32, i32* %nframes185, align 4, !tbaa !128
  %idxprom = zext i32 %54 to i64
  %arrayidx186 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %53, i64 %idxprom
  %conv187 = zext i8 %ftype.1 to i32
  %cmp188 = icmp ne i32 %conv187, 17
  br i1 %cmp188, label %if.then190, label %if.else196

if.then190:                                       ; preds = %while.body
  %cmp191 = icmp sgt i32 %sub346, 25
  br i1 %cmp191, label %cond.true, label %if.end205

cond.true:                                        ; preds = %if.then190
  %arrayidx193 = getelementptr inbounds i8, i8* %add.ptr350, i64 25
  %55 = load i8, i8* %arrayidx193, align 1, !tbaa !82
  %conv194 = zext i8 %55 to i32
  br label %if.end205

if.else196:                                       ; preds = %while.body
  %cmp197 = icmp sgt i32 %sub346, 21
  br i1 %cmp197, label %cond.true199, label %if.end205

cond.true199:                                     ; preds = %if.else196
  %arrayidx200 = getelementptr inbounds i8, i8* %add.ptr350, i64 21
  %56 = load i8, i8* %arrayidx200, align 1, !tbaa !82
  %conv201 = zext i8 %56 to i32
  br label %if.end205

if.end205:                                        ; preds = %cond.true199, %if.else196, %cond.true, %if.then190
  %n.0 = phi i32 [ %conv194, %cond.true ], [ 0, %if.then190 ], [ %conv201, %cond.true199 ], [ 0, %if.else196 ]
  %tobool206 = icmp ne i32 %n.0, 0
  %n.0. = select i1 %tobool206, i32 %n.0, i32 3
  %mul = mul i32 4, %n.0.
  %add = add i32 26, %mul
  %cmp211 = icmp ult i32 %sub346, %add
  br i1 %cmp211, label %do.body214, label %if.end227

do.body214:                                       ; preds = %if.end205
  %57 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and215 = and i32 %57, 2
  %tobool216 = icmp ne i32 %and215, 0
  br i1 %tobool216, label %if.then217, label %cleanup

if.then217:                                       ; preds = %do.body214
  %udev218 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %58 = load %struct.usb_device*, %struct.usb_device** %udev218, align 8, !tbaa !27
  %devnum219 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %58, i32 0, i32 0
  %59 = load i32, i32* %devnum219, align 8, !tbaa !98
  %desc220 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber221 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc220, i32 0, i32 2
  %60 = load i8, i8* %bInterfaceNumber221, align 2, !tbaa !54
  %conv222 = zext i8 %60 to i32
  %call223 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.58, i32 0, i32 0), i32 %59, i32 %conv222)
  br label %cleanup

if.end227:                                        ; preds = %if.end205
  %arrayidx228 = getelementptr inbounds i8, i8* %add.ptr350, i64 3
  %61 = load i8, i8* %arrayidx228, align 1, !tbaa !82
  %bFrameIndex = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 0
  store i8 %61, i8* %bFrameIndex, align 8, !tbaa !144
  %arrayidx229 = getelementptr inbounds i8, i8* %add.ptr350, i64 4
  %62 = load i8, i8* %arrayidx229, align 1, !tbaa !82
  %bmCapabilities = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 1
  store i8 %62, i8* %bmCapabilities, align 1, !tbaa !145
  %arrayidx230 = getelementptr inbounds i8, i8* %add.ptr350, i64 5
  %call231 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx230)
  %conv232 = zext i16 %call231 to i32
  %mul233 = mul i32 %conv232, %width_multiplier.2
  %conv234 = trunc i32 %mul233 to i16
  %wWidth = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 2
  store i16 %conv234, i16* %wWidth, align 2, !tbaa !146
  %arrayidx235 = getelementptr inbounds i8, i8* %add.ptr350, i64 7
  %call236 = call zeroext i16 @get_unaligned_le16(i8* %arrayidx235)
  %wHeight = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 3
  store i16 %call236, i16* %wHeight, align 4, !tbaa !147
  %arrayidx237 = getelementptr inbounds i8, i8* %add.ptr350, i64 9
  %call238 = call i32 @get_unaligned_le32(i8* %arrayidx237)
  %dwMinBitRate = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 4
  store i32 %call238, i32* %dwMinBitRate, align 8, !tbaa !148
  %arrayidx239 = getelementptr inbounds i8, i8* %add.ptr350, i64 13
  %call240 = call i32 @get_unaligned_le32(i8* %arrayidx239)
  %dwMaxBitRate = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 5
  store i32 %call240, i32* %dwMaxBitRate, align 4, !tbaa !149
  %conv241 = zext i8 %ftype.1 to i32
  %cmp242 = icmp ne i32 %conv241, 17
  br i1 %cmp242, label %if.then244, label %if.end259

if.then244:                                       ; preds = %if.end227
  %arrayidx245 = getelementptr inbounds i8, i8* %add.ptr350, i64 17
  %call246 = call i32 @get_unaligned_le32(i8* %arrayidx245)
  br label %if.end259

if.end259:                                        ; preds = %if.end227, %if.then244
  %.sink8 = phi i32 [ %call246, %if.then244 ], [ 0, %if.end227 ]
  %.sink7 = phi i64 [ 21, %if.then244 ], [ 17, %if.end227 ]
  %.sink6 = phi i64 [ 25, %if.then244 ], [ 21, %if.end227 ]
  %dwMaxVideoFrameBufferSize253 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 6
  store i32 %.sink8, i32* %dwMaxVideoFrameBufferSize253, align 8, !tbaa !150
  %arrayidx254 = getelementptr inbounds i8, i8* %add.ptr350, i64 %.sink7
  %call255 = call i32 @get_unaligned_le32(i8* %arrayidx254)
  %dwDefaultFrameInterval256 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 8
  store i32 %call255, i32* %dwDefaultFrameInterval256, align 8, !tbaa !142
  %arrayidx257 = getelementptr inbounds i8, i8* %add.ptr350, i64 %.sink6
  %63 = load i8, i8* %arrayidx257, align 1, !tbaa !82
  %bFrameIntervalType258 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 7
  store i8 %63, i8* %bFrameIntervalType258, align 4, !tbaa !140
  %64 = load i32*, i32** %intervals, align 8, !tbaa !18
  %dwFrameInterval260 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 9
  store i32* %64, i32** %dwFrameInterval260, align 8, !tbaa !143
  %flags261 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 5
  %65 = load i32, i32* %flags261, align 8, !tbaa !139
  %and262 = and i32 %65, 1
  %tobool263 = icmp ne i32 %and262, 0
  br i1 %tobool263, label %if.end274, label %if.then264

if.then264:                                       ; preds = %if.end259
  %bpp265 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 2
  %66 = load i8, i8* %bpp265, align 2, !tbaa !138
  %conv266 = zext i8 %66 to i32
  %wWidth267 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 2
  %67 = load i16, i16* %wWidth267, align 2, !tbaa !146
  %conv268 = zext i16 %67 to i32
  %mul269 = mul nsw i32 %conv266, %conv268
  %wHeight270 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 3
  %68 = load i16, i16* %wHeight270, align 4, !tbaa !147
  %conv271 = zext i16 %68 to i32
  %mul272 = mul nsw i32 %mul269, %conv271
  %div = sdiv i32 %mul272, 8
  %dwMaxVideoFrameBufferSize273 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 6
  store i32 %div, i32* %dwMaxVideoFrameBufferSize273, align 8, !tbaa !150
  br label %if.end274

if.end274:                                        ; preds = %if.then264, %if.end259
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end274
  %i.0 = phi i32 [ 0, %if.end274 ], [ %inc, %for.body ]
  %cmp275 = icmp ult i32 %i.0, %n.0.
  br i1 %cmp275, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %mul277 = mul i32 4, %i.0
  %add278 = add i32 26, %mul277
  %idxprom279 = zext i32 %add278 to i64
  %arrayidx280 = getelementptr inbounds i8, i8* %add.ptr350, i64 %idxprom279
  %call281 = call i32 @get_unaligned_le32(i8* %arrayidx280)
  %tobool282 = icmp ne i32 %call281, 0
  %call281. = select i1 %tobool282, i32 %call281, i32 1
  %69 = load i32*, i32** %intervals, align 8, !tbaa !18
  %incdec.ptr287 = getelementptr inbounds i32, i32* %69, i32 1
  store i32* %incdec.ptr287, i32** %intervals, align 8, !tbaa !18
  store i32 %call281., i32* %69, align 4, !tbaa !17
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %bFrameIntervalType288 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 7
  %70 = load i8, i8* %bFrameIntervalType288, align 4, !tbaa !140
  %conv289 = zext i8 %70 to i32
  %tobool290 = icmp ne i32 %conv289, 0
  %71 = zext i1 %tobool290 to i64
  %cond291 = select i1 %tobool290, i32 1, i32 2
  %sub292 = sub i32 %n.0., %cond291
  %72 = bitcast i32* %__UNIQUE_ID_min1_20 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %72) #5
  %dwFrameInterval293 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 9
  %73 = load i32*, i32** %dwFrameInterval293, align 8, !tbaa !143
  %idxprom294 = zext i32 %sub292 to i64
  %arrayidx295 = getelementptr inbounds i32, i32* %73, i64 %idxprom294
  %74 = load i32, i32* %arrayidx295, align 4, !tbaa !17
  store i32 %74, i32* %__UNIQUE_ID_min1_20, align 4, !tbaa !17
  %75 = bitcast i32* %__UNIQUE_ID_min2_21 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %75) #5
  %76 = bitcast i32* %__UNIQUE_ID_max1_18 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %76) #5
  %dwFrameInterval296 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 9
  %77 = load i32*, i32** %dwFrameInterval296, align 8, !tbaa !143
  %arrayidx297 = getelementptr inbounds i32, i32* %77, i64 0
  %78 = load i32, i32* %arrayidx297, align 4, !tbaa !17
  store i32 %78, i32* %__UNIQUE_ID_max1_18, align 4, !tbaa !17
  %79 = bitcast i32* %__UNIQUE_ID_max2_19 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %79) #5
  %dwDefaultFrameInterval298 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 8
  %80 = load i32, i32* %dwDefaultFrameInterval298, align 8, !tbaa !142
  store i32 %80, i32* %__UNIQUE_ID_max2_19, align 4, !tbaa !17
  %cmp299 = icmp eq i32* %__UNIQUE_ID_max1_18, %__UNIQUE_ID_max2_19
  %conv300 = zext i1 %cmp299 to i32
  %81 = load i32, i32* %__UNIQUE_ID_max1_18, align 4, !tbaa !17
  %82 = load i32, i32* %__UNIQUE_ID_max2_19, align 4, !tbaa !17
  %cmp301 = icmp ugt i32 %81, %82
  %83 = load i32, i32* %__UNIQUE_ID_max1_18, align 4
  %84 = load i32, i32* %__UNIQUE_ID_max2_19, align 4
  %cond306 = select i1 %cmp301, i32 %83, i32 %84
  %85 = bitcast i32* %__UNIQUE_ID_max2_19 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %85) #5
  %86 = bitcast i32* %__UNIQUE_ID_max1_18 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %86) #5
  store i32 %cond306, i32* %__UNIQUE_ID_min2_21, align 4, !tbaa !17
  %cmp307 = icmp eq i32* %__UNIQUE_ID_min1_20, %__UNIQUE_ID_min2_21
  %conv308 = zext i1 %cmp307 to i32
  %87 = load i32, i32* %__UNIQUE_ID_min1_20, align 4, !tbaa !17
  %88 = load i32, i32* %__UNIQUE_ID_min2_21, align 4, !tbaa !17
  %cmp310 = icmp ult i32 %87, %88
  %89 = load i32, i32* %__UNIQUE_ID_min1_20, align 4
  %90 = load i32, i32* %__UNIQUE_ID_min2_21, align 4
  %cond315 = select i1 %cmp310, i32 %89, i32 %90
  %91 = bitcast i32* %__UNIQUE_ID_min2_21 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %91) #5
  %92 = bitcast i32* %__UNIQUE_ID_min1_20 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %92) #5
  %dwDefaultFrameInterval316 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 8
  store i32 %cond315, i32* %dwDefaultFrameInterval316, align 8, !tbaa !142
  %quirks317 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 3
  %93 = load i32, i32* %quirks317, align 8, !tbaa !57
  %and318 = and i32 %93, 512
  %tobool319 = icmp ne i32 %and318, 0
  br i1 %tobool319, label %if.then320, label %do.body326

if.then320:                                       ; preds = %for.end
  %bFrameIntervalType321 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 7
  store i8 1, i8* %bFrameIntervalType321, align 4, !tbaa !140
  %dwDefaultFrameInterval322 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 8
  %94 = load i32, i32* %dwDefaultFrameInterval322, align 8, !tbaa !142
  %dwFrameInterval323 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 9
  %95 = load i32*, i32** %dwFrameInterval323, align 8, !tbaa !143
  %arrayidx324 = getelementptr inbounds i32, i32* %95, i64 0
  store i32 %94, i32* %arrayidx324, align 4, !tbaa !17
  br label %do.body326

do.body326:                                       ; preds = %for.end, %if.then320
  %96 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and327 = and i32 %96, 2
  %tobool328 = icmp ne i32 %and327, 0
  br i1 %tobool328, label %if.then329, label %do.end341

if.then329:                                       ; preds = %do.body326
  %wWidth330 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 2
  %97 = load i16, i16* %wWidth330, align 2, !tbaa !146
  %conv331 = zext i16 %97 to i32
  %wHeight332 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 3
  %98 = load i16, i16* %wHeight332, align 4, !tbaa !147
  %conv333 = zext i16 %98 to i32
  %dwDefaultFrameInterval334 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 8
  %99 = load i32, i32* %dwDefaultFrameInterval334, align 8, !tbaa !142
  %div335 = udiv i32 10000000, %99
  %dwDefaultFrameInterval336 = getelementptr inbounds %struct.uvc_frame, %struct.uvc_frame* %arrayidx186, i32 0, i32 8
  %100 = load i32, i32* %dwDefaultFrameInterval336, align 8, !tbaa !142
  %div337 = udiv i32 100000000, %100
  %rem = urem i32 %div337, 10
  %call338 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.59, i32 0, i32 0), i32 %conv331, i32 %conv333, i32 %div335, i32 %rem)
  br label %do.end341

do.end341:                                        ; preds = %if.then329, %do.body326
  %nframes342 = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 7
  %101 = load i32, i32* %nframes342, align 4, !tbaa !128
  %inc343 = add i32 %101, 1
  store i32 %inc343, i32* %nframes342, align 4, !tbaa !128
  br label %while.cond

while.end:                                        ; preds = %while.cond, %land.lhs.true, %land.rhs
  %cmp351 = icmp sgt i32 %sub346, 2
  br i1 %cmp351, label %land.lhs.true353, label %if.end371

land.lhs.true353:                                 ; preds = %while.end
  %arrayidx354 = getelementptr inbounds i8, i8* %add.ptr350, i64 1
  %102 = load i8, i8* %arrayidx354, align 1, !tbaa !82
  %conv355 = zext i8 %102 to i32
  %cmp356 = icmp eq i32 %conv355, 36
  br i1 %cmp356, label %land.lhs.true358, label %if.end371

land.lhs.true358:                                 ; preds = %land.lhs.true353
  %arrayidx359 = getelementptr inbounds i8, i8* %add.ptr350, i64 2
  %103 = load i8, i8* %arrayidx359, align 1, !tbaa !82
  %conv360 = zext i8 %103 to i32
  %cmp361 = icmp eq i32 %conv360, 3
  br i1 %cmp361, label %if.then363, label %if.end371

if.then363:                                       ; preds = %land.lhs.true358
  %arrayidx364 = getelementptr inbounds i8, i8* %add.ptr350, i64 0
  %104 = load i8, i8* %arrayidx364, align 1, !tbaa !82
  %conv365 = zext i8 %104 to i32
  %sub366 = sub nsw i32 %sub346, %conv365
  %arrayidx367 = getelementptr inbounds i8, i8* %add.ptr350, i64 0
  %105 = load i8, i8* %arrayidx367, align 1, !tbaa !82
  %conv368 = zext i8 %105 to i32
  %idx.ext369 = sext i32 %conv368 to i64
  %add.ptr370 = getelementptr inbounds i8, i8* %add.ptr350, i64 %idx.ext369
  br label %if.end371

if.end371:                                        ; preds = %if.then363, %land.lhs.true358, %land.lhs.true353, %while.end
  %buflen.addr.1 = phi i32 [ %sub366, %if.then363 ], [ %sub346, %land.lhs.true358 ], [ %sub346, %land.lhs.true353 ], [ %sub346, %while.end ]
  %buffer.addr.1 = phi i8* [ %add.ptr370, %if.then363 ], [ %add.ptr350, %land.lhs.true358 ], [ %add.ptr350, %land.lhs.true353 ], [ %add.ptr350, %while.end ]
  %cmp372 = icmp sgt i32 %buflen.addr.1, 2
  br i1 %cmp372, label %land.lhs.true374, label %if.end412

land.lhs.true374:                                 ; preds = %if.end371
  %arrayidx375 = getelementptr inbounds i8, i8* %buffer.addr.1, i64 1
  %106 = load i8, i8* %arrayidx375, align 1, !tbaa !82
  %conv376 = zext i8 %106 to i32
  %cmp377 = icmp eq i32 %conv376, 36
  br i1 %cmp377, label %land.lhs.true379, label %if.end412

land.lhs.true379:                                 ; preds = %land.lhs.true374
  %arrayidx380 = getelementptr inbounds i8, i8* %buffer.addr.1, i64 2
  %107 = load i8, i8* %arrayidx380, align 1, !tbaa !82
  %conv381 = zext i8 %107 to i32
  %cmp382 = icmp eq i32 %conv381, 13
  br i1 %cmp382, label %if.then384, label %if.end412

if.then384:                                       ; preds = %land.lhs.true379
  %cmp385 = icmp slt i32 %buflen.addr.1, 6
  br i1 %cmp385, label %do.body388, label %if.end401

do.body388:                                       ; preds = %if.then384
  %108 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and389 = and i32 %108, 2
  %tobool390 = icmp ne i32 %and389, 0
  br i1 %tobool390, label %if.then391, label %cleanup

if.then391:                                       ; preds = %do.body388
  %udev392 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %109 = load %struct.usb_device*, %struct.usb_device** %udev392, align 8, !tbaa !27
  %devnum393 = getelementptr inbounds %struct.usb_device, %struct.usb_device* %109, i32 0, i32 0
  %110 = load i32, i32* %devnum393, align 8, !tbaa !98
  %desc394 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %1, i32 0, i32 0
  %bInterfaceNumber395 = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc394, i32 0, i32 2
  %111 = load i8, i8* %bInterfaceNumber395, align 2, !tbaa !54
  %conv396 = zext i8 %111 to i32
  %call397 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.60, i32 0, i32 0), i32 %110, i32 %conv396)
  br label %cleanup

if.end401:                                        ; preds = %if.then384
  %arrayidx402 = getelementptr inbounds i8, i8* %buffer.addr.1, i64 3
  %112 = load i8, i8* %arrayidx402, align 1, !tbaa !82
  %call403 = call i32 @uvc_colorspace(i8 zeroext %112)
  %conv404 = trunc i32 %call403 to i8
  %colorspace = getelementptr inbounds %struct.uvc_format, %struct.uvc_format* %format, i32 0, i32 3
  store i8 %conv404, i8* %colorspace, align 1, !tbaa !151
  %arrayidx405 = getelementptr inbounds i8, i8* %buffer.addr.1, i64 0
  %113 = load i8, i8* %arrayidx405, align 1, !tbaa !82
  %conv406 = zext i8 %113 to i32
  %sub407 = sub nsw i32 %buflen.addr.1, %conv406
  %arrayidx408 = getelementptr inbounds i8, i8* %buffer.addr.1, i64 0
  %114 = load i8, i8* %arrayidx408, align 1, !tbaa !82
  %conv409 = zext i8 %114 to i32
  %idx.ext410 = sext i32 %conv409 to i64
  %add.ptr411 = getelementptr inbounds i8, i8* %buffer.addr.1, i64 %idx.ext410
  br label %if.end412

if.end412:                                        ; preds = %if.end401, %land.lhs.true379, %land.lhs.true374, %if.end371
  %buffer.addr.2 = phi i8* [ %add.ptr411, %if.end401 ], [ %buffer.addr.1, %land.lhs.true379 ], [ %buffer.addr.1, %land.lhs.true374 ], [ %buffer.addr.1, %if.end371 ]
  %sub.ptr.lhs.cast = ptrtoint i8* %buffer.addr.2 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv413 = trunc i64 %sub.ptr.sub to i32
  br label %cleanup

cleanup:                                          ; preds = %do.body388, %if.then391, %do.body214, %if.then217, %do.body143, %if.then146, %do.body111, %if.then114, %do.body82, %if.then85, %do.body58, %if.then61, %do.body, %if.then9, %if.end412
  %retval.0 = phi i32 [ %conv413, %if.end412 ], [ -22, %if.then9 ], [ -22, %do.body ], [ -22, %if.then61 ], [ -22, %do.body58 ], [ -22, %if.then85 ], [ -22, %do.body82 ], [ -22, %if.then114 ], [ -22, %do.body111 ], [ -22, %if.then146 ], [ -22, %do.body143 ], [ -22, %if.then217 ], [ -22, %do.body214 ], [ -22, %if.then391 ], [ -22, %do.body388 ]
  ret i32 %retval.0
}

declare void @usb_put_intf(%struct.usb_interface*) #3

; Function Attrs: nounwind uwtable
define internal %struct.uvc_format_desc* @uvc_format_by_guid(i8* %guid) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 29
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [29 x %struct.uvc_format_desc], [29 x %struct.uvc_format_desc]* @uvc_fmts, i64 0, i64 %idxprom
  %guid1 = getelementptr inbounds %struct.uvc_format_desc, %struct.uvc_format_desc* %arrayidx, i32 0, i32 1
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %guid1, i32 0, i32 0
  %call = call i32 @memcmp(i8* %guid, i8* %arraydecay, i64 16)
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %if.then, label %for.inc

if.then:                                          ; preds = %for.body
  %idxprom3 = zext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [29 x %struct.uvc_format_desc], [29 x %struct.uvc_format_desc]* @uvc_fmts, i64 0, i64 %idxprom3
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.then
  %retval.0 = phi %struct.uvc_format_desc* [ %arrayidx4, %if.then ], [ null, %for.cond ]
  ret %struct.uvc_format_desc* %retval.0
}

declare i64 @strlcat(i8*, i8*, i64) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #1

; Function Attrs: nounwind uwtable
define internal i32 @uvc_colorspace(i8 zeroext %primaries) #0 {
entry:
  %conv = zext i8 %primaries to i64
  %cmp = icmp ult i64 %conv, 6
  br i1 %cmp, label %if.then, label %return

if.then:                                          ; preds = %entry
  %idxprom = zext i8 %primaries to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* @uvc_colorspace.colorprimaries, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !82
  %conv2 = zext i8 %0 to i32
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ %conv2, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

declare i32 @memcmp(i8*, i8*, i64) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_xfer_int(%struct.usb_endpoint_descriptor* %epd) #4 {
entry:
  %bmAttributes = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 3
  %0 = load i8, i8* %bmAttributes, align 1, !tbaa !152
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 3
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @usb_endpoint_dir_in(%struct.usb_endpoint_descriptor* %epd) #4 {
entry:
  %bEndpointAddress = getelementptr inbounds %struct.usb_endpoint_descriptor, %struct.usb_endpoint_descriptor* %epd, i32 0, i32 2
  %0 = load i8, i8* %bEndpointAddress, align 1, !tbaa !88
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 128
  %cmp = icmp eq i32 %and, 128
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind uwtable
define internal %struct.uvc_video_chain* @uvc_alloc_chain(%struct.uvc_device* %dev) #0 {
entry:
  %call = call i8* @kzalloc(i64 112, i32 20971712)
  %0 = bitcast i8* %call to %struct.uvc_video_chain*
  %cmp = icmp eq %struct.uvc_video_chain* %0, null
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %entities = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %0, i32 0, i32 2
  call void @INIT_LIST_HEAD(%struct.list_head* %entities)
  %ctrl_mutex = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %0, i32 0, i32 5
  call void @__mutex_init(%struct.mutex* %ctrl_mutex, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.89, i32 0, i32 0), %struct.lock_class_key* @uvc_alloc_chain.__key)
  %dev1 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %0, i32 0, i32 0
  store %struct.uvc_device* %dev, %struct.uvc_device** %dev1, align 8, !tbaa !153
  %prio = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %0, i32 0, i32 6
  call void @v4l2_prio_init(%struct.v4l2_prio_state* %prio)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end
  %retval.0 = phi %struct.uvc_video_chain* [ %0, %if.end ], [ null, %entry ]
  ret %struct.uvc_video_chain* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_scan_chain(%struct.uvc_video_chain* %chain, %struct.uvc_entity* %term) #0 {
entry:
  %entity = alloca %struct.uvc_entity*, align 8
  %0 = bitcast %struct.uvc_entity** %entity to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %1, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.90, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  store %struct.uvc_entity* %term, %struct.uvc_entity** %entity, align 8, !tbaa !18
  br label %while.cond

while.cond:                                       ; preds = %if.end30, %do.end
  %prev.0 = phi %struct.uvc_entity* [ null, %do.end ], [ %12, %if.end30 ]
  %2 = load %struct.uvc_entity*, %struct.uvc_entity** %entity, align 8, !tbaa !18
  %cmp = icmp ne %struct.uvc_entity* %2, null
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load %struct.uvc_entity*, %struct.uvc_entity** %entity, align 8, !tbaa !18
  %chain1 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %3, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %chain1, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !91
  %tobool2 = icmp ne %struct.list_head* %4, null
  br i1 %tobool2, label %do.body7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %5 = load %struct.uvc_entity*, %struct.uvc_entity** %entity, align 8, !tbaa !18
  %chain3 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %5, i32 0, i32 1
  %prev4 = getelementptr inbounds %struct.list_head, %struct.list_head* %chain3, i32 0, i32 1
  %6 = load %struct.list_head*, %struct.list_head** %prev4, align 8, !tbaa !92
  %tobool5 = icmp ne %struct.list_head* %6, null
  br i1 %tobool5, label %do.body7, label %if.end15

do.body7:                                         ; preds = %while.body, %lor.lhs.false
  %7 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and8 = and i32 %7, 2
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %cleanup

if.then10:                                        ; preds = %do.body7
  %8 = load %struct.uvc_entity*, %struct.uvc_entity** %entity, align 8, !tbaa !18
  %id = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %8, i32 0, i32 3
  %9 = load i8, i8* %id, align 4, !tbaa !19
  %conv = zext i8 %9 to i32
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.91, i32 0, i32 0), i32 %conv)
  br label %cleanup

if.end15:                                         ; preds = %lor.lhs.false
  %10 = load %struct.uvc_entity*, %struct.uvc_entity** %entity, align 8, !tbaa !18
  %call16 = call i32 @uvc_scan_chain_entity(%struct.uvc_video_chain* %chain, %struct.uvc_entity* %10)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %cleanup, label %if.end20

if.end20:                                         ; preds = %if.end15
  %11 = load %struct.uvc_entity*, %struct.uvc_entity** %entity, align 8, !tbaa !18
  %call21 = call i32 @uvc_scan_chain_forward(%struct.uvc_video_chain* %chain, %struct.uvc_entity* %11, %struct.uvc_entity* %prev.0)
  %cmp22 = icmp slt i32 %call21, 0
  br i1 %cmp22, label %cleanup, label %if.end25

if.end25:                                         ; preds = %if.end20
  %12 = load %struct.uvc_entity*, %struct.uvc_entity** %entity, align 8, !tbaa !18
  %call26 = call i32 @uvc_scan_chain_backward(%struct.uvc_video_chain* %chain, %struct.uvc_entity** %entity)
  %cmp27 = icmp slt i32 %call26, 0
  br i1 %cmp27, label %cleanup, label %if.end30

if.end30:                                         ; preds = %if.end25
  br label %while.cond

cleanup:                                          ; preds = %while.cond, %if.end25, %if.end20, %if.end15, %do.body7, %if.then10
  %retval.0 = phi i32 [ -22, %if.then10 ], [ -22, %do.body7 ], [ -22, %if.end15 ], [ -22, %if.end20 ], [ -22, %if.end25 ], [ 0, %while.cond ]
  %13 = bitcast %struct.uvc_entity** %entity to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #5
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i8* @uvc_print_chain(%struct.uvc_video_chain* %chain) #0 {
entry:
  %entities = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  %call = call i32 @uvc_print_terms(%struct.list_head* %entities, i16 zeroext 0, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @uvc_print_chain.buffer, i32 0, i32 0))
  %idx.ext = zext i32 %call to i64
  %add.ptr = getelementptr inbounds i8, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @uvc_print_chain.buffer, i32 0, i32 0), i64 %idx.ext
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %add.ptr, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.110, i32 0, i32 0))
  %idx.ext2 = sext i32 %call1 to i64
  %add.ptr3 = getelementptr inbounds i8, i8* %add.ptr, i64 %idx.ext2
  %entities4 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  %call5 = call i32 @uvc_print_terms(%struct.list_head* %entities4, i16 zeroext -32768, i8* %add.ptr3)
  ret i8* getelementptr inbounds ([43 x i8], [43 x i8]* @uvc_print_chain.buffer, i32 0, i32 0)
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #4 {
entry:
  %__u = alloca %union.anon.73, align 8
  %0 = bitcast %union.anon.73* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.73* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.73* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val, align 8, !tbaa !82
  %3 = bitcast %union.anon.73* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #5
  %cmp = icmp eq %struct.list_head* %2, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_scan_fallback(%struct.uvc_device* %dev) #0 {
entry:
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list28.sink = phi %struct.list_head* [ %list28, %for.inc ], [ %entities, %entry ]
  %oterm.0 = phi %struct.uvc_entity* [ null, %entry ], [ %oterm.1, %for.inc ]
  %iterm.0 = phi %struct.uvc_entity* [ null, %entry ], [ %iterm.1, %for.inc ]
  %next29 = getelementptr inbounds %struct.list_head, %struct.list_head* %list28.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next29, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr31 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr31 to %struct.uvc_entity*
  %list = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 0
  %entities1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %list, %entities1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %type = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %3 = load i16, i16* %type, align 2, !tbaa !90
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 65280
  %cmp2 = icmp ne i32 %and, 0
  br i1 %cmp2, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %for.body
  %type4 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %4 = load i16, i16* %type4, align 2, !tbaa !90
  %conv5 = zext i16 %4 to i32
  %and6 = and i32 %conv5, 32768
  %cmp7 = icmp eq i32 %and6, 0
  br i1 %cmp7, label %if.then, label %if.end10

if.then:                                          ; preds = %land.lhs.true
  %tobool = icmp ne %struct.uvc_entity* %iterm.0, null
  br i1 %tobool, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.then, %land.lhs.true, %for.body
  %iterm.1 = phi %struct.uvc_entity* [ %iterm.0, %land.lhs.true ], [ %iterm.0, %for.body ], [ %2, %if.then ]
  %type11 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %5 = load i16, i16* %type11, align 2, !tbaa !90
  %conv12 = zext i16 %5 to i32
  %and13 = and i32 %conv12, 65280
  %cmp14 = icmp ne i32 %and13, 0
  br i1 %cmp14, label %land.lhs.true16, label %for.inc

land.lhs.true16:                                  ; preds = %if.end10
  %type17 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %6 = load i16, i16* %type17, align 2, !tbaa !90
  %conv18 = zext i16 %6 to i32
  %and19 = and i32 %conv18, 32768
  %cmp20 = icmp eq i32 %and19, 32768
  br i1 %cmp20, label %if.then22, label %for.inc

if.then22:                                        ; preds = %land.lhs.true16
  %tobool23 = icmp ne %struct.uvc_entity* %oterm.0, null
  br i1 %tobool23, label %cleanup, label %for.inc

for.inc:                                          ; preds = %if.end10, %land.lhs.true16, %if.then22
  %oterm.1 = phi %struct.uvc_entity* [ %oterm.0, %land.lhs.true16 ], [ %oterm.0, %if.end10 ], [ %2, %if.then22 ]
  %list28 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %cmp32 = icmp eq %struct.uvc_entity* %iterm.0, null
  %cmp34 = icmp eq %struct.uvc_entity* %oterm.0, null
  %or.cond = or i1 %cmp32, %cmp34
  br i1 %or.cond, label %cleanup, label %if.end37

if.end37:                                         ; preds = %for.end
  %call = call %struct.uvc_video_chain* @uvc_alloc_chain(%struct.uvc_device* %dev)
  %cmp38 = icmp eq %struct.uvc_video_chain* %call, null
  br i1 %cmp38, label %cleanup, label %if.end41

if.end41:                                         ; preds = %if.end37
  %call42 = call i32 @uvc_scan_chain_entity(%struct.uvc_video_chain* %call, %struct.uvc_entity* %oterm.0)
  %cmp43 = icmp slt i32 %call42, 0
  br i1 %cmp43, label %error, label %if.end46

if.end46:                                         ; preds = %if.end41
  %entities48 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  br label %for.cond52

for.cond52:                                       ; preds = %for.inc78, %if.end46
  %list80.sink = phi %struct.list_head* [ %list80, %for.inc78 ], [ %entities48, %if.end46 ]
  %prev.0 = phi %struct.uvc_entity* [ %oterm.0, %if.end46 ], [ %prev.1, %for.inc78 ]
  %prev81 = getelementptr inbounds %struct.list_head, %struct.list_head* %list80.sink, i32 0, i32 1
  %7 = load %struct.list_head*, %struct.list_head** %prev81, align 8, !tbaa !18
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr83 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr83 to %struct.uvc_entity*
  %list53 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %9, i32 0, i32 0
  %entities54 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %cmp55 = icmp ne %struct.list_head* %list53, %entities54
  br i1 %cmp55, label %for.body57, label %for.end84

for.body57:                                       ; preds = %for.cond52
  %type58 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %9, i32 0, i32 4
  %10 = load i16, i16* %type58, align 2, !tbaa !90
  %conv59 = zext i16 %10 to i32
  %cmp60 = icmp ne i32 %conv59, 5
  br i1 %cmp60, label %land.lhs.true62, label %if.end68

land.lhs.true62:                                  ; preds = %for.body57
  %type63 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %9, i32 0, i32 4
  %11 = load i16, i16* %type63, align 2, !tbaa !90
  %conv64 = zext i16 %11 to i32
  %cmp65 = icmp ne i32 %conv64, 6
  br i1 %cmp65, label %for.inc78, label %if.end68

if.end68:                                         ; preds = %land.lhs.true62, %for.body57
  %num_pads = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %9, i32 0, i32 8
  %12 = load i32, i32* %num_pads, align 8, !tbaa !102
  %cmp69 = icmp ne i32 %12, 2
  br i1 %cmp69, label %for.inc78, label %if.end72

if.end72:                                         ; preds = %if.end68
  %call73 = call i32 @uvc_scan_chain_entity(%struct.uvc_video_chain* %call, %struct.uvc_entity* %9)
  %cmp74 = icmp slt i32 %call73, 0
  br i1 %cmp74, label %error, label %if.end77

if.end77:                                         ; preds = %if.end72
  %id = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %9, i32 0, i32 3
  %13 = load i8, i8* %id, align 4, !tbaa !19
  %baSourceID = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %prev.0, i32 0, i32 13
  %14 = load i8*, i8** %baSourceID, align 8, !tbaa !99
  %arrayidx = getelementptr inbounds i8, i8* %14, i64 0
  store i8 %13, i8* %arrayidx, align 1, !tbaa !82
  br label %for.inc78

for.inc78:                                        ; preds = %if.end68, %land.lhs.true62, %if.end77
  %prev.1 = phi %struct.uvc_entity* [ %9, %if.end77 ], [ %prev.0, %land.lhs.true62 ], [ %prev.0, %if.end68 ]
  %list80 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %9, i32 0, i32 0
  br label %for.cond52

for.end84:                                        ; preds = %for.cond52
  %call85 = call i32 @uvc_scan_chain_entity(%struct.uvc_video_chain* %call, %struct.uvc_entity* %iterm.0)
  %cmp86 = icmp slt i32 %call85, 0
  br i1 %cmp86, label %error, label %if.end89

if.end89:                                         ; preds = %for.end84
  %id90 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %iterm.0, i32 0, i32 3
  %15 = load i8, i8* %id90, align 4, !tbaa !19
  %baSourceID91 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %prev.0, i32 0, i32 13
  %16 = load i8*, i8** %baSourceID91, align 8, !tbaa !99
  %arrayidx92 = getelementptr inbounds i8, i8* %16, i64 0
  store i8 %15, i8* %arrayidx92, align 1, !tbaa !82
  %list93 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %call, i32 0, i32 1
  %chains = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  call void @list_add_tail(%struct.list_head* %list93, %struct.list_head* %chains)
  %17 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and94 = and i32 %17, 1
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %if.then96, label %cleanup

if.then96:                                        ; preds = %if.end89
  %call97 = call i8* @uvc_print_chain(%struct.uvc_video_chain* %call)
  %call98 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.114, i32 0, i32 0), i8* %call97)
  br label %cleanup

error:                                            ; preds = %for.end84, %if.end72, %if.end41
  %18 = bitcast %struct.uvc_video_chain* %call to i8*
  call void @kfree(i8* %18)
  br label %cleanup

cleanup:                                          ; preds = %if.end89, %if.then96, %if.end37, %for.end, %if.then22, %if.then, %error
  %retval.0 = phi i32 [ -22, %error ], [ -22, %if.then ], [ -22, %if.then22 ], [ -22, %for.end ], [ -12, %if.end37 ], [ 0, %if.then96 ], [ 0, %if.end89 ]
  ret i32 %retval.0
}

declare void @v4l2_prio_init(%struct.v4l2_prio_state*) #3

; Function Attrs: nounwind uwtable
define internal i32 @uvc_scan_chain_entity(%struct.uvc_video_chain* %chain, %struct.uvc_entity* %entity) #0 {
entry:
  %type = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 4
  %0 = load i16, i16* %type, align 2, !tbaa !90
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 32767
  br label %NodeBlock16

NodeBlock16:                                      ; preds = %entry
  %Pivot17 = icmp slt i32 %and, 257
  br i1 %Pivot17, label %NodeBlock3, label %NodeBlock14

NodeBlock14:                                      ; preds = %NodeBlock16
  %Pivot15 = icmp slt i32 %and, 512
  br i1 %Pivot15, label %LeafBlock5, label %NodeBlock12

NodeBlock12:                                      ; preds = %NodeBlock14
  %Pivot13 = icmp slt i32 %and, 768
  br i1 %Pivot13, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock12
  %and.off10 = add i32 %and, -768
  %SwitchLeaf11 = icmp ule i32 %and.off10, 2
  br i1 %SwitchLeaf11, label %sw.bb68, label %NewDefault

LeafBlock7:                                       ; preds = %NodeBlock12
  %and.off = add i32 %and, -512
  %SwitchLeaf8 = icmp ule i32 %and.off, 2
  br i1 %SwitchLeaf8, label %sw.bb60, label %NewDefault

LeafBlock5:                                       ; preds = %NodeBlock14
  %SwitchLeaf6 = icmp eq i32 %and, 257
  br i1 %SwitchLeaf6, label %sw.bb76, label %NewDefault

NodeBlock3:                                       ; preds = %NodeBlock16
  %Pivot4 = icmp slt i32 %and, 5
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %and, 6
  br i1 %Pivot, label %sw.bb14, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 6
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %and, 4
  br i1 %SwitchLeaf, label %sw.bb34, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %1 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and1 = and i32 %1, 1
  %tobool = icmp ne i32 %and1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %id = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %2 = load i8, i8* %id, align 4, !tbaa !19
  %conv2 = zext i8 %2 to i32
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.92, i32 0, i32 0), i32 %conv2)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %bNrInPins = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 12
  %3 = load i8, i8* %bNrInPins, align 8, !tbaa !107
  %conv3 = zext i8 %3 to i32
  %cmp = icmp ne i32 %conv3, 1
  br i1 %cmp, label %do.body, label %sw.epilog

do.body:                                          ; preds = %if.end
  %4 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and6 = and i32 %4, 2
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %return

if.then8:                                         ; preds = %do.body
  %id9 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %5 = load i8, i8* %id9, align 4, !tbaa !19
  %conv10 = zext i8 %5 to i32
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([58 x i8], [58 x i8]* @.str.93, i32 0, i32 0), i32 %conv10)
  br label %return

sw.bb14:                                          ; preds = %NodeBlock
  %6 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and15 = and i32 %6, 1
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end21

if.then17:                                        ; preds = %sw.bb14
  %id18 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %7 = load i8, i8* %id18, align 4, !tbaa !19
  %conv19 = zext i8 %7 to i32
  %call20 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.94, i32 0, i32 0), i32 %conv19)
  br label %if.end21

if.end21:                                         ; preds = %if.then17, %sw.bb14
  %processing = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 3
  %8 = load %struct.uvc_entity*, %struct.uvc_entity** %processing, align 8, !tbaa !155
  %cmp22 = icmp ne %struct.uvc_entity* %8, null
  br i1 %cmp22, label %do.body25, label %if.end32

do.body25:                                        ; preds = %if.end21
  %9 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and26 = and i32 %9, 2
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then28, label %return

if.then28:                                        ; preds = %do.body25
  %call29 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.95, i32 0, i32 0))
  br label %return

if.end32:                                         ; preds = %if.end21
  %processing33 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 3
  store %struct.uvc_entity* %entity, %struct.uvc_entity** %processing33, align 8, !tbaa !155
  br label %sw.epilog

sw.bb34:                                          ; preds = %LeafBlock
  %10 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and35 = and i32 %10, 1
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then37, label %if.end41

if.then37:                                        ; preds = %sw.bb34
  %id38 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %11 = load i8, i8* %id38, align 4, !tbaa !19
  %conv39 = zext i8 %11 to i32
  %call40 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.96, i32 0, i32 0), i32 %conv39)
  br label %if.end41

if.end41:                                         ; preds = %if.then37, %sw.bb34
  %bNrInPins42 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 12
  %12 = load i8, i8* %bNrInPins42, align 8, !tbaa !107
  %conv43 = zext i8 %12 to i32
  %cmp44 = icmp eq i32 %conv43, 1
  br i1 %cmp44, label %sw.epilog, label %if.end47

if.end47:                                         ; preds = %if.end41
  %selector = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 4
  %13 = load %struct.uvc_entity*, %struct.uvc_entity** %selector, align 8, !tbaa !156
  %cmp48 = icmp ne %struct.uvc_entity* %13, null
  br i1 %cmp48, label %do.body51, label %if.end58

do.body51:                                        ; preds = %if.end47
  %14 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and52 = and i32 %14, 2
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then54, label %return

if.then54:                                        ; preds = %do.body51
  %call55 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.97, i32 0, i32 0))
  br label %return

if.end58:                                         ; preds = %if.end47
  %selector59 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 4
  store %struct.uvc_entity* %entity, %struct.uvc_entity** %selector59, align 8, !tbaa !156
  br label %sw.epilog

sw.bb60:                                          ; preds = %LeafBlock7
  %15 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and61 = and i32 %15, 1
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then63, label %sw.epilog

if.then63:                                        ; preds = %sw.bb60
  %id64 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %16 = load i8, i8* %id64, align 4, !tbaa !19
  %conv65 = zext i8 %16 to i32
  %call66 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.98, i32 0, i32 0), i32 %conv65)
  br label %sw.epilog

sw.bb68:                                          ; preds = %LeafBlock9
  %17 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and69 = and i32 %17, 1
  %tobool70 = icmp ne i32 %and69, 0
  br i1 %tobool70, label %if.then71, label %sw.epilog

if.then71:                                        ; preds = %sw.bb68
  %id72 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %18 = load i8, i8* %id72, align 4, !tbaa !19
  %conv73 = zext i8 %18 to i32
  %call74 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.99, i32 0, i32 0), i32 %conv73)
  br label %sw.epilog

sw.bb76:                                          ; preds = %LeafBlock5
  %type77 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 4
  %19 = load i16, i16* %type77, align 2, !tbaa !90
  %conv78 = zext i16 %19 to i32
  %and79 = and i32 %conv78, 65280
  %cmp80 = icmp ne i32 %and79, 0
  br i1 %cmp80, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %sw.bb76
  %type82 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 4
  %20 = load i16, i16* %type82, align 2, !tbaa !90
  %conv83 = zext i16 %20 to i32
  %and84 = and i32 %conv83, 32768
  %cmp85 = icmp eq i32 %and84, 0
  br i1 %cmp85, label %if.then87, label %if.else

if.then87:                                        ; preds = %land.lhs.true
  %21 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and88 = and i32 %21, 1
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %if.then90, label %sw.epilog

if.then90:                                        ; preds = %if.then87
  %id91 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %22 = load i8, i8* %id91, align 4, !tbaa !19
  %conv92 = zext i8 %22 to i32
  %call93 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.98, i32 0, i32 0), i32 %conv92)
  br label %sw.epilog

if.else:                                          ; preds = %land.lhs.true, %sw.bb76
  %23 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and95 = and i32 %23, 1
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.then97, label %sw.epilog

if.then97:                                        ; preds = %if.else
  %id98 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %24 = load i8, i8* %id98, align 4, !tbaa !19
  %conv99 = zext i8 %24 to i32
  %call100 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.99, i32 0, i32 0), i32 %conv99)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock9, %LeafBlock7, %LeafBlock5, %LeafBlock1, %LeafBlock
  br label %do.body103

do.body103:                                       ; preds = %NewDefault
  %25 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and104 = and i32 %25, 2
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %if.then106, label %return

if.then106:                                       ; preds = %do.body103
  %type107 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 4
  %26 = load i16, i16* %type107, align 2, !tbaa !90
  %conv108 = zext i16 %26 to i32
  %and109 = and i32 %conv108, 32767
  %call110 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.100, i32 0, i32 0), i32 %and109)
  br label %return

sw.epilog:                                        ; preds = %if.then90, %if.then87, %if.then97, %if.else, %sw.bb68, %if.then71, %sw.bb60, %if.then63, %if.end41, %if.end, %if.end58, %if.end32
  %chain113 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 1
  %entities = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  call void @list_add_tail(%struct.list_head* %chain113, %struct.list_head* %entities)
  br label %return

return:                                           ; preds = %if.then106, %do.body103, %if.then54, %do.body51, %if.then28, %do.body25, %if.then8, %do.body, %sw.epilog
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -1, %do.body ], [ -1, %if.then8 ], [ -1, %do.body25 ], [ -1, %if.then28 ], [ -1, %do.body51 ], [ -1, %if.then54 ], [ -1, %do.body103 ], [ -1, %if.then106 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_scan_chain_forward(%struct.uvc_video_chain* %chain, %struct.uvc_entity* %entity, %struct.uvc_entity* %prev) #0 {
entry:
  br label %while.cond.outer

while.cond.outer:                                 ; preds = %sw.epilog, %entry
  %forward.0.ph = phi %struct.uvc_entity* [ %call, %sw.epilog ], [ null, %entry ]
  %found.0.ph = phi i32 [ %found.3, %sw.epilog ], [ 0, %entry ]
  br label %while.cond

while.cond:                                       ; preds = %while.cond.outer, %if.then4
  %forward.0 = phi %struct.uvc_entity* [ %call, %if.then4 ], [ %forward.0.ph, %while.cond.outer ]
  %dev = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 0
  %0 = load %struct.uvc_device*, %struct.uvc_device** %dev, align 8, !tbaa !153
  %id = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %1 = load i8, i8* %id, align 4, !tbaa !19
  %conv = zext i8 %1 to i32
  %call = call %struct.uvc_entity* @uvc_entity_by_reference(%struct.uvc_device* %0, i32 %conv, %struct.uvc_entity* %forward.0)
  %cmp = icmp eq %struct.uvc_entity* %call, null
  br i1 %cmp, label %while.end, label %if.end

if.end:                                           ; preds = %while.cond
  %cmp2 = icmp eq %struct.uvc_entity* %call, %prev
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %while.cond

if.end5:                                          ; preds = %if.end
  %type = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 4
  %2 = load i16, i16* %type, align 2, !tbaa !90
  %conv6 = zext i16 %2 to i32
  %and = and i32 %conv6, 32767
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end5
  %Pivot6 = icmp slt i32 %and, 257
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %and, 768
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %and.off = add i32 %and, -768
  %SwitchLeaf4 = icmp ule i32 %and.off, 2
  br i1 %SwitchLeaf4, label %sw.bb30, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %and, 257
  br i1 %SwitchLeaf2, label %sw.bb30, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %and, 6
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %bNrInPins = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 12
  %3 = load i8, i8* %bNrInPins, align 8, !tbaa !107
  %conv7 = zext i8 %3 to i32
  %cmp8 = icmp ne i32 %conv7, 1
  br i1 %cmp8, label %do.body, label %if.end17

do.body:                                          ; preds = %sw.bb
  %4 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and11 = and i32 %4, 2
  %tobool = icmp ne i32 %and11, 0
  br i1 %tobool, label %if.then12, label %cleanup

if.then12:                                        ; preds = %do.body
  %id13 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %entity, i32 0, i32 3
  %5 = load i8, i8* %id13, align 4, !tbaa !19
  %conv14 = zext i8 %5 to i32
  %call15 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([58 x i8], [58 x i8]* @.str.93, i32 0, i32 0), i32 %conv14)
  br label %cleanup

if.end17:                                         ; preds = %sw.bb
  %chain18 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 1
  %entities = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  call void @list_add_tail(%struct.list_head* %chain18, %struct.list_head* %entities)
  %6 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and19 = and i32 %6, 1
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %sw.epilog

if.then21:                                        ; preds = %if.end17
  %tobool22 = icmp ne i32 %found.0.ph, 0
  br i1 %tobool22, label %if.end25, label %if.then23

if.then23:                                        ; preds = %if.then21
  %call24 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.101, i32 0, i32 0))
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.then21
  %id26 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 3
  %7 = load i8, i8* %id26, align 4, !tbaa !19
  %conv27 = zext i8 %7 to i32
  %call28 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.102, i32 0, i32 0), i32 %conv27)
  br label %sw.epilog

sw.bb30:                                          ; preds = %LeafBlock3, %LeafBlock1
  %type31 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 4
  %8 = load i16, i16* %type31, align 2, !tbaa !90
  %conv32 = zext i16 %8 to i32
  %and33 = and i32 %conv32, 65280
  %cmp34 = icmp ne i32 %and33, 0
  br i1 %cmp34, label %land.lhs.true, label %if.end52

land.lhs.true:                                    ; preds = %sw.bb30
  %type36 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 4
  %9 = load i16, i16* %type36, align 2, !tbaa !90
  %conv37 = zext i16 %9 to i32
  %and38 = and i32 %conv37, 32768
  %cmp39 = icmp eq i32 %and38, 0
  br i1 %cmp39, label %do.body42, label %if.end52

do.body42:                                        ; preds = %land.lhs.true
  %10 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and43 = and i32 %10, 2
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then45, label %cleanup

if.then45:                                        ; preds = %do.body42
  %id46 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 3
  %11 = load i8, i8* %id46, align 4, !tbaa !19
  %conv47 = zext i8 %11 to i32
  %call48 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.103, i32 0, i32 0), i32 %conv47)
  br label %cleanup

if.end52:                                         ; preds = %land.lhs.true, %sw.bb30
  %chain53 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 1
  %entities54 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  call void @list_add_tail(%struct.list_head* %chain53, %struct.list_head* %entities54)
  %12 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and55 = and i32 %12, 1
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %sw.epilog

if.then57:                                        ; preds = %if.end52
  %tobool58 = icmp ne i32 %found.0.ph, 0
  br i1 %tobool58, label %if.end61, label %if.then59

if.then59:                                        ; preds = %if.then57
  %call60 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.101, i32 0, i32 0))
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %if.then57
  %id62 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call, i32 0, i32 3
  %13 = load i8, i8* %id62, align 4, !tbaa !19
  %conv63 = zext i8 %13 to i32
  %call64 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.99, i32 0, i32 0), i32 %conv63)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %if.end52, %if.end61, %if.end17, %if.end25
  %found.3 = phi i32 [ %found.0.ph, %NewDefault ], [ 1, %if.end25 ], [ %found.0.ph, %if.end17 ], [ 1, %if.end61 ], [ %found.0.ph, %if.end52 ]
  br label %while.cond.outer

while.end:                                        ; preds = %while.cond
  %tobool66 = icmp ne i32 %found.0.ph, 0
  br i1 %tobool66, label %if.then67, label %cleanup

if.then67:                                        ; preds = %while.end
  %call68 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.104, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %while.end, %if.then67, %do.body42, %if.then45, %do.body, %if.then12
  %retval.0 = phi i32 [ -22, %if.then12 ], [ -22, %do.body ], [ -22, %if.then45 ], [ -22, %do.body42 ], [ 0, %if.then67 ], [ 0, %while.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_scan_chain_backward(%struct.uvc_video_chain* %chain, %struct.uvc_entity** %_entity) #0 {
entry:
  %0 = load %struct.uvc_entity*, %struct.uvc_entity** %_entity, align 8, !tbaa !18
  %type = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 4
  %1 = load i16, i16* %type, align 2, !tbaa !90
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 32767
  br label %NodeBlock15

NodeBlock15:                                      ; preds = %entry
  %Pivot16 = icmp slt i32 %and, 257
  br i1 %Pivot16, label %NodeBlock, label %NodeBlock13

NodeBlock13:                                      ; preds = %NodeBlock15
  %Pivot14 = icmp slt i32 %and, 512
  br i1 %Pivot14, label %LeafBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %and, 768
  br i1 %Pivot12, label %LeafBlock5, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock11
  %and.off9 = add i32 %and, -768
  %SwitchLeaf10 = icmp ule i32 %and.off9, 2
  br i1 %SwitchLeaf10, label %sw.bb54, label %NewDefault

LeafBlock5:                                       ; preds = %NodeBlock11
  %and.off6 = add i32 %and, -512
  %SwitchLeaf7 = icmp ule i32 %and.off6, 2
  br i1 %SwitchLeaf7, label %sw.bb54, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock13
  %SwitchLeaf4 = icmp eq i32 %and, 257
  br i1 %SwitchLeaf4, label %sw.bb54, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock15
  %Pivot = icmp slt i32 %and, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %and.off = add i32 %and, -5
  %SwitchLeaf2 = icmp ule i32 %and.off, 1
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %and, 4
  br i1 %SwitchLeaf, label %sw.bb2, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %baSourceID = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 13
  %2 = load i8*, i8** %baSourceID, align 8, !tbaa !99
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 0
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !82
  %conv1 = zext i8 %3 to i32
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock
  %bNrInPins = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 12
  %4 = load i8, i8* %bNrInPins, align 8, !tbaa !107
  %conv3 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb2
  %baSourceID5 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 13
  %5 = load i8*, i8** %baSourceID5, align 8, !tbaa !99
  %arrayidx6 = getelementptr inbounds i8, i8* %5, i64 0
  %6 = load i8, i8* %arrayidx6, align 1, !tbaa !82
  %conv7 = zext i8 %6 to i32
  br label %sw.epilog

if.end:                                           ; preds = %sw.bb2
  %7 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and8 = and i32 %7, 1
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.105, i32 0, i32 0))
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end
  %selector = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 4
  store %struct.uvc_entity* %0, %struct.uvc_entity** %selector, align 8, !tbaa !156
  br label %for.cond

for.cond:                                         ; preds = %if.end46, %if.end10
  %i.0 = phi i32 [ 0, %if.end10 ], [ %inc, %if.end46 ]
  %bNrInPins11 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 12
  %8 = load i8, i8* %bNrInPins11, align 8, !tbaa !107
  %conv12 = zext i8 %8 to i32
  %cmp13 = icmp slt i32 %i.0, %conv12
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %baSourceID15 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 13
  %9 = load i8*, i8** %baSourceID15, align 8, !tbaa !99
  %idxprom = sext i32 %i.0 to i64
  %arrayidx16 = getelementptr inbounds i8, i8* %9, i64 %idxprom
  %10 = load i8, i8* %arrayidx16, align 1, !tbaa !82
  %conv17 = zext i8 %10 to i32
  %dev = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 0
  %11 = load %struct.uvc_device*, %struct.uvc_device** %dev, align 8, !tbaa !153
  %call18 = call %struct.uvc_entity* @uvc_entity_by_id(%struct.uvc_device* %11, i32 %conv17)
  %cmp19 = icmp eq %struct.uvc_entity* %call18, null
  br i1 %cmp19, label %do.body, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %type21 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call18, i32 0, i32 4
  %12 = load i16, i16* %type21, align 2, !tbaa !90
  %conv22 = zext i16 %12 to i32
  %and23 = and i32 %conv22, 65280
  %cmp24 = icmp ne i32 %and23, 0
  br i1 %cmp24, label %land.lhs.true, label %do.body

land.lhs.true:                                    ; preds = %lor.lhs.false
  %type26 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call18, i32 0, i32 4
  %13 = load i16, i16* %type26, align 2, !tbaa !90
  %conv27 = zext i16 %13 to i32
  %and28 = and i32 %conv27, 32768
  %cmp29 = icmp eq i32 %and28, 0
  br i1 %cmp29, label %if.end39, label %do.body

do.body:                                          ; preds = %for.body, %lor.lhs.false, %land.lhs.true
  %14 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and32 = and i32 %14, 2
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.then34, label %cleanup

if.then34:                                        ; preds = %do.body
  %id35 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 3
  %15 = load i8, i8* %id35, align 4, !tbaa !19
  %conv36 = zext i8 %15 to i32
  %call37 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.106, i32 0, i32 0), i32 %conv36, i32 %i.0)
  br label %cleanup

if.end39:                                         ; preds = %land.lhs.true
  %16 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and40 = and i32 %16, 1
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then42, label %if.end46

if.then42:                                        ; preds = %if.end39
  %id43 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call18, i32 0, i32 3
  %17 = load i8, i8* %id43, align 4, !tbaa !19
  %conv44 = zext i8 %17 to i32
  %call45 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.107, i32 0, i32 0), i32 %conv44)
  br label %if.end46

if.end46:                                         ; preds = %if.then42, %if.end39
  %chain47 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %call18, i32 0, i32 1
  %entities = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  call void @list_add_tail(%struct.list_head* %chain47, %struct.list_head* %entities)
  %call48 = call i32 @uvc_scan_chain_forward(%struct.uvc_video_chain* %chain, %struct.uvc_entity* %call18, %struct.uvc_entity* %0)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and49 = and i32 %18, 1
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %if.then51, label %sw.epilog

if.then51:                                        ; preds = %for.end
  %call52 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.108, i32 0, i32 0))
  br label %sw.epilog

sw.bb54:                                          ; preds = %LeafBlock8, %LeafBlock5, %LeafBlock3
  %type55 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 4
  %19 = load i16, i16* %type55, align 2, !tbaa !90
  %conv56 = zext i16 %19 to i32
  %and57 = and i32 %conv56, 65280
  %cmp58 = icmp ne i32 %and57, 0
  br i1 %cmp58, label %land.lhs.true60, label %sw.epilog

land.lhs.true60:                                  ; preds = %sw.bb54
  %type61 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 4
  %20 = load i16, i16* %type61, align 2, !tbaa !90
  %conv62 = zext i16 %20 to i32
  %and63 = and i32 %conv62, 32768
  %cmp64 = icmp eq i32 %and63, 32768
  br i1 %cmp64, label %cond.true, label %sw.epilog

cond.true:                                        ; preds = %land.lhs.true60
  %baSourceID66 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %0, i32 0, i32 13
  %21 = load i8*, i8** %baSourceID66, align 8, !tbaa !99
  %arrayidx67 = getelementptr inbounds i8, i8* %21, i64 0
  %22 = load i8, i8* %arrayidx67, align 1, !tbaa !82
  %conv68 = zext i8 %22 to i32
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock8, %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %cond.true, %land.lhs.true60, %sw.bb54, %for.end, %if.then51, %if.then, %sw.bb
  %id.0 = phi i32 [ -22, %NewDefault ], [ %conv7, %if.then ], [ %conv1, %sw.bb ], [ 0, %if.then51 ], [ 0, %for.end ], [ %conv68, %cond.true ], [ 0, %land.lhs.true60 ], [ 0, %sw.bb54 ]
  %cmp69 = icmp sle i32 %id.0, 0
  br i1 %cmp69, label %if.then71, label %if.end72

if.then71:                                        ; preds = %sw.epilog
  store %struct.uvc_entity* null, %struct.uvc_entity** %_entity, align 8, !tbaa !18
  br label %cleanup

if.end72:                                         ; preds = %sw.epilog
  %dev73 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 0
  %23 = load %struct.uvc_device*, %struct.uvc_device** %dev73, align 8, !tbaa !153
  %call74 = call %struct.uvc_entity* @uvc_entity_by_id(%struct.uvc_device* %23, i32 %id.0)
  %cmp75 = icmp eq %struct.uvc_entity* %call74, null
  br i1 %cmp75, label %do.body78, label %if.end86

do.body78:                                        ; preds = %if.end72
  %24 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and79 = and i32 %24, 2
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %if.then81, label %cleanup

if.then81:                                        ; preds = %do.body78
  %call82 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.109, i32 0, i32 0), i32 %id.0)
  br label %cleanup

if.end86:                                         ; preds = %if.end72
  store %struct.uvc_entity* %call74, %struct.uvc_entity** %_entity, align 8, !tbaa !18
  br label %cleanup

cleanup:                                          ; preds = %do.body78, %if.then81, %do.body, %if.then34, %if.end86, %if.then71
  %retval.0 = phi i32 [ %id.0, %if.then71 ], [ 0, %if.end86 ], [ -1, %if.then34 ], [ -1, %do.body ], [ -22, %if.then81 ], [ -22, %do.body78 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.uvc_entity* @uvc_entity_by_reference(%struct.uvc_device* %dev, i32 %id, %struct.uvc_entity* %entity) #0 {
entry:
  %cmp = icmp eq %struct.uvc_entity* %entity, null
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %0 = bitcast %struct.list_head* %entities to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.uvc_entity*
  %entity.addr.0 = select i1 %cmp, %struct.uvc_entity* %1, %struct.uvc_entity* %entity
  br label %for.cond

for.cond:                                         ; preds = %for.inc16, %entry
  %.sink = phi %struct.uvc_entity* [ %4, %for.inc16 ], [ %entity.addr.0, %entry ]
  %list18 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %.sink, i32 0, i32 0
  %next19 = getelementptr inbounds %struct.list_head, %struct.list_head* %list18, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next19, align 8, !tbaa !157
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr21 = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr21 to %struct.uvc_entity*
  %list4 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %4, i32 0, i32 0
  %entities5 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %cmp6 = icmp ne %struct.list_head* %list4, %entities5
  br i1 %cmp6, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc, %for.body
  %i.0 = phi i32 [ 0, %for.body ], [ %inc, %for.inc ]
  %bNrInPins = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %4, i32 0, i32 12
  %5 = load i8, i8* %bNrInPins, align 8, !tbaa !107
  %conv = zext i8 %5 to i32
  %cmp8 = icmp ult i32 %i.0, %conv
  br i1 %cmp8, label %for.body10, label %for.inc16

for.body10:                                       ; preds = %for.cond7
  %baSourceID = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %4, i32 0, i32 13
  %6 = load i8*, i8** %baSourceID, align 8, !tbaa !99
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds i8, i8* %6, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !82
  %conv11 = zext i8 %7 to i32
  %cmp12 = icmp eq i32 %conv11, %id
  br i1 %cmp12, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body10
  %inc = add i32 %i.0, 1
  br label %for.cond7

for.inc16:                                        ; preds = %for.cond7
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %for.body10
  %retval.0 = phi %struct.uvc_entity* [ %4, %for.body10 ], [ null, %for.cond ]
  ret %struct.uvc_entity* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_print_terms(%struct.list_head* %terms, i16 zeroext %dir, i8* %buffer) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %chain24.sink = phi %struct.list_head* [ %chain24, %for.inc ], [ %terms, %entry ]
  %nterms.0 = phi i32 [ 0, %entry ], [ %nterms.1, %for.inc ]
  %p.0 = phi i8* [ %buffer, %entry ], [ %p.2, %for.inc ]
  %next25 = getelementptr inbounds %struct.list_head, %struct.list_head* %chain24.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next25, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr27 = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr27 to %struct.uvc_entity*
  %chain = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %chain, %terms
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %type = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %3 = load i16, i16* %type, align 2, !tbaa !90
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 65280
  %cmp1 = icmp ne i32 %and, 0
  br i1 %cmp1, label %lor.lhs.false, label %for.inc

lor.lhs.false:                                    ; preds = %for.body
  %type3 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %4 = load i16, i16* %type3, align 2, !tbaa !90
  %conv4 = zext i16 %4 to i32
  %and5 = and i32 %conv4, 32768
  %conv6 = zext i16 %dir to i32
  %cmp7 = icmp ne i32 %and5, %conv6
  br i1 %cmp7, label %for.inc, label %if.end

if.end:                                           ; preds = %lor.lhs.false
  %tobool = icmp ne i32 %nterms.0, 0
  br i1 %tobool, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %p.0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0))
  %idx.ext = sext i32 %call to i64
  %add.ptr10 = getelementptr inbounds i8, i8* %p.0, i64 %idx.ext
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end
  %p.1 = phi i8* [ %add.ptr10, %if.then9 ], [ %p.0, %if.end ]
  %inc = add i32 %nterms.0, 1
  %cmp12 = icmp uge i32 %inc, 4
  br i1 %cmp12, label %if.then14, label %if.end18

if.then14:                                        ; preds = %if.end11
  %call15 = call i32 (i8*, i8*, ...) @sprintf(i8* %p.1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.112, i32 0, i32 0))
  %idx.ext16 = sext i32 %call15 to i64
  %add.ptr17 = getelementptr inbounds i8, i8* %p.1, i64 %idx.ext16
  br label %for.end

if.end18:                                         ; preds = %if.end11
  %id = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 3
  %5 = load i8, i8* %id, align 4, !tbaa !19
  %conv19 = zext i8 %5 to i32
  %call20 = call i32 (i8*, i8*, ...) @sprintf(i8* %p.1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.113, i32 0, i32 0), i32 %conv19)
  %idx.ext21 = sext i32 %call20 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %p.1, i64 %idx.ext21
  br label %for.inc

for.inc:                                          ; preds = %for.body, %lor.lhs.false, %if.end18
  %nterms.1 = phi i32 [ %inc, %if.end18 ], [ %nterms.0, %lor.lhs.false ], [ %nterms.0, %for.body ]
  %p.2 = phi i8* [ %add.ptr22, %if.end18 ], [ %p.0, %lor.lhs.false ], [ %p.0, %for.body ]
  %chain24 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %if.then14
  %p.3 = phi i8* [ %add.ptr17, %if.then14 ], [ %p.0, %for.cond ]
  %sub.ptr.lhs.cast = ptrtoint i8* %p.3 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %buffer to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv28 = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv28
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__read_once_size(i8* %p, i8* %res, i32 %size) #2 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load volatile i8, i8* %p, align 1, !tbaa !82
  store i8 %0, i8* %res, align 1, !tbaa !82
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %p to i16*
  %2 = load volatile i16, i16* %1, align 2, !tbaa !94
  %3 = bitcast i8* %res to i16*
  store i16 %2, i16* %3, align 2, !tbaa !94
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %p to i32*
  %5 = load volatile i32, i32* %4, align 4, !tbaa !17
  %6 = bitcast i8* %res to i32*
  store i32 %5, i32* %6, align 4, !tbaa !17
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %p to i64*
  %8 = load volatile i64, i64* %7, align 8, !tbaa !95
  %9 = bitcast i8* %res to i64*
  store i64 %8, i64* %9, align 8, !tbaa !95
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !158
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %res, i8* %p, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !159
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_register_terms(%struct.uvc_device* %dev, %struct.uvc_video_chain* %chain) #0 {
entry:
  %entities = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %chain21.sink = phi %struct.list_head* [ %chain21, %for.inc ], [ %entities, %entry ]
  %next22 = getelementptr inbounds %struct.list_head, %struct.list_head* %chain21.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next22, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr24 = getelementptr inbounds i8, i8* %1, i64 -16
  %2 = bitcast i8* %add.ptr24 to %struct.uvc_entity*
  %chain1 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 1
  %entities2 = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %chain, i32 0, i32 2
  %cmp = icmp ne %struct.list_head* %chain1, %entities2
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %type = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 4
  %3 = load i16, i16* %type, align 2, !tbaa !90
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 32767
  %cmp3 = icmp ne i32 %and, 257
  br i1 %cmp3, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %id = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 3
  %4 = load i8, i8* %id, align 4, !tbaa !19
  %conv5 = zext i8 %4 to i32
  %call = call %struct.uvc_streaming* @uvc_stream_by_id(%struct.uvc_device* %dev, i32 %conv5)
  %cmp6 = icmp eq %struct.uvc_streaming* %call, null
  br i1 %cmp6, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end
  %id9 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 3
  %5 = load i8, i8* %id9, align 4, !tbaa !19
  %conv10 = zext i8 %5 to i32
  %call11 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([58 x i8], [58 x i8]* @.str.115, i32 0, i32 0), i32 %conv10)
  br label %for.inc

if.end12:                                         ; preds = %if.end
  %chain13 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %call, i32 0, i32 3
  store %struct.uvc_video_chain* %chain, %struct.uvc_video_chain** %chain13, align 8, !tbaa !160
  %call14 = call i32 @uvc_register_video(%struct.uvc_device* %dev, %struct.uvc_streaming* %call)
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end12
  %vdev = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %call, i32 0, i32 2
  %vdev19 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 6
  store %struct.video_device* %vdev, %struct.video_device** %vdev19, align 8, !tbaa !161
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end18, %if.then8
  %chain21 = getelementptr inbounds %struct.uvc_entity, %struct.uvc_entity* %2, i32 0, i32 1
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %if.end12
  %retval.0 = phi i32 [ %call14, %if.end12 ], [ 0, %for.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal %struct.uvc_streaming* @uvc_stream_by_id(%struct.uvc_device* %dev, i32 %id) #0 {
entry:
  %streams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 14
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %list5.sink = phi %struct.list_head* [ %list5, %for.inc ], [ %streams, %entry ]
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %list5.sink, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !18
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr8 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr8 to %struct.uvc_streaming*
  %list = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %2, i32 0, i32 0
  %streams1 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 14
  %cmp = icmp ne %struct.list_head* %list, %streams1
  br i1 %cmp, label %for.body, label %cleanup

for.body:                                         ; preds = %for.cond
  %header = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %2, i32 0, i32 8
  %bTerminalLink = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header, i32 0, i32 2
  %3 = load i8, i8* %bTerminalLink, align 2, !tbaa !118
  %conv = zext i8 %3 to i32
  %cmp2 = icmp eq i32 %conv, %id
  br i1 %cmp2, label %cleanup, label %for.inc

for.inc:                                          ; preds = %for.body
  %list5 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %2, i32 0, i32 0
  br label %for.cond

cleanup:                                          ; preds = %for.cond, %for.body
  %retval.0 = phi %struct.uvc_streaming* [ %2, %for.body ], [ null, %for.cond ]
  ret %struct.uvc_streaming* %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @uvc_register_video(%struct.uvc_device* %dev, %struct.uvc_streaming* %stream) #0 {
entry:
  %vdev1 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %stream, i32 0, i32 2
  %queue = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %stream, i32 0, i32 18
  %type = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %stream, i32 0, i32 9
  %0 = load i32, i32* %type, align 8, !tbaa !114
  %1 = load i32, i32* @uvc_no_drop_param, align 4, !tbaa !17
  %tobool = icmp ne i32 %1, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %call = call i32 @uvc_queue_init(%struct.uvc_video_queue* %queue, i32 %0, i32 %lnot.ext)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %call3 = call i32 @uvc_video_init(%struct.uvc_streaming* %stream)
  %cmp = icmp slt i32 %call3, 0
  br i1 %cmp, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %call5 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.116, i32 0, i32 0), i32 %call3)
  br label %cleanup

if.end6:                                          ; preds = %if.end
  call void @uvc_debugfs_init_stream(%struct.uvc_streaming* %stream)
  %vdev7 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 9
  %v4l2_dev = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev1, i32 0, i32 4
  store %struct.v4l2_device* %vdev7, %struct.v4l2_device** %v4l2_dev, align 8, !tbaa !162
  %fops = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev1, i32 0, i32 0
  store %struct.v4l2_file_operations* @uvc_fops, %struct.v4l2_file_operations** %fops, align 8, !tbaa !163
  %ioctl_ops = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev1, i32 0, i32 21
  store %struct.v4l2_ioctl_ops* @uvc_ioctl_ops, %struct.v4l2_ioctl_ops** %ioctl_ops, align 8, !tbaa !164
  %release = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev1, i32 0, i32 20
  store void (%struct.video_device*)* @uvc_release, void (%struct.video_device*)** %release, align 8, !tbaa !165
  %chain = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %stream, i32 0, i32 3
  %2 = load %struct.uvc_video_chain*, %struct.uvc_video_chain** %chain, align 8, !tbaa !160
  %prio = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %2, i32 0, i32 6
  %prio8 = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev1, i32 0, i32 8
  store %struct.v4l2_prio_state* %prio, %struct.v4l2_prio_state** %prio8, align 8, !tbaa !166
  %type9 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %stream, i32 0, i32 9
  %3 = load i32, i32* %type9, align 8, !tbaa !114
  %cmp10 = icmp eq i32 %3, 2
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end6
  %vfl_dir = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev1, i32 0, i32 11
  store i32 1, i32* %vfl_dir, align 4, !tbaa !167
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end6
  %name = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev1, i32 0, i32 9
  %arraydecay = getelementptr inbounds [32 x i8], [32 x i8]* %name, i32 0, i32 0
  %name13 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 5
  %arraydecay14 = getelementptr inbounds [32 x i8], [32 x i8]* %name13, i32 0, i32 0
  %call15 = call i64 @strlcpy(i8* %arraydecay, i8* %arraydecay14, i64 32)
  %4 = bitcast %struct.uvc_streaming* %stream to i8*
  call void @video_set_drvdata(%struct.video_device* %vdev1, i8* %4)
  %call16 = call i32 @video_register_device(%struct.video_device* %vdev1, i32 0, i32 -1)
  %cmp17 = icmp slt i32 %call16, 0
  br i1 %cmp17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end12
  %call19 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.117, i32 0, i32 0), i32 %call16)
  br label %cleanup

if.end20:                                         ; preds = %if.end12
  %type21 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %stream, i32 0, i32 9
  %5 = load i32, i32* %type21, align 8, !tbaa !114
  %cmp22 = icmp eq i32 %5, 1
  %chain24 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %stream, i32 0, i32 3
  %6 = load %struct.uvc_video_chain*, %struct.uvc_video_chain** %chain24, align 8, !tbaa !160
  %caps = getelementptr inbounds %struct.uvc_video_chain, %struct.uvc_video_chain* %6, i32 0, i32 7
  %7 = load i32, i32* %caps, align 8, !tbaa !168
  %.sink = select i1 %cmp22, i32 1, i32 2
  %or27 = or i32 %7, %.sink
  store i32 %or27, i32* %caps, align 8, !tbaa !168
  %nstreams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 15
  call void @atomic_inc(%struct.atomic_t* %nstreams)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end20, %if.then18, %if.then4
  %retval.0 = phi i32 [ %call3, %if.then4 ], [ %call16, %if.then18 ], [ 0, %if.end20 ], [ %call, %entry ]
  ret i32 %retval.0
}

declare i32 @uvc_queue_init(%struct.uvc_video_queue*, i32, i32) #3

declare i32 @uvc_video_init(%struct.uvc_streaming*) #3

declare void @uvc_debugfs_init_stream(%struct.uvc_streaming*) #3

; Function Attrs: nounwind uwtable
define internal void @uvc_release(%struct.video_device* %vdev) #0 {
entry:
  %call = call i8* @video_get_drvdata(%struct.video_device* %vdev)
  %0 = bitcast i8* %call to %struct.uvc_streaming*
  %dev1 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %0, i32 0, i32 1
  %1 = load %struct.uvc_device*, %struct.uvc_device** %dev1, align 8, !tbaa !110
  %nstreams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %1, i32 0, i32 15
  %call2 = call zeroext i1 @atomic_dec_and_test(%struct.atomic_t* %nstreams)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @uvc_delete(%struct.uvc_device* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @video_set_drvdata(%struct.video_device* %vdev, i8* %data) #4 {
entry:
  %dev = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev, i32 0, i32 2
  call void @dev_set_drvdata(%struct.device* %dev, i8* %data)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @video_register_device(%struct.video_device* %vdev, i32 %type, i32 %nr) #4 {
entry:
  %fops = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev, i32 0, i32 0
  %0 = load %struct.v4l2_file_operations*, %struct.v4l2_file_operations** %fops, align 8, !tbaa !163
  %owner = getelementptr inbounds %struct.v4l2_file_operations, %struct.v4l2_file_operations* %0, i32 0, i32 0
  %1 = load %struct.module*, %struct.module** %owner, align 8, !tbaa !169
  %call = call i32 @__video_register_device(%struct.video_device* %vdev, i32 %type, i32 %nr, i32 1, %struct.module* %1)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @atomic_inc(%struct.atomic_t* %v) #2 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) #5, !srcloc !171
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @video_get_drvdata(%struct.video_device* %vdev) #4 {
entry:
  %dev = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev, i32 0, i32 2
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @atomic_dec_and_test(%struct.atomic_t* %v) #2 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #5
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; decl $0;\0A\09sete $1\0A", "=*m,=*qm,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i8* %c, i32* %counter) #5, !srcloc !172
  %0 = load i8, i8* %c, align 1, !tbaa !173, !range !174
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #5
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @uvc_delete(%struct.uvc_device* %dev) #0 {
entry:
  call void @uvc_status_cleanup(%struct.uvc_device* %dev)
  call void @uvc_ctrl_cleanup_device(%struct.uvc_device* %dev)
  %intf = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 1
  %0 = load %struct.usb_interface*, %struct.usb_interface** %intf, align 8, !tbaa !38
  call void @usb_put_intf(%struct.usb_interface* %0)
  %udev = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 0
  %1 = load %struct.usb_device*, %struct.usb_device** %udev, align 8, !tbaa !27
  call void @usb_put_dev(%struct.usb_device* %1)
  %vdev = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 9
  %dev1 = getelementptr inbounds %struct.v4l2_device, %struct.v4l2_device* %vdev, i32 0, i32 0
  %2 = load %struct.device*, %struct.device** %dev1, align 8, !tbaa !175
  %tobool = icmp ne %struct.device* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %vdev2 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 9
  call void @v4l2_device_unregister(%struct.v4l2_device* %vdev2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %chains = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %chains, i32 0, i32 0
  %3 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !108
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %.sink = phi %struct.list_head* [ %4, %for.body ], [ %3, %if.end ]
  %p.0 = phi %struct.list_head* [ %3, %if.end ], [ %4, %for.body ]
  %next5 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink, i32 0, i32 0
  %4 = load %struct.list_head*, %struct.list_head** %next5, align 8, !tbaa !108
  %chains4 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 13
  %cmp = icmp ne %struct.list_head* %p.0, %chains4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = bitcast %struct.list_head* %p.0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 -8
  %6 = bitcast i8* %add.ptr to %struct.uvc_video_chain*
  %7 = bitcast %struct.uvc_video_chain* %6 to i8*
  call void @kfree(i8* %7)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %entities = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %next6 = getelementptr inbounds %struct.list_head, %struct.list_head* %entities, i32 0, i32 0
  %8 = load %struct.list_head*, %struct.list_head** %next6, align 8, !tbaa !108
  br label %for.cond8

for.cond8:                                        ; preds = %for.body11, %for.end
  %.sink1 = phi %struct.list_head* [ %9, %for.body11 ], [ %8, %for.end ]
  %p.1 = phi %struct.list_head* [ %8, %for.end ], [ %9, %for.body11 ]
  %next16 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink1, i32 0, i32 0
  %9 = load %struct.list_head*, %struct.list_head** %next16, align 8, !tbaa !108
  %entities9 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 12
  %cmp10 = icmp ne %struct.list_head* %p.1, %entities9
  br i1 %cmp10, label %for.body11, label %for.end17

for.body11:                                       ; preds = %for.cond8
  %10 = bitcast %struct.list_head* %p.1 to i8*
  %add.ptr14 = getelementptr inbounds i8, i8* %10, i64 0
  %11 = bitcast i8* %add.ptr14 to %struct.uvc_entity*
  %12 = bitcast %struct.uvc_entity* %11 to i8*
  call void @kfree(i8* %12)
  br label %for.cond8

for.end17:                                        ; preds = %for.cond8
  %streams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 14
  %next18 = getelementptr inbounds %struct.list_head, %struct.list_head* %streams, i32 0, i32 0
  %13 = load %struct.list_head*, %struct.list_head** %next18, align 8, !tbaa !108
  br label %for.cond20

for.cond20:                                       ; preds = %for.body23, %for.end17
  %.sink2 = phi %struct.list_head* [ %14, %for.body23 ], [ %13, %for.end17 ]
  %p.2 = phi %struct.list_head* [ %13, %for.end17 ], [ %14, %for.body23 ]
  %next30 = getelementptr inbounds %struct.list_head, %struct.list_head* %.sink2, i32 0, i32 0
  %14 = load %struct.list_head*, %struct.list_head** %next30, align 8, !tbaa !108
  %streams21 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %dev, i32 0, i32 14
  %cmp22 = icmp ne %struct.list_head* %p.2, %streams21
  br i1 %cmp22, label %for.body23, label %for.end31

for.body23:                                       ; preds = %for.cond20
  %15 = bitcast %struct.list_head* %p.2 to i8*
  %add.ptr26 = getelementptr inbounds i8, i8* %15, i64 0
  %16 = bitcast i8* %add.ptr26 to %struct.uvc_streaming*
  %intf27 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %16, i32 0, i32 5
  %17 = load %struct.usb_interface*, %struct.usb_interface** %intf27, align 8, !tbaa !68
  call void @usb_driver_release_interface(%struct.usb_driver* getelementptr inbounds (%struct.uvc_driver, %struct.uvc_driver* @uvc_driver, i32 0, i32 0), %struct.usb_interface* %17)
  %intf28 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %16, i32 0, i32 5
  %18 = load %struct.usb_interface*, %struct.usb_interface** %intf28, align 8, !tbaa !68
  call void @usb_put_intf(%struct.usb_interface* %18)
  %format = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %16, i32 0, i32 11
  %19 = load %struct.uvc_format*, %struct.uvc_format** %format, align 8, !tbaa !124
  %20 = bitcast %struct.uvc_format* %19 to i8*
  call void @kfree(i8* %20)
  %header = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %16, i32 0, i32 8
  %bmaControls = getelementptr inbounds %struct.uvc_streaming_header, %struct.uvc_streaming_header* %header, i32 0, i32 4
  %21 = load i8*, i8** %bmaControls, align 8, !tbaa !123
  call void @kfree(i8* %21)
  %22 = bitcast %struct.uvc_streaming* %16 to i8*
  call void @kfree(i8* %22)
  br label %for.cond20

for.end31:                                        ; preds = %for.cond20
  %23 = bitcast %struct.uvc_device* %dev to i8*
  call void @kfree(i8* %23)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !176
  ret i8* %0
}

declare void @uvc_status_cleanup(%struct.uvc_device*) #3

declare void @uvc_ctrl_cleanup_device(%struct.uvc_device*) #3

declare void @usb_put_dev(%struct.usb_device*) #3

declare void @v4l2_device_unregister(%struct.v4l2_device*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) #4 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  store i8* %data, i8** %driver_data, align 8, !tbaa !176
  ret void
}

declare i32 @__video_register_device(%struct.video_device*, i32, i32, i32, %struct.module*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @video_is_registered(%struct.video_device* %vdev) #4 {
entry:
  %flags = getelementptr inbounds %struct.video_device, %struct.video_device* %vdev, i32 0, i32 14
  %call = call zeroext i1 @constant_test_bit(i64 0, i64* %flags)
  %conv = zext i1 %call to i32
  ret i32 %conv
}

declare void @video_unregister_device(%struct.video_device*) #3

declare void @uvc_debugfs_cleanup_stream(%struct.uvc_streaming*) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @constant_test_bit(i64 %nr, i64* %addr) #2 {
entry:
  %and = and i64 %nr, 63
  %shl = shl i64 1, %and
  %shr = ashr i64 %nr, 6
  %arrayidx = getelementptr inbounds i64, i64* %addr, i64 %shr
  %0 = load volatile i64, i64* %arrayidx, align 8, !tbaa !177
  %and1 = and i64 %shl, %0
  %cmp = icmp ne i64 %and1, 0
  ret i1 %cmp
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @usb_get_intfdata(%struct.usb_interface* %intf) #4 {
entry:
  %dev = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 7
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  ret i8* %call
}

declare void @mutex_lock(%struct.mutex*) #3

declare void @uvc_status_stop(%struct.uvc_device*) #3

declare void @mutex_unlock(%struct.mutex*) #3

declare i32 @uvc_video_suspend(%struct.uvc_streaming*) #3

; Function Attrs: nounwind uwtable
define internal i32 @__uvc_resume(%struct.usb_interface* %intf, i32 %reset) #0 {
entry:
  %call = call i8* @usb_get_intfdata(%struct.usb_interface* %intf)
  %0 = bitcast i8* %call to %struct.uvc_device*
  %1 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and = and i32 %1, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %cur_altsetting = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %2 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting, align 8, !tbaa !39
  %desc = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %2, i32 0, i32 0
  %bInterfaceNumber = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc, i32 0, i32 2
  %3 = load i8, i8* %bInterfaceNumber, align 2, !tbaa !54
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.120, i32 0, i32 0), i32 %conv)
  br label %do.end

do.end:                                           ; preds = %if.then, %entry
  %cur_altsetting2 = getelementptr inbounds %struct.usb_interface, %struct.usb_interface* %intf, i32 0, i32 1
  %4 = load %struct.usb_host_interface*, %struct.usb_host_interface** %cur_altsetting2, align 8, !tbaa !39
  %desc3 = getelementptr inbounds %struct.usb_host_interface, %struct.usb_host_interface* %4, i32 0, i32 0
  %bInterfaceSubClass = getelementptr inbounds %struct.usb_interface_descriptor, %struct.usb_interface_descriptor* %desc3, i32 0, i32 6
  %5 = load i8, i8* %bInterfaceSubClass, align 2, !tbaa !66
  %conv4 = zext i8 %5 to i32
  %cmp = icmp eq i32 %conv4, 1
  br i1 %cmp, label %if.then6, label %if.end20

if.then6:                                         ; preds = %do.end
  %tobool7 = icmp ne i32 %reset, 0
  br i1 %tobool7, label %if.then8, label %if.end14

if.then8:                                         ; preds = %if.then6
  %call9 = call i32 @uvc_ctrl_restore_values(%struct.uvc_device* %0)
  %cmp10 = icmp slt i32 %call9, 0
  br i1 %cmp10, label %cleanup, label %if.end14

if.end14:                                         ; preds = %if.then8, %if.then6
  %ret.0 = phi i32 [ 0, %if.then6 ], [ %call9, %if.then8 ]
  %lock = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 6
  call void @mutex_lock(%struct.mutex* %lock)
  %users = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 7
  %6 = load i32, i32* %users, align 8, !tbaa !67
  %tobool15 = icmp ne i32 %6, 0
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end14
  %call17 = call i32 @uvc_status_start(%struct.uvc_device* %0, i32 20971520)
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %if.end14
  %ret.1 = phi i32 [ %call17, %if.then16 ], [ %ret.0, %if.end14 ]
  %lock19 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 6
  call void @mutex_unlock(%struct.mutex* %lock19)
  br label %cleanup

if.end20:                                         ; preds = %do.end
  %streams = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 14
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end20
  %list38.sink = phi %struct.list_head* [ %list38, %for.inc ], [ %streams, %if.end20 ]
  %next39 = getelementptr inbounds %struct.list_head, %struct.list_head* %list38.sink, i32 0, i32 0
  %7 = load %struct.list_head*, %struct.list_head** %next39, align 8, !tbaa !18
  %8 = bitcast %struct.list_head* %7 to i8*
  %add.ptr41 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr41 to %struct.uvc_streaming*
  %list = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 0
  %streams21 = getelementptr inbounds %struct.uvc_device, %struct.uvc_device* %0, i32 0, i32 14
  %cmp22 = icmp ne %struct.list_head* %list, %streams21
  br i1 %cmp22, label %for.body, label %do.body42

for.body:                                         ; preds = %for.cond
  %intf24 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 5
  %10 = load %struct.usb_interface*, %struct.usb_interface** %intf24, align 8, !tbaa !68
  %cmp25 = icmp eq %struct.usb_interface* %10, %intf
  br i1 %cmp25, label %if.then27, label %for.inc

if.then27:                                        ; preds = %for.body
  %call28 = call i32 @uvc_video_resume(%struct.uvc_streaming* %9, i32 %reset)
  %cmp29 = icmp slt i32 %call28, 0
  br i1 %cmp29, label %if.then31, label %cleanup

if.then31:                                        ; preds = %if.then27
  %queue = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 18
  %queue32 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 18
  %queue33 = getelementptr inbounds %struct.uvc_video_queue, %struct.uvc_video_queue* %queue32, i32 0, i32 0
  %type = getelementptr inbounds %struct.vb2_queue, %struct.vb2_queue* %queue33, i32 0, i32 0
  %11 = load i32, i32* %type, align 8, !tbaa !178
  %call34 = call i32 @uvc_queue_streamoff(%struct.uvc_video_queue* %queue, i32 %11)
  br label %cleanup

for.inc:                                          ; preds = %for.body
  %list38 = getelementptr inbounds %struct.uvc_streaming, %struct.uvc_streaming* %9, i32 0, i32 0
  br label %for.cond

do.body42:                                        ; preds = %for.cond
  %12 = load i32, i32* @uvc_trace_param, align 4, !tbaa !17
  %and43 = and i32 %12, 256
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then45, label %cleanup

if.then45:                                        ; preds = %do.body42
  %call46 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.121, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %do.body42, %if.then45, %if.then27, %if.then31, %if.then8, %if.end18
  %retval.0 = phi i32 [ %ret.1, %if.end18 ], [ %call9, %if.then8 ], [ %call28, %if.then31 ], [ %call28, %if.then27 ], [ -22, %if.then45 ], [ -22, %do.body42 ]
  ret i32 %retval.0
}

declare i32 @uvc_ctrl_restore_values(%struct.uvc_device*) #3

declare i32 @uvc_status_start(%struct.uvc_device*, i32) #3

declare i32 @uvc_video_resume(%struct.uvc_streaming*, i32) #3

declare i32 @uvc_queue_streamoff(%struct.uvc_video_queue*, i32) #3

declare void @uvc_debugfs_init() #3

declare i32 @usb_register_driver(%struct.usb_driver*, %struct.module*, i8*) #3

declare i64 @__modver_version_show(%struct.module_attribute*, %struct.module_kobject*, i8*) #3

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !5, i64 4}
!3 = !{!"usb_host_interface", !4, i64 0, !7, i64 12, !8, i64 16, !8, i64 24, !8, i64 32}
!4 = !{!"usb_interface_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !5, i64 8}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"int", !5, i64 0}
!8 = !{!"any pointer", !5, i64 0}
!9 = !{!3, !8, i64 24}
!10 = !{!11, !5, i64 2}
!11 = !{!"usb_host_endpoint", !12, i64 0, !14, i64 9, !15, i64 15, !16, i64 24, !8, i64 40, !8, i64 48, !8, i64 56, !7, i64 64, !7, i64 68, !7, i64 72}
!12 = !{!"usb_endpoint_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !13, i64 4, !5, i64 6, !5, i64 7, !5, i64 8}
!13 = !{!"short", !5, i64 0}
!14 = !{!"usb_ss_ep_comp_descriptor", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !13, i64 4}
!15 = !{!"usb_ssp_isoc_ep_comp_descriptor", !5, i64 0, !5, i64 1, !13, i64 2, !7, i64 4}
!16 = !{!"list_head", !8, i64 0, !8, i64 8}
!17 = !{!7, !7, i64 0}
!18 = !{!8, !8, i64 0}
!19 = !{!20, !5, i64 36}
!20 = !{!"uvc_entity", !16, i64 0, !16, i64 16, !7, i64 32, !5, i64 36, !13, i64 38, !5, i64 40, !8, i64 104, !21, i64 112, !7, i64 296, !7, i64 300, !8, i64 304, !5, i64 312, !5, i64 352, !8, i64 360, !7, i64 368, !8, i64 376}
!21 = !{!"v4l2_subdev", !16, i64 0, !8, i64 16, !22, i64 24, !7, i64 28, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !5, i64 64, !7, i64 96, !8, i64 104, !8, i64 112, !8, i64 120, !8, i64 128, !8, i64 136, !16, i64 144, !8, i64 160, !8, i64 168, !8, i64 176}
!22 = !{!"_Bool", !5, i64 0}
!23 = !{!24, !13, i64 2}
!24 = !{!"usb_device_id", !13, i64 0, !13, i64 2, !13, i64 4, !13, i64 6, !13, i64 8, !5, i64 10, !5, i64 11, !5, i64 12, !5, i64 13, !5, i64 14, !5, i64 15, !5, i64 16, !25, i64 24}
!25 = !{!"long", !5, i64 0}
!26 = !{!24, !13, i64 4}
!27 = !{!28, !8, i64 0}
!28 = !{!"uvc_device", !8, i64 0, !8, i64 8, !25, i64 16, !7, i64 24, !7, i64 28, !5, i64 32, !29, i64 64, !7, i64 96, !33, i64 100, !34, i64 104, !13, i64 216, !7, i64 220, !16, i64 224, !16, i64 240, !16, i64 256, !33, i64 272, !8, i64 280, !8, i64 288, !8, i64 296, !8, i64 304, !5, i64 312}
!29 = !{!"mutex", !30, i64 0, !31, i64 8, !32, i64 12, !16, i64 16}
!30 = !{!"", !25, i64 0}
!31 = !{!"spinlock", !5, i64 0}
!32 = !{!"optimistic_spin_queue", !33, i64 0}
!33 = !{!"", !7, i64 0}
!34 = !{!"v4l2_device", !8, i64 0, !16, i64 8, !31, i64 24, !5, i64 28, !8, i64 64, !8, i64 72, !35, i64 80, !36, i64 96, !8, i64 104}
!35 = !{!"v4l2_prio_state", !5, i64 0}
!36 = !{!"kref", !37, i64 0}
!37 = !{!"refcount_struct", !33, i64 0}
!38 = !{!28, !8, i64 8}
!39 = !{!40, !8, i64 8}
!40 = !{!"usb_interface", !8, i64 0, !8, i64 8, !7, i64 16, !8, i64 24, !7, i64 32, !5, i64 36, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !7, i64 40, !41, i64 48, !8, i64 776, !33, i64 784, !50, i64 792}
!41 = !{!"device", !8, i64 0, !8, i64 8, !42, i64 16, !8, i64 80, !8, i64 88, !29, i64 96, !8, i64 128, !8, i64 136, !8, i64 144, !8, i64 152, !43, i64 160, !44, i64 200, !8, i64 488, !8, i64 496, !16, i64 504, !7, i64 520, !8, i64 528, !8, i64 536, !51, i64 544, !25, i64 552, !8, i64 560, !16, i64 568, !8, i64 584, !52, i64 592, !8, i64 600, !8, i64 608, !7, i64 616, !7, i64 620, !31, i64 624, !16, i64 632, !53, i64 648, !8, i64 680, !8, i64 688, !8, i64 696, !8, i64 704, !8, i64 712, !22, i64 720, !22, i64 720}
!42 = !{!"kobject", !8, i64 0, !16, i64 8, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !36, i64 56, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60}
!43 = !{!"dev_links_info", !16, i64 0, !16, i64 16, !5, i64 32}
!44 = !{!"dev_pm_info", !45, i64 0, !7, i64 4, !7, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 4, !22, i64 5, !31, i64 8, !16, i64 16, !46, i64 32, !8, i64 64, !22, i64 72, !22, i64 72, !22, i64 72, !48, i64 80, !25, i64 128, !50, i64 136, !47, i64 168, !8, i64 192, !33, i64 200, !33, i64 204, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !22, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 212, !5, i64 216, !5, i64 220, !7, i64 224, !7, i64 228, !25, i64 232, !25, i64 240, !25, i64 248, !25, i64 256, !8, i64 264, !8, i64 272, !8, i64 280}
!45 = !{!"pm_message", !7, i64 0}
!46 = !{!"completion", !7, i64 0, !47, i64 8}
!47 = !{!"__wait_queue_head", !31, i64 0, !16, i64 8}
!48 = !{!"timer_list", !49, i64 0, !25, i64 16, !8, i64 24, !25, i64 32, !7, i64 40}
!49 = !{!"hlist_node", !8, i64 0, !8, i64 8}
!50 = !{!"work_struct", !30, i64 0, !16, i64 8, !8, i64 24}
!51 = !{!"long long", !5, i64 0}
!52 = !{!"dev_archdata", !8, i64 0}
!53 = !{!"klist_node", !8, i64 0, !16, i64 8, !36, i64 24}
!54 = !{!3, !5, i64 2}
!55 = !{!28, !7, i64 28}
!56 = !{!24, !25, i64 24}
!57 = !{!28, !7, i64 24}
!58 = !{!59, !8, i64 1208}
!59 = !{!"usb_device", !7, i64 0, !5, i64 4, !7, i64 20, !5, i64 24, !5, i64 28, !8, i64 32, !7, i64 40, !5, i64 44, !8, i64 56, !8, i64 64, !11, i64 72, !41, i64 152, !60, i64 880, !8, i64 904, !8, i64 912, !8, i64 920, !5, i64 928, !5, i64 1056, !8, i64 1184, !13, i64 1192, !5, i64 1194, !5, i64 1195, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1196, !7, i64 1197, !7, i64 1197, !7, i64 1197, !7, i64 1197, !7, i64 1197, !7, i64 1200, !8, i64 1208, !8, i64 1216, !8, i64 1224, !16, i64 1232, !7, i64 1248, !7, i64 1252, !33, i64 1256, !25, i64 1264, !25, i64 1272, !7, i64 1280, !7, i64 1280, !7, i64 1280, !8, i64 1288, !7, i64 1296, !5, i64 1300, !61, i64 1304, !62, i64 1312, !62, i64 1328, !7, i64 1344}
!60 = !{!"usb_device_descriptor", !5, i64 0, !5, i64 1, !13, i64 2, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7, !13, i64 8, !13, i64 10, !13, i64 12, !5, i64 14, !5, i64 15, !5, i64 16, !5, i64 17}
!61 = !{!"usb2_lpm_parameters", !7, i64 0, !7, i64 4}
!62 = !{!"usb3_lpm_parameters", !7, i64 0, !7, i64 4, !7, i64 8, !7, i64 12}
!63 = !{!59, !13, i64 888}
!64 = !{!59, !13, i64 890}
!65 = !{!28, !13, i64 216}
!66 = !{!3, !5, i64 6}
!67 = !{!28, !7, i64 96}
!68 = !{!69, !8, i64 1000}
!69 = !{!"uvc_streaming", !16, i64 0, !8, i64 16, !70, i64 24, !8, i64 984, !33, i64 992, !8, i64 1000, !7, i64 1008, !13, i64 1012, !71, i64 1016, !5, i64 1040, !7, i64 1044, !8, i64 1048, !72, i64 1056, !8, i64 1096, !8, i64 1104, !8, i64 1112, !29, i64 1120, !7, i64 1152, !73, i64 1160, !8, i64 1784, !75, i64 1792, !5, i64 2064, !5, i64 2104, !5, i64 2144, !7, i64 2184, !7, i64 2188, !5, i64 2192, !8, i64 2200, !76, i64 2208, !80, i64 2360}
!70 = !{!"video_device", !8, i64 0, !7, i64 8, !41, i64 16, !8, i64 744, !8, i64 752, !8, i64 760, !8, i64 768, !8, i64 776, !8, i64 784, !5, i64 792, !7, i64 824, !7, i64 828, !7, i64 832, !13, i64 836, !25, i64 840, !7, i64 848, !31, i64 852, !16, i64 856, !7, i64 872, !51, i64 880, !8, i64 888, !8, i64 896, !5, i64 904, !5, i64 928, !8, i64 952}
!71 = !{!"uvc_streaming_header", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !8, i64 8, !5, i64 16, !5, i64 17, !5, i64 18, !5, i64 19}
!72 = !{!"uvc_streaming_control", !13, i64 0, !5, i64 2, !5, i64 3, !7, i64 4, !13, i64 8, !13, i64 10, !13, i64 12, !13, i64 14, !13, i64 16, !7, i64 18, !7, i64 22, !7, i64 26, !5, i64 30, !5, i64 31, !5, i64 32, !5, i64 33}
!73 = !{!"uvc_video_queue", !74, i64 0, !29, i64 560, !7, i64 592, !7, i64 596, !31, i64 600, !16, i64 608}
!74 = !{!"vb2_queue", !7, i64 0, !7, i64 4, !8, i64 8, !25, i64 16, !7, i64 24, !7, i64 24, !7, i64 24, !7, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64, !8, i64 72, !7, i64 80, !7, i64 84, !7, i64 88, !7, i64 92, !29, i64 96, !7, i64 128, !5, i64 136, !7, i64 392, !16, i64 400, !7, i64 416, !33, i64 420, !16, i64 424, !31, i64 440, !47, i64 448, !5, i64 472, !7, i64 536, !7, i64 536, !7, i64 536, !7, i64 536, !7, i64 536, !7, i64 536, !7, i64 536, !7, i64 536, !8, i64 544, !8, i64 552}
!75 = !{!"", !5, i64 0, !7, i64 256, !7, i64 260, !7, i64 264, !7, i64 268}
!76 = !{!"", !77, i64 0, !78, i64 64}
!77 = !{!"uvc_stats_frame", !7, i64 0, !7, i64 4, !7, i64 8, !7, i64 12, !7, i64 16, !7, i64 20, !7, i64 24, !7, i64 28, !7, i64 32, !22, i64 36, !22, i64 37, !7, i64 40, !7, i64 44, !7, i64 48, !13, i64 52, !7, i64 56}
!78 = !{!"uvc_stats_stream", !79, i64 0, !79, i64 16, !7, i64 32, !7, i64 36, !7, i64 40, !7, i64 44, !7, i64 48, !7, i64 52, !7, i64 56, !7, i64 60, !7, i64 64, !7, i64 68, !7, i64 72, !7, i64 76, !7, i64 80, !7, i64 84}
!79 = !{!"timespec", !25, i64 0, !25, i64 8}
!80 = !{!"uvc_clock", !8, i64 0, !7, i64 8, !7, i64 12, !7, i64 16, !13, i64 20, !13, i64 22, !31, i64 24}
!81 = !{!40, !8, i64 48}
!82 = !{!5, !5, i64 0}
!83 = !{!16, !8, i64 8}
!84 = !{!3, !8, i64 16}
!85 = !{!3, !7, i64 12}
!86 = !{!12, !13, i64 4}
!87 = !{!12, !5, i64 6}
!88 = !{!12, !5, i64 2}
!89 = !{!28, !8, i64 280}
!90 = !{!20, !13, i64 38}
!91 = !{!20, !8, i64 16}
!92 = !{!20, !8, i64 24}
!93 = !{!20, !7, i64 32}
!94 = !{!13, !13, i64 0}
!95 = !{!51, !51, i64 0}
!96 = !{i32 -2147259255}
!97 = !{i32 -2147259217}
!98 = !{!59, !7, i64 0}
!99 = !{!20, !8, i64 360}
!100 = !{!28, !7, i64 220}
!101 = !{!20, !7, i64 300}
!102 = !{!20, !7, i64 296}
!103 = !{!20, !8, i64 304}
!104 = !{!105, !25, i64 48}
!105 = !{!"media_pad", !106, i64 0, !8, i64 32, !13, i64 40, !25, i64 48}
!106 = !{!"media_gobj", !8, i64 0, !7, i64 8, !16, i64 16}
!107 = !{!20, !5, i64 352}
!108 = !{!16, !8, i64 0}
!109 = !{!40, !8, i64 0}
!110 = !{!69, !8, i64 16}
!111 = !{!69, !7, i64 1008}
!112 = !{!11, !7, i64 64}
!113 = !{!11, !8, i64 56}
!114 = !{!69, !5, i64 1040}
!115 = !{!69, !5, i64 1016}
!116 = !{!69, !5, i64 1017}
!117 = !{!69, !5, i64 1032}
!118 = !{!69, !5, i64 1018}
!119 = !{!69, !5, i64 1033}
!120 = !{!69, !5, i64 1034}
!121 = !{!69, !5, i64 1035}
!122 = !{!69, !5, i64 1019}
!123 = !{!69, !8, i64 1024}
!124 = !{!69, !8, i64 1048}
!125 = !{!69, !7, i64 1044}
!126 = !{!127, !8, i64 48}
!127 = !{!"uvc_format", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !7, i64 4, !7, i64 8, !5, i64 12, !7, i64 44, !8, i64 48}
!128 = !{!127, !7, i64 44}
!129 = !{!40, !7, i64 16}
!130 = !{!11, !13, i64 4}
!131 = !{!69, !13, i64 1012}
!132 = !{!127, !5, i64 0}
!133 = !{!127, !5, i64 1}
!134 = !{!135, !8, i64 0}
!135 = !{!"uvc_format_desc", !8, i64 0, !5, i64 8, !7, i64 24}
!136 = !{!135, !7, i64 24}
!137 = !{!127, !7, i64 4}
!138 = !{!127, !5, i64 2}
!139 = !{!127, !7, i64 8}
!140 = !{!141, !5, i64 20}
!141 = !{!"uvc_frame", !5, i64 0, !5, i64 1, !13, i64 2, !13, i64 4, !7, i64 8, !7, i64 12, !7, i64 16, !5, i64 20, !7, i64 24, !8, i64 32}
!142 = !{!141, !7, i64 24}
!143 = !{!141, !8, i64 32}
!144 = !{!141, !5, i64 0}
!145 = !{!141, !5, i64 1}
!146 = !{!141, !13, i64 2}
!147 = !{!141, !13, i64 4}
!148 = !{!141, !7, i64 8}
!149 = !{!141, !7, i64 12}
!150 = !{!141, !7, i64 16}
!151 = !{!127, !5, i64 3}
!152 = !{!12, !5, i64 3}
!153 = !{!154, !8, i64 0}
!154 = !{!"uvc_video_chain", !8, i64 0, !16, i64 8, !16, i64 24, !8, i64 40, !8, i64 48, !29, i64 56, !35, i64 88, !7, i64 104}
!155 = !{!154, !8, i64 40}
!156 = !{!154, !8, i64 48}
!157 = !{!20, !8, i64 0}
!158 = !{i32 -2147259992}
!159 = !{i32 -2147259954}
!160 = !{!69, !8, i64 984}
!161 = !{!20, !8, i64 104}
!162 = !{!70, !8, i64 752}
!163 = !{!70, !8, i64 0}
!164 = !{!70, !8, i64 896}
!165 = !{!70, !8, i64 888}
!166 = !{!70, !8, i64 784}
!167 = !{!70, !7, i64 828}
!168 = !{!154, !7, i64 104}
!169 = !{!170, !8, i64 0}
!170 = !{!"v4l2_file_operations", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64, !8, i64 72}
!171 = !{i32 -2147191550, i32 -2147191511, i32 -2147191490, i32 -2147191453, i32 -2147191430, i32 -2147191560}
!172 = !{i32 -2147190548, i32 -2147190509, i32 -2147190488, i32 -2147190451, i32 -2147190428, i32 -2147190419, i32 -2147190375}
!173 = !{!22, !22, i64 0}
!174 = !{i8 0, i8 2}
!175 = !{!28, !8, i64 104}
!176 = !{!41, !8, i64 152}
!177 = !{!25, !25, i64 0}
!178 = !{!69, !7, i64 1160}
