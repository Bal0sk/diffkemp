; ModuleID = 'drivers/hwmon/lm93.bc'
source_filename = "drivers/hwmon/lm93.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.33 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type opaque
%struct.seq_file = type opaque
%struct.vm_operations_struct = type opaque
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.32, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.rb_root = type { %struct.rb_node* }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.2 }
%union.anon.2 = type { %struct.anon }
%struct.anon = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type opaque
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.kuid_t = type { i32 }
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.5 }
%union.anon.5 = type { %struct.anon.9, [80 x i8] }
%struct.anon.9 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.page = type { i64, %union.anon.15, %union.anon.16, %union.anon.17, %union.anon.21, %union.anon.24, [8 x i8] }
%union.anon.15 = type { %struct.address_space* }
%struct.address_space = type opaque
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.21 = type { %struct.list_head }
%union.anon.24 = type { i64 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kioctx_table = type opaque
%struct.user_namespace = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.atomic64_t = type { i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.pgprot = type { i64 }
%struct.anon.32 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.mempolicy = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%union.anon.33 = type { i8* }
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.i2c_driver = type { i32, i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_client*, %struct.i2c_device_id*)*, i32 (%struct.i2c_client*)*, i32 (%struct.i2c_client*)*, void (%struct.i2c_client*)*, void (%struct.i2c_client*, i32, i32)*, i32 (%struct.i2c_client*, i32, i8*)*, %struct.device_driver, %struct.i2c_device_id*, i32 (%struct.i2c_client*, %struct.i2c_board_info*)*, i16*, %struct.list_head }
%struct.i2c_adapter = type { %struct.module*, i32, %struct.i2c_algorithm*, i8*, %struct.i2c_lock_operations*, %struct.rt_mutex, %struct.rt_mutex, i32, i32, %struct.device, i32, [48 x i8], %struct.completion, %struct.mutex, %struct.list_head, %struct.i2c_bus_recovery_info*, %struct.i2c_adapter_quirks*, %struct.irq_domain* }
%struct.i2c_algorithm = type { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }
%struct.i2c_msg = type { i16, i16, i16, i8* }
%union.i2c_smbus_data = type { i16, [32 x i8] }
%struct.i2c_lock_operations = type { void (%struct.i2c_adapter*, i32)*, i32 (%struct.i2c_adapter*, i32)*, void (%struct.i2c_adapter*, i32)* }
%struct.rt_mutex = type { %struct.raw_spinlock, %struct.rb_root, %struct.rb_node*, %struct.task_struct* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.kgid_t = type { i32 }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type {}
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.dma_map_ops = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.i2c_bus_recovery_info = type { {}*, {}*, void (%struct.i2c_adapter*, i32)*, {}*, void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }
%struct.i2c_adapter_quirks = type { i64, i32, i16, i16, i16, i16 }
%struct.irq_domain = type { %struct.list_head, i8*, %struct.irq_domain_ops*, i8*, i32, %struct.fwnode_handle*, i32, %struct.irq_domain_chip_generic*, %struct.irq_domain*, i64, i32, i32, %struct.radix_tree_root, [0 x i32] }
%struct.irq_domain_ops = type { i32 (%struct.irq_domain*, %struct.device_node*, i32)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i32)*, i32 (%struct.irq_domain*, i32, i64)*, void (%struct.irq_domain*, i32)*, i32 (%struct.irq_domain*, %struct.device_node*, i32*, i32, i64*, i32*)*, i32 (%struct.irq_domain*, i32, i32, i8*)*, void (%struct.irq_domain*, i32, i32)*, void (%struct.irq_domain*, %struct.irq_data*)*, void (%struct.irq_domain*, %struct.irq_data*)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i64*, i32*)* }
%struct.irq_fwspec = type { %struct.fwnode_handle*, i32, [16 x i32] }
%struct.irq_data = type opaque
%struct.irq_domain_chip_generic = type opaque
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.i2c_client = type { i16, i16, [20 x i8], %struct.i2c_adapter*, %struct.device, i32, %struct.list_head }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.i2c_device_id = type { [20 x i8], i64 }
%struct.i2c_board_info = type { [20 x i8], i16, i16, i8*, %struct.dev_archdata*, %struct.device_node*, %struct.fwnode_handle*, %struct.property_entry*, i32 }
%struct.property_entry = type { i8*, i64, i8, i8, %union.anon.34 }
%union.anon.34 = type { %union.anon.35 }
%union.anon.35 = type { i8* }
%struct.anon.41 = type { i8, i8 }
%struct.sensor_device_attribute = type { %struct.device_attribute, i32 }
%struct.sensor_device_attribute_2 = type { %struct.device_attribute, i8, i8 }
%struct.lm93_data = type { %struct.i2c_client*, %struct.mutex, i64, void (%struct.lm93_data*, %struct.i2c_client*)*, i8, %struct.block1_t, [6 x i8], [16 x i8], [2 x %struct.anon.37], [4 x i16], [4 x %struct.anon.38], [16 x %struct.anon.39], [4 x i16], [2 x [4 x i8]], %struct.anon.40, i8, [2 x i8], [2 x i8], [2 x i8], i8, i8, i8, [4 x i8], [2 x i8], [2 x i8], i8, i8, i8, i8, [2 x i8] }
%struct.block1_t = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.anon.37 = type { i8, i8 }
%struct.anon.38 = type { i8, i8 }
%struct.anon.39 = type { i8, i8 }
%struct.anon.40 = type { [4 x i8], [12 x i8] }

@__param_str_disable_block = internal constant [19 x i8] c"lm93.disable_block\00", align 16
@param_ops_bool = external constant %struct.kernel_param_ops, align 8
@disable_block = internal global i8 0, align 1
@__param_disable_block = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_disable_block, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.33 { i8* @disable_block } }, section "__param", align 8
@__param_str_init = internal constant [10 x i8] c"lm93.init\00", align 1
@init = internal global i8 0, align 1
@__param_init = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_init, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_bool, i16 0, i8 -1, i8 0, %union.anon.33 { i8* @init } }, section "__param", align 8
@__param_str_vccp_limit_type = internal constant [21 x i8] c"lm93.vccp_limit_type\00", align 16
@param_array_ops = external constant %struct.kernel_param_ops, align 8
@__param_arr_vccp_limit_type = internal constant %struct.kparam_array { i32 2, i32 4, i32* null, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([2 x i32]* @vccp_limit_type to i8*) }, align 8
@__param_vccp_limit_type = internal constant { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } } { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__param_str_vccp_limit_type, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_array_ops, i16 0, i8 -1, i8 0, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_vccp_limit_type } }, section "__param", align 8
@__param_str_vid_agtl = internal constant [14 x i8] c"lm93.vid_agtl\00", align 1
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@vid_agtl = internal global i32 0, align 4
@__param_vid_agtl = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_vid_agtl, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_int, i16 0, i8 -1, i8 0, %union.anon.33 { i8* bitcast (i32* @vid_agtl to i8*) } }, section "__param", align 8
@__initcall_lm93_driver_init6 = internal global i32 ()* @lm93_driver_init, section ".initcall6.init", align 8
@lm93_driver = internal global %struct.i2c_driver { i32 1, i32 (%struct.i2c_adapter*)* null, i32 (%struct.i2c_client*, %struct.i2c_device_id*)* @lm93_probe, i32 (%struct.i2c_client*)* null, i32 (%struct.i2c_client*)* null, void (%struct.i2c_client*)* null, void (%struct.i2c_client*, i32, i32)* null, i32 (%struct.i2c_client*, i32, i8*)* null, %struct.device_driver { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, i32 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.i2c_device_id* getelementptr inbounds ([3 x %struct.i2c_device_id], [3 x %struct.i2c_device_id]* @lm93_id, i32 0, i32 0), i32 (%struct.i2c_client*, %struct.i2c_board_info*)* @lm93_detect, i16* getelementptr inbounds ([4 x i16], [4 x i16]* @normal_i2c, i32 0, i32 0), %struct.list_head zeroinitializer }, align 8
@__exitcall_lm93_driver_exit = internal global void ()* @lm93_driver_exit, section ".exitcall.exit", align 8
@vccp_limit_type = internal global [2 x i32] zeroinitializer, align 4
@.str = private unnamed_addr constant [5 x i8] c"lm93\00", align 1
@lm93_id = internal constant [3 x %struct.i2c_device_id] [%struct.i2c_device_id { [20 x i8] c"lm93\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i64 0 }, %struct.i2c_device_id { [20 x i8] c"lm94\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i64 0 }, %struct.i2c_device_id zeroinitializer], align 16
@normal_i2c = internal constant [4 x i16] [i16 44, i16 45, i16 46, i16 -2], align 2
@lm93_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.1 = private unnamed_addr constant [19 x i8] c"&data->update_lock\00", align 1
@lm93_groups = internal global [2 x %struct.attribute_group*] [%struct.attribute_group* @lm93_group, %struct.attribute_group* null], align 16
@lm93_block_read_cmds = internal constant [12 x %struct.anon.41] [%struct.anon.41 { i8 -14, i8 8 }, %struct.anon.41 { i8 -13, i8 8 }, %struct.anon.41 { i8 -12, i8 6 }, %struct.anon.41 { i8 -11, i8 16 }, %struct.anon.41 { i8 -10, i8 4 }, %struct.anon.41 { i8 -9, i8 8 }, %struct.anon.41 { i8 -8, i8 12 }, %struct.anon.41 { i8 -7, i8 32 }, %struct.anon.41 { i8 -6, i8 8 }, %struct.anon.41 { i8 -5, i8 8 }, %struct.anon.41 { i8 -4, i8 16 }, %struct.anon.41 { i8 -3, i8 9 }], align 16
@lm93_block_buffer = internal global [32 x i8] zeroinitializer, align 16
@.str.2 = private unnamed_addr constant [47 x i8] c"lm93: block read data failed, command 0x%02x.\0A\00", align 1
@.str.3 = private unnamed_addr constant [46 x i8] c"lm93: read byte data failed, address 0x%02x.\0A\00", align 1
@.str.4 = private unnamed_addr constant [38 x i8] c"lm93: All read byte retries failed!!\0A\00", align 1
@.str.5 = private unnamed_addr constant [57 x i8] c"lm93: write byte data failed, 0x%02x at address 0x%02x.\0A\00", align 1
@.str.6 = private unnamed_addr constant [46 x i8] c"lm93: read word data failed, address 0x%02x.\0A\00", align 1
@.str.7 = private unnamed_addr constant [38 x i8] c"lm93: All read word retries failed!!\0A\00", align 1
@.str.8 = private unnamed_addr constant [52 x i8] c"timed out waiting for sensor chip to signal ready!\0A\00", align 1
@lm93_group = internal constant %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, i16 (%struct.kobject*, %struct.bin_attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([153 x %struct.attribute*], [153 x %struct.attribute*]* @lm93_attrs, i32 0, i32 0), %struct.bin_attribute** null }, align 8
@lm93_attrs = internal global [153 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in5_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in6_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in7_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in8_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in9_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in10_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in11_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in12_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in13_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in14_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in15_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in16_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in5_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in6_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in7_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in8_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in9_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in10_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in11_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in12_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in13_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in14_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in15_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in16_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in5_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in6_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in7_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in8_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in9_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in10_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in11_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in12_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in13_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in14_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in15_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in16_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_base, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_base, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_base, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_boost, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_boost, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_boost, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_boost_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_boost_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_boost_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset3, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset4, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset5, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset6, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset7, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset8, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset9, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset10, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset11, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset12, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset3, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset4, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset5, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset6, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset7, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset8, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset9, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset10, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset11, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset12, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset3, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset4, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset5, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset6, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset7, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset8, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset9, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset10, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset11, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset12, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_pwm_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_pwm_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_pwm_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_offset_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_offset_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_offset_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan3_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan4_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_enable, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_enable, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_freq, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_freq, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_auto_channels, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_auto_channels, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_auto_spinup_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_auto_spinup_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_auto_spinup_time, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_auto_spinup_time, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_pwm_auto_prochot_ramp, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_pwm_auto_vrdhot_ramp, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_cpu0_vid, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_cpu1_vid, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_avg, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_avg, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_override, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_override, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_interval, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_interval, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_prochot_override_duty_cycle, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_prochot_short, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_vrdhot1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_vrdhot2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_gpio, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_alarms, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.9, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.11, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_in5_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 4 }, align 8
@sensor_dev_attr_in6_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.15, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 5 }, align 8
@sensor_dev_attr_in7_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.16, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 6 }, align 8
@sensor_dev_attr_in8_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.17, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 7 }, align 8
@sensor_dev_attr_in9_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 8 }, align 8
@sensor_dev_attr_in10_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.19, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 9 }, align 8
@sensor_dev_attr_in11_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.20, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 10 }, align 8
@sensor_dev_attr_in12_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.21, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 11 }, align 8
@sensor_dev_attr_in13_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.22, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 12 }, align 8
@sensor_dev_attr_in14_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.23, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 13 }, align 8
@sensor_dev_attr_in15_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.24, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 14 }, align 8
@sensor_dev_attr_in16_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.25, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@sensor_dev_attr_in1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.26, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 0 }, align 8
@sensor_dev_attr_in2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.28, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 1 }, align 8
@sensor_dev_attr_in3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.29, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 2 }, align 8
@sensor_dev_attr_in4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.30, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 3 }, align 8
@sensor_dev_attr_in5_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.31, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 4 }, align 8
@sensor_dev_attr_in6_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.32, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 5 }, align 8
@sensor_dev_attr_in7_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.33, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 6 }, align 8
@sensor_dev_attr_in8_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.34, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 7 }, align 8
@sensor_dev_attr_in9_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.35, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 8 }, align 8
@sensor_dev_attr_in10_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.36, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 9 }, align 8
@sensor_dev_attr_in11_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.37, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 10 }, align 8
@sensor_dev_attr_in12_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.38, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 11 }, align 8
@sensor_dev_attr_in13_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 12 }, align 8
@sensor_dev_attr_in14_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.40, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 13 }, align 8
@sensor_dev_attr_in15_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.41, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 14 }, align 8
@sensor_dev_attr_in16_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.42, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 15 }, align 8
@sensor_dev_attr_in1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 0 }, align 8
@sensor_dev_attr_in2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 1 }, align 8
@sensor_dev_attr_in3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.45, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 2 }, align 8
@sensor_dev_attr_in4_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 3 }, align 8
@sensor_dev_attr_in5_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 4 }, align 8
@sensor_dev_attr_in6_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.48, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 5 }, align 8
@sensor_dev_attr_in7_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 6 }, align 8
@sensor_dev_attr_in8_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.50, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 7 }, align 8
@sensor_dev_attr_in9_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.51, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 8 }, align 8
@sensor_dev_attr_in10_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.52, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 9 }, align 8
@sensor_dev_attr_in11_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.53, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 10 }, align 8
@sensor_dev_attr_in12_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 11 }, align 8
@sensor_dev_attr_in13_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.55, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 12 }, align 8
@sensor_dev_attr_in14_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.56, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 13 }, align 8
@sensor_dev_attr_in15_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.57, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 14 }, align 8
@sensor_dev_attr_in16_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.58, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 15 }, align 8
@sensor_dev_attr_temp1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.59, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_temp2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.60, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_temp3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.61, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_temp1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.62, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_min }, i32 0 }, align 8
@sensor_dev_attr_temp2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.63, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_min }, i32 1 }, align 8
@sensor_dev_attr_temp3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.64, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_min }, i32 2 }, align 8
@sensor_dev_attr_temp1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.65, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_max }, i32 0 }, align 8
@sensor_dev_attr_temp2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.66, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_max }, i32 1 }, align 8
@sensor_dev_attr_temp3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.67, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_max }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_base = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.68, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_base, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_base }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_base = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.69, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_base, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_base }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_base = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.70, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_base, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_base }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_boost = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.71, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_boost = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.72, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_boost = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.73, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_boost_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.74, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost_hyst }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_boost_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.75, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost_hyst }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_boost_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.76, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost_hyst }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_offset1 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.77, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 0 }, align 8
@sensor_dev_attr_temp1_auto_offset2 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.78, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 1 }, align 8
@sensor_dev_attr_temp1_auto_offset3 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.79, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 2 }, align 8
@sensor_dev_attr_temp1_auto_offset4 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.80, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 3 }, align 8
@sensor_dev_attr_temp1_auto_offset5 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.81, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 4 }, align 8
@sensor_dev_attr_temp1_auto_offset6 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.82, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 5 }, align 8
@sensor_dev_attr_temp1_auto_offset7 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.83, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 6 }, align 8
@sensor_dev_attr_temp1_auto_offset8 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.84, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 7 }, align 8
@sensor_dev_attr_temp1_auto_offset9 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.85, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 8 }, align 8
@sensor_dev_attr_temp1_auto_offset10 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.86, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 9 }, align 8
@sensor_dev_attr_temp1_auto_offset11 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.87, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 10 }, align 8
@sensor_dev_attr_temp1_auto_offset12 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 11 }, align 8
@sensor_dev_attr_temp2_auto_offset1 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.89, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 0 }, align 8
@sensor_dev_attr_temp2_auto_offset2 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.90, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 1 }, align 8
@sensor_dev_attr_temp2_auto_offset3 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.91, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 2 }, align 8
@sensor_dev_attr_temp2_auto_offset4 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.92, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 3 }, align 8
@sensor_dev_attr_temp2_auto_offset5 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.93, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 4 }, align 8
@sensor_dev_attr_temp2_auto_offset6 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.94, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 5 }, align 8
@sensor_dev_attr_temp2_auto_offset7 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.95, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 6 }, align 8
@sensor_dev_attr_temp2_auto_offset8 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.96, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 7 }, align 8
@sensor_dev_attr_temp2_auto_offset9 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.97, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 8 }, align 8
@sensor_dev_attr_temp2_auto_offset10 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.98, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 9 }, align 8
@sensor_dev_attr_temp2_auto_offset11 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.99, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 10 }, align 8
@sensor_dev_attr_temp2_auto_offset12 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.100, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 11 }, align 8
@sensor_dev_attr_temp3_auto_offset1 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.101, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 0 }, align 8
@sensor_dev_attr_temp3_auto_offset2 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.102, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 1 }, align 8
@sensor_dev_attr_temp3_auto_offset3 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.103, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 2 }, align 8
@sensor_dev_attr_temp3_auto_offset4 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.104, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 3 }, align 8
@sensor_dev_attr_temp3_auto_offset5 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.105, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 4 }, align 8
@sensor_dev_attr_temp3_auto_offset6 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.106, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 5 }, align 8
@sensor_dev_attr_temp3_auto_offset7 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.107, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 6 }, align 8
@sensor_dev_attr_temp3_auto_offset8 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.108, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 7 }, align 8
@sensor_dev_attr_temp3_auto_offset9 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.109, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 8 }, align 8
@sensor_dev_attr_temp3_auto_offset10 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.110, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 9 }, align 8
@sensor_dev_attr_temp3_auto_offset11 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.111, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 10 }, align 8
@sensor_dev_attr_temp3_auto_offset12 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.112, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 11 }, align 8
@sensor_dev_attr_temp1_auto_pwm_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.113, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_pwm_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_pwm_min }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_pwm_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.114, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_pwm_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_pwm_min }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_pwm_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.115, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_pwm_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_pwm_min }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_offset_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.116, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset_hyst }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_offset_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.117, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset_hyst }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_offset_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.118, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset_hyst }, i32 2 }, align 8
@sensor_dev_attr_fan1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.119, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_fan2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.120, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_fan3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.121, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_fan4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.122, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_fan1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.123, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 0 }, align 8
@sensor_dev_attr_fan2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.125, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 1 }, align 8
@sensor_dev_attr_fan3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.126, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 2 }, align 8
@sensor_dev_attr_fan4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.127, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 3 }, align 8
@sensor_dev_attr_fan1_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.128, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 0 }, align 8
@sensor_dev_attr_fan2_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.129, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 1 }, align 8
@sensor_dev_attr_fan3_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.130, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 2 }, align 8
@sensor_dev_attr_fan4_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.131, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 3 }, align 8
@sensor_dev_attr_pwm1 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.132, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, i32 0 }, align 8
@sensor_dev_attr_pwm2 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.133, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, i32 1 }, align 8
@sensor_dev_attr_pwm1_enable = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.134, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_enable, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_enable }, i32 0 }, align 8
@sensor_dev_attr_pwm2_enable = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.135, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_enable, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_enable }, i32 1 }, align 8
@sensor_dev_attr_pwm1_freq = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.136, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_freq, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_freq }, i32 0 }, align 8
@sensor_dev_attr_pwm2_freq = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.137, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_freq, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_freq }, i32 1 }, align 8
@sensor_dev_attr_pwm1_auto_channels = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.138, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_channels, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_channels }, i32 0 }, align 8
@sensor_dev_attr_pwm2_auto_channels = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.139, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_channels, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_channels }, i32 1 }, align 8
@sensor_dev_attr_pwm1_auto_spinup_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.140, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_min }, i32 0 }, align 8
@sensor_dev_attr_pwm2_auto_spinup_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.141, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_min }, i32 1 }, align 8
@sensor_dev_attr_pwm1_auto_spinup_time = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.142, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_time, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_time }, i32 0 }, align 8
@sensor_dev_attr_pwm2_auto_spinup_time = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.143, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_time, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_time }, i32 1 }, align 8
@dev_attr_pwm_auto_prochot_ramp = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.144, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @pwm_auto_prochot_ramp_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @pwm_auto_prochot_ramp_store }, align 8
@dev_attr_pwm_auto_vrdhot_ramp = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.145, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @pwm_auto_vrdhot_ramp_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @pwm_auto_vrdhot_ramp_store }, align 8
@sensor_dev_attr_cpu0_vid = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.146, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vid, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_cpu1_vid = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.147, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vid, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_prochot1 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.148, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_prochot2 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.149, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_prochot1_avg = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.150, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_avg, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_prochot2_avg = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.151, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_avg, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_prochot1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.152, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_max }, i32 0 }, align 8
@sensor_dev_attr_prochot2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.153, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_max }, i32 1 }, align 8
@sensor_dev_attr_prochot1_override = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.154, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_override, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_override }, i32 0 }, align 8
@sensor_dev_attr_prochot2_override = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.155, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_override, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_override }, i32 1 }, align 8
@sensor_dev_attr_prochot1_interval = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.156, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_interval, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_interval }, i32 0 }, align 8
@sensor_dev_attr_prochot2_interval = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.157, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_interval, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_interval }, i32 1 }, align 8
@dev_attr_prochot_override_duty_cycle = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.158, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @prochot_override_duty_cycle_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @prochot_override_duty_cycle_store }, align 8
@dev_attr_prochot_short = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.159, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @prochot_short_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @prochot_short_store }, align 8
@sensor_dev_attr_vrdhot1 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.160, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vrdhot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_vrdhot2 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.161, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vrdhot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@dev_attr_gpio = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.162, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @gpio_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_alarms = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.163, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @alarms_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.9 = private unnamed_addr constant [10 x i8] c"in1_input\00", align 1
@.str.10 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@jiffies = external global i64, align 8
@lm93_vin_val_max = internal constant [16 x i64] [i64 1236, i64 1236, i64 1236, i64 1600, i64 2000, i64 2000, i64 1600, i64 1600, i64 4400, i64 6500, i64 3333, i64 2625, i64 1312, i64 1312, i64 1236, i64 3600], align 16
@lm93_vin_val_min = internal constant [16 x i64] [i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 3000], align 16
@lm93_vin_reg_max = internal constant [16 x i8] c"\FF\FF\FF\FF\FF\FF\FF\FF\FF\FA\FF\FF\FF\FF\FF\D1", align 16
@lm93_vin_reg_min = internal constant [16 x i8] c"\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\AE", align 16
@.str.11 = private unnamed_addr constant [10 x i8] c"in2_input\00", align 1
@.str.12 = private unnamed_addr constant [10 x i8] c"in3_input\00", align 1
@.str.13 = private unnamed_addr constant [10 x i8] c"in4_input\00", align 1
@.str.14 = private unnamed_addr constant [10 x i8] c"in5_input\00", align 1
@.str.15 = private unnamed_addr constant [10 x i8] c"in6_input\00", align 1
@.str.16 = private unnamed_addr constant [10 x i8] c"in7_input\00", align 1
@.str.17 = private unnamed_addr constant [10 x i8] c"in8_input\00", align 1
@.str.18 = private unnamed_addr constant [10 x i8] c"in9_input\00", align 1
@.str.19 = private unnamed_addr constant [11 x i8] c"in10_input\00", align 1
@.str.20 = private unnamed_addr constant [11 x i8] c"in11_input\00", align 1
@.str.21 = private unnamed_addr constant [11 x i8] c"in12_input\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"in13_input\00", align 1
@.str.23 = private unnamed_addr constant [11 x i8] c"in14_input\00", align 1
@.str.24 = private unnamed_addr constant [11 x i8] c"in15_input\00", align 1
@.str.25 = private unnamed_addr constant [11 x i8] c"in16_input\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"in1_min\00", align 1
@.str.27 = private unnamed_addr constant [5 x i8] c"%ld\0A\00", align 1
@.str.28 = private unnamed_addr constant [8 x i8] c"in2_min\00", align 1
@.str.29 = private unnamed_addr constant [8 x i8] c"in3_min\00", align 1
@.str.30 = private unnamed_addr constant [8 x i8] c"in4_min\00", align 1
@.str.31 = private unnamed_addr constant [8 x i8] c"in5_min\00", align 1
@.str.32 = private unnamed_addr constant [8 x i8] c"in6_min\00", align 1
@.str.33 = private unnamed_addr constant [8 x i8] c"in7_min\00", align 1
@.str.34 = private unnamed_addr constant [8 x i8] c"in8_min\00", align 1
@.str.35 = private unnamed_addr constant [8 x i8] c"in9_min\00", align 1
@.str.36 = private unnamed_addr constant [9 x i8] c"in10_min\00", align 1
@.str.37 = private unnamed_addr constant [9 x i8] c"in11_min\00", align 1
@.str.38 = private unnamed_addr constant [9 x i8] c"in12_min\00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c"in13_min\00", align 1
@.str.40 = private unnamed_addr constant [9 x i8] c"in14_min\00", align 1
@.str.41 = private unnamed_addr constant [9 x i8] c"in15_min\00", align 1
@.str.42 = private unnamed_addr constant [9 x i8] c"in16_min\00", align 1
@.str.43 = private unnamed_addr constant [8 x i8] c"in1_max\00", align 1
@.str.44 = private unnamed_addr constant [8 x i8] c"in2_max\00", align 1
@.str.45 = private unnamed_addr constant [8 x i8] c"in3_max\00", align 1
@.str.46 = private unnamed_addr constant [8 x i8] c"in4_max\00", align 1
@.str.47 = private unnamed_addr constant [8 x i8] c"in5_max\00", align 1
@.str.48 = private unnamed_addr constant [8 x i8] c"in6_max\00", align 1
@.str.49 = private unnamed_addr constant [8 x i8] c"in7_max\00", align 1
@.str.50 = private unnamed_addr constant [8 x i8] c"in8_max\00", align 1
@.str.51 = private unnamed_addr constant [8 x i8] c"in9_max\00", align 1
@.str.52 = private unnamed_addr constant [9 x i8] c"in10_max\00", align 1
@.str.53 = private unnamed_addr constant [9 x i8] c"in11_max\00", align 1
@.str.54 = private unnamed_addr constant [9 x i8] c"in12_max\00", align 1
@.str.55 = private unnamed_addr constant [9 x i8] c"in13_max\00", align 1
@.str.56 = private unnamed_addr constant [9 x i8] c"in14_max\00", align 1
@.str.57 = private unnamed_addr constant [9 x i8] c"in15_max\00", align 1
@.str.58 = private unnamed_addr constant [9 x i8] c"in16_max\00", align 1
@.str.59 = private unnamed_addr constant [12 x i8] c"temp1_input\00", align 1
@.str.60 = private unnamed_addr constant [12 x i8] c"temp2_input\00", align 1
@.str.61 = private unnamed_addr constant [12 x i8] c"temp3_input\00", align 1
@.str.62 = private unnamed_addr constant [10 x i8] c"temp1_min\00", align 1
@.str.63 = private unnamed_addr constant [10 x i8] c"temp2_min\00", align 1
@.str.64 = private unnamed_addr constant [10 x i8] c"temp3_min\00", align 1
@.str.65 = private unnamed_addr constant [10 x i8] c"temp1_max\00", align 1
@.str.66 = private unnamed_addr constant [10 x i8] c"temp2_max\00", align 1
@.str.67 = private unnamed_addr constant [10 x i8] c"temp3_max\00", align 1
@.str.68 = private unnamed_addr constant [16 x i8] c"temp1_auto_base\00", align 1
@.str.69 = private unnamed_addr constant [16 x i8] c"temp2_auto_base\00", align 1
@.str.70 = private unnamed_addr constant [16 x i8] c"temp3_auto_base\00", align 1
@.str.71 = private unnamed_addr constant [17 x i8] c"temp1_auto_boost\00", align 1
@.str.72 = private unnamed_addr constant [17 x i8] c"temp2_auto_boost\00", align 1
@.str.73 = private unnamed_addr constant [17 x i8] c"temp3_auto_boost\00", align 1
@.str.74 = private unnamed_addr constant [22 x i8] c"temp1_auto_boost_hyst\00", align 1
@.str.75 = private unnamed_addr constant [22 x i8] c"temp2_auto_boost_hyst\00", align 1
@.str.76 = private unnamed_addr constant [22 x i8] c"temp3_auto_boost_hyst\00", align 1
@.str.77 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset1\00", align 1
@.str.78 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset2\00", align 1
@.str.79 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset3\00", align 1
@.str.80 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset4\00", align 1
@.str.81 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset5\00", align 1
@.str.82 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset6\00", align 1
@.str.83 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset7\00", align 1
@.str.84 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset8\00", align 1
@.str.85 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset9\00", align 1
@.str.86 = private unnamed_addr constant [20 x i8] c"temp1_auto_offset10\00", align 1
@.str.87 = private unnamed_addr constant [20 x i8] c"temp1_auto_offset11\00", align 1
@.str.88 = private unnamed_addr constant [20 x i8] c"temp1_auto_offset12\00", align 1
@.str.89 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset1\00", align 1
@.str.90 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset2\00", align 1
@.str.91 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset3\00", align 1
@.str.92 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset4\00", align 1
@.str.93 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset5\00", align 1
@.str.94 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset6\00", align 1
@.str.95 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset7\00", align 1
@.str.96 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset8\00", align 1
@.str.97 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset9\00", align 1
@.str.98 = private unnamed_addr constant [20 x i8] c"temp2_auto_offset10\00", align 1
@.str.99 = private unnamed_addr constant [20 x i8] c"temp2_auto_offset11\00", align 1
@.str.100 = private unnamed_addr constant [20 x i8] c"temp2_auto_offset12\00", align 1
@.str.101 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset1\00", align 1
@.str.102 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset2\00", align 1
@.str.103 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset3\00", align 1
@.str.104 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset4\00", align 1
@.str.105 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset5\00", align 1
@.str.106 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset6\00", align 1
@.str.107 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset7\00", align 1
@.str.108 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset8\00", align 1
@.str.109 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset9\00", align 1
@.str.110 = private unnamed_addr constant [20 x i8] c"temp3_auto_offset10\00", align 1
@.str.111 = private unnamed_addr constant [20 x i8] c"temp3_auto_offset11\00", align 1
@.str.112 = private unnamed_addr constant [20 x i8] c"temp3_auto_offset12\00", align 1
@.str.113 = private unnamed_addr constant [19 x i8] c"temp1_auto_pwm_min\00", align 1
@lm93_pwm_map = internal global [2 x [16 x i32]] [[16 x i32] [i32 0, i32 64, i32 80, i32 96, i32 112, i32 128, i32 144, i32 160, i32 176, i32 192, i32 208, i32 224, i32 240, i32 255, i32 255, i32 255], [16 x i32] [i32 0, i32 64, i32 73, i32 82, i32 91, i32 100, i32 109, i32 118, i32 128, i32 137, i32 146, i32 182, i32 219, i32 255, i32 255, i32 255]], align 16
@.str.114 = private unnamed_addr constant [19 x i8] c"temp2_auto_pwm_min\00", align 1
@.str.115 = private unnamed_addr constant [19 x i8] c"temp3_auto_pwm_min\00", align 1
@.str.116 = private unnamed_addr constant [23 x i8] c"temp1_auto_offset_hyst\00", align 1
@.str.117 = private unnamed_addr constant [23 x i8] c"temp2_auto_offset_hyst\00", align 1
@.str.118 = private unnamed_addr constant [23 x i8] c"temp3_auto_offset_hyst\00", align 1
@.str.119 = private unnamed_addr constant [11 x i8] c"fan1_input\00", align 1
@.str.120 = private unnamed_addr constant [11 x i8] c"fan2_input\00", align 1
@.str.121 = private unnamed_addr constant [11 x i8] c"fan3_input\00", align 1
@.str.122 = private unnamed_addr constant [11 x i8] c"fan4_input\00", align 1
@.str.123 = private unnamed_addr constant [9 x i8] c"fan1_min\00", align 1
@.str.124 = private unnamed_addr constant [57 x i8] c"lm93: write word data failed, 0x%04x at address 0x%02x.\0A\00", align 1
@.str.125 = private unnamed_addr constant [9 x i8] c"fan2_min\00", align 1
@.str.126 = private unnamed_addr constant [9 x i8] c"fan3_min\00", align 1
@.str.127 = private unnamed_addr constant [9 x i8] c"fan4_min\00", align 1
@.str.128 = private unnamed_addr constant [16 x i8] c"fan1_smart_tach\00", align 1
@.str.129 = private unnamed_addr constant [16 x i8] c"fan2_smart_tach\00", align 1
@.str.130 = private unnamed_addr constant [16 x i8] c"fan3_smart_tach\00", align 1
@.str.131 = private unnamed_addr constant [16 x i8] c"fan4_smart_tach\00", align 1
@.str.132 = private unnamed_addr constant [5 x i8] c"pwm1\00", align 1
@.str.133 = private unnamed_addr constant [5 x i8] c"pwm2\00", align 1
@.str.134 = private unnamed_addr constant [12 x i8] c"pwm1_enable\00", align 1
@.str.135 = private unnamed_addr constant [12 x i8] c"pwm2_enable\00", align 1
@.str.136 = private unnamed_addr constant [10 x i8] c"pwm1_freq\00", align 1
@lm93_pwm_freq_map = internal global [8 x i32] [i32 22500, i32 96, i32 84, i32 72, i32 60, i32 48, i32 36, i32 12], align 16
@.str.137 = private unnamed_addr constant [10 x i8] c"pwm2_freq\00", align 1
@.str.138 = private unnamed_addr constant [19 x i8] c"pwm1_auto_channels\00", align 1
@.str.139 = private unnamed_addr constant [19 x i8] c"pwm2_auto_channels\00", align 1
@.str.140 = private unnamed_addr constant [21 x i8] c"pwm1_auto_spinup_min\00", align 1
@.str.141 = private unnamed_addr constant [21 x i8] c"pwm2_auto_spinup_min\00", align 1
@.str.142 = private unnamed_addr constant [22 x i8] c"pwm1_auto_spinup_time\00", align 1
@lm93_spinup_time_map = internal global [8 x i32] [i32 0, i32 10, i32 25, i32 40, i32 70, i32 100, i32 200, i32 400], align 16
@.str.143 = private unnamed_addr constant [22 x i8] c"pwm2_auto_spinup_time\00", align 1
@.str.144 = private unnamed_addr constant [22 x i8] c"pwm_auto_prochot_ramp\00", align 1
@.str.145 = private unnamed_addr constant [21 x i8] c"pwm_auto_vrdhot_ramp\00", align 1
@.str.146 = private unnamed_addr constant [9 x i8] c"cpu0_vid\00", align 1
@.str.147 = private unnamed_addr constant [9 x i8] c"cpu1_vid\00", align 1
@.str.148 = private unnamed_addr constant [9 x i8] c"prochot1\00", align 1
@.str.149 = private unnamed_addr constant [9 x i8] c"prochot2\00", align 1
@.str.150 = private unnamed_addr constant [13 x i8] c"prochot1_avg\00", align 1
@.str.151 = private unnamed_addr constant [13 x i8] c"prochot2_avg\00", align 1
@.str.152 = private unnamed_addr constant [13 x i8] c"prochot1_max\00", align 1
@.str.153 = private unnamed_addr constant [13 x i8] c"prochot2_max\00", align 1
@.str.154 = private unnamed_addr constant [18 x i8] c"prochot1_override\00", align 1
@prochot_override_mask = internal constant [2 x i8] c"\80@", align 1
@.str.155 = private unnamed_addr constant [18 x i8] c"prochot2_override\00", align 1
@.str.156 = private unnamed_addr constant [18 x i8] c"prochot1_interval\00", align 1
@lm93_interval_map = internal global [10 x i32] [i32 73, i32 146, i32 290, i32 580, i32 1170, i32 2330, i32 4660, i32 9320, i32 18600, i32 37200], align 16
@.str.157 = private unnamed_addr constant [18 x i8] c"prochot2_interval\00", align 1
@.str.158 = private unnamed_addr constant [28 x i8] c"prochot_override_duty_cycle\00", align 1
@.str.159 = private unnamed_addr constant [14 x i8] c"prochot_short\00", align 1
@.str.160 = private unnamed_addr constant [8 x i8] c"vrdhot1\00", align 1
@.str.161 = private unnamed_addr constant [8 x i8] c"vrdhot2\00", align 1
@.str.162 = private unnamed_addr constant [5 x i8] c"gpio\00", align 1
@.str.163 = private unnamed_addr constant [7 x i8] c"alarms\00", align 1
@.str.164 = private unnamed_addr constant [5 x i8] c"lm94\00", align 1
@llvm.used = appending global [7 x i8*] [i8* bitcast (%struct.kernel_param* @__param_disable_block to i8*), i8* bitcast (%struct.kernel_param* @__param_init to i8*), i8* bitcast ({ i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, { %struct.kparam_array* } }* @__param_vccp_limit_type to i8*), i8* bitcast (%struct.kernel_param* @__param_vid_agtl to i8*), i8* bitcast (i32 ()** @__initcall_lm93_driver_init6 to i8*), i8* bitcast (void ()* @lm93_driver_exit to i8*), i8* bitcast (void ()** @__exitcall_lm93_driver_exit to i8*)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define internal i32 @lm93_driver_init() #0 section ".init.text" {
entry:
  %call = call i32 @i2c_register_driver(%struct.module* null, %struct.i2c_driver* @lm93_driver)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @lm93_driver_exit() #0 section ".exit.text" {
entry:
  call void @i2c_del_driver(%struct.i2c_driver* @lm93_driver)
  ret void
}

declare void @i2c_del_driver(%struct.i2c_driver*) #1

declare i32 @i2c_register_driver(%struct.module*, %struct.i2c_driver*) #1

; Function Attrs: nounwind uwtable
define internal i32 @lm93_probe(%struct.i2c_client* %client, %struct.i2c_device_id* %id) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  %adapter = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 3
  %0 = load %struct.i2c_adapter*, %struct.i2c_adapter** %adapter, align 8, !tbaa !2
  %call = call i32 @i2c_get_functionality(%struct.i2c_adapter* %0)
  %and = and i32 58195968, %call
  %cmp = icmp eq i32 %and, 58195968
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @disable_block, align 1, !tbaa !32, !range !33
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.else, label %if.end6

if.else:                                          ; preds = %land.lhs.true, %entry
  %and2 = and i32 7864320, %call
  %cmp3 = icmp eq i32 %and2, 7864320
  br i1 %cmp3, label %if.end6, label %cleanup

if.end6:                                          ; preds = %if.else, %land.lhs.true
  %update.0 = phi void (%struct.lm93_data*, %struct.i2c_client*)* [ @lm93_update_client_full, %land.lhs.true ], [ @lm93_update_client_min, %if.else ]
  %call7 = call i8* @devm_kzalloc(%struct.device* %dev1, i64 200, i32 20971712)
  %2 = bitcast i8* %call7 to %struct.lm93_data*
  %tobool8 = icmp ne %struct.lm93_data* %2, null
  br i1 %tobool8, label %if.end10, label %cleanup

if.end10:                                         ; preds = %if.end6
  %client11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 0
  store %struct.i2c_client* %client, %struct.i2c_client** %client11, align 8, !tbaa !34
  %update12 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 3
  store void (%struct.lm93_data*, %struct.i2c_client*)* %update.0, void (%struct.lm93_data*, %struct.i2c_client*)** %update12, align 8, !tbaa !38
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @__mutex_init(%struct.mutex* %update_lock, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.1, i32 0, i32 0), %struct.lock_class_key* @lm93_probe.__key)
  call void @lm93_init_client(%struct.i2c_client* %client)
  %name = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 2
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %name, i32 0, i32 0
  %3 = bitcast %struct.lm93_data* %2 to i8*
  %call13 = call %struct.device* @devm_hwmon_device_register_with_groups(%struct.device* %dev1, i8* %arraydecay, i8* %3, %struct.attribute_group** getelementptr inbounds ([2 x %struct.attribute_group*], [2 x %struct.attribute_group*]* @lm93_groups, i32 0, i32 0))
  %4 = bitcast %struct.device* %call13 to i8*
  %call14 = call i32 @PTR_ERR_OR_ZERO(i8* %4)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.else, %if.end10
  %retval.0 = phi i32 [ %call14, %if.end10 ], [ -19, %if.else ], [ -12, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_detect(%struct.i2c_client* %client, %struct.i2c_board_info* %info) #0 {
entry:
  %adapter1 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 3
  %0 = load %struct.i2c_adapter*, %struct.i2c_adapter** %adapter1, align 8, !tbaa !2
  %call = call i32 @i2c_check_functionality(%struct.i2c_adapter* %0, i32 7864320)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext 62)
  %conv = zext i8 %call2 to i32
  %cmp = icmp ne i32 %conv, 1
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext 63)
  %conv7 = zext i8 %call6 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end5
  %Pivot = icmp slt i32 %conv7, 120
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %conv7.off2 = add i32 %conv7, -120
  %SwitchLeaf3 = icmp ule i32 %conv7.off2, 2
  br i1 %SwitchLeaf3, label %sw.bb8, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %conv7.off = add i32 %conv7, -114
  %SwitchLeaf = icmp ule i32 %conv7.off, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb8:                                           ; preds = %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock, %sw.bb8
  %name.0 = phi i8* [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.164, i32 0, i32 0), %sw.bb8 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), %LeafBlock ]
  %type = getelementptr inbounds %struct.i2c_board_info, %struct.i2c_board_info* %info, i32 0, i32 0
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %type, i32 0, i32 0
  %call9 = call i64 @strlcpy(i8* %arraydecay, i8* %name.0, i64 20)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %cleanup

cleanup:                                          ; preds = %NewDefault, %if.end, %entry, %sw.epilog
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -19, %entry ], [ -19, %if.end ], [ -19, %NewDefault ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @i2c_get_functionality(%struct.i2c_adapter* %adap) #3 {
entry:
  %algo = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 2
  %0 = load %struct.i2c_algorithm*, %struct.i2c_algorithm** %algo, align 8, !tbaa !39
  %functionality = getelementptr inbounds %struct.i2c_algorithm, %struct.i2c_algorithm* %0, i32 0, i32 2
  %1 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %functionality, align 8, !tbaa !45
  %call = call i32 %1(%struct.i2c_adapter* %adap)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @lm93_update_client_full(%struct.lm93_data* %data, %struct.i2c_client* %client) #0 {
entry:
  %block3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 7
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %block3, i32 0, i32 0
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 3, i8* %arraydecay)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 11
  %arraydecay1 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block7, i32 0, i32 0
  %0 = bitcast %struct.anon.39* %arraydecay1 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 7, i8* %0)
  %block2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 6
  %arraydecay2 = getelementptr inbounds [6 x i8], [6 x i8]* %block2, i32 0, i32 0
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 2, i8* %arraydecay2)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 8
  %arraydecay3 = getelementptr inbounds [2 x %struct.anon.37], [2 x %struct.anon.37]* %block4, i32 0, i32 0
  %1 = bitcast %struct.anon.37* %arraydecay3 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 4, i8* %1)
  %block5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 9
  %arraydecay4 = getelementptr inbounds [4 x i16], [4 x i16]* %block5, i32 0, i32 0
  %2 = bitcast i16* %arraydecay4 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 5, i8* %2)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 12
  %arraydecay5 = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i32 0, i32 0
  %3 = bitcast i16* %arraydecay5 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 8, i8* %3)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 13
  %arraydecay6 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i32 0, i32 0
  %4 = bitcast [4 x i8]* %arraydecay6 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 9, i8* %4)
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 5
  %5 = bitcast %struct.block1_t* %block1 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 1, i8* %5)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 14
  %6 = bitcast %struct.anon.40* %block10 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 10, i8* %6)
  call void @lm93_update_client_common(%struct.lm93_data* %data, %struct.i2c_client* %client)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @lm93_update_client_min(%struct.lm93_data* %data, %struct.i2c_client* %client) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 86, %i.0
  %conv = trunc i32 %add to i8
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv)
  %block3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %block3, i64 0, i64 %idxprom
  store i8 %call, i8* %arrayidx, align 1, !tbaa !47
  %mul = mul nsw i32 %i.0, 2
  %add1 = add nsw i32 144, %mul
  %conv2 = trunc i32 %add1 to i8
  %call3 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv2)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 11
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block7, i64 0, i64 %idxprom4
  %min = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx5, i32 0, i32 0
  store i8 %call3, i8* %min, align 2, !tbaa !48
  %mul6 = mul nsw i32 %i.0, 2
  %add7 = add nsw i32 145, %mul6
  %conv8 = trunc i32 %add7 to i8
  %call9 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv8)
  %block710 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 11
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block710, i64 0, i64 %idxprom11
  %max = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx12, i32 0, i32 1
  store i8 %call9, i8* %max, align 1, !tbaa !50
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond13

for.cond13:                                       ; preds = %for.body16, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc23, %for.body16 ]
  %cmp14 = icmp slt i32 %i.1, 4
  br i1 %cmp14, label %for.body16, label %for.end24

for.body16:                                       ; preds = %for.cond13
  %add17 = add nsw i32 80, %i.1
  %conv18 = trunc i32 %add17 to i8
  %call19 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv18)
  %block2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 6
  %idxprom20 = sext i32 %i.1 to i64
  %arrayidx21 = getelementptr inbounds [6 x i8], [6 x i8]* %block2, i64 0, i64 %idxprom20
  store i8 %call19, i8* %arrayidx21, align 1, !tbaa !47
  %inc23 = add nsw i32 %i.1, 1
  br label %for.cond13

for.end24:                                        ; preds = %for.cond13
  br label %for.cond25

for.cond25:                                       ; preds = %for.body28, %for.end24
  %i.2 = phi i32 [ 0, %for.end24 ], [ %inc43, %for.body28 ]
  %cmp26 = icmp slt i32 %i.2, 2
  br i1 %cmp26, label %for.body28, label %for.end44

for.body28:                                       ; preds = %for.cond25
  %mul29 = mul nsw i32 %i.2, 2
  %add30 = add nsw i32 103, %mul29
  %conv31 = trunc i32 %add30 to i8
  %call32 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv31)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 8
  %idxprom33 = sext i32 %i.2 to i64
  %arrayidx34 = getelementptr inbounds [2 x %struct.anon.37], [2 x %struct.anon.37]* %block4, i64 0, i64 %idxprom33
  %cur = getelementptr inbounds %struct.anon.37, %struct.anon.37* %arrayidx34, i32 0, i32 0
  store i8 %call32, i8* %cur, align 1, !tbaa !48
  %mul35 = mul nsw i32 %i.2, 2
  %add36 = add nsw i32 104, %mul35
  %conv37 = trunc i32 %add36 to i8
  %call38 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv37)
  %block439 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 8
  %idxprom40 = sext i32 %i.2 to i64
  %arrayidx41 = getelementptr inbounds [2 x %struct.anon.37], [2 x %struct.anon.37]* %block439, i64 0, i64 %idxprom40
  %avg = getelementptr inbounds %struct.anon.37, %struct.anon.37* %arrayidx41, i32 0, i32 1
  store i8 %call38, i8* %avg, align 1, !tbaa !50
  %inc43 = add nsw i32 %i.2, 1
  br label %for.cond25

for.end44:                                        ; preds = %for.cond25
  br label %for.cond45

for.cond45:                                       ; preds = %for.body48, %for.end44
  %i.3 = phi i32 [ 0, %for.end44 ], [ %inc62, %for.body48 ]
  %cmp46 = icmp slt i32 %i.3, 4
  br i1 %cmp46, label %for.body48, label %for.end63

for.body48:                                       ; preds = %for.cond45
  %mul49 = mul nsw i32 %i.3, 2
  %add50 = add nsw i32 110, %mul49
  %conv51 = trunc i32 %add50 to i8
  %call52 = call zeroext i16 @lm93_read_word(%struct.i2c_client* %client, i8 zeroext %conv51)
  %block5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 9
  %idxprom53 = sext i32 %i.3 to i64
  %arrayidx54 = getelementptr inbounds [4 x i16], [4 x i16]* %block5, i64 0, i64 %idxprom53
  store i16 %call52, i16* %arrayidx54, align 2, !tbaa !51
  %mul55 = mul nsw i32 %i.3, 2
  %add56 = add nsw i32 180, %mul55
  %conv57 = trunc i32 %add56 to i8
  %call58 = call zeroext i16 @lm93_read_word(%struct.i2c_client* %client, i8 zeroext %conv57)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 12
  %idxprom59 = sext i32 %i.3 to i64
  %arrayidx60 = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i64 0, i64 %idxprom59
  store i16 %call58, i16* %arrayidx60, align 2, !tbaa !51
  %inc62 = add nsw i32 %i.3, 1
  br label %for.cond45

for.end63:                                        ; preds = %for.cond45
  br label %for.cond64

for.cond64:                                       ; preds = %for.inc84, %for.end63
  %i.4 = phi i32 [ 0, %for.end63 ], [ %inc85, %for.inc84 ]
  %cmp65 = icmp slt i32 %i.4, 2
  br i1 %cmp65, label %for.body67, label %for.end86

for.body67:                                       ; preds = %for.cond64
  br label %for.cond68

for.cond68:                                       ; preds = %for.body71, %for.body67
  %j.0 = phi i32 [ 0, %for.body67 ], [ %inc82, %for.body71 ]
  %cmp69 = icmp slt i32 %j.0, 4
  br i1 %cmp69, label %for.body71, label %for.inc84

for.body71:                                       ; preds = %for.cond68
  %add72 = add nsw i32 200, %j.0
  %mul73 = mul nsw i32 %i.4, 4
  %add74 = add nsw i32 %add72, %mul73
  %conv75 = trunc i32 %add74 to i8
  %call76 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv75)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 13
  %idxprom77 = sext i32 %i.4 to i64
  %arrayidx78 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom77
  %idxprom79 = sext i32 %j.0 to i64
  %arrayidx80 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx78, i64 0, i64 %idxprom79
  store i8 %call76, i8* %arrayidx80, align 1, !tbaa !47
  %inc82 = add nsw i32 %j.0, 1
  br label %for.cond68

for.inc84:                                        ; preds = %for.cond68
  %inc85 = add nsw i32 %i.4, 1
  br label %for.cond64

for.end86:                                        ; preds = %for.cond64
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 5
  %0 = bitcast %struct.block1_t* %block1 to i8*
  br label %for.cond87

for.cond87:                                       ; preds = %for.body90, %for.end86
  %i.5 = phi i32 [ 0, %for.end86 ], [ %inc95, %for.body90 ]
  %cmp88 = icmp slt i32 %i.5, 8
  br i1 %cmp88, label %for.body90, label %for.end96

for.body90:                                       ; preds = %for.cond87
  %add91 = add nsw i32 72, %i.5
  %conv92 = trunc i32 %add91 to i8
  %call93 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv92)
  %idx.ext = sext i32 %i.5 to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  store i8 %call93, i8* %add.ptr, align 1, !tbaa !47
  %inc95 = add nsw i32 %i.5, 1
  br label %for.cond87

for.end96:                                        ; preds = %for.cond87
  br label %for.cond97

for.cond97:                                       ; preds = %for.body100, %for.end96
  %i.6 = phi i32 [ 0, %for.end96 ], [ %inc107, %for.body100 ]
  %cmp98 = icmp slt i32 %i.6, 4
  br i1 %cmp98, label %for.body100, label %for.end108

for.body100:                                      ; preds = %for.cond97
  %add101 = add nsw i32 208, %i.6
  %conv102 = trunc i32 %add101 to i8
  %call103 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv102)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 14
  %base = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block10, i32 0, i32 0
  %idxprom104 = sext i32 %i.6 to i64
  %arrayidx105 = getelementptr inbounds [4 x i8], [4 x i8]* %base, i64 0, i64 %idxprom104
  store i8 %call103, i8* %arrayidx105, align 1, !tbaa !47
  %inc107 = add nsw i32 %i.6, 1
  br label %for.cond97

for.end108:                                       ; preds = %for.cond97
  br label %for.cond109

for.cond109:                                      ; preds = %for.body112, %for.end108
  %i.7 = phi i32 [ 0, %for.end108 ], [ %inc120, %for.body112 ]
  %cmp110 = icmp slt i32 %i.7, 12
  br i1 %cmp110, label %for.body112, label %for.end121

for.body112:                                      ; preds = %for.cond109
  %add113 = add nsw i32 212, %i.7
  %conv114 = trunc i32 %add113 to i8
  %call115 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv114)
  %block10116 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 14
  %offset = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block10116, i32 0, i32 1
  %idxprom117 = sext i32 %i.7 to i64
  %arrayidx118 = getelementptr inbounds [12 x i8], [12 x i8]* %offset, i64 0, i64 %idxprom117
  store i8 %call115, i8* %arrayidx118, align 1, !tbaa !47
  %inc120 = add nsw i32 %i.7, 1
  br label %for.cond109

for.end121:                                       ; preds = %for.cond109
  call void @lm93_update_client_common(%struct.lm93_data* %data, %struct.i2c_client* %client)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @devm_kzalloc(%struct.device* %dev, i64 %size, i32 %gfp) #3 {
entry:
  %or = or i32 %gfp, 32768
  %call = call noalias i8* @devm_kmalloc(%struct.device* %dev, i64 %size, i32 %or)
  ret i8* %call
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal void @lm93_init_client(%struct.i2c_client* %client) #0 {
entry:
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -66)
  %conv = zext i8 %call to i32
  %0 = load i32, i32* @vid_agtl, align 4, !tbaa !52
  %tobool = icmp ne i32 %0, 0
  %1 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 3, i32 0
  %or = or i32 %conv, %cond
  %conv1 = trunc i32 %or to i8
  %call2 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -66, i8 zeroext %conv1)
  %2 = load i8, i8* @init, align 1, !tbaa !32, !range !33
  %tobool3 = trunc i8 %2 to i1
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %conv5 = zext i8 %call4 to i32
  %or6 = or i32 %conv5, 8
  %conv7 = trunc i32 %or6 to i8
  %call8 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -29, i8 zeroext %conv7)
  %call9 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -30)
  %conv10 = zext i8 %call9 to i32
  %or11 = or i32 %conv10, 2
  %conv12 = trunc i32 %or11 to i8
  %call13 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -30, i8 zeroext %conv12)
  %call14 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -28, i8 zeroext 0)
  %call15 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -19)
  %conv16 = zext i8 %call15 to i32
  %and = and i32 %conv16, -4
  %conv17 = trunc i32 %and to i8
  %3 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 0), align 4, !tbaa !52
  %tobool18 = icmp ne i32 %3, 0
  %4 = zext i1 %tobool18 to i64
  %cond19 = select i1 %tobool18, i32 16, i32 0
  %neg = xor i32 %cond19, -1
  %conv20 = zext i8 %conv17 to i32
  %and21 = and i32 %conv20, %neg
  %conv22 = trunc i32 %and21 to i8
  %5 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 1), align 4, !tbaa !52
  %tobool23 = icmp ne i32 %5, 0
  %6 = zext i1 %tobool23 to i64
  %cond24 = select i1 %tobool23, i32 32, i32 0
  %neg25 = xor i32 %cond24, -1
  %conv26 = zext i8 %conv22 to i32
  %and27 = and i32 %conv26, %neg25
  %conv28 = trunc i32 %and27 to i8
  %call29 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -19, i8 zeroext %conv28)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call30 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %conv31 = zext i8 %call30 to i32
  %or32 = or i32 %conv31, 1
  %conv33 = trunc i32 %or32 to i8
  %call34 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -29, i8 zeroext %conv33)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 20
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @msleep(i32 10)
  %call36 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %conv37 = zext i8 %call36 to i32
  %and38 = and i32 %conv37, 128
  %cmp39 = icmp eq i32 %and38, 128
  br i1 %cmp39, label %cleanup.cont, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.8, i32 0, i32 0))
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %for.body
  ret void
}

declare %struct.device* @devm_hwmon_device_register_with_groups(%struct.device*, i8*, i8*, %struct.attribute_group**) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @PTR_ERR_OR_ZERO(i8* %ptr) #3 {
entry:
  %call = call zeroext i1 @IS_ERR(i8* %ptr)
  br i1 %call, label %if.then, label %return

if.then:                                          ; preds = %entry
  %call1 = call i64 @PTR_ERR(i8* %ptr)
  %conv = trunc i64 %call1 to i32
  br label %return

return:                                           ; preds = %entry, %if.then
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define internal void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext %fbn, i8* %values) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %result.0 = phi i32 [ 0, %entry ], [ %call, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i8 %fbn to i64
  %arrayidx = getelementptr inbounds [12 x %struct.anon.41], [12 x %struct.anon.41]* @lm93_block_read_cmds, i64 0, i64 %idxprom
  %cmd = getelementptr inbounds %struct.anon.41, %struct.anon.41* %arrayidx, i32 0, i32 0
  %0 = load i8, i8* %cmd, align 2, !tbaa !48
  %call = call i32 @i2c_smbus_read_block_data(%struct.i2c_client* %client, i8 zeroext %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @lm93_block_buffer, i32 0, i32 0))
  %idxprom1 = zext i8 %fbn to i64
  %arrayidx2 = getelementptr inbounds [12 x %struct.anon.41], [12 x %struct.anon.41]* @lm93_block_read_cmds, i64 0, i64 %idxprom1
  %len = getelementptr inbounds %struct.anon.41, %struct.anon.41* %arrayidx2, i32 0, i32 1
  %1 = load i8, i8* %len, align 1, !tbaa !50
  %conv = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %call, %conv
  br i1 %cmp3, label %for.end, label %if.else

if.else:                                          ; preds = %for.body
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  %idxprom5 = zext i8 %fbn to i64
  %arrayidx6 = getelementptr inbounds [12 x %struct.anon.41], [12 x %struct.anon.41]* @lm93_block_read_cmds, i64 0, i64 %idxprom5
  %cmd7 = getelementptr inbounds %struct.anon.41, %struct.anon.41* %arrayidx6, i32 0, i32 0
  %2 = load i8, i8* %cmd7, align 2, !tbaa !48
  %conv8 = zext i8 %2 to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.2, i32 0, i32 0), i32 %conv8)
  %add = add nsw i32 %i.0, 3
  %conv9 = sext i32 %add to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %__ms.0 = phi i64 [ %conv9, %if.else ], [ %dec, %while.body ]
  %dec = add i64 %__ms.0, -1
  %tobool = icmp ne i64 %__ms.0, 0
  br i1 %tobool, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 4295000)
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %result.1 = phi i32 [ %call, %for.body ], [ %result.0, %for.cond ]
  %idxprom10 = zext i8 %fbn to i64
  %arrayidx11 = getelementptr inbounds [12 x %struct.anon.41], [12 x %struct.anon.41]* @lm93_block_read_cmds, i64 0, i64 %idxprom10
  %len12 = getelementptr inbounds %struct.anon.41, %struct.anon.41* %arrayidx11, i32 0, i32 1
  %3 = load i8, i8* %len12, align 1, !tbaa !50
  %conv13 = zext i8 %3 to i32
  %cmp14 = icmp eq i32 %result.1, %conv13
  br i1 %cmp14, label %if.then16, label %if.end22

if.then16:                                        ; preds = %for.end
  %idxprom17 = zext i8 %fbn to i64
  %arrayidx18 = getelementptr inbounds [12 x %struct.anon.41], [12 x %struct.anon.41]* @lm93_block_read_cmds, i64 0, i64 %idxprom17
  %len19 = getelementptr inbounds %struct.anon.41, %struct.anon.41* %arrayidx18, i32 0, i32 1
  %4 = load i8, i8* %len19, align 1, !tbaa !50
  %conv20 = zext i8 %4 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %values, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @lm93_block_buffer, i32 0, i32 0), i64 %conv20, i32 1, i1 false)
  br label %if.end22

if.end22:                                         ; preds = %for.end, %if.then16
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @lm93_update_client_common(%struct.lm93_data* %data, %struct.i2c_client* %client) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %mul = mul nsw i32 %i.0, 2
  %add = add nsw i32 120, %mul
  %conv = trunc i32 %add to i8
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 10
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim, i64 0, i64 %idxprom
  %min = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx, i32 0, i32 0
  store i8 %call, i8* %min, align 2, !tbaa !48
  %mul1 = mul nsw i32 %i.0, 2
  %add2 = add nsw i32 121, %mul1
  %conv3 = trunc i32 %add2 to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv3)
  %temp_lim5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 10
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim5, i64 0, i64 %idxprom6
  %max = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx7, i32 0, i32 1
  store i8 %call4, i8* %max, align 1, !tbaa !50
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call8 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %config = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 15
  store i8 %call8, i8* %config, align 4, !tbaa !53
  br label %for.cond9

for.cond9:                                        ; preds = %for.body12, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc19, %for.body12 ]
  %cmp10 = icmp slt i32 %i.1, 2
  br i1 %cmp10, label %for.body12, label %for.end20

for.body12:                                       ; preds = %for.cond9
  %add13 = add nsw i32 108, %i.1
  %conv14 = trunc i32 %add13 to i8
  %call15 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv14)
  %vid = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 16
  %idxprom16 = sext i32 %i.1 to i64
  %arrayidx17 = getelementptr inbounds [2 x i8], [2 x i8]* %vid, i64 0, i64 %idxprom16
  store i8 %call15, i8* %arrayidx17, align 1, !tbaa !47
  %inc19 = add nsw i32 %i.1, 1
  br label %for.cond9

for.end20:                                        ; preds = %for.cond9
  br label %for.cond21

for.cond21:                                       ; preds = %for.body24, %for.end20
  %i.2 = phi i32 [ 0, %for.end20 ], [ %inc31, %for.body24 ]
  %cmp22 = icmp slt i32 %i.2, 2
  br i1 %cmp22, label %for.body24, label %for.end32

for.body24:                                       ; preds = %for.cond21
  %add25 = add nsw i32 176, %i.2
  %conv26 = trunc i32 %add25 to i8
  %call27 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv26)
  %prochot_max = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 17
  %idxprom28 = sext i32 %i.2 to i64
  %arrayidx29 = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max, i64 0, i64 %idxprom28
  store i8 %call27, i8* %arrayidx29, align 1, !tbaa !47
  %inc31 = add nsw i32 %i.2, 1
  br label %for.cond21

for.end32:                                        ; preds = %for.cond21
  br label %for.cond33

for.cond33:                                       ; preds = %for.body36, %for.end32
  %i.3 = phi i32 [ 0, %for.end32 ], [ %inc43, %for.body36 ]
  %cmp34 = icmp slt i32 %i.3, 2
  br i1 %cmp34, label %for.body36, label %for.end44

for.body36:                                       ; preds = %for.cond33
  %add37 = add nsw i32 178, %i.3
  %conv38 = trunc i32 %add37 to i8
  %call39 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv38)
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 18
  %idxprom40 = sext i32 %i.3 to i64
  %arrayidx41 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom40
  store i8 %call39, i8* %arrayidx41, align 1, !tbaa !47
  %inc43 = add nsw i32 %i.3, 1
  br label %for.cond33

for.end44:                                        ; preds = %for.cond33
  %call45 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext 107)
  %gpi = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 19
  store i8 %call45, i8* %gpi, align 1, !tbaa !54
  %call46 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -58)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 20
  store i8 %call46, i8* %prochot_override, align 4, !tbaa !55
  %call47 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -57)
  %prochot_interval = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 21
  store i8 %call47, i8* %prochot_interval, align 1, !tbaa !56
  br label %for.cond48

for.cond48:                                       ; preds = %for.body51, %for.end44
  %i.4 = phi i32 [ 0, %for.end44 ], [ %inc58, %for.body51 ]
  %cmp49 = icmp slt i32 %i.4, 4
  br i1 %cmp49, label %for.body51, label %for.end59

for.body51:                                       ; preds = %for.cond48
  %add52 = add nsw i32 128, %i.4
  %conv53 = trunc i32 %add52 to i8
  %call54 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv53)
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 22
  %idxprom55 = sext i32 %i.4 to i64
  %arrayidx56 = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom55
  store i8 %call54, i8* %arrayidx56, align 1, !tbaa !47
  %inc58 = add nsw i32 %i.4, 1
  br label %for.cond48

for.end59:                                        ; preds = %for.cond48
  %call60 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -64)
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx61 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 0
  store i8 %call60, i8* %arrayidx61, align 2, !tbaa !47
  %call62 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -63)
  %boost_hyst63 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx64 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst63, i64 0, i64 1
  store i8 %call62, i8* %arrayidx64, align 1, !tbaa !47
  %call65 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -61)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 24
  %arrayidx66 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 0
  store i8 %call65, i8* %arrayidx66, align 4, !tbaa !47
  %call67 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -60)
  %auto_pwm_min_hyst68 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 24
  %arrayidx69 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst68, i64 0, i64 1
  store i8 %call67, i8* %arrayidx69, align 1, !tbaa !47
  %call70 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -65)
  %pwm_ramp_ctl = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 25
  store i8 %call70, i8* %pwm_ramp_ctl, align 2, !tbaa !57
  %call71 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -68)
  %sfc1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 26
  store i8 %call71, i8* %sfc1, align 1, !tbaa !58
  %call72 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  store i8 %call72, i8* %sfc2, align 8, !tbaa !59
  %call73 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -32)
  %sf_tach_to_pwm = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  store i8 %call73, i8* %sf_tach_to_pwm, align 1, !tbaa !60
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 5
  %0 = bitcast %struct.block1_t* %block1 to i8*
  br label %for.cond74

for.cond74:                                       ; preds = %for.body77, %for.end59
  %i.5 = phi i32 [ 0, %for.end59 ], [ %inc82, %for.body77 ]
  %cmp75 = icmp slt i32 %i.5, 8
  br i1 %cmp75, label %for.body77, label %for.end83

for.body77:                                       ; preds = %for.cond74
  %add78 = add nsw i32 72, %i.5
  %conv79 = trunc i32 %add78 to i8
  %idx.ext = sext i32 %i.5 to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  %1 = load i8, i8* %add.ptr, align 1, !tbaa !47
  %call80 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext %conv79, i8 zeroext %1)
  %inc82 = add nsw i32 %i.5, 1
  br label %for.cond74

for.end83:                                        ; preds = %for.cond74
  ret void
}

declare i32 @i2c_smbus_read_block_data(%struct.i2c_client*, i8 zeroext, i8*) #1

declare void @dev_warn(%struct.device*, i8*, ...) #1

declare void @__const_udelay(i64) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define internal zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %reg) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_smbus_read_byte_data(%struct.i2c_client* %client, i8 zeroext %reg)
  %cmp1 = icmp sge i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %conv = trunc i32 %call to i8
  br label %cleanup

if.else:                                          ; preds = %for.body
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  %conv2 = zext i8 %reg to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.3, i32 0, i32 0), i32 %conv2)
  %add = add nsw i32 %i.0, 3
  %conv3 = sext i32 %add to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %__ms.0 = phi i64 [ %conv3, %if.else ], [ %dec, %while.body ]
  %dec = add i64 %__ms.0, -1
  %tobool = icmp ne i64 %__ms.0, 0
  br i1 %tobool, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 4295000)
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev4 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev4, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.4, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i8 [ %conv, %if.then ], [ 0, %for.end ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext %reg, i8 zeroext %value) #0 {
entry:
  %call = call i32 @i2c_smbus_write_byte_data(%struct.i2c_client* %client, i8 zeroext %reg, i8 zeroext %value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  %conv = zext i8 %value to i32
  %conv1 = zext i8 %reg to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.5, i32 0, i32 0), i32 %conv, i32 %conv1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

declare i32 @i2c_smbus_read_byte_data(%struct.i2c_client*, i8 zeroext) #1

declare void @dev_err(%struct.device*, i8*, ...) #1

declare i32 @i2c_smbus_write_byte_data(%struct.i2c_client*, i8 zeroext, i8 zeroext) #1

; Function Attrs: nounwind uwtable
define internal zeroext i16 @lm93_read_word(%struct.i2c_client* %client, i8 zeroext %reg) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_smbus_read_word_data(%struct.i2c_client* %client, i8 zeroext %reg)
  %cmp1 = icmp sge i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %conv = trunc i32 %call to i16
  br label %cleanup

if.else:                                          ; preds = %for.body
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  %conv2 = zext i8 %reg to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.6, i32 0, i32 0), i32 %conv2)
  %add = add nsw i32 %i.0, 3
  %conv3 = sext i32 %add to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %__ms.0 = phi i64 [ %conv3, %if.else ], [ %dec, %while.body ]
  %dec = add i64 %__ms.0, -1
  %tobool = icmp ne i64 %__ms.0, 0
  br i1 %tobool, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 4295000)
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev4 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev4, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.7, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i16 [ %conv, %if.then ], [ 0, %for.end ]
  ret i16 %retval.0
}

declare i32 @i2c_smbus_read_word_data(%struct.i2c_client*, i8 zeroext) #1

declare noalias i8* @devm_kmalloc(%struct.device*, i64, i32) #1

declare void @msleep(i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @show_in(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 7
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %block3, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call1 = call i32 @LM93_IN_FROM_REG(i32 %2, i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal %struct.lm93_data* @lm93_update_device(%struct.device* %dev) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 0
  %1 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #5
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #5
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %6 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %7 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #5
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %8 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  %9 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  %last_updated = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 2
  %10 = load i64, i64* %last_updated, align 8, !tbaa !65
  %add = add i64 %10, 1500
  %11 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %sub = sub i64 %add, %11
  %cmp10 = icmp slt i64 %sub, 0
  br i1 %cmp10, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %valid = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 4
  %12 = load i8, i8* %valid, align 8, !tbaa !67
  %tobool12 = icmp ne i8 %12, 0
  br i1 %tobool12, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %update = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 3
  %13 = load void (%struct.lm93_data*, %struct.i2c_client*)*, void (%struct.lm93_data*, %struct.i2c_client*)** %update, align 8, !tbaa !38
  call void %13(%struct.lm93_data* %0, %struct.i2c_client* %1)
  %14 = load volatile i64, i64* @jiffies, align 8, !tbaa !66
  %last_updated13 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 2
  store i64 %14, i64* %last_updated13, align 8, !tbaa !65
  %valid14 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 4
  store i8 1, i8* %valid14, align 8, !tbaa !67
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %update_lock15 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock15)
  ret %struct.lm93_data* %0
}

declare i32 @sprintf(i8*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @LM93_IN_FROM_REG(i32 %nr, i8 zeroext %reg) #0 {
entry:
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_max, i64 0, i64 %idxprom
  %0 = load i64, i64* %arrayidx, align 8, !tbaa !66
  %mul = mul i64 %0, 1000
  %idxprom1 = sext i32 %nr to i64
  %arrayidx2 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_min, i64 0, i64 %idxprom1
  %1 = load i64, i64* %arrayidx2, align 8, !tbaa !66
  %mul3 = mul i64 %1, 1000
  %sub = sub nsw i64 %mul, %mul3
  %idxprom4 = sext i32 %nr to i64
  %arrayidx5 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_max, i64 0, i64 %idxprom4
  %2 = load i8, i8* %arrayidx5, align 1, !tbaa !47
  %conv = zext i8 %2 to i32
  %idxprom6 = sext i32 %nr to i64
  %arrayidx7 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom6
  %3 = load i8, i8* %arrayidx7, align 1, !tbaa !47
  %conv8 = zext i8 %3 to i32
  %sub9 = sub nsw i32 %conv, %conv8
  %conv10 = sext i32 %sub9 to i64
  %div = sdiv i64 %sub, %conv10
  %idxprom11 = sext i32 %nr to i64
  %arrayidx12 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom11
  %4 = load i8, i8* %arrayidx12, align 1, !tbaa !47
  %conv13 = zext i8 %4 to i64
  %mul14 = mul nsw i64 %div, %conv13
  %sub15 = sub nsw i64 %mul3, %mul14
  %conv16 = zext i8 %reg to i64
  %mul17 = mul nsw i64 %div, %conv16
  %add = add nsw i64 %mul17, %sub15
  %add18 = add nsw i64 %add, 500
  %div19 = sdiv i64 %add18, 1000
  %conv20 = trunc i64 %div19 to i32
  ret i32 %conv20
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_get_drvdata(%struct.device* %dev) #3 {
entry:
  %driver_data = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %0 = load i8*, i8** %driver_data, align 8, !tbaa !68
  ret i8* %0
}

declare void @mutex_lock(%struct.mutex*) #1

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: nounwind uwtable
define internal i64 @show_in_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sub = sub nsw i32 %2, 6
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !52
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %vid2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 16
  %idxprom3 = sext i32 %sub to i64
  %arrayidx4 = getelementptr inbounds [2 x i8], [2 x i8]* %vid2, i64 0, i64 %idxprom3
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !47
  %call5 = call i32 @LM93_VID_FROM_REG(i8 zeroext %4)
  %conv = sext i32 %call5 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 18
  %idxprom6 = sext i32 %sub to i64
  %arrayidx7 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom6
  %5 = load i8, i8* %arrayidx7, align 1, !tbaa !47
  %conv8 = trunc i64 %conv to i32
  %call9 = call i32 @LM93_IN_REL_FROM_REG(i8 zeroext %5, i32 0, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry, %land.lhs.true
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 11
  %idxprom11 = sext i32 %2 to i64
  %arrayidx12 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block7, i64 0, i64 %idxprom11
  %min = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx12, i32 0, i32 0
  %6 = load i8, i8* %min, align 2, !tbaa !48
  %call13 = call i32 @LM93_IN_FROM_REG(i32 %2, i8 zeroext %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call13.sink = phi i32 [ %call13, %if.else ], [ %call9, %if.then ]
  %conv14 = zext i32 %call13.sink to i64
  %call15 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27, i32 0, i32 0), i64 %conv14)
  %conv16 = sext i32 %call15 to i64
  ret i64 %conv16
}

; Function Attrs: nounwind uwtable
define internal i64 @store_in_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %sub = sub nsw i32 %2, 6
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4, !tbaa !52
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %land.lhs.true
  %vid8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 16
  %idxprom9 = sext i32 %sub to i64
  %arrayidx10 = getelementptr inbounds [2 x i8], [2 x i8]* %vid8, i64 0, i64 %idxprom9
  %7 = load i8, i8* %arrayidx10, align 1, !tbaa !47
  %call11 = call i32 @LM93_VID_FROM_REG(i8 zeroext %7)
  %conv12 = sext i32 %call11 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 18
  %idxprom13 = sext i32 %sub to i64
  %arrayidx14 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom13
  %8 = load i8, i8* %arrayidx14, align 1, !tbaa !47
  %conv15 = zext i8 %8 to i32
  %and = and i32 %conv15, 240
  %9 = load i64, i64* %val, align 8, !tbaa !66
  %conv16 = trunc i64 %9 to i32
  %conv17 = trunc i64 %conv12 to i32
  %call18 = call zeroext i8 @LM93_IN_REL_TO_REG(i32 %conv16, i32 0, i32 %conv17)
  %conv19 = zext i8 %call18 to i32
  %or = or i32 %and, %conv19
  %conv20 = trunc i32 %or to i8
  %vccp_limits21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 18
  %idxprom22 = sext i32 %sub to i64
  %arrayidx23 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits21, i64 0, i64 %idxprom22
  store i8 %conv20, i8* %arrayidx23, align 1, !tbaa !47
  %add = add nsw i32 178, %sub
  %conv24 = trunc i32 %add to i8
  %vccp_limits25 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 18
  %idxprom26 = sext i32 %sub to i64
  %arrayidx27 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits25, i64 0, i64 %idxprom26
  %10 = load i8, i8* %arrayidx27, align 1, !tbaa !47
  %call28 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv24, i8 zeroext %10)
  br label %if.end40

if.else:                                          ; preds = %if.end, %land.lhs.true
  %11 = load i64, i64* %val, align 8, !tbaa !66
  %conv29 = trunc i64 %11 to i32
  %call30 = call zeroext i8 @LM93_IN_TO_REG(i32 %2, i32 %conv29)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 11
  %idxprom31 = sext i32 %2 to i64
  %arrayidx32 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block7, i64 0, i64 %idxprom31
  %min = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx32, i32 0, i32 0
  store i8 %call30, i8* %min, align 2, !tbaa !48
  %mul = mul nsw i32 %2, 2
  %add33 = add nsw i32 144, %mul
  %conv34 = trunc i32 %add33 to i8
  %block735 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 11
  %idxprom36 = sext i32 %2 to i64
  %arrayidx37 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block735, i64 0, i64 %idxprom36
  %min38 = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx37, i32 0, i32 0
  %12 = load i8, i8* %min38, align 2, !tbaa !48
  %call39 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv34, i8 zeroext %12)
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then7
  %update_lock41 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock41)
  br label %cleanup

cleanup:                                          ; preds = %if.end40, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end40 ]
  %13 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_VID_FROM_REG(i8 zeroext %reg) #0 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 63
  %call = call i32 @vid_from_reg(i32 %and, i8 zeroext 100)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_IN_REL_FROM_REG(i8 zeroext %reg, i32 %upper, i32 %vid) #0 {
entry:
  %tobool = icmp ne i32 %upper, 0
  %conv = zext i8 %reg to i32
  %.sink1 = select i1 %tobool, i32 4, i32 0
  %.sink = select i1 %tobool, i32 12500, i32 -25000
  %shr2 = ashr i32 %conv, %.sink1
  %and3 = and i32 %shr2, 15
  %add4 = add nsw i32 %and3, 1
  %mul5 = mul nsw i32 %add4, %.sink
  %conv6 = sext i32 %mul5 to i64
  %mul7 = mul nsw i32 %vid, 1000
  %conv8 = sext i32 %mul7 to i64
  %add9 = add nsw i64 %conv8, %conv6
  %add10 = add nsw i64 %add9, 5000
  %div = sdiv i64 %add10, 10000
  %conv11 = trunc i64 %div to i32
  ret i32 %conv11
}

declare i32 @vid_from_reg(i32, i8 zeroext) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #3 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_IN_REL_TO_REG(i32 %val, i32 %upper, i32 %vid) #0 {
entry:
  %__UNIQUE_ID_min1_26 = alloca i64, align 8
  %__UNIQUE_ID_min1_24 = alloca i64, align 8
  %__UNIQUE_ID_min2_25 = alloca i64, align 8
  %__UNIQUE_ID_min2_27 = alloca i64, align 8
  %__UNIQUE_ID_min1_30 = alloca i64, align 8
  %__UNIQUE_ID_min1_28 = alloca i64, align 8
  %__UNIQUE_ID_min2_29 = alloca i64, align 8
  %__UNIQUE_ID_min2_31 = alloca i64, align 8
  %mul = mul nsw i32 %vid, 1000
  %mul1 = mul i32 %val, 10000
  %sub = sub i32 %mul, %mul1
  %conv = zext i32 %sub to i64
  %tobool = icmp ne i32 %upper, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = bitcast i64* %__UNIQUE_ID_min1_26 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  store i64 %conv, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !66
  %2 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  store i64 12500, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !66
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_24, %__UNIQUE_ID_min2_25
  %conv2 = zext i1 %cmp to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_24, align 8, !tbaa !66
  %4 = load i64, i64* %__UNIQUE_ID_min2_25, align 8, !tbaa !66
  %cmp3 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_24, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_25, align 8
  %cond = select i1 %cmp3, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_25 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__UNIQUE_ID_min1_24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_26, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_27 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 200000, i64* %__UNIQUE_ID_min2_27, align 8, !tbaa !66
  %cmp5 = icmp eq i64* %__UNIQUE_ID_min1_26, %__UNIQUE_ID_min2_27
  %conv6 = zext i1 %cmp5 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_26, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_27, align 8, !tbaa !66
  %cmp8 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_26, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_27, align 8
  %cond13 = select i1 %cmp8, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_27 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_26 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  %div = sdiv i64 %cond13, 12500
  br label %cleanup

if.else:                                          ; preds = %entry
  %16 = bitcast i64* %__UNIQUE_ID_min1_30 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #5
  %17 = bitcast i64* %__UNIQUE_ID_min1_28 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %17) #5
  store i64 %conv, i64* %__UNIQUE_ID_min1_28, align 8, !tbaa !66
  %18 = bitcast i64* %__UNIQUE_ID_min2_29 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %18) #5
  store i64 -400000, i64* %__UNIQUE_ID_min2_29, align 8, !tbaa !66
  %cmp16 = icmp eq i64* %__UNIQUE_ID_min1_28, %__UNIQUE_ID_min2_29
  %conv17 = zext i1 %cmp16 to i32
  %19 = load i64, i64* %__UNIQUE_ID_min1_28, align 8, !tbaa !66
  %20 = load i64, i64* %__UNIQUE_ID_min2_29, align 8, !tbaa !66
  %cmp19 = icmp sgt i64 %19, %20
  %21 = load i64, i64* %__UNIQUE_ID_min1_28, align 8
  %22 = load i64, i64* %__UNIQUE_ID_min2_29, align 8
  %cond24 = select i1 %cmp19, i64 %21, i64 %22
  %23 = bitcast i64* %__UNIQUE_ID_min2_29 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #5
  %24 = bitcast i64* %__UNIQUE_ID_min1_28 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #5
  store i64 %cond24, i64* %__UNIQUE_ID_min1_30, align 8, !tbaa !66
  %25 = bitcast i64* %__UNIQUE_ID_min2_31 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %25) #5
  store i64 -25000, i64* %__UNIQUE_ID_min2_31, align 8, !tbaa !66
  %cmp25 = icmp eq i64* %__UNIQUE_ID_min1_30, %__UNIQUE_ID_min2_31
  %conv26 = zext i1 %cmp25 to i32
  %26 = load i64, i64* %__UNIQUE_ID_min1_30, align 8, !tbaa !66
  %27 = load i64, i64* %__UNIQUE_ID_min2_31, align 8, !tbaa !66
  %cmp28 = icmp slt i64 %26, %27
  %28 = load i64, i64* %__UNIQUE_ID_min1_30, align 8
  %29 = load i64, i64* %__UNIQUE_ID_min2_31, align 8
  %cond33 = select i1 %cmp28, i64 %28, i64 %29
  %30 = bitcast i64* %__UNIQUE_ID_min2_31 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %30) #5
  %31 = bitcast i64* %__UNIQUE_ID_min1_30 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #5
  %div34 = sdiv i64 %cond33, -25000
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then
  %div34.sink = phi i64 [ %div34, %if.else ], [ %div, %if.then ]
  %.sink = phi i64 [ 0, %if.else ], [ 4, %if.then ]
  %sub35 = sub nsw i64 %div34.sink, 1
  %shl36 = shl i64 %sub35, %.sink
  %conv37 = trunc i64 %shl36 to i8
  ret i8 %conv37
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_IN_TO_REG(i32 %nr, i32 %val) #0 {
entry:
  %__UNIQUE_ID_min1_18 = alloca i32, align 4
  %__UNIQUE_ID_min1_16 = alloca i32, align 4
  %__UNIQUE_ID_min2_17 = alloca i32, align 4
  %__UNIQUE_ID_min2_19 = alloca i32, align 4
  %__UNIQUE_ID_min1_22 = alloca i8, align 1
  %__UNIQUE_ID_min1_20 = alloca i8, align 1
  %__UNIQUE_ID_min2_21 = alloca i8, align 1
  %__UNIQUE_ID_min2_23 = alloca i8, align 1
  %0 = bitcast i32* %__UNIQUE_ID_min1_18 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
  %1 = bitcast i32* %__UNIQUE_ID_min1_16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #5
  store i32 %val, i32* %__UNIQUE_ID_min1_16, align 4, !tbaa !52
  %2 = bitcast i32* %__UNIQUE_ID_min2_17 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #5
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_min, i64 0, i64 %idxprom
  %3 = load i64, i64* %arrayidx, align 8, !tbaa !66
  %conv = trunc i64 %3 to i32
  store i32 %conv, i32* %__UNIQUE_ID_min2_17, align 4, !tbaa !52
  %cmp = icmp eq i32* %__UNIQUE_ID_min1_16, %__UNIQUE_ID_min2_17
  %conv1 = zext i1 %cmp to i32
  %4 = load i32, i32* %__UNIQUE_ID_min1_16, align 4, !tbaa !52
  %5 = load i32, i32* %__UNIQUE_ID_min2_17, align 4, !tbaa !52
  %cmp2 = icmp ugt i32 %4, %5
  %6 = load i32, i32* %__UNIQUE_ID_min1_16, align 4
  %7 = load i32, i32* %__UNIQUE_ID_min2_17, align 4
  %cond = select i1 %cmp2, i32 %6, i32 %7
  %8 = bitcast i32* %__UNIQUE_ID_min2_17 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #5
  %9 = bitcast i32* %__UNIQUE_ID_min1_16 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #5
  store i32 %cond, i32* %__UNIQUE_ID_min1_18, align 4, !tbaa !52
  %10 = bitcast i32* %__UNIQUE_ID_min2_19 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %10) #5
  %idxprom4 = sext i32 %nr to i64
  %arrayidx5 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_max, i64 0, i64 %idxprom4
  %11 = load i64, i64* %arrayidx5, align 8, !tbaa !66
  %conv6 = trunc i64 %11 to i32
  store i32 %conv6, i32* %__UNIQUE_ID_min2_19, align 4, !tbaa !52
  %cmp7 = icmp eq i32* %__UNIQUE_ID_min1_18, %__UNIQUE_ID_min2_19
  %conv8 = zext i1 %cmp7 to i32
  %12 = load i32, i32* %__UNIQUE_ID_min1_18, align 4, !tbaa !52
  %13 = load i32, i32* %__UNIQUE_ID_min2_19, align 4, !tbaa !52
  %cmp10 = icmp ult i32 %12, %13
  %14 = load i32, i32* %__UNIQUE_ID_min1_18, align 4
  %15 = load i32, i32* %__UNIQUE_ID_min2_19, align 4
  %cond15 = select i1 %cmp10, i32 %14, i32 %15
  %16 = bitcast i32* %__UNIQUE_ID_min2_19 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #5
  %17 = bitcast i32* %__UNIQUE_ID_min1_18 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %17) #5
  %conv16 = zext i32 %cond15 to i64
  %mul = mul nsw i64 %conv16, 1000
  %idxprom17 = sext i32 %nr to i64
  %arrayidx18 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_max, i64 0, i64 %idxprom17
  %18 = load i64, i64* %arrayidx18, align 8, !tbaa !66
  %mul19 = mul i64 %18, 1000
  %idxprom20 = sext i32 %nr to i64
  %arrayidx21 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_min, i64 0, i64 %idxprom20
  %19 = load i64, i64* %arrayidx21, align 8, !tbaa !66
  %mul22 = mul i64 %19, 1000
  %sub = sub nsw i64 %mul19, %mul22
  %idxprom23 = sext i32 %nr to i64
  %arrayidx24 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_max, i64 0, i64 %idxprom23
  %20 = load i8, i8* %arrayidx24, align 1, !tbaa !47
  %conv25 = zext i8 %20 to i32
  %idxprom26 = sext i32 %nr to i64
  %arrayidx27 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom26
  %21 = load i8, i8* %arrayidx27, align 1, !tbaa !47
  %conv28 = zext i8 %21 to i32
  %sub29 = sub nsw i32 %conv25, %conv28
  %conv30 = sext i32 %sub29 to i64
  %div = sdiv i64 %sub, %conv30
  %idxprom31 = sext i32 %nr to i64
  %arrayidx32 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom31
  %22 = load i8, i8* %arrayidx32, align 1, !tbaa !47
  %conv33 = zext i8 %22 to i64
  %mul34 = mul nsw i64 %div, %conv33
  %sub35 = sub nsw i64 %mul22, %mul34
  %sub36 = sub nsw i64 %mul, %sub35
  %div37 = sdiv i64 %div, 2
  %add = add nsw i64 %sub36, %div37
  %div38 = sdiv i64 %add, %div
  %conv39 = trunc i64 %div38 to i8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %__UNIQUE_ID_min1_22) #5
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %__UNIQUE_ID_min1_20) #5
  store i8 %conv39, i8* %__UNIQUE_ID_min1_20, align 1, !tbaa !47
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %__UNIQUE_ID_min2_21) #5
  %idxprom40 = sext i32 %nr to i64
  %arrayidx41 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom40
  %23 = load i8, i8* %arrayidx41, align 1, !tbaa !47
  store i8 %23, i8* %__UNIQUE_ID_min2_21, align 1, !tbaa !47
  %cmp42 = icmp eq i8* %__UNIQUE_ID_min1_20, %__UNIQUE_ID_min2_21
  %conv43 = zext i1 %cmp42 to i32
  %24 = load i8, i8* %__UNIQUE_ID_min1_20, align 1, !tbaa !47
  %conv45 = zext i8 %24 to i32
  %25 = load i8, i8* %__UNIQUE_ID_min2_21, align 1, !tbaa !47
  %conv46 = zext i8 %25 to i32
  %cmp47 = icmp sgt i32 %conv45, %conv46
  %26 = load i8, i8* %__UNIQUE_ID_min2_21, align 1
  %27 = load i8, i8* %__UNIQUE_ID_min1_20, align 1
  %.sink = select i1 %cmp47, i8 %27, i8 %26
  %conv52 = zext i8 %.sink to i32
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %__UNIQUE_ID_min2_21) #5
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %__UNIQUE_ID_min1_20) #5
  %conv55 = trunc i32 %conv52 to i8
  store i8 %conv55, i8* %__UNIQUE_ID_min1_22, align 1, !tbaa !47
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %__UNIQUE_ID_min2_23) #5
  %idxprom56 = sext i32 %nr to i64
  %arrayidx57 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_max, i64 0, i64 %idxprom56
  %28 = load i8, i8* %arrayidx57, align 1, !tbaa !47
  store i8 %28, i8* %__UNIQUE_ID_min2_23, align 1, !tbaa !47
  %cmp58 = icmp eq i8* %__UNIQUE_ID_min1_22, %__UNIQUE_ID_min2_23
  %conv59 = zext i1 %cmp58 to i32
  %29 = load i8, i8* %__UNIQUE_ID_min1_22, align 1, !tbaa !47
  %conv61 = zext i8 %29 to i32
  %30 = load i8, i8* %__UNIQUE_ID_min2_23, align 1, !tbaa !47
  %conv62 = zext i8 %30 to i32
  %cmp63 = icmp slt i32 %conv61, %conv62
  %31 = load i8, i8* %__UNIQUE_ID_min2_23, align 1
  %32 = load i8, i8* %__UNIQUE_ID_min1_22, align 1
  %.sink1 = select i1 %cmp63, i8 %32, i8 %31
  %conv68 = zext i8 %.sink1 to i32
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %__UNIQUE_ID_min2_23) #5
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %__UNIQUE_ID_min1_22) #5
  %conv71 = trunc i32 %conv68 to i8
  ret i8 %conv71
}

declare i32 @kstrtoull(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @show_in_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sub = sub nsw i32 %2, 6
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !52
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %vid2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 16
  %idxprom3 = sext i32 %sub to i64
  %arrayidx4 = getelementptr inbounds [2 x i8], [2 x i8]* %vid2, i64 0, i64 %idxprom3
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !47
  %call5 = call i32 @LM93_VID_FROM_REG(i8 zeroext %4)
  %conv = sext i32 %call5 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 18
  %idxprom6 = sext i32 %sub to i64
  %arrayidx7 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom6
  %5 = load i8, i8* %arrayidx7, align 1, !tbaa !47
  %conv8 = trunc i64 %conv to i32
  %call9 = call i32 @LM93_IN_REL_FROM_REG(i8 zeroext %5, i32 1, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry, %land.lhs.true
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 11
  %idxprom11 = sext i32 %2 to i64
  %arrayidx12 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block7, i64 0, i64 %idxprom11
  %max = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx12, i32 0, i32 1
  %6 = load i8, i8* %max, align 1, !tbaa !50
  %call13 = call i32 @LM93_IN_FROM_REG(i32 %2, i8 zeroext %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call13.sink = phi i32 [ %call13, %if.else ], [ %call9, %if.then ]
  %conv14 = zext i32 %call13.sink to i64
  %call15 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27, i32 0, i32 0), i64 %conv14)
  %conv16 = sext i32 %call15 to i64
  ret i64 %conv16
}

; Function Attrs: nounwind uwtable
define internal i64 @store_in_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %sub = sub nsw i32 %2, 6
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4, !tbaa !52
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %land.lhs.true
  %vid8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 16
  %idxprom9 = sext i32 %sub to i64
  %arrayidx10 = getelementptr inbounds [2 x i8], [2 x i8]* %vid8, i64 0, i64 %idxprom9
  %7 = load i8, i8* %arrayidx10, align 1, !tbaa !47
  %call11 = call i32 @LM93_VID_FROM_REG(i8 zeroext %7)
  %conv12 = sext i32 %call11 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 18
  %idxprom13 = sext i32 %sub to i64
  %arrayidx14 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom13
  %8 = load i8, i8* %arrayidx14, align 1, !tbaa !47
  %conv15 = zext i8 %8 to i32
  %and = and i32 %conv15, 15
  %9 = load i64, i64* %val, align 8, !tbaa !66
  %conv16 = trunc i64 %9 to i32
  %conv17 = trunc i64 %conv12 to i32
  %call18 = call zeroext i8 @LM93_IN_REL_TO_REG(i32 %conv16, i32 1, i32 %conv17)
  %conv19 = zext i8 %call18 to i32
  %or = or i32 %and, %conv19
  %conv20 = trunc i32 %or to i8
  %vccp_limits21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 18
  %idxprom22 = sext i32 %sub to i64
  %arrayidx23 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits21, i64 0, i64 %idxprom22
  store i8 %conv20, i8* %arrayidx23, align 1, !tbaa !47
  %add = add nsw i32 178, %sub
  %conv24 = trunc i32 %add to i8
  %vccp_limits25 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 18
  %idxprom26 = sext i32 %sub to i64
  %arrayidx27 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits25, i64 0, i64 %idxprom26
  %10 = load i8, i8* %arrayidx27, align 1, !tbaa !47
  %call28 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv24, i8 zeroext %10)
  br label %if.end40

if.else:                                          ; preds = %if.end, %land.lhs.true
  %11 = load i64, i64* %val, align 8, !tbaa !66
  %conv29 = trunc i64 %11 to i32
  %call30 = call zeroext i8 @LM93_IN_TO_REG(i32 %2, i32 %conv29)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 11
  %idxprom31 = sext i32 %2 to i64
  %arrayidx32 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block7, i64 0, i64 %idxprom31
  %max = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx32, i32 0, i32 1
  store i8 %call30, i8* %max, align 1, !tbaa !50
  %mul = mul nsw i32 %2, 2
  %add33 = add nsw i32 145, %mul
  %conv34 = trunc i32 %add33 to i8
  %block735 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 11
  %idxprom36 = sext i32 %2 to i64
  %arrayidx37 = getelementptr inbounds [16 x %struct.anon.39], [16 x %struct.anon.39]* %block735, i64 0, i64 %idxprom36
  %max38 = getelementptr inbounds %struct.anon.39, %struct.anon.39* %arrayidx37, i32 0, i32 1
  %12 = load i8, i8* %max38, align 1, !tbaa !50
  %call39 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv34, i8 zeroext %12)
  br label %if.end40

if.end40:                                         ; preds = %if.else, %if.then7
  %update_lock41 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock41)
  br label %cleanup

cleanup:                                          ; preds = %if.end40, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end40 ]
  %13 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 6
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %block2, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_FROM_REG(i8 zeroext %reg) #0 {
entry:
  %conv = sext i8 %reg to i32
  %mul = mul nsw i32 %conv, 1000
  ret i32 %mul
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim, i64 0, i64 %idxprom
  %min = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %min, align 2, !tbaa !48
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %call3 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %6)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim, i64 0, i64 %idxprom
  %min = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx, i32 0, i32 0
  store i8 %call3, i8* %min, align 2, !tbaa !48
  %mul = mul nsw i32 %2, 2
  %add = add nsw i32 120, %mul
  %conv4 = trunc i32 %add to i8
  %temp_lim5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 10
  %idxprom6 = sext i32 %2 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim5, i64 0, i64 %idxprom6
  %min8 = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx7, i32 0, i32 0
  %7 = load i8, i8* %min8, align 2, !tbaa !48
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv4, i8 zeroext %7)
  %update_lock10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtol(i8* %s, i32 %base, i64* %res) #3 {
entry:
  %call = call i32 @kstrtoll(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_TEMP_TO_REG(i64 %temp) #0 {
entry:
  %__UNIQUE_ID_min1_34 = alloca i64, align 8
  %__UNIQUE_ID_min1_32 = alloca i64, align 8
  %__UNIQUE_ID_min2_33 = alloca i64, align 8
  %__UNIQUE_ID_min2_35 = alloca i64, align 8
  %0 = bitcast i64* %__UNIQUE_ID_min1_34 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = bitcast i64* %__UNIQUE_ID_min1_32 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  store i64 %temp, i64* %__UNIQUE_ID_min1_32, align 8, !tbaa !66
  %2 = bitcast i64* %__UNIQUE_ID_min2_33 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  store i64 -128000, i64* %__UNIQUE_ID_min2_33, align 8, !tbaa !66
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_32, %__UNIQUE_ID_min2_33
  %conv = zext i1 %cmp to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_32, align 8, !tbaa !66
  %4 = load i64, i64* %__UNIQUE_ID_min2_33, align 8, !tbaa !66
  %cmp1 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_32, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_33, align 8
  %cond = select i1 %cmp1, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_33 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__UNIQUE_ID_min1_32 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_34, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_35 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 127000, i64* %__UNIQUE_ID_min2_35, align 8, !tbaa !66
  %cmp3 = icmp eq i64* %__UNIQUE_ID_min1_34, %__UNIQUE_ID_min2_35
  %conv4 = zext i1 %cmp3 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_34, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_35, align 8, !tbaa !66
  %cmp6 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_34, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_35, align 8
  %cond11 = select i1 %cmp6, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_35 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_34 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  %conv12 = trunc i64 %cond11 to i32
  %cmp13 = icmp slt i32 %conv12, 0
  %16 = zext i1 %cmp13 to i64
  %cond15 = select i1 %cmp13, i32 -500, i32 500
  %add = add nsw i32 %conv12, %cond15
  %div = sdiv i32 %add, 1000
  %conv16 = trunc i32 %div to i8
  ret i8 %conv16
}

declare i32 @kstrtoll(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim, i64 0, i64 %idxprom
  %max = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx, i32 0, i32 1
  %3 = load i8, i8* %max, align 1, !tbaa !50
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %call3 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %6)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim, i64 0, i64 %idxprom
  %max = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx, i32 0, i32 1
  store i8 %call3, i8* %max, align 1, !tbaa !50
  %mul = mul nsw i32 %2, 2
  %add = add nsw i32 121, %mul
  %conv4 = trunc i32 %add to i8
  %temp_lim5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 10
  %idxprom6 = sext i32 %2 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.anon.38], [4 x %struct.anon.38]* %temp_lim5, i64 0, i64 %idxprom6
  %max8 = getelementptr inbounds %struct.anon.38, %struct.anon.38* %arrayidx7, i32 0, i32 1
  %7 = load i8, i8* %max8, align 1, !tbaa !50
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv4, i8 zeroext %7)
  %update_lock10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_base(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 14
  %base = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block10, i32 0, i32 0
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %base, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_base(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %call3 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %6)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 14
  %base = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block10, i32 0, i32 0
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %base, i64 0, i64 %idxprom
  store i8 %call3, i8* %arrayidx, align 1, !tbaa !47
  %add = add nsw i32 208, %2
  %conv4 = trunc i32 %add to i8
  %block105 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 14
  %base6 = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block105, i32 0, i32 0
  %idxprom7 = sext i32 %2 to i64
  %arrayidx8 = getelementptr inbounds [4 x i8], [4 x i8]* %base6, i64 0, i64 %idxprom7
  %7 = load i8, i8* %arrayidx8, align 1, !tbaa !47
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv4, i8 zeroext %7)
  %update_lock10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_boost(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 22
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_boost(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %call3 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %6)
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 22
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  store i8 %call3, i8* %arrayidx, align 1, !tbaa !47
  %add = add nsw i32 128, %2
  %conv4 = trunc i32 %add to i8
  %boost5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 22
  %idxprom6 = sext i32 %2 to i64
  %arrayidx7 = getelementptr inbounds [4 x i8], [4 x i8]* %boost5, i64 0, i64 %idxprom6
  %7 = load i8, i8* %arrayidx7, align 1, !tbaa !47
  %call8 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv4, i8 zeroext %7)
  %update_lock9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock9)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_boost_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %3 = load i8, i8* %sfc2, align 8, !tbaa !59
  %call1 = call i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %3, i32 %2)
  %call2 = call i32 @LM93_AUTO_BOOST_HYST_FROM_REGS(%struct.lm93_data* %call, i32 %2, i32 %call1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_boost_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call3 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 27
  store i8 %call3, i8* %sfc2, align 8, !tbaa !59
  %cmp = icmp slt i32 %2, 2
  %6 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %sfc25 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 27
  %7 = load i8, i8* %sfc25, align 8, !tbaa !59
  %conv6 = zext i8 %7 to i32
  %or = or i32 %conv6, %cond
  %conv7 = trunc i32 %or to i8
  store i8 %conv7, i8* %sfc25, align 8, !tbaa !59
  %sfc28 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 27
  %8 = load i8, i8* %sfc28, align 8, !tbaa !59
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -67, i8 zeroext %8)
  %9 = load i64, i64* %val, align 8, !tbaa !66
  %call10 = call zeroext i8 @LM93_AUTO_BOOST_HYST_TO_REG(%struct.lm93_data* %3, i64 %9, i32 %2, i32 1)
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 23
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 %idxprom
  store i8 %call10, i8* %arrayidx, align 1, !tbaa !47
  %div11 = sdiv i32 %2, 2
  %add = add nsw i32 192, %div11
  %conv12 = trunc i32 %add to i8
  %boost_hyst13 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 23
  %div14 = sdiv i32 %2, 2
  %idxprom15 = sext i32 %div14 to i64
  %arrayidx16 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst13, i64 0, i64 %idxprom15
  %10 = load i8, i8* %arrayidx16, align 1, !tbaa !47
  %call17 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv12, i8 zeroext %10)
  %update_lock18 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock18)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %11 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %sfc2, i32 %nr) #0 {
entry:
  %conv = zext i8 %sfc2 to i32
  %cmp = icmp slt i32 %nr, 2
  %0 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %and = and i32 %conv, %cond
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_AUTO_BOOST_HYST_FROM_REGS(%struct.lm93_data* %data, i32 %nr, i32 %mode) #0 {
entry:
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nr, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %nr, 2
  br i1 %Pivot, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %nr, 2
  br i1 %SwitchLeaf2, label %sw.bb8, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %nr, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 0
  %0 = load i8, i8* %arrayidx, align 2, !tbaa !47
  %conv = zext i8 %0 to i32
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock
  %boost_hyst3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx4 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst3, i64 0, i64 0
  %1 = load i8, i8* %arrayidx4, align 2, !tbaa !47
  %conv5 = zext i8 %1 to i32
  %shr = ashr i32 %conv5, 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %LeafBlock1
  %boost_hyst9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx10 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst9, i64 0, i64 1
  %2 = load i8, i8* %arrayidx10, align 1, !tbaa !47
  %conv11 = zext i8 %2 to i32
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %boost_hyst15 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx16 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst15, i64 0, i64 1
  %3 = load i8, i8* %arrayidx16, align 1, !tbaa !47
  %conv17 = zext i8 %3 to i32
  %shr18 = ashr i32 %conv17, 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb2, %sw.bb
  %shr18.sink = phi i32 [ %shr18, %sw.default ], [ %conv11, %sw.bb8 ], [ %shr, %sw.bb2 ], [ %conv, %sw.bb ]
  %and19 = and i32 %shr18.sink, 15
  %conv20 = trunc i32 %and19 to i8
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 22
  %idxprom = sext i32 %nr to i64
  %arrayidx21 = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx21, align 1, !tbaa !47
  %call = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %4)
  %call22 = call i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %conv20, i32 %mode)
  %sub = sub nsw i32 %call, %call22
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %reg, i32 %mode) #0 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %tobool = icmp ne i32 %mode, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 5, i32 10
  %mul = mul nsw i32 %and, %cond
  ret i32 %mul
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_AUTO_BOOST_HYST_TO_REG(%struct.lm93_data* %data, i64 %hyst, i32 %nr, i32 %mode) #0 {
entry:
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 22
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %0)
  %conv = sext i32 %call to i64
  %sub = sub nsw i64 %conv, %hyst
  %conv1 = trunc i64 %sub to i32
  %call2 = call zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %conv1, i32 %mode)
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nr, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %nr, 2
  br i1 %Pivot, label %sw.bb8, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %nr, 2
  br i1 %SwitchLeaf2, label %sw.bb17, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %nr, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx3 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 0
  %1 = load i8, i8* %arrayidx3, align 2, !tbaa !47
  %conv4 = zext i8 %1 to i32
  %and = and i32 %conv4, 240
  br label %sw.epilog

sw.bb8:                                           ; preds = %NodeBlock
  %conv9 = zext i8 %call2 to i32
  %shl = shl i32 %conv9, 4
  %and10 = and i32 %shl, 240
  %boost_hyst11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx12 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst11, i64 0, i64 0
  %2 = load i8, i8* %arrayidx12, align 2, !tbaa !47
  br label %sw.epilog

sw.bb17:                                          ; preds = %LeafBlock1
  %boost_hyst18 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx19 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst18, i64 0, i64 1
  %3 = load i8, i8* %arrayidx19, align 1, !tbaa !47
  %conv20 = zext i8 %3 to i32
  %and21 = and i32 %conv20, 240
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %conv27 = zext i8 %call2 to i32
  %shl28 = shl i32 %conv27, 4
  %and29 = and i32 %shl28, 240
  %boost_hyst30 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx31 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst30, i64 0, i64 1
  %4 = load i8, i8* %arrayidx31, align 1, !tbaa !47
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb17, %sw.bb8, %sw.bb
  %.sink = phi i8 [ %4, %sw.default ], [ %call2, %sw.bb17 ], [ %2, %sw.bb8 ], [ %call2, %sw.bb ]
  %and29.sink = phi i32 [ %and29, %sw.default ], [ %and21, %sw.bb17 ], [ %and10, %sw.bb8 ], [ %and, %sw.bb ]
  %conv32 = zext i8 %.sink to i32
  %and33 = and i32 %conv32, 15
  %or34 = or i32 %and29.sink, %and33
  %conv35 = trunc i32 %or34 to i8
  ret i8 %conv35
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %off, i32 %mode) #0 {
entry:
  %__UNIQUE_ID_min1_38 = alloca i32, align 4
  %__UNIQUE_ID_min1_36 = alloca i32, align 4
  %__UNIQUE_ID_min2_37 = alloca i32, align 4
  %__UNIQUE_ID_min2_39 = alloca i32, align 4
  %tobool = icmp ne i32 %mode, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 5, i32 10
  %1 = bitcast i32* %__UNIQUE_ID_min1_38 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #5
  %2 = bitcast i32* %__UNIQUE_ID_min1_36 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #5
  store i32 %off, i32* %__UNIQUE_ID_min1_36, align 4, !tbaa !52
  %3 = bitcast i32* %__UNIQUE_ID_min2_37 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #5
  store i32 0, i32* %__UNIQUE_ID_min2_37, align 4, !tbaa !52
  %cmp = icmp eq i32* %__UNIQUE_ID_min1_36, %__UNIQUE_ID_min2_37
  %conv = zext i1 %cmp to i32
  %4 = load i32, i32* %__UNIQUE_ID_min1_36, align 4, !tbaa !52
  %5 = load i32, i32* %__UNIQUE_ID_min2_37, align 4, !tbaa !52
  %cmp1 = icmp sgt i32 %4, %5
  %6 = load i32, i32* %__UNIQUE_ID_min1_36, align 4
  %7 = load i32, i32* %__UNIQUE_ID_min2_37, align 4
  %cond3 = select i1 %cmp1, i32 %6, i32 %7
  %8 = bitcast i32* %__UNIQUE_ID_min2_37 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #5
  %9 = bitcast i32* %__UNIQUE_ID_min1_36 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #5
  store i32 %cond3, i32* %__UNIQUE_ID_min1_38, align 4, !tbaa !52
  %10 = bitcast i32* %__UNIQUE_ID_min2_39 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %10) #5
  %tobool4 = icmp ne i32 %mode, 0
  %11 = zext i1 %tobool4 to i64
  %cond5 = select i1 %tobool4, i32 75, i32 150
  store i32 %cond5, i32* %__UNIQUE_ID_min2_39, align 4, !tbaa !52
  %cmp6 = icmp eq i32* %__UNIQUE_ID_min1_38, %__UNIQUE_ID_min2_39
  %conv7 = zext i1 %cmp6 to i32
  %12 = load i32, i32* %__UNIQUE_ID_min1_38, align 4, !tbaa !52
  %13 = load i32, i32* %__UNIQUE_ID_min2_39, align 4, !tbaa !52
  %cmp9 = icmp slt i32 %12, %13
  %14 = load i32, i32* %__UNIQUE_ID_min1_38, align 4
  %15 = load i32, i32* %__UNIQUE_ID_min2_39, align 4
  %cond14 = select i1 %cmp9, i32 %14, i32 %15
  %16 = bitcast i32* %__UNIQUE_ID_min2_39 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %16) #5
  %17 = bitcast i32* %__UNIQUE_ID_min1_38 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %17) #5
  %div = sdiv i32 %cond, 2
  %add = add nsw i32 %cond14, %div
  %div15 = sdiv i32 %add, %cond
  %conv16 = trunc i32 %div15 to i8
  ret i8 %conv16
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_offset(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %2 = load i8, i8* %index, align 8, !tbaa !69
  %conv = zext i8 %2 to i32
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !71
  %conv2 = zext i8 %3 to i32
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %4 = load i8, i8* %sfc2, align 8, !tbaa !59
  %call3 = call i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %4, i32 %conv)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 14
  %offset = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block10, i32 0, i32 1
  %idxprom = sext i32 %conv2 to i64
  %arrayidx = getelementptr inbounds [12 x i8], [12 x i8]* %offset, i64 0, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call4 = call i32 @LM93_TEMP_AUTO_OFFSET_FROM_REG(i8 zeroext %5, i32 %conv, i32 %call3)
  %call5 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call4)
  %conv6 = sext i32 %call5 to i64
  ret i64 %conv6
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_offset(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %2 = load i8, i8* %index, align 8, !tbaa !69
  %conv = zext i8 %2 to i32
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !71
  %conv2 = zext i8 %3 to i32
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %4 = bitcast i8* %call to %struct.lm93_data*
  %client3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 0
  %5 = load %struct.i2c_client*, %struct.i2c_client** %client3, align 8, !tbaa !34
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv5 = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %5, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 27
  store i8 %call6, i8* %sfc2, align 8, !tbaa !59
  %cmp = icmp slt i32 %conv, 2
  %7 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %sfc28 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 27
  %8 = load i8, i8* %sfc28, align 8, !tbaa !59
  %conv9 = zext i8 %8 to i32
  %or = or i32 %conv9, %cond
  %conv10 = trunc i32 %or to i8
  store i8 %conv10, i8* %sfc28, align 8, !tbaa !59
  %sfc211 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 27
  %9 = load i8, i8* %sfc211, align 8, !tbaa !59
  %call12 = call i32 @lm93_write_byte(%struct.i2c_client* %5, i8 zeroext -67, i8 zeroext %9)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 14
  %offset = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block10, i32 0, i32 1
  %idxprom = sext i32 %conv2 to i64
  %arrayidx = getelementptr inbounds [12 x i8], [12 x i8]* %offset, i64 0, i64 %idxprom
  %10 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %11 = load i64, i64* %val, align 8, !tbaa !66
  %conv13 = trunc i64 %11 to i32
  %call14 = call zeroext i8 @LM93_TEMP_AUTO_OFFSET_TO_REG(i8 zeroext %10, i32 %conv13, i32 %conv, i32 1)
  %block1015 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 14
  %offset16 = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block1015, i32 0, i32 1
  %idxprom17 = sext i32 %conv2 to i64
  %arrayidx18 = getelementptr inbounds [12 x i8], [12 x i8]* %offset16, i64 0, i64 %idxprom17
  store i8 %call14, i8* %arrayidx18, align 1, !tbaa !47
  %add = add nsw i32 212, %conv2
  %conv19 = trunc i32 %add to i8
  %block1020 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 14
  %offset21 = getelementptr inbounds %struct.anon.40, %struct.anon.40* %block1020, i32 0, i32 1
  %idxprom22 = sext i32 %conv2 to i64
  %arrayidx23 = getelementptr inbounds [12 x i8], [12 x i8]* %offset21, i64 0, i64 %idxprom22
  %12 = load i8, i8* %arrayidx23, align 1, !tbaa !47
  %call24 = call i32 @lm93_write_byte(%struct.i2c_client* %5, i8 zeroext %conv19, i8 zeroext %12)
  %update_lock25 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %4, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock25)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv5, %if.then ], [ %count, %if.end ]
  %13 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_AUTO_OFFSET_FROM_REG(i8 zeroext %reg, i32 %nr, i32 %mode) #0 {
entry:
  %cmp = icmp slt i32 %nr, 2
  %conv = zext i8 %reg to i32
  %shr = ashr i32 %conv, 4
  %shr.sink = select i1 %cmp, i32 %conv, i32 %shr
  %and3 = and i32 %shr.sink, 15
  %conv4 = trunc i32 %and3 to i8
  %call5 = call i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %conv4, i32 %mode)
  ret i32 %call5
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_TEMP_AUTO_OFFSET_TO_REG(i8 zeroext %old, i32 %off, i32 %nr, i32 %mode) #0 {
entry:
  %call = call zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %off, i32 %mode)
  %cmp = icmp slt i32 %nr, 2
  %conv4 = zext i8 %call to i32
  %shl = shl i32 %conv4, 4
  %conv = zext i8 %old to i32
  %shl.sink = select i1 %cmp, i32 %conv, i32 %shl
  %old.sink = select i1 %cmp, i8 %call, i8 %old
  %and5 = and i32 %shl.sink, 240
  %conv6 = zext i8 %old.sink to i32
  %and7 = and i32 %conv6, 15
  %or8 = or i32 %and5, %and7
  %conv9 = trunc i32 %or8 to i8
  ret i8 %conv9
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_pwm_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 24
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %conv = zext i8 %3 to i32
  %shr = ashr i32 %conv, 4
  %and = and i32 %shr, 15
  %conv1 = trunc i32 %and to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom2 = sext i32 %2 to i64
  %arrayidx3 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom2
  %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx3, i64 0, i64 3
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !47
  %conv5 = zext i8 %4 to i32
  %and6 = and i32 %conv5, 7
  %tobool = icmp ne i32 %and6, 0
  %5 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call7 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv1, i32 %cond)
  %call8 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call7)
  %conv9 = sext i32 %call8 to i64
  ret i64 %conv9
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_pwm_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %div = sdiv i32 %2, 2
  %add = add nsw i32 195, %div
  %conv3 = trunc i32 %add to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv3)
  %mul = mul nsw i32 %2, 4
  %add5 = add nsw i32 203, %mul
  %conv6 = trunc i32 %add5 to i8
  %call7 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv6)
  %conv8 = zext i8 %call4 to i32
  %and = and i32 %conv8, 15
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %conv9 = trunc i64 %6 to i32
  %conv10 = zext i8 %call7 to i32
  %and11 = and i32 %conv10, 7
  %tobool12 = icmp ne i32 %and11, 0
  %7 = zext i1 %tobool12 to i64
  %cond = select i1 %tobool12, i32 1, i32 0
  %call13 = call zeroext i8 @LM93_PWM_TO_REG(i32 %conv9, i32 %cond)
  %conv14 = zext i8 %call13 to i32
  %shl = shl i32 %conv14, 4
  %or = or i32 %and, %shl
  %conv15 = trunc i32 %or to i8
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 24
  %div16 = sdiv i32 %2, 2
  %idxprom = sext i32 %div16 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  store i8 %conv15, i8* %arrayidx, align 1, !tbaa !47
  %div17 = sdiv i32 %2, 2
  %add18 = add nsw i32 195, %div17
  %conv19 = trunc i32 %add18 to i8
  %call20 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv19, i8 zeroext %conv15)
  %update_lock21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock21)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_PWM_FROM_REG(i8 zeroext %reg, i32 %freq) #0 {
entry:
  %idxprom = zext i32 %freq to i64
  %arrayidx = getelementptr inbounds [2 x [16 x i32]], [2 x [16 x i32]]* @lm93_pwm_map, i64 0, i64 %idxprom
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %idxprom1 = sext i32 %and to i64
  %arrayidx2 = getelementptr inbounds [16 x i32], [16 x i32]* %arrayidx, i64 0, i64 %idxprom1
  %0 = load i32, i32* %arrayidx2, align 4, !tbaa !52
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_PWM_TO_REG(i32 %pwm, i32 %freq) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %freq to i64
  %arrayidx = getelementptr inbounds [2 x [16 x i32]], [2 x [16 x i32]]* @lm93_pwm_map, i64 0, i64 %idxprom
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [16 x i32], [16 x i32]* %arrayidx, i64 0, i64 %idxprom1
  %0 = load i32, i32* %arrayidx2, align 4, !tbaa !52
  %cmp3 = icmp sle i32 %pwm, %0
  br i1 %cmp3, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv = trunc i32 %i.0 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_offset_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %3 = load i8, i8* %sfc2, align 8, !tbaa !59
  %call1 = call i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %3, i32 %2)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 24
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call2 = call i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %4, i32 %call1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_offset_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call3 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 27
  store i8 %call3, i8* %sfc2, align 8, !tbaa !59
  %cmp = icmp slt i32 %2, 2
  %6 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %sfc25 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 27
  %7 = load i8, i8* %sfc25, align 8, !tbaa !59
  %conv6 = zext i8 %7 to i32
  %or = or i32 %conv6, %cond
  %conv7 = trunc i32 %or to i8
  store i8 %conv7, i8* %sfc25, align 8, !tbaa !59
  %sfc28 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 27
  %8 = load i8, i8* %sfc28, align 8, !tbaa !59
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -67, i8 zeroext %8)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 24
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %conv10 = zext i8 %9 to i32
  %and = and i32 %conv10, 240
  %10 = load i64, i64* %val, align 8, !tbaa !66
  %conv11 = trunc i64 %10 to i32
  %call12 = call zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %conv11, i32 1)
  %conv13 = zext i8 %call12 to i32
  %and14 = and i32 %conv13, 15
  %or15 = or i32 %and, %and14
  %conv16 = trunc i32 %or15 to i8
  %auto_pwm_min_hyst17 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 24
  %div18 = sdiv i32 %2, 2
  %idxprom19 = sext i32 %div18 to i64
  %arrayidx20 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst17, i64 0, i64 %idxprom19
  store i8 %conv16, i8* %arrayidx20, align 1, !tbaa !47
  %div21 = sdiv i32 %2, 2
  %add = add nsw i32 195, %div21
  %conv22 = trunc i32 %add to i8
  %call23 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv22, i8 zeroext %conv16)
  %update_lock24 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock24)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %11 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_input(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 9
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i16], [4 x i16]* %block5, i64 0, i64 %idxprom
  %3 = load i16, i16* %arrayidx, align 2, !tbaa !51
  %call1 = call i32 @LM93_FAN_FROM_REG(i16 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_FAN_FROM_REG(i16 zeroext %regs) #0 {
entry:
  %conv = zext i16 %regs to i32
  %shr = ashr i32 %conv, 2
  %conv1 = trunc i32 %shr to i16
  %conv2 = zext i16 %conv1 to i32
  %cmp = icmp eq i32 %conv2, 0
  br i1 %cmp, label %cond.end10, label %cond.false

cond.false:                                       ; preds = %entry
  %conv4 = zext i16 %conv1 to i32
  %cmp5 = icmp eq i32 %conv4, 16383
  br i1 %cmp5, label %cond.end10, label %cond.false8

cond.false8:                                      ; preds = %cond.false
  %conv9 = zext i16 %conv1 to i32
  %div = sdiv i32 1350000, %conv9
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.false, %entry
  %cond11 = phi i32 [ -1, %entry ], [ %div, %cond.false8 ], [ 0, %cond.false ]
  ret i32 %cond11
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i64 0, i64 %idxprom
  %3 = load i16, i16* %arrayidx, align 2, !tbaa !51
  %call1 = call i32 @LM93_FAN_FROM_REG(i16 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_fan_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %call3 = call zeroext i16 @LM93_FAN_TO_REG(i64 %6)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i64 0, i64 %idxprom
  store i16 %call3, i16* %arrayidx, align 2, !tbaa !51
  %mul = mul nsw i32 %2, 2
  %add = add nsw i32 180, %mul
  %conv4 = trunc i32 %add to i8
  %block85 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 12
  %idxprom6 = sext i32 %2 to i64
  %arrayidx7 = getelementptr inbounds [4 x i16], [4 x i16]* %block85, i64 0, i64 %idxprom6
  %7 = load i16, i16* %arrayidx7, align 2, !tbaa !51
  %call8 = call i32 @lm93_write_word(%struct.i2c_client* %4, i8 zeroext %conv4, i16 zeroext %7)
  %update_lock9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock9)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @LM93_FAN_TO_REG(i64 %rpm) #0 {
entry:
  %__UNIQUE_ID_min1_42 = alloca i64, align 8
  %__UNIQUE_ID_min1_40 = alloca i64, align 8
  %__UNIQUE_ID_min2_41 = alloca i64, align 8
  %__UNIQUE_ID_min2_43 = alloca i64, align 8
  %__UNIQUE_ID_min1_46 = alloca i64, align 8
  %__UNIQUE_ID_min1_44 = alloca i64, align 8
  %__UNIQUE_ID_min2_45 = alloca i64, align 8
  %__UNIQUE_ID_min2_47 = alloca i64, align 8
  %cmp = icmp eq i64 %rpm, 0
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  %0 = bitcast i64* %__UNIQUE_ID_min1_42 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = bitcast i64* %__UNIQUE_ID_min1_40 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  store i64 %rpm, i64* %__UNIQUE_ID_min1_40, align 8, !tbaa !66
  %2 = bitcast i64* %__UNIQUE_ID_min2_41 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  store i64 1, i64* %__UNIQUE_ID_min2_41, align 8, !tbaa !66
  %cmp1 = icmp eq i64* %__UNIQUE_ID_min1_40, %__UNIQUE_ID_min2_41
  %conv = zext i1 %cmp1 to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_40, align 8, !tbaa !66
  %4 = load i64, i64* %__UNIQUE_ID_min2_41, align 8, !tbaa !66
  %cmp2 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_40, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_41, align 8
  %cond = select i1 %cmp2, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_41 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__UNIQUE_ID_min1_40 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_42, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_43 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 1000000, i64* %__UNIQUE_ID_min2_43, align 8, !tbaa !66
  %cmp4 = icmp eq i64* %__UNIQUE_ID_min1_42, %__UNIQUE_ID_min2_43
  %conv5 = zext i1 %cmp4 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_42, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_43, align 8, !tbaa !66
  %cmp7 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_42, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_43, align 8
  %cond12 = select i1 %cmp7, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_43 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_42 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  %16 = bitcast i64* %__UNIQUE_ID_min1_46 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #5
  %17 = bitcast i64* %__UNIQUE_ID_min1_44 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %17) #5
  %add = add nsw i64 1350000, %cond12
  %div = sdiv i64 %add, %cond12
  store i64 %div, i64* %__UNIQUE_ID_min1_44, align 8, !tbaa !66
  %18 = bitcast i64* %__UNIQUE_ID_min2_45 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %18) #5
  store i64 1, i64* %__UNIQUE_ID_min2_45, align 8, !tbaa !66
  %cmp13 = icmp eq i64* %__UNIQUE_ID_min1_44, %__UNIQUE_ID_min2_45
  %conv14 = zext i1 %cmp13 to i32
  %19 = load i64, i64* %__UNIQUE_ID_min1_44, align 8, !tbaa !66
  %20 = load i64, i64* %__UNIQUE_ID_min2_45, align 8, !tbaa !66
  %cmp16 = icmp sgt i64 %19, %20
  %21 = load i64, i64* %__UNIQUE_ID_min1_44, align 8
  %22 = load i64, i64* %__UNIQUE_ID_min2_45, align 8
  %cond21 = select i1 %cmp16, i64 %21, i64 %22
  %23 = bitcast i64* %__UNIQUE_ID_min2_45 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %23) #5
  %24 = bitcast i64* %__UNIQUE_ID_min1_44 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #5
  store i64 %cond21, i64* %__UNIQUE_ID_min1_46, align 8, !tbaa !66
  %25 = bitcast i64* %__UNIQUE_ID_min2_47 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %25) #5
  store i64 16382, i64* %__UNIQUE_ID_min2_47, align 8, !tbaa !66
  %cmp22 = icmp eq i64* %__UNIQUE_ID_min1_46, %__UNIQUE_ID_min2_47
  %conv23 = zext i1 %cmp22 to i32
  %26 = load i64, i64* %__UNIQUE_ID_min1_46, align 8, !tbaa !66
  %27 = load i64, i64* %__UNIQUE_ID_min2_47, align 8, !tbaa !66
  %cmp25 = icmp slt i64 %26, %27
  %28 = load i64, i64* %__UNIQUE_ID_min1_46, align 8
  %29 = load i64, i64* %__UNIQUE_ID_min2_47, align 8
  %cond30 = select i1 %cmp25, i64 %28, i64 %29
  %30 = bitcast i64* %__UNIQUE_ID_min2_47 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %30) #5
  %31 = bitcast i64* %__UNIQUE_ID_min1_46 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %31) #5
  %conv31 = trunc i64 %cond30 to i16
  br label %if.end

if.end:                                           ; preds = %entry, %if.else
  %count.0 = phi i16 [ %conv31, %if.else ], [ 16383, %entry ]
  %conv32 = zext i16 %count.0 to i32
  %shl = shl i32 %conv32, 2
  %conv33 = trunc i32 %shl to i16
  ret i16 %conv33
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_write_word(%struct.i2c_client* %client, i8 zeroext %reg, i16 zeroext %value) #0 {
entry:
  %call = call i32 @i2c_smbus_write_word_data(%struct.i2c_client* %client, i8 zeroext %reg, i16 zeroext %value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 4
  %conv = zext i16 %value to i32
  %conv1 = zext i8 %reg to i32
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.124, i32 0, i32 0), i32 %conv, i32 %conv1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

declare i32 @i2c_smbus_write_word_data(%struct.i2c_client*, i8 zeroext, i16 zeroext) #1

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_smart_tach(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sf_tach_to_pwm = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 28
  %3 = load i8, i8* %sf_tach_to_pwm, align 1, !tbaa !60
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %2, 2
  %shr = ashr i32 %conv, %mul
  %and = and i32 %shr, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %4 = load i8, i8* %sfc2, align 8, !tbaa !59
  %conv1 = zext i8 %4 to i32
  %shr2 = ashr i32 %conv1, %2
  %and3 = and i32 %shr2, 1
  %tobool4 = icmp ne i32 %and3, 0
  %conv5 = sext i32 %and to i64
  %conv5. = select i1 %tobool4, i64 %conv5, i64 0
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %rc.0 = phi i64 [ 0, %entry ], [ %conv5., %land.lhs.true ]
  %call6 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27, i32 0, i32 0), i64 %rc.0)
  %conv7 = sext i32 %call6 to i64
  ret i64 %conv7
}

; Function Attrs: nounwind uwtable
define internal i64 @store_fan_smart_tach(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %cmp = icmp ule i64 %6, 2
  br i1 %cmp, label %if.then4, label %if.end15

if.then4:                                         ; preds = %if.end
  %7 = load i64, i64* %val, align 8, !tbaa !66
  %tobool5 = icmp ne i64 %7, 0
  br i1 %tobool5, label %if.then6, label %if.end14

if.then6:                                         ; preds = %if.then4
  %8 = load i64, i64* %val, align 8, !tbaa !66
  %sub = sub i64 %8, 1
  %mul = mul i64 %sub, 4
  %add = add i64 203, %mul
  %conv7 = trunc i64 %add to i8
  %call8 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv7)
  %conv9 = zext i8 %call8 to i32
  %and = and i32 %conv9, 7
  %cmp10 = icmp eq i32 %and, 0
  br i1 %cmp10, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.then6
  store i64 0, i64* %val, align 8, !tbaa !66
  br label %if.end14

if.end14:                                         ; preds = %if.then6, %if.then12, %if.then4
  %9 = load i64, i64* %val, align 8, !tbaa !66
  call void @lm93_write_fan_smart_tach(%struct.i2c_client* %4, %struct.lm93_data* %3, i32 %2, i64 %9)
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.end
  %update_lock16 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock16)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end15 ]
  %10 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @lm93_write_fan_smart_tach(%struct.i2c_client* %client, %struct.lm93_data* %data, i32 %fan, i64 %value) #0 {
entry:
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -32)
  %sf_tach_to_pwm = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  store i8 %call, i8* %sf_tach_to_pwm, align 1, !tbaa !60
  %mul = mul nsw i32 %fan, 2
  %shl = shl i32 3, %mul
  %neg = xor i32 %shl, -1
  %sf_tach_to_pwm1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  %0 = load i8, i8* %sf_tach_to_pwm1, align 1, !tbaa !60
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, %neg
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %sf_tach_to_pwm1, align 1, !tbaa !60
  %mul3 = mul nsw i32 %fan, 2
  %sh_prom = zext i32 %mul3 to i64
  %shl4 = shl i64 %value, %sh_prom
  %sf_tach_to_pwm5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  %1 = load i8, i8* %sf_tach_to_pwm5, align 1, !tbaa !60
  %conv6 = zext i8 %1 to i64
  %or = or i64 %conv6, %shl4
  %conv7 = trunc i64 %or to i8
  store i8 %conv7, i8* %sf_tach_to_pwm5, align 1, !tbaa !60
  %sf_tach_to_pwm8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  %2 = load i8, i8* %sf_tach_to_pwm8, align 1, !tbaa !60
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -32, i8 zeroext %2)
  %call10 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  store i8 %call10, i8* %sfc2, align 8, !tbaa !59
  %tobool = icmp ne i64 %value, 0
  %shl11 = shl i32 1, %fan
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sfc212 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %3 = load i8, i8* %sfc212, align 8, !tbaa !59
  %conv13 = zext i8 %3 to i32
  %or14 = or i32 %conv13, %shl11
  br label %if.end

if.else:                                          ; preds = %entry
  %neg17 = xor i32 %shl11, -1
  %sfc218 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %4 = load i8, i8* %sfc218, align 8, !tbaa !59
  %conv19 = zext i8 %4 to i32
  %and20 = and i32 %conv19, %neg17
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %and20.sink = phi i32 [ %and20, %if.else ], [ %or14, %if.then ]
  %sfc218.sink = phi i8* [ %sfc218, %if.else ], [ %sfc212, %if.then ]
  %conv21 = trunc i32 %and20.sink to i8
  store i8 %conv21, i8* %sfc218.sink, align 8, !tbaa !59
  %sfc222 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %5 = load i8, i8* %sfc222, align 8, !tbaa !59
  %call23 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -67, i8 zeroext %5)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 1
  %3 = load i8, i8* %arrayidx1, align 1, !tbaa !47
  %block92 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom3 = sext i32 %2 to i64
  %arrayidx4 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block92, i64 0, i64 %idxprom3
  %arrayidx5 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx4, i64 0, i64 3
  %4 = load i8, i8* %arrayidx5, align 1, !tbaa !47
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %pwm_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 29
  %idxprom6 = sext i32 %2 to i64
  %arrayidx7 = getelementptr inbounds [2 x i8], [2 x i8]* %pwm_override, i64 0, i64 %idxprom6
  %5 = load i8, i8* %arrayidx7, align 1, !tbaa !47
  %conv8 = zext i8 %5 to i64
  br label %if.end

if.else:                                          ; preds = %entry
  %conv9 = zext i8 %3 to i32
  %shr = ashr i32 %conv9, 4
  %conv10 = trunc i32 %shr to i8
  %conv11 = zext i8 %4 to i32
  %and12 = and i32 %conv11, 7
  %tobool13 = icmp ne i32 %and12, 0
  %6 = zext i1 %tobool13 to i64
  %cond = select i1 %tobool13, i32 1, i32 0
  %call14 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv10, i32 %cond)
  %conv15 = sext i32 %call14 to i64
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %rc.0 = phi i64 [ %conv8, %if.then ], [ %conv15, %if.else ]
  %call16 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27, i32 0, i32 0), i64 %rc.0)
  %conv17 = sext i32 %call16 to i64
  ret i64 %conv17
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 201, %mul
  %conv3 = trunc i32 %add to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv3)
  %mul5 = mul nsw i32 %2, 4
  %add6 = add nsw i32 203, %mul5
  %conv7 = trunc i32 %add6 to i8
  %call8 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv7)
  %conv9 = zext i8 %call4 to i32
  %and = and i32 %conv9, 15
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %conv10 = trunc i64 %6 to i32
  %conv11 = zext i8 %call8 to i32
  %and12 = and i32 %conv11, 7
  %tobool13 = icmp ne i32 %and12, 0
  %7 = zext i1 %tobool13 to i64
  %cond = select i1 %tobool13, i32 1, i32 0
  %call14 = call zeroext i8 @LM93_PWM_TO_REG(i32 %conv10, i32 %cond)
  %conv15 = zext i8 %call14 to i32
  %shl = shl i32 %conv15, 4
  %or = or i32 %and, %shl
  %conv16 = trunc i32 %or to i8
  %conv17 = zext i8 %conv16 to i32
  %shr = ashr i32 %conv17, 4
  %conv18 = trunc i32 %shr to i8
  %conv19 = zext i8 %call8 to i32
  %and20 = and i32 %conv19, 7
  %tobool21 = icmp ne i32 %and20, 0
  %8 = zext i1 %tobool21 to i64
  %cond22 = select i1 %tobool21, i32 1, i32 0
  %call23 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv18, i32 %cond22)
  %conv24 = trunc i32 %call23 to i8
  %pwm_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 29
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %pwm_override, i64 0, i64 %idxprom
  store i8 %conv24, i8* %arrayidx, align 1, !tbaa !47
  %mul25 = mul nsw i32 %2, 4
  %add26 = add nsw i32 201, %mul25
  %conv27 = trunc i32 %add26 to i8
  %call28 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv27, i8 zeroext %conv16)
  %update_lock29 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock29)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_enable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 1
  %3 = load i8, i8* %arrayidx1, align 1, !tbaa !47
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %3 to i32
  %and3 = and i32 %conv2, 240
  %cmp = icmp eq i32 %and3, 240
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 0, i32 1
  %conv5 = sext i32 %cond to i64
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %rc.0 = phi i64 [ %conv5, %if.then ], [ 2, %entry ]
  %call6 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27, i32 0, i32 0), i64 %rc.0)
  %conv7 = sext i32 %call6 to i64
  ret i64 %conv7
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_enable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 201, %mul
  %conv3 = trunc i32 %add to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv3)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end
  %Pivot4 = icmp slt i64 %6, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i64 %6, 2
  br i1 %Pivot, label %sw.bb7, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i64 %6, 2
  br i1 %SwitchLeaf2, label %sw.bb11, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i64 %6, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %conv5 = zext i8 %call4 to i32
  %or = or i32 %conv5, 241
  br label %sw.epilog

sw.bb7:                                           ; preds = %NodeBlock
  %conv8 = zext i8 %call4 to i32
  %or9 = or i32 %conv8, 1
  br label %sw.epilog

sw.bb11:                                          ; preds = %LeafBlock1
  %conv12 = zext i8 %call4 to i32
  %and = and i32 %conv12, -2
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %update_lock14 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock14)
  br label %cleanup

sw.epilog:                                        ; preds = %sw.bb11, %sw.bb7, %sw.bb
  %and.sink = phi i32 [ %and, %sw.bb11 ], [ %or9, %sw.bb7 ], [ %or, %sw.bb ]
  %conv13 = trunc i32 %and.sink to i8
  %mul15 = mul nsw i32 %2, 4
  %add16 = add nsw i32 201, %mul15
  %conv17 = trunc i32 %add16 to i8
  %call18 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv17, i8 zeroext %conv13)
  %update_lock19 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock19)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %sw.default, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ -22, %sw.default ], [ %count, %sw.epilog ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_freq(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 3
  %3 = load i8, i8* %arrayidx1, align 1, !tbaa !47
  %call2 = call i32 @LM93_PWM_FREQ_FROM_REG(i8 zeroext %3)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_freq(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 203, %mul
  %conv3 = trunc i32 %add to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv3)
  %conv5 = zext i8 %call4 to i32
  %and = and i32 %conv5, 248
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %conv6 = trunc i64 %6 to i32
  %call7 = call zeroext i8 @LM93_PWM_FREQ_TO_REG(i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  %or = or i32 %and, %conv8
  %conv9 = trunc i32 %or to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx10 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 3
  store i8 %conv9, i8* %arrayidx10, align 1, !tbaa !47
  %tobool11 = icmp ne i8 %conv9, 0
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.end
  call void @lm93_disable_fan_smart_tach(%struct.i2c_client* %4, %struct.lm93_data* %3, i32 %2)
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end
  %mul14 = mul nsw i32 %2, 4
  %add15 = add nsw i32 203, %mul14
  %conv16 = trunc i32 %add15 to i8
  %call17 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv16, i8 zeroext %conv9)
  %update_lock18 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock18)
  br label %cleanup

cleanup:                                          ; preds = %if.end13, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end13 ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_PWM_FREQ_FROM_REG(i8 zeroext %reg) #0 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 7
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_pwm_freq_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !52
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_PWM_FREQ_TO_REG(i32 %freq) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 7, %entry ], [ %dec, %for.inc ]
  %cmp = icmp sgt i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_pwm_freq_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !52
  %cmp1 = icmp sle i32 %freq, %0
  br i1 %cmp1, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv = trunc i32 %i.0 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal void @lm93_disable_fan_smart_tach(%struct.i2c_client* %client, %struct.lm93_data* %data, i32 %pwm) #0 {
entry:
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -32)
  %conv = zext i8 %call to i32
  %shr = ashr i32 %conv, %pwm
  %and = and i32 %shr, 85
  %and1 = and i32 %and, 1
  %and2 = and i32 %and, 4
  %shr3 = ashr i32 %and2, 1
  %or = or i32 %and1, %shr3
  %and4 = and i32 %and, 16
  %shr5 = ashr i32 %and4, 2
  %or6 = or i32 %or, %shr5
  %and7 = and i32 %and, 64
  %shr8 = ashr i32 %and7, 3
  %or9 = or i32 %or6, %shr8
  %call10 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  store i8 %call10, i8* %sfc2, align 8, !tbaa !59
  %neg = xor i32 %or9, -1
  %sfc211 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %0 = load i8, i8* %sfc211, align 8, !tbaa !59
  %conv12 = zext i8 %0 to i32
  %and13 = and i32 %conv12, %neg
  %conv14 = trunc i32 %and13 to i8
  store i8 %conv14, i8* %sfc211, align 8, !tbaa !59
  %sfc215 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %1 = load i8, i8* %sfc215, align 8, !tbaa !59
  %call16 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -67, i8 zeroext %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_channels(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 0
  %3 = load i8, i8* %arrayidx1, align 4, !tbaa !47
  %conv = zext i8 %3 to i32
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %conv)
  %conv3 = sext i32 %call2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_channels(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_58 = alloca i64, align 8
  %__UNIQUE_ID_min1_56 = alloca i64, align 8
  %__UNIQUE_ID_min2_57 = alloca i64, align 8
  %__UNIQUE_ID_min2_59 = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = bitcast i64* %__UNIQUE_ID_min1_58 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %7 = bitcast i64* %__UNIQUE_ID_min1_56 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #5
  %8 = load i64, i64* %val, align 8, !tbaa !66
  store i64 %8, i64* %__UNIQUE_ID_min1_56, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_57 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 0, i64* %__UNIQUE_ID_min2_57, align 8, !tbaa !66
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_56, %__UNIQUE_ID_min2_57
  %conv3 = zext i1 %cmp to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_56, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_57, align 8, !tbaa !66
  %cmp5 = icmp ugt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_56, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_57, align 8
  %cond = select i1 %cmp5, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_57 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_56 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_58, align 8, !tbaa !66
  %16 = bitcast i64* %__UNIQUE_ID_min2_59 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %16) #5
  store i64 255, i64* %__UNIQUE_ID_min2_59, align 8, !tbaa !66
  %cmp7 = icmp eq i64* %__UNIQUE_ID_min1_58, %__UNIQUE_ID_min2_59
  %conv8 = zext i1 %cmp7 to i32
  %17 = load i64, i64* %__UNIQUE_ID_min1_58, align 8, !tbaa !66
  %18 = load i64, i64* %__UNIQUE_ID_min2_59, align 8, !tbaa !66
  %cmp10 = icmp ult i64 %17, %18
  %19 = load i64, i64* %__UNIQUE_ID_min1_58, align 8
  %20 = load i64, i64* %__UNIQUE_ID_min2_59, align 8
  %cond15 = select i1 %cmp10, i64 %19, i64 %20
  %21 = bitcast i64* %__UNIQUE_ID_min2_59 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %21) #5
  %22 = bitcast i64* %__UNIQUE_ID_min1_58 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #5
  %conv16 = trunc i64 %cond15 to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx17 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 0
  store i8 %conv16, i8* %arrayidx17, align 4, !tbaa !47
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 200, %mul
  %conv18 = trunc i32 %add to i8
  %block919 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 13
  %idxprom20 = sext i32 %2 to i64
  %arrayidx21 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block919, i64 0, i64 %idxprom20
  %arrayidx22 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx21, i64 0, i64 0
  %23 = load i8, i8* %arrayidx22, align 4, !tbaa !47
  %call23 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv18, i8 zeroext %23)
  %update_lock24 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock24)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %24 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_spinup_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  %3 = load i8, i8* %arrayidx1, align 2, !tbaa !47
  %block92 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom3 = sext i32 %2 to i64
  %arrayidx4 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block92, i64 0, i64 %idxprom3
  %arrayidx5 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx4, i64 0, i64 3
  %4 = load i8, i8* %arrayidx5, align 1, !tbaa !47
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 15
  %conv6 = trunc i32 %and to i8
  %conv7 = zext i8 %4 to i32
  %and8 = and i32 %conv7, 7
  %tobool = icmp ne i32 %and8, 0
  %5 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call9 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv6, i32 %cond)
  %call10 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call9)
  %conv11 = sext i32 %call10 to i64
  ret i64 %conv11
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_spinup_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 202, %mul
  %conv3 = trunc i32 %add to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv3)
  %mul5 = mul nsw i32 %2, 4
  %add6 = add nsw i32 203, %mul5
  %conv7 = trunc i32 %add6 to i8
  %call8 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv7)
  %conv9 = zext i8 %call4 to i32
  %and = and i32 %conv9, 240
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %conv10 = trunc i64 %6 to i32
  %conv11 = zext i8 %call8 to i32
  %and12 = and i32 %conv11, 7
  %tobool13 = icmp ne i32 %and12, 0
  %7 = zext i1 %tobool13 to i64
  %cond = select i1 %tobool13, i32 1, i32 0
  %call14 = call zeroext i8 @LM93_PWM_TO_REG(i32 %conv10, i32 %cond)
  %conv15 = zext i8 %call14 to i32
  %or = or i32 %and, %conv15
  %conv16 = trunc i32 %or to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx17 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  store i8 %conv16, i8* %arrayidx17, align 2, !tbaa !47
  %mul18 = mul nsw i32 %2, 4
  %add19 = add nsw i32 202, %mul18
  %conv20 = trunc i32 %add19 to i8
  %call21 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv20, i8 zeroext %conv16)
  %update_lock22 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock22)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_spinup_time(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  %3 = load i8, i8* %arrayidx1, align 2, !tbaa !47
  %call2 = call i32 @LM93_SPINUP_TIME_FROM_REG(i8 zeroext %3)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_spinup_time(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 202, %mul
  %conv3 = trunc i32 %add to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv3)
  %conv5 = zext i8 %call4 to i32
  %and = and i32 %conv5, 31
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %conv6 = trunc i64 %6 to i32
  %call7 = call zeroext i8 @LM93_SPINUP_TIME_TO_REG(i32 %conv6)
  %conv8 = zext i8 %call7 to i32
  %shl = shl i32 %conv8, 5
  %and9 = and i32 %shl, 224
  %or = or i32 %and, %and9
  %conv10 = trunc i32 %or to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx11 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  store i8 %conv10, i8* %arrayidx11, align 2, !tbaa !47
  %mul12 = mul nsw i32 %2, 4
  %add13 = add nsw i32 202, %mul12
  %conv14 = trunc i32 %add13 to i8
  %call15 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv14, i8 zeroext %conv10)
  %update_lock16 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock16)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_SPINUP_TIME_FROM_REG(i8 zeroext %reg) #0 {
entry:
  %conv = zext i8 %reg to i32
  %shr = ashr i32 %conv, 5
  %and = and i32 %shr, 7
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_spinup_time_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !52
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_SPINUP_TIME_TO_REG(i32 %time) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_spinup_time_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !52
  %cmp1 = icmp sle i32 %time, %0
  br i1 %cmp1, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv = trunc i32 %i.0 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @pwm_auto_prochot_ramp_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %pwm_ramp_ctl = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 25
  %0 = load i8, i8* %pwm_ramp_ctl, align 2, !tbaa !57
  %conv = zext i8 %0 to i32
  %shr = ashr i32 %conv, 4
  %and = and i32 %shr, 15
  %conv1 = trunc i32 %and to i8
  %call2 = call i32 @LM93_RAMP_FROM_REG(i8 zeroext %conv1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call2)
  %conv4 = sext i32 %call3 to i64
  ret i64 %conv4
}

; Function Attrs: nounwind uwtable
define internal i64 @pwm_auto_prochot_ramp_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 0
  %1 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %2 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call3 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %1, i8 zeroext -65)
  %conv4 = zext i8 %call3 to i32
  %and = and i32 %conv4, 15
  %3 = load i64, i64* %val, align 8, !tbaa !66
  %conv5 = trunc i64 %3 to i32
  %call6 = call zeroext i8 @LM93_RAMP_TO_REG(i32 %conv5)
  %conv7 = zext i8 %call6 to i32
  %shl = shl i32 %conv7, 4
  %and8 = and i32 %shl, 240
  %or = or i32 %and, %and8
  %conv9 = trunc i32 %or to i8
  %call10 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -65, i8 zeroext %conv9)
  %update_lock11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock11)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_RAMP_FROM_REG(i8 zeroext %reg) #0 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %mul = mul nsw i32 %and, 5
  ret i32 %mul
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_RAMP_TO_REG(i32 %ramp) #0 {
entry:
  %__UNIQUE_ID_min1_50 = alloca i32, align 4
  %__UNIQUE_ID_min1_48 = alloca i32, align 4
  %__UNIQUE_ID_min2_49 = alloca i32, align 4
  %__UNIQUE_ID_min2_51 = alloca i32, align 4
  %0 = bitcast i32* %__UNIQUE_ID_min1_50 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #5
  %1 = bitcast i32* %__UNIQUE_ID_min1_48 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #5
  store i32 %ramp, i32* %__UNIQUE_ID_min1_48, align 4, !tbaa !52
  %2 = bitcast i32* %__UNIQUE_ID_min2_49 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #5
  store i32 0, i32* %__UNIQUE_ID_min2_49, align 4, !tbaa !52
  %cmp = icmp eq i32* %__UNIQUE_ID_min1_48, %__UNIQUE_ID_min2_49
  %conv = zext i1 %cmp to i32
  %3 = load i32, i32* %__UNIQUE_ID_min1_48, align 4, !tbaa !52
  %4 = load i32, i32* %__UNIQUE_ID_min2_49, align 4, !tbaa !52
  %cmp1 = icmp sgt i32 %3, %4
  %5 = load i32, i32* %__UNIQUE_ID_min1_48, align 4
  %6 = load i32, i32* %__UNIQUE_ID_min2_49, align 4
  %cond = select i1 %cmp1, i32 %5, i32 %6
  %7 = bitcast i32* %__UNIQUE_ID_min2_49 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #5
  %8 = bitcast i32* %__UNIQUE_ID_min1_48 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #5
  store i32 %cond, i32* %__UNIQUE_ID_min1_50, align 4, !tbaa !52
  %9 = bitcast i32* %__UNIQUE_ID_min2_51 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %9) #5
  store i32 75, i32* %__UNIQUE_ID_min2_51, align 4, !tbaa !52
  %cmp3 = icmp eq i32* %__UNIQUE_ID_min1_50, %__UNIQUE_ID_min2_51
  %conv4 = zext i1 %cmp3 to i32
  %10 = load i32, i32* %__UNIQUE_ID_min1_50, align 4, !tbaa !52
  %11 = load i32, i32* %__UNIQUE_ID_min2_51, align 4, !tbaa !52
  %cmp6 = icmp slt i32 %10, %11
  %12 = load i32, i32* %__UNIQUE_ID_min1_50, align 4
  %13 = load i32, i32* %__UNIQUE_ID_min2_51, align 4
  %cond11 = select i1 %cmp6, i32 %12, i32 %13
  %14 = bitcast i32* %__UNIQUE_ID_min2_51 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #5
  %15 = bitcast i32* %__UNIQUE_ID_min1_50 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %15) #5
  %add = add nsw i32 %cond11, 2
  %div = sdiv i32 %add, 5
  %conv12 = trunc i32 %div to i8
  ret i8 %conv12
}

; Function Attrs: nounwind uwtable
define internal i64 @pwm_auto_vrdhot_ramp_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %pwm_ramp_ctl = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 25
  %0 = load i8, i8* %pwm_ramp_ctl, align 2, !tbaa !57
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  %call2 = call i32 @LM93_RAMP_FROM_REG(i8 zeroext %conv1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call2)
  %conv4 = sext i32 %call3 to i64
  ret i64 %conv4
}

; Function Attrs: nounwind uwtable
define internal i64 @pwm_auto_vrdhot_ramp_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 0
  %1 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %2 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call3 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %1, i8 zeroext -65)
  %conv4 = zext i8 %call3 to i32
  %and = and i32 %conv4, 240
  %3 = load i64, i64* %val, align 8, !tbaa !66
  %conv5 = trunc i64 %3 to i32
  %call6 = call zeroext i8 @LM93_RAMP_TO_REG(i32 %conv5)
  %conv7 = zext i8 %call6 to i32
  %and8 = and i32 %conv7, 15
  %or = or i32 %and, %and8
  %conv9 = trunc i32 %or to i8
  %call10 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -65, i8 zeroext %conv9)
  %update_lock11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock11)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ 0, %if.end ]
  %4 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_vid(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %vid = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 16
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %vid, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %call1 = call i32 @LM93_VID_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 8
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x %struct.anon.37], [2 x %struct.anon.37]* %block4, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.37, %struct.anon.37* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %cur, align 1, !tbaa !48
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_avg(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 8
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x %struct.anon.37], [2 x %struct.anon.37]* %block4, i64 0, i64 %idxprom
  %avg = getelementptr inbounds %struct.anon.37, %struct.anon.37* %arrayidx, i32 0, i32 1
  %3 = load i8, i8* %avg, align 1, !tbaa !50
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %prochot_max = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %call3 = call zeroext i8 @LM93_PROCHOT_TO_REG(i64 %6)
  %prochot_max = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max, i64 0, i64 %idxprom
  store i8 %call3, i8* %arrayidx, align 1, !tbaa !47
  %add = add nsw i32 176, %2
  %conv4 = trunc i32 %add to i8
  %prochot_max5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 17
  %idxprom6 = sext i32 %2 to i64
  %arrayidx7 = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max5, i64 0, i64 %idxprom6
  %7 = load i8, i8* %arrayidx7, align 1, !tbaa !47
  %call8 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv4, i8 zeroext %7)
  %update_lock9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock9)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_PROCHOT_TO_REG(i64 %prochot) #0 {
entry:
  %__UNIQUE_ID_min1_54 = alloca i64, align 8
  %__UNIQUE_ID_min1_52 = alloca i64, align 8
  %__UNIQUE_ID_min2_53 = alloca i64, align 8
  %__UNIQUE_ID_min2_55 = alloca i64, align 8
  %0 = bitcast i64* %__UNIQUE_ID_min1_54 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #5
  %1 = bitcast i64* %__UNIQUE_ID_min1_52 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #5
  store i64 %prochot, i64* %__UNIQUE_ID_min1_52, align 8, !tbaa !66
  %2 = bitcast i64* %__UNIQUE_ID_min2_53 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  store i64 0, i64* %__UNIQUE_ID_min2_53, align 8, !tbaa !66
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_52, %__UNIQUE_ID_min2_53
  %conv = zext i1 %cmp to i32
  %3 = load i64, i64* %__UNIQUE_ID_min1_52, align 8, !tbaa !66
  %4 = load i64, i64* %__UNIQUE_ID_min2_53, align 8, !tbaa !66
  %cmp1 = icmp sgt i64 %3, %4
  %5 = load i64, i64* %__UNIQUE_ID_min1_52, align 8
  %6 = load i64, i64* %__UNIQUE_ID_min2_53, align 8
  %cond = select i1 %cmp1, i64 %5, i64 %6
  %7 = bitcast i64* %__UNIQUE_ID_min2_53 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__UNIQUE_ID_min1_52 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_54, align 8, !tbaa !66
  %9 = bitcast i64* %__UNIQUE_ID_min2_55 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %9) #5
  store i64 255, i64* %__UNIQUE_ID_min2_55, align 8, !tbaa !66
  %cmp3 = icmp eq i64* %__UNIQUE_ID_min1_54, %__UNIQUE_ID_min2_55
  %conv4 = zext i1 %cmp3 to i32
  %10 = load i64, i64* %__UNIQUE_ID_min1_54, align 8, !tbaa !66
  %11 = load i64, i64* %__UNIQUE_ID_min2_55, align 8, !tbaa !66
  %cmp6 = icmp slt i64 %10, %11
  %12 = load i64, i64* %__UNIQUE_ID_min1_54, align 8
  %13 = load i64, i64* %__UNIQUE_ID_min2_55, align 8
  %cond11 = select i1 %cmp6, i64 %12, i64 %13
  %14 = bitcast i64* %__UNIQUE_ID_min2_55 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  %15 = bitcast i64* %__UNIQUE_ID_min1_54 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %15) #5
  %conv12 = trunc i64 %cond11 to i8
  ret i8 %conv12
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_override(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 20
  %3 = load i8, i8* %prochot_override, align 4, !tbaa !55
  %conv = zext i8 %3 to i32
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* @prochot_override_mask, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %conv1 = zext i8 %4 to i32
  %and = and i32 %conv, %conv1
  %tobool = icmp ne i32 %and, 0
  %5 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %cond)
  %conv3 = sext i32 %call2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_override(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %tobool3 = icmp ne i64 %6, 0
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* @prochot_override_mask, i64 0, i64 %idxprom
  %7 = load i8, i8* %arrayidx, align 1, !tbaa !47
  %conv5 = zext i8 %7 to i32
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.end
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 20
  %8 = load i8, i8* %prochot_override, align 4, !tbaa !55
  %conv6 = zext i8 %8 to i32
  %or = or i32 %conv6, %conv5
  br label %if.end14

if.else:                                          ; preds = %if.end
  %neg = xor i32 %conv5, -1
  %prochot_override11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 20
  %9 = load i8, i8* %prochot_override11, align 4, !tbaa !55
  %conv12 = zext i8 %9 to i32
  %and = and i32 %conv12, %neg
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.then4
  %and.sink = phi i32 [ %and, %if.else ], [ %or, %if.then4 ]
  %prochot_override11.sink = phi i8* [ %prochot_override11, %if.else ], [ %prochot_override, %if.then4 ]
  %conv13 = trunc i32 %and.sink to i8
  store i8 %conv13, i8* %prochot_override11.sink, align 4, !tbaa !55
  %prochot_override15 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 20
  %10 = load i8, i8* %prochot_override15, align 4, !tbaa !55
  %call16 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -58, i8 zeroext %10)
  %update_lock17 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock17)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end14 ]
  %11 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_interval(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %cmp = icmp eq i32 %2, 1
  %prochot_interval = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 21
  %3 = load i8, i8* %prochot_interval, align 1, !tbaa !56
  %conv = zext i8 %3 to i32
  %and5 = and i32 %conv, 15
  %and = and i32 %conv, 240
  %shr = ashr i32 %and, 4
  %and5.sink = select i1 %cmp, i32 %shr, i32 %and5
  %conv6 = trunc i32 %and5.sink to i8
  %call7 = call i32 @LM93_INTERVAL_FROM_REG(i8 zeroext %conv6)
  %call8 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call7)
  %conv9 = sext i32 %call8 to i64
  ret i64 %conv9
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_interval(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %3 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 0
  %4 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %call3 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call3 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext -57)
  %cmp = icmp eq i32 %2, 1
  %conv7 = zext i8 %call4 to i32
  br i1 %cmp, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %and = and i32 %conv7, 15
  %6 = load i64, i64* %val, align 8, !tbaa !66
  %call8 = call zeroext i8 @LM93_INTERVAL_TO_REG(i64 %6)
  %conv9 = zext i8 %call8 to i32
  %shl = shl i32 %conv9, 4
  %or = or i32 %and, %shl
  br label %if.end17

if.else:                                          ; preds = %if.end
  %and12 = and i32 %conv7, 240
  %7 = load i64, i64* %val, align 8, !tbaa !66
  %call13 = call zeroext i8 @LM93_INTERVAL_TO_REG(i64 %7)
  %conv14 = zext i8 %call13 to i32
  %or15 = or i32 %and12, %conv14
  br label %if.end17

if.end17:                                         ; preds = %if.else, %if.then6
  %or15.sink = phi i32 [ %or15, %if.else ], [ %or, %if.then6 ]
  %conv16 = trunc i32 %or15.sink to i8
  %prochot_interval = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 21
  store i8 %conv16, i8* %prochot_interval, align 1, !tbaa !56
  %call18 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -57, i8 zeroext %conv16)
  %update_lock19 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %3, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock19)
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end17 ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_INTERVAL_FROM_REG(i8 zeroext %reg) #0 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* @lm93_interval_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !52
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_INTERVAL_TO_REG(i64 %interval) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* @lm93_interval_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !52
  %conv = sext i32 %0 to i64
  %cmp1 = icmp sle i64 %interval, %conv
  br i1 %cmp1, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv3 = trunc i32 %i.0 to i8
  ret i8 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @prochot_override_duty_cycle_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 20
  %0 = load i8, i8* %prochot_override, align 4, !tbaa !55
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %and)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @prochot_override_duty_cycle_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %__UNIQUE_ID_min1_62 = alloca i64, align 8
  %__UNIQUE_ID_min1_60 = alloca i64, align 8
  %__UNIQUE_ID_min2_61 = alloca i64, align 8
  %__UNIQUE_ID_min2_63 = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 0
  %1 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %2 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 20
  %3 = load i8, i8* %prochot_override, align 4, !tbaa !55
  %conv3 = zext i8 %3 to i32
  %and = and i32 %conv3, 240
  %conv4 = sext i32 %and to i64
  %4 = bitcast i64* %__UNIQUE_ID_min1_62 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
  %5 = bitcast i64* %__UNIQUE_ID_min1_60 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5
  %6 = load i64, i64* %val, align 8, !tbaa !66
  store i64 %6, i64* %__UNIQUE_ID_min1_60, align 8, !tbaa !66
  %7 = bitcast i64* %__UNIQUE_ID_min2_61 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #5
  store i64 0, i64* %__UNIQUE_ID_min2_61, align 8, !tbaa !66
  %cmp = icmp eq i64* %__UNIQUE_ID_min1_60, %__UNIQUE_ID_min2_61
  %conv5 = zext i1 %cmp to i32
  %8 = load i64, i64* %__UNIQUE_ID_min1_60, align 8, !tbaa !66
  %9 = load i64, i64* %__UNIQUE_ID_min2_61, align 8, !tbaa !66
  %cmp6 = icmp ugt i64 %8, %9
  %10 = load i64, i64* %__UNIQUE_ID_min1_60, align 8
  %11 = load i64, i64* %__UNIQUE_ID_min2_61, align 8
  %cond = select i1 %cmp6, i64 %10, i64 %11
  %12 = bitcast i64* %__UNIQUE_ID_min2_61 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
  %13 = bitcast i64* %__UNIQUE_ID_min1_60 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #5
  store i64 %cond, i64* %__UNIQUE_ID_min1_62, align 8, !tbaa !66
  %14 = bitcast i64* %__UNIQUE_ID_min2_63 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %14) #5
  store i64 15, i64* %__UNIQUE_ID_min2_63, align 8, !tbaa !66
  %cmp8 = icmp eq i64* %__UNIQUE_ID_min1_62, %__UNIQUE_ID_min2_63
  %conv9 = zext i1 %cmp8 to i32
  %15 = load i64, i64* %__UNIQUE_ID_min1_62, align 8, !tbaa !66
  %16 = load i64, i64* %__UNIQUE_ID_min2_63, align 8, !tbaa !66
  %cmp11 = icmp ult i64 %15, %16
  %17 = load i64, i64* %__UNIQUE_ID_min1_62, align 8
  %18 = load i64, i64* %__UNIQUE_ID_min2_63, align 8
  %cond16 = select i1 %cmp11, i64 %17, i64 %18
  %19 = bitcast i64* %__UNIQUE_ID_min2_63 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %19) #5
  %20 = bitcast i64* %__UNIQUE_ID_min1_62 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #5
  %or = or i64 %conv4, %cond16
  %conv17 = trunc i64 %or to i8
  %prochot_override18 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 20
  store i8 %conv17, i8* %prochot_override18, align 4, !tbaa !55
  %prochot_override19 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 20
  %21 = load i8, i8* %prochot_override19, align 4, !tbaa !55
  %call20 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -58, i8 zeroext %21)
  %update_lock21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock21)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %22 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %22) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @prochot_short_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %config = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 15
  %0 = load i8, i8* %config, align 4, !tbaa !53
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 16
  %tobool = icmp ne i32 %and, 0
  %1 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %cond)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @prochot_short_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %val = alloca i64, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %dev)
  %0 = bitcast i8* %call to %struct.lm93_data*
  %client1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 0
  %1 = load %struct.i2c_client*, %struct.i2c_client** %client1, align 8, !tbaa !34
  %2 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #5
  %call2 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call2 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %3 = load i64, i64* %val, align 8, !tbaa !66
  %tobool3 = icmp ne i64 %3, 0
  %config = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 15
  %4 = load i8, i8* %config, align 4, !tbaa !53
  %conv5 = zext i8 %4 to i32
  %and = and i32 %conv5, -17
  %or = or i32 %conv5, 16
  %and.sink = select i1 %tobool3, i32 %or, i32 %and
  %conv9 = trunc i32 %and.sink to i8
  store i8 %conv9, i8* %config, align 4, !tbaa !53
  %config11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 15
  %5 = load i8, i8* %config11, align 4, !tbaa !53
  %call12 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -29, i8 zeroext %5)
  %update_lock13 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock13)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_vrdhot(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !61
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 5
  %host_status_1 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %block1, i32 0, i32 0
  %3 = load i8, i8* %host_status_1, align 1, !tbaa !72
  %conv = zext i8 %3 to i32
  %add = add nsw i32 %2, 4
  %shl = shl i32 1, %add
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  %4 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %cond)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @gpio_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %gpi = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 19
  %0 = load i8, i8* %gpi, align 1, !tbaa !54
  %call1 = call i32 @LM93_GPI_FROM_REG(i8 zeroext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_GPI_FROM_REG(i8 zeroext %reg) #0 {
entry:
  %conv = zext i8 %reg to i32
  %neg = xor i32 %conv, -1
  %and = and i32 %neg, 255
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i64 @alarms_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 5
  %0 = bitcast %struct.block1_t* %block1 to i64*
  %1 = load i64, i64* %0, align 1
  %call1 = call i32 @LM93_ALARMS_FROM_REG(i64 %1)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_ALARMS_FROM_REG(i64 %b1.coerce) #0 {
entry:
  %b1 = alloca %struct.block1_t, align 1
  %0 = bitcast %struct.block1_t* %b1 to i64*
  store i64 %b1.coerce, i64* %0, align 1
  %host_status_2 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 1
  %1 = load i8, i8* %host_status_2, align 1, !tbaa !73
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 63
  %2 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 0), align 4, !tbaa !52
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %host_status_4 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 3
  %3 = load i8, i8* %host_status_4, align 1, !tbaa !74
  %conv1 = zext i8 %3 to i32
  %and2 = and i32 %conv1, 16
  %shl = shl i32 %and2, 2
  br label %if.end

if.else:                                          ; preds = %entry
  %host_status_23 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 1
  %4 = load i8, i8* %host_status_23, align 1, !tbaa !73
  %conv4 = zext i8 %4 to i32
  %and5 = and i32 %conv4, 64
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %and5.sink = phi i32 [ %and5, %if.else ], [ %shl, %if.then ]
  %or6 = or i32 %and, %and5.sink
  %5 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 1), align 4, !tbaa !52
  %tobool7 = icmp ne i32 %5, 0
  br i1 %tobool7, label %if.then8, label %if.else14

if.then8:                                         ; preds = %if.end
  %host_status_49 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 3
  %6 = load i8, i8* %host_status_49, align 1, !tbaa !74
  %conv10 = zext i8 %6 to i32
  %and11 = and i32 %conv10, 32
  %shl12 = shl i32 %and11, 2
  br label %if.end19

if.else14:                                        ; preds = %if.end
  %host_status_215 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 1
  %7 = load i8, i8* %host_status_215, align 1, !tbaa !73
  %conv16 = zext i8 %7 to i32
  %and17 = and i32 %conv16, 128
  br label %if.end19

if.end19:                                         ; preds = %if.else14, %if.then8
  %and17.sink = phi i32 [ %and17, %if.else14 ], [ %shl12, %if.then8 ]
  %or18 = or i32 %or6, %and17.sink
  %host_status_3 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 2
  %8 = load i8, i8* %host_status_3, align 1, !tbaa !75
  %conv20 = zext i8 %8 to i32
  %shl21 = shl i32 %conv20, 8
  %or22 = or i32 %or18, %shl21
  %fan_status = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 7
  %9 = load i8, i8* %fan_status, align 1, !tbaa !76
  %conv23 = zext i8 %9 to i32
  %and24 = and i32 %conv23, 15
  %shl25 = shl i32 %and24, 16
  %or26 = or i32 %or22, %shl25
  %p1_prochot_status = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 4
  %10 = load i8, i8* %p1_prochot_status, align 1, !tbaa !77
  %conv27 = zext i8 %10 to i32
  %and28 = and i32 %conv27, 128
  %shl29 = shl i32 %and28, 13
  %or30 = or i32 %or26, %shl29
  %p2_prochot_status = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 5
  %11 = load i8, i8* %p2_prochot_status, align 1, !tbaa !78
  %conv31 = zext i8 %11 to i32
  %and32 = and i32 %conv31, 128
  %shl33 = shl i32 %and32, 14
  %or34 = or i32 %or30, %shl33
  %host_status_435 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 3
  %12 = load i8, i8* %host_status_435, align 1, !tbaa !74
  %conv36 = zext i8 %12 to i32
  %and37 = and i32 %conv36, 252
  %shl38 = shl i32 %and37, 20
  %or39 = or i32 %or34, %shl38
  %host_status_1 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 0
  %13 = load i8, i8* %host_status_1, align 1, !tbaa !79
  %conv40 = zext i8 %13 to i32
  %and41 = and i32 %conv40, 7
  %shl42 = shl i32 %and41, 28
  %or43 = or i32 %or39, %shl42
  ret i32 %or43
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @i2c_check_functionality(%struct.i2c_adapter* %adap, i32 %func) #3 {
entry:
  %call = call i32 @i2c_get_functionality(%struct.i2c_adapter* %adap)
  %and = and i32 %func, %call
  %cmp = icmp eq i32 %and, %func
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i64 @strlcpy(i8*, i8*, i64) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !7, i64 24}
!3 = !{!"i2c_client", !4, i64 0, !4, i64 2, !5, i64 4, !7, i64 24, !8, i64 32, !14, i64 760, !10, i64 768}
!4 = !{!"short", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"any pointer", !5, i64 0}
!8 = !{!"device", !7, i64 0, !7, i64 8, !9, i64 16, !7, i64 80, !7, i64 88, !15, i64 96, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !20, i64 160, !21, i64 200, !7, i64 488, !7, i64 496, !10, i64 504, !14, i64 520, !7, i64 528, !7, i64 536, !29, i64 544, !17, i64 552, !7, i64 560, !10, i64 568, !7, i64 584, !30, i64 592, !7, i64 600, !7, i64 608, !14, i64 616, !14, i64 620, !18, i64 624, !10, i64 632, !31, i64 648, !7, i64 680, !7, i64 688, !7, i64 696, !7, i64 704, !7, i64 712, !23, i64 720, !23, i64 720}
!9 = !{!"kobject", !7, i64 0, !10, i64 8, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !11, i64 56, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60}
!10 = !{!"list_head", !7, i64 0, !7, i64 8}
!11 = !{!"kref", !12, i64 0}
!12 = !{!"refcount_struct", !13, i64 0}
!13 = !{!"", !14, i64 0}
!14 = !{!"int", !5, i64 0}
!15 = !{!"mutex", !16, i64 0, !18, i64 8, !19, i64 12, !10, i64 16}
!16 = !{!"", !17, i64 0}
!17 = !{!"long", !5, i64 0}
!18 = !{!"spinlock", !5, i64 0}
!19 = !{!"optimistic_spin_queue", !13, i64 0}
!20 = !{!"dev_links_info", !10, i64 0, !10, i64 16, !5, i64 32}
!21 = !{!"dev_pm_info", !22, i64 0, !14, i64 4, !14, i64 4, !23, i64 4, !23, i64 4, !23, i64 4, !23, i64 4, !23, i64 4, !23, i64 4, !23, i64 5, !18, i64 8, !10, i64 16, !24, i64 32, !7, i64 64, !23, i64 72, !23, i64 72, !23, i64 72, !26, i64 80, !17, i64 128, !28, i64 136, !25, i64 168, !7, i64 192, !13, i64 200, !13, i64 204, !14, i64 208, !14, i64 208, !14, i64 208, !14, i64 208, !14, i64 208, !14, i64 208, !23, i64 209, !14, i64 209, !14, i64 209, !14, i64 209, !14, i64 209, !14, i64 209, !14, i64 212, !5, i64 216, !5, i64 220, !14, i64 224, !14, i64 228, !17, i64 232, !17, i64 240, !17, i64 248, !17, i64 256, !7, i64 264, !7, i64 272, !7, i64 280}
!22 = !{!"pm_message", !14, i64 0}
!23 = !{!"_Bool", !5, i64 0}
!24 = !{!"completion", !14, i64 0, !25, i64 8}
!25 = !{!"__wait_queue_head", !18, i64 0, !10, i64 8}
!26 = !{!"timer_list", !27, i64 0, !17, i64 16, !7, i64 24, !17, i64 32, !14, i64 40}
!27 = !{!"hlist_node", !7, i64 0, !7, i64 8}
!28 = !{!"work_struct", !16, i64 0, !10, i64 8, !7, i64 24}
!29 = !{!"long long", !5, i64 0}
!30 = !{!"dev_archdata", !7, i64 0}
!31 = !{!"klist_node", !7, i64 0, !10, i64 8, !11, i64 24}
!32 = !{!23, !23, i64 0}
!33 = !{i8 0, i8 2}
!34 = !{!35, !7, i64 0}
!35 = !{!"lm93_data", !7, i64 0, !15, i64 8, !17, i64 40, !7, i64 48, !5, i64 56, !36, i64 57, !5, i64 65, !5, i64 71, !5, i64 87, !5, i64 92, !5, i64 100, !5, i64 108, !5, i64 140, !5, i64 148, !37, i64 156, !5, i64 172, !5, i64 173, !5, i64 175, !5, i64 177, !5, i64 179, !5, i64 180, !5, i64 181, !5, i64 182, !5, i64 186, !5, i64 188, !5, i64 190, !5, i64 191, !5, i64 192, !5, i64 193, !5, i64 194}
!36 = !{!"block1_t", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7}
!37 = !{!"", !5, i64 0, !5, i64 4}
!38 = !{!35, !7, i64 48}
!39 = !{!40, !7, i64 16}
!40 = !{!"i2c_adapter", !7, i64 0, !14, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !41, i64 40, !41, i64 72, !14, i64 104, !14, i64 108, !8, i64 112, !14, i64 840, !5, i64 844, !24, i64 896, !15, i64 928, !10, i64 960, !7, i64 976, !7, i64 984, !7, i64 992}
!41 = !{!"rt_mutex", !42, i64 0, !44, i64 8, !7, i64 16, !7, i64 24}
!42 = !{!"raw_spinlock", !43, i64 0}
!43 = !{!"qspinlock", !13, i64 0}
!44 = !{!"rb_root", !7, i64 0}
!45 = !{!46, !7, i64 16}
!46 = !{!"i2c_algorithm", !7, i64 0, !7, i64 8, !7, i64 16}
!47 = !{!5, !5, i64 0}
!48 = !{!49, !5, i64 0}
!49 = !{!"", !5, i64 0, !5, i64 1}
!50 = !{!49, !5, i64 1}
!51 = !{!4, !4, i64 0}
!52 = !{!14, !14, i64 0}
!53 = !{!35, !5, i64 172}
!54 = !{!35, !5, i64 179}
!55 = !{!35, !5, i64 180}
!56 = !{!35, !5, i64 181}
!57 = !{!35, !5, i64 190}
!58 = !{!35, !5, i64 191}
!59 = !{!35, !5, i64 192}
!60 = !{!35, !5, i64 193}
!61 = !{!62, !14, i64 32}
!62 = !{!"sensor_device_attribute", !63, i64 0, !14, i64 32}
!63 = !{!"device_attribute", !64, i64 0, !7, i64 16, !7, i64 24}
!64 = !{!"attribute", !7, i64 0, !4, i64 8}
!65 = !{!35, !17, i64 40}
!66 = !{!17, !17, i64 0}
!67 = !{!35, !5, i64 56}
!68 = !{!8, !7, i64 152}
!69 = !{!70, !5, i64 32}
!70 = !{!"sensor_device_attribute_2", !63, i64 0, !5, i64 32, !5, i64 33}
!71 = !{!70, !5, i64 33}
!72 = !{!35, !5, i64 57}
!73 = !{!36, !5, i64 1}
!74 = !{!36, !5, i64 3}
!75 = !{!36, !5, i64 2}
!76 = !{!36, !5, i64 7}
!77 = !{!36, !5, i64 4}
!78 = !{!36, !5, i64 5}
!79 = !{!36, !5, i64 0}
