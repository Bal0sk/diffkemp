; ModuleID = 'drivers/hwmon/lm93.bc'
source_filename = "drivers/hwmon/lm93.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.31 }
%union.anon.31 = type { i8* }
%struct.kparam_array = type { i32, i32, i32*, %struct.kernel_param_ops*, i8* }
%struct.i2c_driver = type { i32, i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_client*, %struct.i2c_device_id*)*, i32 (%struct.i2c_client*)*, void (%struct.i2c_client*)*, i32 (%struct.i2c_client*, i32)*, i32 (%struct.i2c_client*)*, void (%struct.i2c_client*, i32)*, i32 (%struct.i2c_client*, i32, i8*)*, %struct.device_driver, %struct.i2c_device_id*, i32 (%struct.i2c_client*, %struct.i2c_board_info*)*, i16*, %struct.list_head }
%struct.i2c_adapter = type { %struct.module*, i32, %struct.i2c_algorithm*, i8*, %struct.rt_mutex, i32, i32, %struct.device, i32, [48 x i8], %struct.completion, %struct.mutex, %struct.list_head, %struct.i2c_bus_recovery_info* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type opaque
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.file = type opaque
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.2, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.4, %union.anon.5 }
%union.anon.2 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.3 = type { i64 }
%union.anon.4 = type { %struct.list_head }
%union.anon.5 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.6 }
%union.anon.6 = type { %struct.anon.7 }
%struct.anon.7 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.9, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.12 }
%union.anon.9 = type { %struct.anon.10 }
%struct.anon.10 = type { i64, i64 }
%union.anon.12 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.14 }
%union.anon.14 = type { %struct.anon.18, [80 x i8] }
%struct.anon.18 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.page = type { i64, %struct.address_space*, %struct.anon.22, %union.anon.28, %union.anon.30, [8 x i8] }
%struct.address_space = type opaque
%struct.anon.22 = type { %union.anon.23, %union.anon.24 }
%union.anon.23 = type { i64 }
%union.anon.24 = type { i64 }
%union.anon.28 = type { %struct.list_head }
%union.anon.30 = type { i64 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.module_ref = type { i64, i64 }
%struct.i2c_algorithm = type { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }
%struct.i2c_msg = type { i16, i16, i16, i8* }
%union.i2c_smbus_data = type { i16, [32 x i8] }
%struct.rt_mutex = type { %struct.raw_spinlock, %struct.plist_head, %struct.task_struct* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type {}
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.proc_dir_entry*, %struct.kref, i64, i8* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32 }
%struct.proc_dir_entry = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.i2c_bus_recovery_info = type { {}*, {}*, void (%struct.i2c_adapter*, i32)*, {}*, void (%struct.i2c_bus_recovery_info*)*, void (%struct.i2c_bus_recovery_info*)*, i32, i32 }
%struct.i2c_client = type { i16, i16, [20 x i8], %struct.i2c_adapter*, %struct.i2c_driver*, %struct.device, i32, %struct.list_head }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.i2c_device_id = type { [20 x i8], i64 }
%struct.i2c_board_info = type { [20 x i8], i16, i16, i8*, %struct.dev_archdata*, %struct.device_node*, %struct.acpi_dev_node, i32 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.anon.36 = type { i8, i8 }
%struct.sensor_device_attribute = type { %struct.device_attribute, i32 }
%struct.sensor_device_attribute_2 = type { %struct.device_attribute, i8, i8 }
%struct.lm93_data = type { %struct.device*, %struct.mutex, i64, void (%struct.lm93_data*, %struct.i2c_client*)*, i8, %struct.block1_t, [6 x i8], [16 x i8], [2 x %struct.anon.32], [4 x i16], [4 x %struct.anon.33], [16 x %struct.anon.34], [4 x i16], [2 x [4 x i8]], %struct.anon.35, i8, [2 x i8], [2 x i8], [2 x i8], i8, i8, i8, [4 x i8], [2 x i8], [2 x i8], i8, i8, i8, i8, [2 x i8] }
%struct.block1_t = type { i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.anon.32 = type { i8, i8 }
%struct.anon.33 = type { i8, i8 }
%struct.anon.34 = type { i8, i8 }
%struct.anon.35 = type { [4 x i8], [12 x i8] }

@__param_str_disable_block = internal constant [19 x i8] c"lm93.disable_block\00", align 16
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@disable_block = internal global i8 0, align 1
@__param_disable_block = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_disable_block, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon.31 { i8* @disable_block } }, section "__param", align 8
@__param_str_init = internal constant [10 x i8] c"lm93.init\00", align 1
@init = internal global i8 0, align 1
@__param_init = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_init, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon.31 { i8* @init } }, section "__param", align 8
@__param_str_vccp_limit_type = internal constant [21 x i8] c"lm93.vccp_limit_type\00", align 16
@param_array_ops = external global %struct.kernel_param_ops, align 8
@__param_arr_vccp_limit_type = internal constant %struct.kparam_array { i32 2, i32 4, i32* null, %struct.kernel_param_ops* @param_ops_int, i8* bitcast ([2 x i32]* @vccp_limit_type to i8*) }, align 8
@__param_vccp_limit_type = internal constant { i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } } { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__param_str_vccp_limit_type, i32 0, i32 0), %struct.kernel_param_ops* @param_array_ops, i16 0, i16 -1, { %struct.kparam_array* } { %struct.kparam_array* @__param_arr_vccp_limit_type } }, section "__param", align 8
@__param_str_vid_agtl = internal constant [14 x i8] c"lm93.vid_agtl\00", align 1
@param_ops_int = external global %struct.kernel_param_ops, align 8
@vid_agtl = internal global i32 0, align 4
@__param_vid_agtl = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_vid_agtl, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.31 { i8* bitcast (i32* @vid_agtl to i8*) } }, section "__param", align 8
@__initcall_lm93_driver_init6 = internal global i32 ()* @lm93_driver_init, section ".initcall6.init", align 8
@lm93_driver = internal global %struct.i2c_driver { i32 1, i32 (%struct.i2c_adapter*)* null, i32 (%struct.i2c_client*, %struct.i2c_device_id*)* @lm93_probe, i32 (%struct.i2c_client*)* @lm93_remove, void (%struct.i2c_client*)* null, i32 (%struct.i2c_client*, i32)* null, i32 (%struct.i2c_client*)* null, void (%struct.i2c_client*, i32)* null, i32 (%struct.i2c_client*, i32, i8*)* null, %struct.device_driver { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* null, %struct.driver_private* null }, %struct.i2c_device_id* getelementptr inbounds ([3 x %struct.i2c_device_id], [3 x %struct.i2c_device_id]* @lm93_id, i32 0, i32 0), i32 (%struct.i2c_client*, %struct.i2c_board_info*)* @lm93_detect, i16* getelementptr inbounds ([4 x i16], [4 x i16]* @normal_i2c, i32 0, i32 0), %struct.list_head zeroinitializer }, align 8
@__exitcall_lm93_driver_exit = internal global void ()* @lm93_driver_exit, section ".exitcall.exit", align 8
@smp_ops = external global %struct.smp_ops, align 8
@vccp_limit_type = internal global [2 x i32] zeroinitializer, align 4
@.str = private unnamed_addr constant [5 x i8] c"lm93\00", align 1
@lm93_id = internal constant [3 x %struct.i2c_device_id] [%struct.i2c_device_id { [20 x i8] c"lm93\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i64 0 }, %struct.i2c_device_id { [20 x i8] c"lm94\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00", i64 0 }, %struct.i2c_device_id zeroinitializer], align 16
@normal_i2c = internal constant [4 x i16] [i16 44, i16 45, i16 46, i16 -2], align 2
@lm93_probe.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.1 = private unnamed_addr constant [19 x i8] c"&data->update_lock\00", align 1
@lm93_attr_grp = internal global %struct.attribute_group { i8* null, i16 (%struct.kobject*, %struct.attribute*, i32)* null, %struct.attribute** getelementptr inbounds ([153 x %struct.attribute*], [153 x %struct.attribute*]* @lm93_attrs, i32 0, i32 0) }, align 8
@.str.2 = private unnamed_addr constant [33 x i8] c"error registering hwmon device.\0A\00", align 1
@lm93_block_read_cmds = internal constant [12 x %struct.anon.36] [%struct.anon.36 { i8 -14, i8 8 }, %struct.anon.36 { i8 -13, i8 8 }, %struct.anon.36 { i8 -12, i8 6 }, %struct.anon.36 { i8 -11, i8 16 }, %struct.anon.36 { i8 -10, i8 4 }, %struct.anon.36 { i8 -9, i8 8 }, %struct.anon.36 { i8 -8, i8 12 }, %struct.anon.36 { i8 -7, i8 32 }, %struct.anon.36 { i8 -6, i8 8 }, %struct.anon.36 { i8 -5, i8 8 }, %struct.anon.36 { i8 -4, i8 16 }, %struct.anon.36 { i8 -3, i8 9 }], align 16
@lm93_block_buffer = internal global [32 x i8] zeroinitializer, align 16
@.str.3 = private unnamed_addr constant [47 x i8] c"lm93: block read data failed, command 0x%02x.\0A\00", align 1
@.str.4 = private unnamed_addr constant [46 x i8] c"lm93: read byte data failed, address 0x%02x.\0A\00", align 1
@.str.5 = private unnamed_addr constant [38 x i8] c"lm93: All read byte retries failed!!\0A\00", align 1
@.str.6 = private unnamed_addr constant [57 x i8] c"lm93: write byte data failed, 0x%02x at address 0x%02x.\0A\00", align 1
@.str.7 = private unnamed_addr constant [46 x i8] c"lm93: read word data failed, address 0x%02x.\0A\00", align 1
@.str.8 = private unnamed_addr constant [38 x i8] c"lm93: All read word retries failed!!\0A\00", align 1
@.str.9 = private unnamed_addr constant [52 x i8] c"timed out waiting for sensor chip to signal ready!\0A\00", align 1
@lm93_attrs = internal global [153 x %struct.attribute*] [%struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in5_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in6_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in7_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in8_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in9_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in10_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in11_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in12_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in13_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in14_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in15_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in16_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in5_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in6_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in7_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in8_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in9_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in10_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in11_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in12_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in13_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in14_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in15_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in16_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in4_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in5_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in6_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in7_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in8_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in9_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in10_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in11_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in12_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in13_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in14_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in15_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_in16_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_base, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_base, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_base, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_boost, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_boost, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_boost, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_boost_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_boost_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_boost_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset3, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset4, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset5, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset6, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset7, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset8, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset9, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset10, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset11, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp1_auto_offset12, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset3, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset4, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset5, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset6, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset7, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset8, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset9, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset10, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset11, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp2_auto_offset12, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset3, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset4, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset5, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset6, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset7, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset8, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset9, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset10, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset11, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* @sensor_dev_attr_temp3_auto_offset12, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_pwm_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_pwm_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_pwm_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp1_auto_offset_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp2_auto_offset_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_temp3_auto_offset_hyst, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan3_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan4_input, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan3_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan4_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan1_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan2_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan3_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_fan4_smart_tach, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_enable, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_enable, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_freq, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_freq, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_auto_channels, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_auto_channels, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_auto_spinup_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_auto_spinup_min, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm1_auto_spinup_time, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_pwm2_auto_spinup_time, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_pwm_auto_prochot_ramp, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_pwm_auto_vrdhot_ramp, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_cpu0_vid, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_cpu1_vid, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_avg, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_avg, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_max, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_override, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_override, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot1_interval, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_prochot2_interval, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_prochot_override_duty_cycle, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_prochot_short, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_vrdhot1, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.sensor_device_attribute, %struct.sensor_device_attribute* @sensor_dev_attr_vrdhot2, i32 0, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_gpio, i32 0, i32 0), %struct.attribute* getelementptr inbounds (%struct.device_attribute, %struct.device_attribute* @dev_attr_alarms, i32 0, i32 0), %struct.attribute* null], align 16
@sensor_dev_attr_in1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.10, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_in2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.12, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_in3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_in4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_in5_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.15, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 4 }, align 8
@sensor_dev_attr_in6_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.16, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 5 }, align 8
@sensor_dev_attr_in7_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.17, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 6 }, align 8
@sensor_dev_attr_in8_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.18, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 7 }, align 8
@sensor_dev_attr_in9_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.19, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 8 }, align 8
@sensor_dev_attr_in10_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.20, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 9 }, align 8
@sensor_dev_attr_in11_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.21, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 10 }, align 8
@sensor_dev_attr_in12_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.22, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 11 }, align 8
@sensor_dev_attr_in13_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.23, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 12 }, align 8
@sensor_dev_attr_in14_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.24, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 13 }, align 8
@sensor_dev_attr_in15_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.25, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 14 }, align 8
@sensor_dev_attr_in16_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.26, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 15 }, align 8
@sensor_dev_attr_in1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.27, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 0 }, align 8
@sensor_dev_attr_in2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.29, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 1 }, align 8
@sensor_dev_attr_in3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.30, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 2 }, align 8
@sensor_dev_attr_in4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.31, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 3 }, align 8
@sensor_dev_attr_in5_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.32, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 4 }, align 8
@sensor_dev_attr_in6_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.33, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 5 }, align 8
@sensor_dev_attr_in7_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.34, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 6 }, align 8
@sensor_dev_attr_in8_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.35, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 7 }, align 8
@sensor_dev_attr_in9_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 8 }, align 8
@sensor_dev_attr_in10_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.37, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 9 }, align 8
@sensor_dev_attr_in11_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.38, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 10 }, align 8
@sensor_dev_attr_in12_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 11 }, align 8
@sensor_dev_attr_in13_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.40, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 12 }, align 8
@sensor_dev_attr_in14_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.41, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 13 }, align 8
@sensor_dev_attr_in15_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.42, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 14 }, align 8
@sensor_dev_attr_in16_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.43, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_min }, i32 15 }, align 8
@sensor_dev_attr_in1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 0 }, align 8
@sensor_dev_attr_in2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.45, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 1 }, align 8
@sensor_dev_attr_in3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 2 }, align 8
@sensor_dev_attr_in4_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 3 }, align 8
@sensor_dev_attr_in5_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.48, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 4 }, align 8
@sensor_dev_attr_in6_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 5 }, align 8
@sensor_dev_attr_in7_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.50, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 6 }, align 8
@sensor_dev_attr_in8_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.51, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 7 }, align 8
@sensor_dev_attr_in9_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.52, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 8 }, align 8
@sensor_dev_attr_in10_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.53, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 9 }, align 8
@sensor_dev_attr_in11_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.54, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 10 }, align 8
@sensor_dev_attr_in12_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.55, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 11 }, align 8
@sensor_dev_attr_in13_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.56, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 12 }, align 8
@sensor_dev_attr_in14_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.57, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 13 }, align 8
@sensor_dev_attr_in15_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.58, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 14 }, align 8
@sensor_dev_attr_in16_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.59, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_in_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_in_max }, i32 15 }, align 8
@sensor_dev_attr_temp1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.60, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_temp2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.61, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_temp3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.62, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_temp1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.63, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_min }, i32 0 }, align 8
@sensor_dev_attr_temp2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.64, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_min }, i32 1 }, align 8
@sensor_dev_attr_temp3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.65, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_min }, i32 2 }, align 8
@sensor_dev_attr_temp1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.66, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_max }, i32 0 }, align 8
@sensor_dev_attr_temp2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.67, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_max }, i32 1 }, align 8
@sensor_dev_attr_temp3_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.68, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_max }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_base = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.69, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_base, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_base }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_base = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.70, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_base, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_base }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_base = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.71, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_base, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_base }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_boost = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.72, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_boost = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.73, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_boost = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.74, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_boost_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.75, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost_hyst }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_boost_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.76, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost_hyst }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_boost_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.77, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_boost_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_boost_hyst }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_offset1 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.78, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 0 }, align 8
@sensor_dev_attr_temp1_auto_offset2 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.79, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 1 }, align 8
@sensor_dev_attr_temp1_auto_offset3 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.80, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 2 }, align 8
@sensor_dev_attr_temp1_auto_offset4 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.81, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 3 }, align 8
@sensor_dev_attr_temp1_auto_offset5 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.82, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 4 }, align 8
@sensor_dev_attr_temp1_auto_offset6 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.83, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 5 }, align 8
@sensor_dev_attr_temp1_auto_offset7 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.84, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 6 }, align 8
@sensor_dev_attr_temp1_auto_offset8 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.85, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 7 }, align 8
@sensor_dev_attr_temp1_auto_offset9 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.86, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 8 }, align 8
@sensor_dev_attr_temp1_auto_offset10 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.87, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 9 }, align 8
@sensor_dev_attr_temp1_auto_offset11 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.88, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 10 }, align 8
@sensor_dev_attr_temp1_auto_offset12 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.89, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 0, i8 11 }, align 8
@sensor_dev_attr_temp2_auto_offset1 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.90, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 0 }, align 8
@sensor_dev_attr_temp2_auto_offset2 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.91, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 1 }, align 8
@sensor_dev_attr_temp2_auto_offset3 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.92, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 2 }, align 8
@sensor_dev_attr_temp2_auto_offset4 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.93, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 3 }, align 8
@sensor_dev_attr_temp2_auto_offset5 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.94, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 4 }, align 8
@sensor_dev_attr_temp2_auto_offset6 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.95, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 5 }, align 8
@sensor_dev_attr_temp2_auto_offset7 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.96, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 6 }, align 8
@sensor_dev_attr_temp2_auto_offset8 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.97, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 7 }, align 8
@sensor_dev_attr_temp2_auto_offset9 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.98, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 8 }, align 8
@sensor_dev_attr_temp2_auto_offset10 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.99, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 9 }, align 8
@sensor_dev_attr_temp2_auto_offset11 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.100, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 10 }, align 8
@sensor_dev_attr_temp2_auto_offset12 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.101, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 1, i8 11 }, align 8
@sensor_dev_attr_temp3_auto_offset1 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.102, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 0 }, align 8
@sensor_dev_attr_temp3_auto_offset2 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.103, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 1 }, align 8
@sensor_dev_attr_temp3_auto_offset3 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.104, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 2 }, align 8
@sensor_dev_attr_temp3_auto_offset4 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.105, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 3 }, align 8
@sensor_dev_attr_temp3_auto_offset5 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.106, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 4 }, align 8
@sensor_dev_attr_temp3_auto_offset6 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.107, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 5 }, align 8
@sensor_dev_attr_temp3_auto_offset7 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.108, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 6 }, align 8
@sensor_dev_attr_temp3_auto_offset8 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.109, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 7 }, align 8
@sensor_dev_attr_temp3_auto_offset9 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.110, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 8 }, align 8
@sensor_dev_attr_temp3_auto_offset10 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.111, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 9 }, align 8
@sensor_dev_attr_temp3_auto_offset11 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.112, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 10 }, align 8
@sensor_dev_attr_temp3_auto_offset12 = internal global %struct.sensor_device_attribute_2 { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.113, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset }, i8 2, i8 11 }, align 8
@sensor_dev_attr_temp1_auto_pwm_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.114, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_pwm_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_pwm_min }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_pwm_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.115, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_pwm_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_pwm_min }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_pwm_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.116, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_pwm_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_pwm_min }, i32 2 }, align 8
@sensor_dev_attr_temp1_auto_offset_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.117, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset_hyst }, i32 0 }, align 8
@sensor_dev_attr_temp2_auto_offset_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.118, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset_hyst }, i32 1 }, align 8
@sensor_dev_attr_temp3_auto_offset_hyst = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.119, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_temp_auto_offset_hyst, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_temp_auto_offset_hyst }, i32 2 }, align 8
@sensor_dev_attr_fan1_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.120, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_fan2_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.121, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_fan3_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.122, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 2 }, align 8
@sensor_dev_attr_fan4_input = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.123, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_input, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 3 }, align 8
@sensor_dev_attr_fan1_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.124, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 0 }, align 8
@sensor_dev_attr_fan2_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.126, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 1 }, align 8
@sensor_dev_attr_fan3_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.127, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 2 }, align 8
@sensor_dev_attr_fan4_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.128, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_min }, i32 3 }, align 8
@sensor_dev_attr_fan1_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.129, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 0 }, align 8
@sensor_dev_attr_fan2_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.130, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 1 }, align 8
@sensor_dev_attr_fan3_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.131, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 2 }, align 8
@sensor_dev_attr_fan4_smart_tach = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.132, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_fan_smart_tach, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_fan_smart_tach }, i32 3 }, align 8
@sensor_dev_attr_pwm1 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.133, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, i32 0 }, align 8
@sensor_dev_attr_pwm2 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.134, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm }, i32 1 }, align 8
@sensor_dev_attr_pwm1_enable = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.135, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_enable, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_enable }, i32 0 }, align 8
@sensor_dev_attr_pwm2_enable = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.136, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_enable, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_enable }, i32 1 }, align 8
@sensor_dev_attr_pwm1_freq = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.137, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_freq, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_freq }, i32 0 }, align 8
@sensor_dev_attr_pwm2_freq = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.138, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_freq, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_freq }, i32 1 }, align 8
@sensor_dev_attr_pwm1_auto_channels = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.139, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_channels, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_channels }, i32 0 }, align 8
@sensor_dev_attr_pwm2_auto_channels = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.140, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_channels, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_channels }, i32 1 }, align 8
@sensor_dev_attr_pwm1_auto_spinup_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.141, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_min }, i32 0 }, align 8
@sensor_dev_attr_pwm2_auto_spinup_min = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.142, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_min, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_min }, i32 1 }, align 8
@sensor_dev_attr_pwm1_auto_spinup_time = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.143, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_time, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_time }, i32 0 }, align 8
@sensor_dev_attr_pwm2_auto_spinup_time = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.144, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_spinup_time, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_spinup_time }, i32 1 }, align 8
@dev_attr_pwm_auto_prochot_ramp = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.145, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_prochot_ramp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_prochot_ramp }, align 8
@dev_attr_pwm_auto_vrdhot_ramp = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.146, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_pwm_auto_vrdhot_ramp, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_pwm_auto_vrdhot_ramp }, align 8
@sensor_dev_attr_cpu0_vid = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.147, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vid, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_cpu1_vid = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.148, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vid, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_prochot1 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.149, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_prochot2 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.150, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_prochot1_avg = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.151, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_avg, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_prochot2_avg = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.152, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_avg, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@sensor_dev_attr_prochot1_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.153, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_max }, i32 0 }, align 8
@sensor_dev_attr_prochot2_max = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.154, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_max, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_max }, i32 1 }, align 8
@sensor_dev_attr_prochot1_override = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.155, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_override, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_override }, i32 0 }, align 8
@sensor_dev_attr_prochot2_override = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.156, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_override, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_override }, i32 1 }, align 8
@sensor_dev_attr_prochot1_interval = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.157, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_interval, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_interval }, i32 0 }, align 8
@sensor_dev_attr_prochot2_interval = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.158, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_interval, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_interval }, i32 1 }, align 8
@dev_attr_prochot_override_duty_cycle = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.159, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_override_duty_cycle, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_override_duty_cycle }, align 8
@dev_attr_prochot_short = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.160, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_prochot_short, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @store_prochot_short }, align 8
@sensor_dev_attr_vrdhot1 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.161, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vrdhot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 0 }, align 8
@sensor_dev_attr_vrdhot2 = internal global %struct.sensor_device_attribute { %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.162, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_vrdhot, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, i32 1 }, align 8
@dev_attr_gpio = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.163, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_gpio, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@dev_attr_alarms = internal global %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.164, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @show_alarms, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, align 8
@.str.10 = private unnamed_addr constant [10 x i8] c"in1_input\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@jiffies = external global i64, align 8
@lm93_vin_val_max = internal constant [16 x i64] [i64 1236, i64 1236, i64 1236, i64 1600, i64 2000, i64 2000, i64 1600, i64 1600, i64 4400, i64 6500, i64 3333, i64 2625, i64 1312, i64 1312, i64 1236, i64 3600], align 16
@lm93_vin_val_min = internal constant [16 x i64] [i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 3000], align 16
@lm93_vin_reg_max = internal constant [16 x i8] c"\FF\FF\FF\FF\FF\FF\FF\FF\FF\FA\FF\FF\FF\FF\FF\D1", align 16
@lm93_vin_reg_min = internal constant [16 x i8] c"\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\AE", align 16
@.str.12 = private unnamed_addr constant [10 x i8] c"in2_input\00", align 1
@.str.13 = private unnamed_addr constant [10 x i8] c"in3_input\00", align 1
@.str.14 = private unnamed_addr constant [10 x i8] c"in4_input\00", align 1
@.str.15 = private unnamed_addr constant [10 x i8] c"in5_input\00", align 1
@.str.16 = private unnamed_addr constant [10 x i8] c"in6_input\00", align 1
@.str.17 = private unnamed_addr constant [10 x i8] c"in7_input\00", align 1
@.str.18 = private unnamed_addr constant [10 x i8] c"in8_input\00", align 1
@.str.19 = private unnamed_addr constant [10 x i8] c"in9_input\00", align 1
@.str.20 = private unnamed_addr constant [11 x i8] c"in10_input\00", align 1
@.str.21 = private unnamed_addr constant [11 x i8] c"in11_input\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"in12_input\00", align 1
@.str.23 = private unnamed_addr constant [11 x i8] c"in13_input\00", align 1
@.str.24 = private unnamed_addr constant [11 x i8] c"in14_input\00", align 1
@.str.25 = private unnamed_addr constant [11 x i8] c"in15_input\00", align 1
@.str.26 = private unnamed_addr constant [11 x i8] c"in16_input\00", align 1
@.str.27 = private unnamed_addr constant [8 x i8] c"in1_min\00", align 1
@.str.28 = private unnamed_addr constant [5 x i8] c"%ld\0A\00", align 1
@.str.29 = private unnamed_addr constant [8 x i8] c"in2_min\00", align 1
@.str.30 = private unnamed_addr constant [8 x i8] c"in3_min\00", align 1
@.str.31 = private unnamed_addr constant [8 x i8] c"in4_min\00", align 1
@.str.32 = private unnamed_addr constant [8 x i8] c"in5_min\00", align 1
@.str.33 = private unnamed_addr constant [8 x i8] c"in6_min\00", align 1
@.str.34 = private unnamed_addr constant [8 x i8] c"in7_min\00", align 1
@.str.35 = private unnamed_addr constant [8 x i8] c"in8_min\00", align 1
@.str.36 = private unnamed_addr constant [8 x i8] c"in9_min\00", align 1
@.str.37 = private unnamed_addr constant [9 x i8] c"in10_min\00", align 1
@.str.38 = private unnamed_addr constant [9 x i8] c"in11_min\00", align 1
@.str.39 = private unnamed_addr constant [9 x i8] c"in12_min\00", align 1
@.str.40 = private unnamed_addr constant [9 x i8] c"in13_min\00", align 1
@.str.41 = private unnamed_addr constant [9 x i8] c"in14_min\00", align 1
@.str.42 = private unnamed_addr constant [9 x i8] c"in15_min\00", align 1
@.str.43 = private unnamed_addr constant [9 x i8] c"in16_min\00", align 1
@.str.44 = private unnamed_addr constant [8 x i8] c"in1_max\00", align 1
@.str.45 = private unnamed_addr constant [8 x i8] c"in2_max\00", align 1
@.str.46 = private unnamed_addr constant [8 x i8] c"in3_max\00", align 1
@.str.47 = private unnamed_addr constant [8 x i8] c"in4_max\00", align 1
@.str.48 = private unnamed_addr constant [8 x i8] c"in5_max\00", align 1
@.str.49 = private unnamed_addr constant [8 x i8] c"in6_max\00", align 1
@.str.50 = private unnamed_addr constant [8 x i8] c"in7_max\00", align 1
@.str.51 = private unnamed_addr constant [8 x i8] c"in8_max\00", align 1
@.str.52 = private unnamed_addr constant [8 x i8] c"in9_max\00", align 1
@.str.53 = private unnamed_addr constant [9 x i8] c"in10_max\00", align 1
@.str.54 = private unnamed_addr constant [9 x i8] c"in11_max\00", align 1
@.str.55 = private unnamed_addr constant [9 x i8] c"in12_max\00", align 1
@.str.56 = private unnamed_addr constant [9 x i8] c"in13_max\00", align 1
@.str.57 = private unnamed_addr constant [9 x i8] c"in14_max\00", align 1
@.str.58 = private unnamed_addr constant [9 x i8] c"in15_max\00", align 1
@.str.59 = private unnamed_addr constant [9 x i8] c"in16_max\00", align 1
@.str.60 = private unnamed_addr constant [12 x i8] c"temp1_input\00", align 1
@.str.61 = private unnamed_addr constant [12 x i8] c"temp2_input\00", align 1
@.str.62 = private unnamed_addr constant [12 x i8] c"temp3_input\00", align 1
@.str.63 = private unnamed_addr constant [10 x i8] c"temp1_min\00", align 1
@.str.64 = private unnamed_addr constant [10 x i8] c"temp2_min\00", align 1
@.str.65 = private unnamed_addr constant [10 x i8] c"temp3_min\00", align 1
@.str.66 = private unnamed_addr constant [10 x i8] c"temp1_max\00", align 1
@.str.67 = private unnamed_addr constant [10 x i8] c"temp2_max\00", align 1
@.str.68 = private unnamed_addr constant [10 x i8] c"temp3_max\00", align 1
@.str.69 = private unnamed_addr constant [16 x i8] c"temp1_auto_base\00", align 1
@.str.70 = private unnamed_addr constant [16 x i8] c"temp2_auto_base\00", align 1
@.str.71 = private unnamed_addr constant [16 x i8] c"temp3_auto_base\00", align 1
@.str.72 = private unnamed_addr constant [17 x i8] c"temp1_auto_boost\00", align 1
@.str.73 = private unnamed_addr constant [17 x i8] c"temp2_auto_boost\00", align 1
@.str.74 = private unnamed_addr constant [17 x i8] c"temp3_auto_boost\00", align 1
@.str.75 = private unnamed_addr constant [22 x i8] c"temp1_auto_boost_hyst\00", align 1
@.str.76 = private unnamed_addr constant [22 x i8] c"temp2_auto_boost_hyst\00", align 1
@.str.77 = private unnamed_addr constant [22 x i8] c"temp3_auto_boost_hyst\00", align 1
@.str.78 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset1\00", align 1
@.str.79 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset2\00", align 1
@.str.80 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset3\00", align 1
@.str.81 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset4\00", align 1
@.str.82 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset5\00", align 1
@.str.83 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset6\00", align 1
@.str.84 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset7\00", align 1
@.str.85 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset8\00", align 1
@.str.86 = private unnamed_addr constant [19 x i8] c"temp1_auto_offset9\00", align 1
@.str.87 = private unnamed_addr constant [20 x i8] c"temp1_auto_offset10\00", align 1
@.str.88 = private unnamed_addr constant [20 x i8] c"temp1_auto_offset11\00", align 1
@.str.89 = private unnamed_addr constant [20 x i8] c"temp1_auto_offset12\00", align 1
@.str.90 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset1\00", align 1
@.str.91 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset2\00", align 1
@.str.92 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset3\00", align 1
@.str.93 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset4\00", align 1
@.str.94 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset5\00", align 1
@.str.95 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset6\00", align 1
@.str.96 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset7\00", align 1
@.str.97 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset8\00", align 1
@.str.98 = private unnamed_addr constant [19 x i8] c"temp2_auto_offset9\00", align 1
@.str.99 = private unnamed_addr constant [20 x i8] c"temp2_auto_offset10\00", align 1
@.str.100 = private unnamed_addr constant [20 x i8] c"temp2_auto_offset11\00", align 1
@.str.101 = private unnamed_addr constant [20 x i8] c"temp2_auto_offset12\00", align 1
@.str.102 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset1\00", align 1
@.str.103 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset2\00", align 1
@.str.104 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset3\00", align 1
@.str.105 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset4\00", align 1
@.str.106 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset5\00", align 1
@.str.107 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset6\00", align 1
@.str.108 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset7\00", align 1
@.str.109 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset8\00", align 1
@.str.110 = private unnamed_addr constant [19 x i8] c"temp3_auto_offset9\00", align 1
@.str.111 = private unnamed_addr constant [20 x i8] c"temp3_auto_offset10\00", align 1
@.str.112 = private unnamed_addr constant [20 x i8] c"temp3_auto_offset11\00", align 1
@.str.113 = private unnamed_addr constant [20 x i8] c"temp3_auto_offset12\00", align 1
@.str.114 = private unnamed_addr constant [19 x i8] c"temp1_auto_pwm_min\00", align 1
@lm93_pwm_map = internal global [2 x [16 x i32]] [[16 x i32] [i32 0, i32 64, i32 80, i32 96, i32 112, i32 128, i32 144, i32 160, i32 176, i32 192, i32 208, i32 224, i32 240, i32 255, i32 255, i32 255], [16 x i32] [i32 0, i32 64, i32 73, i32 82, i32 91, i32 100, i32 109, i32 118, i32 128, i32 137, i32 146, i32 182, i32 219, i32 255, i32 255, i32 255]], align 16
@.str.115 = private unnamed_addr constant [19 x i8] c"temp2_auto_pwm_min\00", align 1
@.str.116 = private unnamed_addr constant [19 x i8] c"temp3_auto_pwm_min\00", align 1
@.str.117 = private unnamed_addr constant [23 x i8] c"temp1_auto_offset_hyst\00", align 1
@.str.118 = private unnamed_addr constant [23 x i8] c"temp2_auto_offset_hyst\00", align 1
@.str.119 = private unnamed_addr constant [23 x i8] c"temp3_auto_offset_hyst\00", align 1
@.str.120 = private unnamed_addr constant [11 x i8] c"fan1_input\00", align 1
@.str.121 = private unnamed_addr constant [11 x i8] c"fan2_input\00", align 1
@.str.122 = private unnamed_addr constant [11 x i8] c"fan3_input\00", align 1
@.str.123 = private unnamed_addr constant [11 x i8] c"fan4_input\00", align 1
@.str.124 = private unnamed_addr constant [9 x i8] c"fan1_min\00", align 1
@.str.125 = private unnamed_addr constant [57 x i8] c"lm93: write word data failed, 0x%04x at address 0x%02x.\0A\00", align 1
@.str.126 = private unnamed_addr constant [9 x i8] c"fan2_min\00", align 1
@.str.127 = private unnamed_addr constant [9 x i8] c"fan3_min\00", align 1
@.str.128 = private unnamed_addr constant [9 x i8] c"fan4_min\00", align 1
@.str.129 = private unnamed_addr constant [16 x i8] c"fan1_smart_tach\00", align 1
@.str.130 = private unnamed_addr constant [16 x i8] c"fan2_smart_tach\00", align 1
@.str.131 = private unnamed_addr constant [16 x i8] c"fan3_smart_tach\00", align 1
@.str.132 = private unnamed_addr constant [16 x i8] c"fan4_smart_tach\00", align 1
@.str.133 = private unnamed_addr constant [5 x i8] c"pwm1\00", align 1
@.str.134 = private unnamed_addr constant [5 x i8] c"pwm2\00", align 1
@.str.135 = private unnamed_addr constant [12 x i8] c"pwm1_enable\00", align 1
@.str.136 = private unnamed_addr constant [12 x i8] c"pwm2_enable\00", align 1
@.str.137 = private unnamed_addr constant [10 x i8] c"pwm1_freq\00", align 1
@lm93_pwm_freq_map = internal global [8 x i32] [i32 22500, i32 96, i32 84, i32 72, i32 60, i32 48, i32 36, i32 12], align 16
@.str.138 = private unnamed_addr constant [10 x i8] c"pwm2_freq\00", align 1
@.str.139 = private unnamed_addr constant [19 x i8] c"pwm1_auto_channels\00", align 1
@.str.140 = private unnamed_addr constant [19 x i8] c"pwm2_auto_channels\00", align 1
@.str.141 = private unnamed_addr constant [21 x i8] c"pwm1_auto_spinup_min\00", align 1
@.str.142 = private unnamed_addr constant [21 x i8] c"pwm2_auto_spinup_min\00", align 1
@.str.143 = private unnamed_addr constant [22 x i8] c"pwm1_auto_spinup_time\00", align 1
@lm93_spinup_time_map = internal global [8 x i32] [i32 0, i32 10, i32 25, i32 40, i32 70, i32 100, i32 200, i32 400], align 16
@.str.144 = private unnamed_addr constant [22 x i8] c"pwm2_auto_spinup_time\00", align 1
@.str.145 = private unnamed_addr constant [22 x i8] c"pwm_auto_prochot_ramp\00", align 1
@.str.146 = private unnamed_addr constant [21 x i8] c"pwm_auto_vrdhot_ramp\00", align 1
@.str.147 = private unnamed_addr constant [9 x i8] c"cpu0_vid\00", align 1
@.str.148 = private unnamed_addr constant [9 x i8] c"cpu1_vid\00", align 1
@.str.149 = private unnamed_addr constant [9 x i8] c"prochot1\00", align 1
@.str.150 = private unnamed_addr constant [9 x i8] c"prochot2\00", align 1
@.str.151 = private unnamed_addr constant [13 x i8] c"prochot1_avg\00", align 1
@.str.152 = private unnamed_addr constant [13 x i8] c"prochot2_avg\00", align 1
@.str.153 = private unnamed_addr constant [13 x i8] c"prochot1_max\00", align 1
@.str.154 = private unnamed_addr constant [13 x i8] c"prochot2_max\00", align 1
@.str.155 = private unnamed_addr constant [18 x i8] c"prochot1_override\00", align 1
@prochot_override_mask = internal constant [2 x i8] c"\80@", align 1
@.str.156 = private unnamed_addr constant [18 x i8] c"prochot2_override\00", align 1
@.str.157 = private unnamed_addr constant [18 x i8] c"prochot1_interval\00", align 1
@lm93_interval_map = internal global [10 x i32] [i32 73, i32 146, i32 290, i32 580, i32 1170, i32 2330, i32 4660, i32 9320, i32 18600, i32 37200], align 16
@.str.158 = private unnamed_addr constant [18 x i8] c"prochot2_interval\00", align 1
@.str.159 = private unnamed_addr constant [28 x i8] c"prochot_override_duty_cycle\00", align 1
@.str.160 = private unnamed_addr constant [14 x i8] c"prochot_short\00", align 1
@.str.161 = private unnamed_addr constant [8 x i8] c"vrdhot1\00", align 1
@.str.162 = private unnamed_addr constant [8 x i8] c"vrdhot2\00", align 1
@.str.163 = private unnamed_addr constant [5 x i8] c"gpio\00", align 1
@.str.164 = private unnamed_addr constant [7 x i8] c"alarms\00", align 1
@.str.165 = private unnamed_addr constant [5 x i8] c"lm94\00", align 1
@llvm.used = appending global [7 x i8*] [i8* bitcast (%struct.kernel_param* @__param_disable_block to i8*), i8* bitcast (%struct.kernel_param* @__param_init to i8*), i8* bitcast ({ i8*, %struct.kernel_param_ops*, i16, i16, { %struct.kparam_array* } }* @__param_vccp_limit_type to i8*), i8* bitcast (%struct.kernel_param* @__param_vid_agtl to i8*), i8* bitcast (i32 ()** @__initcall_lm93_driver_init6 to i8*), i8* bitcast (void ()* @lm93_driver_exit to i8*), i8* bitcast (void ()** @__exitcall_lm93_driver_exit to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_driver_init() #1 section ".init.text" {
entry:
  %call = call i32 @i2c_register_driver(%struct.module* null, %struct.i2c_driver* @lm93_driver)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @lm93_driver_exit() #1 section ".exit.text" {
entry:
  call void @i2c_del_driver(%struct.i2c_driver* @lm93_driver)
  ret void
}

declare void @i2c_del_driver(%struct.i2c_driver*) #2

declare i32 @i2c_register_driver(%struct.module*, %struct.i2c_driver*) #2

; Function Attrs: nounwind uwtable
define internal i32 @lm93_probe(%struct.i2c_client* %client, %struct.i2c_device_id* %id) #1 {
entry:
  %adapter = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 3
  %0 = load %struct.i2c_adapter*, %struct.i2c_adapter** %adapter, align 8, !tbaa !12
  %call = call i32 @i2c_get_functionality(%struct.i2c_adapter* %0)
  %and = and i32 58195968, %call
  %cmp = icmp eq i32 %and, 58195968
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @disable_block, align 1, !tbaa !32, !range !33
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.else, label %if.end7

if.else:                                          ; preds = %land.lhs.true, %entry
  %and1 = and i32 7864320, %call
  %cmp2 = icmp eq i32 %and1, 7864320
  br i1 %cmp2, label %if.end7, label %cleanup

if.end7:                                          ; preds = %if.else, %land.lhs.true
  %update.0 = phi void (%struct.lm93_data*, %struct.i2c_client*)* [ @lm93_update_client_full, %land.lhs.true ], [ @lm93_update_client_min, %if.else ]
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %call8 = call i8* @devm_kzalloc(%struct.device* %dev, i64 208, i32 208)
  %2 = bitcast i8* %call8 to %struct.lm93_data*
  %tobool9 = icmp ne %struct.lm93_data* %2, null
  br i1 %tobool9, label %if.end12, label %cleanup

if.end12:                                         ; preds = %if.end7
  %3 = bitcast %struct.lm93_data* %2 to i8*
  call void @i2c_set_clientdata(%struct.i2c_client* %client, i8* %3)
  %valid = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 4
  store i8 0, i8* %valid, align 8, !tbaa !34
  %update13 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 3
  store void (%struct.lm93_data*, %struct.i2c_client*)* %update.0, void (%struct.lm93_data*, %struct.i2c_client*)** %update13, align 8, !tbaa !39
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @__mutex_init(%struct.mutex* %update_lock, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.1, i32 0, i32 0), %struct.lock_class_key* @lm93_probe.__key)
  call void @lm93_init_client(%struct.i2c_client* %client)
  %dev14 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev14, i32 0, i32 2
  %call15 = call i32 @sysfs_create_group(%struct.kobject* %kobj, %struct.attribute_group* @lm93_attr_grp)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end12
  %dev19 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %call20 = call %struct.device* @hwmon_device_register(%struct.device* %dev19)
  %hwmon_dev = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 0
  store %struct.device* %call20, %struct.device** %hwmon_dev, align 8, !tbaa !40
  %hwmon_dev21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 0
  %4 = load %struct.device*, %struct.device** %hwmon_dev21, align 8, !tbaa !40
  %5 = bitcast %struct.device* %4 to i8*
  %call22 = call i64 @IS_ERR(i8* %5)
  %tobool23 = icmp ne i64 %call22, 0
  br i1 %tobool23, label %if.end25, label %cleanup

if.end25:                                         ; preds = %if.end18
  %hwmon_dev26 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 0
  %6 = load %struct.device*, %struct.device** %hwmon_dev26, align 8, !tbaa !40
  %7 = bitcast %struct.device* %6 to i8*
  %call27 = call i64 @PTR_ERR(i8* %7)
  %conv = trunc i64 %call27 to i32
  %dev28 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %call29 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev28, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.2, i32 0, i32 0))
  %dev30 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %kobj31 = getelementptr inbounds %struct.device, %struct.device* %dev30, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj31, %struct.attribute_group* @lm93_attr_grp)
  br label %cleanup

cleanup:                                          ; preds = %if.end18, %if.end12, %if.end7, %if.else, %if.end25
  %retval.0 = phi i32 [ %conv, %if.end25 ], [ -19, %if.else ], [ -12, %if.end7 ], [ %call15, %if.end12 ], [ 0, %if.end18 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_remove(%struct.i2c_client* %client) #1 {
entry:
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %client)
  %0 = bitcast i8* %call to %struct.lm93_data*
  %hwmon_dev = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %0, i32 0, i32 0
  %1 = load %struct.device*, %struct.device** %hwmon_dev, align 8, !tbaa !40
  call void @hwmon_device_unregister(%struct.device* %1)
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  call void @sysfs_remove_group(%struct.kobject* %kobj, %struct.attribute_group* @lm93_attr_grp)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_detect(%struct.i2c_client* %client, %struct.i2c_board_info* %info) #1 {
entry:
  %adapter1 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 3
  %0 = load %struct.i2c_adapter*, %struct.i2c_adapter** %adapter1, align 8, !tbaa !12
  %call = call i32 @i2c_check_functionality(%struct.i2c_adapter* %0, i32 7864320)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext 62)
  %conv = zext i8 %call2 to i32
  %cmp = icmp ne i32 %conv, 1
  br i1 %cmp, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext 63)
  %conv7 = zext i8 %call6 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end5
  %Pivot = icmp slt i32 %conv7, 120
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %conv7.off2 = add i32 %conv7, -120
  %SwitchLeaf3 = icmp ule i32 %conv7.off2, 2
  br i1 %SwitchLeaf3, label %sw.bb8, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %conv7.off = add i32 %conv7, -114
  %SwitchLeaf = icmp ule i32 %conv7.off, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb8:                                           ; preds = %LeafBlock1
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock, %sw.bb8
  %name.0 = phi i8* [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.165, i32 0, i32 0), %sw.bb8 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), %LeafBlock ]
  %type = getelementptr inbounds %struct.i2c_board_info, %struct.i2c_board_info* %info, i32 0, i32 0
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %type, i32 0, i32 0
  %call10 = call i64 @strlcpy(i8* %arraydecay, i8* %name.0, i64 20)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %cleanup

cleanup:                                          ; preds = %NewDefault, %if.end, %entry, %sw.epilog
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -19, %entry ], [ -19, %if.end ], [ -19, %NewDefault ]
  ret i32 %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @i2c_get_functionality(%struct.i2c_adapter* %adap) #0 {
entry:
  %algo = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 2
  %0 = load %struct.i2c_algorithm*, %struct.i2c_algorithm** %algo, align 8, !tbaa !41
  %functionality = getelementptr inbounds %struct.i2c_algorithm, %struct.i2c_algorithm* %0, i32 0, i32 2
  %1 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %functionality, align 8, !tbaa !47
  %call = call i32 %1(%struct.i2c_adapter* %adap)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @lm93_update_client_full(%struct.lm93_data* %data, %struct.i2c_client* %client) #1 {
entry:
  %block3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 7
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %block3, i32 0, i32 0
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 3, i8* %arraydecay)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 11
  %arraydecay1 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block7, i32 0, i32 0
  %0 = bitcast %struct.anon.34* %arraydecay1 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 7, i8* %0)
  %block2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 6
  %arraydecay2 = getelementptr inbounds [6 x i8], [6 x i8]* %block2, i32 0, i32 0
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 2, i8* %arraydecay2)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 8
  %arraydecay3 = getelementptr inbounds [2 x %struct.anon.32], [2 x %struct.anon.32]* %block4, i32 0, i32 0
  %1 = bitcast %struct.anon.32* %arraydecay3 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 4, i8* %1)
  %block5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 9
  %arraydecay4 = getelementptr inbounds [4 x i16], [4 x i16]* %block5, i32 0, i32 0
  %2 = bitcast i16* %arraydecay4 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 5, i8* %2)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 12
  %arraydecay5 = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i32 0, i32 0
  %3 = bitcast i16* %arraydecay5 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 8, i8* %3)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 13
  %arraydecay6 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i32 0, i32 0
  %4 = bitcast [4 x i8]* %arraydecay6 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 9, i8* %4)
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 5
  %5 = bitcast %struct.block1_t* %block1 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 1, i8* %5)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 14
  %6 = bitcast %struct.anon.35* %block10 to i8*
  call void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext 10, i8* %6)
  call void @lm93_update_client_common(%struct.lm93_data* %data, %struct.i2c_client* %client)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @lm93_update_client_min(%struct.lm93_data* %data, %struct.i2c_client* %client) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %add = add nsw i32 86, %i.0
  %conv = trunc i32 %add to i8
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv)
  %block3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 7
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %block3, i64 0, i64 %idxprom
  store i8 %call, i8* %arrayidx, align 1, !tbaa !49
  %mul = mul nsw i32 %i.0, 2
  %add1 = add nsw i32 144, %mul
  %conv2 = trunc i32 %add1 to i8
  %call3 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv2)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 11
  %idxprom4 = sext i32 %i.0 to i64
  %arrayidx5 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block7, i64 0, i64 %idxprom4
  %min = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx5, i32 0, i32 0
  store i8 %call3, i8* %min, align 2, !tbaa !50
  %mul6 = mul nsw i32 %i.0, 2
  %add7 = add nsw i32 145, %mul6
  %conv8 = trunc i32 %add7 to i8
  %call9 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv8)
  %block710 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 11
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block710, i64 0, i64 %idxprom11
  %max = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx12, i32 0, i32 1
  store i8 %call9, i8* %max, align 1, !tbaa !52
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond13

for.cond13:                                       ; preds = %for.body16, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc23, %for.body16 ]
  %cmp14 = icmp slt i32 %i.1, 4
  br i1 %cmp14, label %for.body16, label %for.end24

for.body16:                                       ; preds = %for.cond13
  %add17 = add nsw i32 80, %i.1
  %conv18 = trunc i32 %add17 to i8
  %call19 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv18)
  %block2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 6
  %idxprom20 = sext i32 %i.1 to i64
  %arrayidx21 = getelementptr inbounds [6 x i8], [6 x i8]* %block2, i64 0, i64 %idxprom20
  store i8 %call19, i8* %arrayidx21, align 1, !tbaa !49
  %inc23 = add nsw i32 %i.1, 1
  br label %for.cond13

for.end24:                                        ; preds = %for.cond13
  br label %for.cond25

for.cond25:                                       ; preds = %for.body28, %for.end24
  %i.2 = phi i32 [ 0, %for.end24 ], [ %inc43, %for.body28 ]
  %cmp26 = icmp slt i32 %i.2, 2
  br i1 %cmp26, label %for.body28, label %for.end44

for.body28:                                       ; preds = %for.cond25
  %mul29 = mul nsw i32 %i.2, 2
  %add30 = add nsw i32 103, %mul29
  %conv31 = trunc i32 %add30 to i8
  %call32 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv31)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 8
  %idxprom33 = sext i32 %i.2 to i64
  %arrayidx34 = getelementptr inbounds [2 x %struct.anon.32], [2 x %struct.anon.32]* %block4, i64 0, i64 %idxprom33
  %cur = getelementptr inbounds %struct.anon.32, %struct.anon.32* %arrayidx34, i32 0, i32 0
  store i8 %call32, i8* %cur, align 1, !tbaa !50
  %mul35 = mul nsw i32 %i.2, 2
  %add36 = add nsw i32 104, %mul35
  %conv37 = trunc i32 %add36 to i8
  %call38 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv37)
  %block439 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 8
  %idxprom40 = sext i32 %i.2 to i64
  %arrayidx41 = getelementptr inbounds [2 x %struct.anon.32], [2 x %struct.anon.32]* %block439, i64 0, i64 %idxprom40
  %avg = getelementptr inbounds %struct.anon.32, %struct.anon.32* %arrayidx41, i32 0, i32 1
  store i8 %call38, i8* %avg, align 1, !tbaa !52
  %inc43 = add nsw i32 %i.2, 1
  br label %for.cond25

for.end44:                                        ; preds = %for.cond25
  br label %for.cond45

for.cond45:                                       ; preds = %for.body48, %for.end44
  %i.3 = phi i32 [ 0, %for.end44 ], [ %inc62, %for.body48 ]
  %cmp46 = icmp slt i32 %i.3, 4
  br i1 %cmp46, label %for.body48, label %for.end63

for.body48:                                       ; preds = %for.cond45
  %mul49 = mul nsw i32 %i.3, 2
  %add50 = add nsw i32 110, %mul49
  %conv51 = trunc i32 %add50 to i8
  %call52 = call zeroext i16 @lm93_read_word(%struct.i2c_client* %client, i8 zeroext %conv51)
  %block5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 9
  %idxprom53 = sext i32 %i.3 to i64
  %arrayidx54 = getelementptr inbounds [4 x i16], [4 x i16]* %block5, i64 0, i64 %idxprom53
  store i16 %call52, i16* %arrayidx54, align 2, !tbaa !53
  %mul55 = mul nsw i32 %i.3, 2
  %add56 = add nsw i32 180, %mul55
  %conv57 = trunc i32 %add56 to i8
  %call58 = call zeroext i16 @lm93_read_word(%struct.i2c_client* %client, i8 zeroext %conv57)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 12
  %idxprom59 = sext i32 %i.3 to i64
  %arrayidx60 = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i64 0, i64 %idxprom59
  store i16 %call58, i16* %arrayidx60, align 2, !tbaa !53
  %inc62 = add nsw i32 %i.3, 1
  br label %for.cond45

for.end63:                                        ; preds = %for.cond45
  br label %for.cond64

for.cond64:                                       ; preds = %for.inc84, %for.end63
  %i.4 = phi i32 [ 0, %for.end63 ], [ %inc85, %for.inc84 ]
  %cmp65 = icmp slt i32 %i.4, 2
  br i1 %cmp65, label %for.body67, label %for.end86

for.body67:                                       ; preds = %for.cond64
  br label %for.cond68

for.cond68:                                       ; preds = %for.body71, %for.body67
  %j.0 = phi i32 [ 0, %for.body67 ], [ %inc82, %for.body71 ]
  %cmp69 = icmp slt i32 %j.0, 4
  br i1 %cmp69, label %for.body71, label %for.inc84

for.body71:                                       ; preds = %for.cond68
  %add72 = add nsw i32 200, %j.0
  %mul73 = mul nsw i32 %i.4, 4
  %add74 = add nsw i32 %add72, %mul73
  %conv75 = trunc i32 %add74 to i8
  %call76 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv75)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 13
  %idxprom77 = sext i32 %i.4 to i64
  %arrayidx78 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom77
  %idxprom79 = sext i32 %j.0 to i64
  %arrayidx80 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx78, i64 0, i64 %idxprom79
  store i8 %call76, i8* %arrayidx80, align 1, !tbaa !49
  %inc82 = add nsw i32 %j.0, 1
  br label %for.cond68

for.inc84:                                        ; preds = %for.cond68
  %inc85 = add nsw i32 %i.4, 1
  br label %for.cond64

for.end86:                                        ; preds = %for.cond64
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 5
  %0 = bitcast %struct.block1_t* %block1 to i8*
  br label %for.cond87

for.cond87:                                       ; preds = %for.body90, %for.end86
  %i.5 = phi i32 [ 0, %for.end86 ], [ %inc95, %for.body90 ]
  %cmp88 = icmp slt i32 %i.5, 8
  br i1 %cmp88, label %for.body90, label %for.end96

for.body90:                                       ; preds = %for.cond87
  %add91 = add nsw i32 72, %i.5
  %conv92 = trunc i32 %add91 to i8
  %call93 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv92)
  %idx.ext = sext i32 %i.5 to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  store i8 %call93, i8* %add.ptr, align 1, !tbaa !49
  %inc95 = add nsw i32 %i.5, 1
  br label %for.cond87

for.end96:                                        ; preds = %for.cond87
  br label %for.cond97

for.cond97:                                       ; preds = %for.body100, %for.end96
  %i.6 = phi i32 [ 0, %for.end96 ], [ %inc107, %for.body100 ]
  %cmp98 = icmp slt i32 %i.6, 4
  br i1 %cmp98, label %for.body100, label %for.end108

for.body100:                                      ; preds = %for.cond97
  %add101 = add nsw i32 208, %i.6
  %conv102 = trunc i32 %add101 to i8
  %call103 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv102)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 14
  %base = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block10, i32 0, i32 0
  %idxprom104 = sext i32 %i.6 to i64
  %arrayidx105 = getelementptr inbounds [4 x i8], [4 x i8]* %base, i64 0, i64 %idxprom104
  store i8 %call103, i8* %arrayidx105, align 1, !tbaa !49
  %inc107 = add nsw i32 %i.6, 1
  br label %for.cond97

for.end108:                                       ; preds = %for.cond97
  br label %for.cond109

for.cond109:                                      ; preds = %for.body112, %for.end108
  %i.7 = phi i32 [ 0, %for.end108 ], [ %inc120, %for.body112 ]
  %cmp110 = icmp slt i32 %i.7, 12
  br i1 %cmp110, label %for.body112, label %for.end121

for.body112:                                      ; preds = %for.cond109
  %add113 = add nsw i32 212, %i.7
  %conv114 = trunc i32 %add113 to i8
  %call115 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv114)
  %block10116 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 14
  %offset = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block10116, i32 0, i32 1
  %idxprom117 = sext i32 %i.7 to i64
  %arrayidx118 = getelementptr inbounds [12 x i8], [12 x i8]* %offset, i64 0, i64 %idxprom117
  store i8 %call115, i8* %arrayidx118, align 1, !tbaa !49
  %inc120 = add nsw i32 %i.7, 1
  br label %for.cond109

for.end121:                                       ; preds = %for.cond109
  call void @lm93_update_client_common(%struct.lm93_data* %data, %struct.i2c_client* %client)
  ret void
}

declare i8* @devm_kzalloc(%struct.device*, i64, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @i2c_set_clientdata(%struct.i2c_client* %dev, i8* %data) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %dev, i32 0, i32 5
  %call = call i32 @dev_set_drvdata(%struct.device* %dev1, i8* %data)
  ret void
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #2

; Function Attrs: nounwind uwtable
define internal void @lm93_init_client(%struct.i2c_client* %client) #1 {
entry:
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -66)
  %conv = zext i8 %call to i32
  %0 = load i32, i32* @vid_agtl, align 4, !tbaa !54
  %tobool = icmp ne i32 %0, 0
  %1 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 3, i32 0
  %or = or i32 %conv, %cond
  %conv1 = trunc i32 %or to i8
  %call2 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -66, i8 zeroext %conv1)
  %2 = load i8, i8* @init, align 1, !tbaa !32, !range !33
  %tobool3 = trunc i8 %2 to i1
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %conv5 = zext i8 %call4 to i32
  %or6 = or i32 %conv5, 8
  %conv7 = trunc i32 %or6 to i8
  %call8 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -29, i8 zeroext %conv7)
  %call9 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -30)
  %conv10 = zext i8 %call9 to i32
  %or11 = or i32 %conv10, 2
  %conv12 = trunc i32 %or11 to i8
  %call13 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -30, i8 zeroext %conv12)
  %call14 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -28, i8 zeroext 0)
  %call15 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -19)
  %conv16 = zext i8 %call15 to i32
  %and = and i32 %conv16, -4
  %conv17 = trunc i32 %and to i8
  %3 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 0), align 4, !tbaa !54
  %tobool18 = icmp ne i32 %3, 0
  %4 = zext i1 %tobool18 to i64
  %cond19 = select i1 %tobool18, i32 16, i32 0
  %neg = xor i32 %cond19, -1
  %conv20 = zext i8 %conv17 to i32
  %and21 = and i32 %conv20, %neg
  %conv22 = trunc i32 %and21 to i8
  %5 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 1), align 4, !tbaa !54
  %tobool23 = icmp ne i32 %5, 0
  %6 = zext i1 %tobool23 to i64
  %cond24 = select i1 %tobool23, i32 32, i32 0
  %neg25 = xor i32 %cond24, -1
  %conv26 = zext i8 %conv22 to i32
  %and27 = and i32 %conv26, %neg25
  %conv28 = trunc i32 %and27 to i8
  %call29 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -19, i8 zeroext %conv28)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call30 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %conv31 = zext i8 %call30 to i32
  %or32 = or i32 %conv31, 1
  %conv33 = trunc i32 %or32 to i8
  %call34 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -29, i8 zeroext %conv33)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 20
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @msleep(i32 10)
  %call36 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %conv37 = zext i8 %call36 to i32
  %and38 = and i32 %conv37, 128
  %cmp39 = icmp eq i32 %and38, 128
  br i1 %cmp39, label %cleanup.cont, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %call43 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.9, i32 0, i32 0))
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %for.body
  ret void
}

declare i32 @sysfs_create_group(%struct.kobject*, %struct.attribute_group*) #2

declare %struct.device* @hwmon_device_register(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

declare i32 @dev_err(%struct.device*, i8*, ...) #2

declare void @sysfs_remove_group(%struct.kobject*, %struct.attribute_group*) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define internal void @lm93_read_block(%struct.i2c_client* %client, i8 zeroext %fbn, i8* %values) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %result.0 = phi i32 [ 0, %entry ], [ %call, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i8 %fbn to i64
  %arrayidx = getelementptr inbounds [12 x %struct.anon.36], [12 x %struct.anon.36]* @lm93_block_read_cmds, i64 0, i64 %idxprom
  %cmd = getelementptr inbounds %struct.anon.36, %struct.anon.36* %arrayidx, i32 0, i32 0
  %0 = load i8, i8* %cmd, align 2, !tbaa !50
  %call = call i32 @i2c_smbus_read_block_data(%struct.i2c_client* %client, i8 zeroext %0, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @lm93_block_buffer, i32 0, i32 0))
  %idxprom1 = zext i8 %fbn to i64
  %arrayidx2 = getelementptr inbounds [12 x %struct.anon.36], [12 x %struct.anon.36]* @lm93_block_read_cmds, i64 0, i64 %idxprom1
  %len = getelementptr inbounds %struct.anon.36, %struct.anon.36* %arrayidx2, i32 0, i32 1
  %1 = load i8, i8* %len, align 1, !tbaa !52
  %conv = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %call, %conv
  br i1 %cmp3, label %for.end, label %if.else

if.else:                                          ; preds = %for.body
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %idxprom5 = zext i8 %fbn to i64
  %arrayidx6 = getelementptr inbounds [12 x %struct.anon.36], [12 x %struct.anon.36]* @lm93_block_read_cmds, i64 0, i64 %idxprom5
  %cmd7 = getelementptr inbounds %struct.anon.36, %struct.anon.36* %arrayidx6, i32 0, i32 0
  %2 = load i8, i8* %cmd7, align 2, !tbaa !50
  %conv8 = zext i8 %2 to i32
  %call9 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.3, i32 0, i32 0), i32 %conv8)
  %add = add nsw i32 %i.0, 3
  %conv10 = sext i32 %add to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %__ms.0 = phi i64 [ %conv10, %if.else ], [ %dec, %while.body ]
  %dec = add i64 %__ms.0, -1
  %tobool = icmp ne i64 %__ms.0, 0
  br i1 %tobool, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 4295000)
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %result.1 = phi i32 [ %call, %for.body ], [ %result.0, %for.cond ]
  %idxprom11 = zext i8 %fbn to i64
  %arrayidx12 = getelementptr inbounds [12 x %struct.anon.36], [12 x %struct.anon.36]* @lm93_block_read_cmds, i64 0, i64 %idxprom11
  %len13 = getelementptr inbounds %struct.anon.36, %struct.anon.36* %arrayidx12, i32 0, i32 1
  %3 = load i8, i8* %len13, align 1, !tbaa !52
  %conv14 = zext i8 %3 to i32
  %cmp15 = icmp eq i32 %result.1, %conv14
  br i1 %cmp15, label %if.then17, label %if.end23

if.then17:                                        ; preds = %for.end
  %idxprom18 = zext i8 %fbn to i64
  %arrayidx19 = getelementptr inbounds [12 x %struct.anon.36], [12 x %struct.anon.36]* @lm93_block_read_cmds, i64 0, i64 %idxprom18
  %len20 = getelementptr inbounds %struct.anon.36, %struct.anon.36* %arrayidx19, i32 0, i32 1
  %4 = load i8, i8* %len20, align 1, !tbaa !52
  %conv21 = zext i8 %4 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %values, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @lm93_block_buffer, i32 0, i32 0), i64 %conv21, i32 1, i1 false)
  br label %if.end23

if.end23:                                         ; preds = %for.end, %if.then17
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @lm93_update_client_common(%struct.lm93_data* %data, %struct.i2c_client* %client) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %mul = mul nsw i32 %i.0, 2
  %add = add nsw i32 120, %mul
  %conv = trunc i32 %add to i8
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 10
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim, i64 0, i64 %idxprom
  %min = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx, i32 0, i32 0
  store i8 %call, i8* %min, align 2, !tbaa !50
  %mul1 = mul nsw i32 %i.0, 2
  %add2 = add nsw i32 121, %mul1
  %conv3 = trunc i32 %add2 to i8
  %call4 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv3)
  %temp_lim5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 10
  %idxprom6 = sext i32 %i.0 to i64
  %arrayidx7 = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim5, i64 0, i64 %idxprom6
  %max = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx7, i32 0, i32 1
  store i8 %call4, i8* %max, align 1, !tbaa !52
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call8 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -29)
  %config = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 15
  store i8 %call8, i8* %config, align 4, !tbaa !55
  br label %for.cond9

for.cond9:                                        ; preds = %for.body12, %for.end
  %i.1 = phi i32 [ 0, %for.end ], [ %inc19, %for.body12 ]
  %cmp10 = icmp slt i32 %i.1, 2
  br i1 %cmp10, label %for.body12, label %for.end20

for.body12:                                       ; preds = %for.cond9
  %add13 = add nsw i32 108, %i.1
  %conv14 = trunc i32 %add13 to i8
  %call15 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv14)
  %vid = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 16
  %idxprom16 = sext i32 %i.1 to i64
  %arrayidx17 = getelementptr inbounds [2 x i8], [2 x i8]* %vid, i64 0, i64 %idxprom16
  store i8 %call15, i8* %arrayidx17, align 1, !tbaa !49
  %inc19 = add nsw i32 %i.1, 1
  br label %for.cond9

for.end20:                                        ; preds = %for.cond9
  br label %for.cond21

for.cond21:                                       ; preds = %for.body24, %for.end20
  %i.2 = phi i32 [ 0, %for.end20 ], [ %inc31, %for.body24 ]
  %cmp22 = icmp slt i32 %i.2, 2
  br i1 %cmp22, label %for.body24, label %for.end32

for.body24:                                       ; preds = %for.cond21
  %add25 = add nsw i32 176, %i.2
  %conv26 = trunc i32 %add25 to i8
  %call27 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv26)
  %prochot_max = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 17
  %idxprom28 = sext i32 %i.2 to i64
  %arrayidx29 = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max, i64 0, i64 %idxprom28
  store i8 %call27, i8* %arrayidx29, align 1, !tbaa !49
  %inc31 = add nsw i32 %i.2, 1
  br label %for.cond21

for.end32:                                        ; preds = %for.cond21
  br label %for.cond33

for.cond33:                                       ; preds = %for.body36, %for.end32
  %i.3 = phi i32 [ 0, %for.end32 ], [ %inc43, %for.body36 ]
  %cmp34 = icmp slt i32 %i.3, 2
  br i1 %cmp34, label %for.body36, label %for.end44

for.body36:                                       ; preds = %for.cond33
  %add37 = add nsw i32 178, %i.3
  %conv38 = trunc i32 %add37 to i8
  %call39 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv38)
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 18
  %idxprom40 = sext i32 %i.3 to i64
  %arrayidx41 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom40
  store i8 %call39, i8* %arrayidx41, align 1, !tbaa !49
  %inc43 = add nsw i32 %i.3, 1
  br label %for.cond33

for.end44:                                        ; preds = %for.cond33
  %call45 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext 107)
  %gpi = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 19
  store i8 %call45, i8* %gpi, align 1, !tbaa !56
  %call46 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -58)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 20
  store i8 %call46, i8* %prochot_override, align 4, !tbaa !57
  %call47 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -57)
  %prochot_interval = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 21
  store i8 %call47, i8* %prochot_interval, align 1, !tbaa !58
  br label %for.cond48

for.cond48:                                       ; preds = %for.body51, %for.end44
  %i.4 = phi i32 [ 0, %for.end44 ], [ %inc58, %for.body51 ]
  %cmp49 = icmp slt i32 %i.4, 4
  br i1 %cmp49, label %for.body51, label %for.end59

for.body51:                                       ; preds = %for.cond48
  %add52 = add nsw i32 128, %i.4
  %conv53 = trunc i32 %add52 to i8
  %call54 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %conv53)
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 22
  %idxprom55 = sext i32 %i.4 to i64
  %arrayidx56 = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom55
  store i8 %call54, i8* %arrayidx56, align 1, !tbaa !49
  %inc58 = add nsw i32 %i.4, 1
  br label %for.cond48

for.end59:                                        ; preds = %for.cond48
  %call60 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -64)
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx61 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 0
  store i8 %call60, i8* %arrayidx61, align 2, !tbaa !49
  %call62 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -63)
  %boost_hyst63 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx64 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst63, i64 0, i64 1
  store i8 %call62, i8* %arrayidx64, align 1, !tbaa !49
  %call65 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -61)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 24
  %arrayidx66 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 0
  store i8 %call65, i8* %arrayidx66, align 4, !tbaa !49
  %call67 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -60)
  %auto_pwm_min_hyst68 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 24
  %arrayidx69 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst68, i64 0, i64 1
  store i8 %call67, i8* %arrayidx69, align 1, !tbaa !49
  %call70 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -65)
  %pwm_ramp_ctl = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 25
  store i8 %call70, i8* %pwm_ramp_ctl, align 2, !tbaa !59
  %call71 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -68)
  %sfc1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 26
  store i8 %call71, i8* %sfc1, align 1, !tbaa !60
  %call72 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  store i8 %call72, i8* %sfc2, align 8, !tbaa !61
  %call73 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -32)
  %sf_tach_to_pwm = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  store i8 %call73, i8* %sf_tach_to_pwm, align 1, !tbaa !62
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 5
  %0 = bitcast %struct.block1_t* %block1 to i8*
  br label %for.cond74

for.cond74:                                       ; preds = %for.body77, %for.end59
  %i.5 = phi i32 [ 0, %for.end59 ], [ %inc82, %for.body77 ]
  %cmp75 = icmp slt i32 %i.5, 8
  br i1 %cmp75, label %for.body77, label %for.end83

for.body77:                                       ; preds = %for.cond74
  %add78 = add nsw i32 72, %i.5
  %conv79 = trunc i32 %add78 to i8
  %idx.ext = sext i32 %i.5 to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  %1 = load i8, i8* %add.ptr, align 1, !tbaa !49
  %call80 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext %conv79, i8 zeroext %1)
  %inc82 = add nsw i32 %i.5, 1
  br label %for.cond74

for.end83:                                        ; preds = %for.cond74
  ret void
}

declare i32 @i2c_smbus_read_block_data(%struct.i2c_client*, i8 zeroext, i8*) #2

declare i32 @dev_warn(%struct.device*, i8*, ...) #2

declare void @__const_udelay(i64) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

; Function Attrs: nounwind uwtable
define internal zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext %reg) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_smbus_read_byte_data(%struct.i2c_client* %client, i8 zeroext %reg)
  %cmp1 = icmp sge i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %conv = trunc i32 %call to i8
  br label %cleanup

if.else:                                          ; preds = %for.body
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %conv2 = zext i8 %reg to i32
  %call3 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.4, i32 0, i32 0), i32 %conv2)
  %add = add nsw i32 %i.0, 3
  %conv4 = sext i32 %add to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %__ms.0 = phi i64 [ %conv4, %if.else ], [ %dec, %while.body ]
  %dec = add i64 %__ms.0, -1
  %tobool = icmp ne i64 %__ms.0, 0
  br i1 %tobool, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 4295000)
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev5 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %call6 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev5, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.5, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i8 [ %conv, %if.then ], [ 0, %for.end ]
  ret i8 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext %reg, i8 zeroext %value) #1 {
entry:
  %call = call i32 @i2c_smbus_write_byte_data(%struct.i2c_client* %client, i8 zeroext %reg, i8 zeroext %value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %conv = zext i8 %value to i32
  %conv1 = zext i8 %reg to i32
  %call2 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.6, i32 0, i32 0), i32 %conv, i32 %conv1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

declare i32 @i2c_smbus_read_byte_data(%struct.i2c_client*, i8 zeroext) #2

declare i32 @i2c_smbus_write_byte_data(%struct.i2c_client*, i8 zeroext, i8 zeroext) #2

; Function Attrs: nounwind uwtable
define internal zeroext i16 @lm93_read_word(%struct.i2c_client* %client, i8 zeroext %reg) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_smbus_read_word_data(%struct.i2c_client* %client, i8 zeroext %reg)
  %cmp1 = icmp sge i32 %call, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %conv = trunc i32 %call to i16
  br label %cleanup

if.else:                                          ; preds = %for.body
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %conv2 = zext i8 %reg to i32
  %call3 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.7, i32 0, i32 0), i32 %conv2)
  %add = add nsw i32 %i.0, 3
  %conv4 = sext i32 %add to i64
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %__ms.0 = phi i64 [ %conv4, %if.else ], [ %dec, %while.body ]
  %dec = add i64 %__ms.0, -1
  %tobool = icmp ne i64 %__ms.0, 0
  br i1 %tobool, label %while.body, label %for.inc

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 4295000)
  br label %while.cond

for.inc:                                          ; preds = %while.cond
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %dev5 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %call6 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev5, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.8, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then
  %retval.0 = phi i16 [ %conv, %if.then ], [ 0, %for.end ]
  ret i16 %retval.0
}

declare i32 @i2c_smbus_read_word_data(%struct.i2c_client*, i8 zeroext) #2

declare i32 @dev_set_drvdata(%struct.device*, i8*) #2

declare void @msleep(i32) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_in(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 7
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [16 x i8], [16 x i8]* %block3, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call1 = call i32 @LM93_IN_FROM_REG(i32 %2, i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal %struct.lm93_data* @lm93_update_device(%struct.device* %dev) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %1)
  %2 = bitcast i8* %call to %struct.lm93_data*
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #5
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #5
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #5
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %7 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #5
  %8 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #5
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %9 = bitcast i64* %__dummy24 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  %10 = bitcast i64* %__dummy3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #5
  %last_updated = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 2
  %11 = load i64, i64* %last_updated, align 8, !tbaa !67
  %add = add i64 %11, 1500
  %12 = load volatile i64, i64* @jiffies, align 8, !tbaa !68
  %sub = sub nsw i64 %add, %12
  %cmp10 = icmp slt i64 %sub, 0
  br i1 %cmp10, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %valid = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 4
  %13 = load i8, i8* %valid, align 8, !tbaa !34
  %tobool12 = icmp ne i8 %13, 0
  br i1 %tobool12, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %update = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 3
  %14 = load void (%struct.lm93_data*, %struct.i2c_client*)*, void (%struct.lm93_data*, %struct.i2c_client*)** %update, align 8, !tbaa !39
  call void %14(%struct.lm93_data* %2, %struct.i2c_client* %1)
  %15 = load volatile i64, i64* @jiffies, align 8, !tbaa !68
  %last_updated13 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 2
  store i64 %15, i64* %last_updated13, align 8, !tbaa !67
  %valid14 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 4
  store i8 1, i8* %valid14, align 8, !tbaa !34
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %update_lock15 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock15)
  ret %struct.lm93_data* %2
}

declare i32 @sprintf(i8*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i32 @LM93_IN_FROM_REG(i32 %nr, i8 zeroext %reg) #1 {
entry:
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_max, i64 0, i64 %idxprom
  %0 = load i64, i64* %arrayidx, align 8, !tbaa !68
  %mul = mul i64 %0, 1000
  %idxprom1 = sext i32 %nr to i64
  %arrayidx2 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_min, i64 0, i64 %idxprom1
  %1 = load i64, i64* %arrayidx2, align 8, !tbaa !68
  %mul3 = mul i64 %1, 1000
  %sub = sub nsw i64 %mul, %mul3
  %idxprom4 = sext i32 %nr to i64
  %arrayidx5 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_max, i64 0, i64 %idxprom4
  %2 = load i8, i8* %arrayidx5, align 1, !tbaa !49
  %conv = zext i8 %2 to i32
  %idxprom6 = sext i32 %nr to i64
  %arrayidx7 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom6
  %3 = load i8, i8* %arrayidx7, align 1, !tbaa !49
  %conv8 = zext i8 %3 to i32
  %sub9 = sub nsw i32 %conv, %conv8
  %conv10 = sext i32 %sub9 to i64
  %div = sdiv i64 %sub, %conv10
  %idxprom11 = sext i32 %nr to i64
  %arrayidx12 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom11
  %4 = load i8, i8* %arrayidx12, align 1, !tbaa !49
  %conv13 = zext i8 %4 to i64
  %mul14 = mul nsw i64 %div, %conv13
  %sub15 = sub nsw i64 %mul3, %mul14
  %conv16 = zext i8 %reg to i64
  %mul17 = mul nsw i64 %div, %conv16
  %add = add nsw i64 %mul17, %sub15
  %add18 = add nsw i64 %add, 500
  %div19 = sdiv i64 %add18, 1000
  %conv20 = trunc i64 %div19 to i32
  ret i32 %conv20
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @i2c_get_clientdata(%struct.i2c_client* %dev) #0 {
entry:
  %dev1 = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %dev, i32 0, i32 5
  %call = call i8* @dev_get_drvdata(%struct.device* %dev1)
  ret i8* %call
}

declare void @mutex_lock(%struct.mutex*) #2

declare void @mutex_unlock(%struct.mutex*) #2

declare i8* @dev_get_drvdata(%struct.device*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_in_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sub = sub nsw i32 %2, 6
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !54
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %vid2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 16
  %idxprom3 = sext i32 %sub to i64
  %arrayidx4 = getelementptr inbounds [2 x i8], [2 x i8]* %vid2, i64 0, i64 %idxprom3
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !49
  %call5 = call i32 @LM93_VID_FROM_REG(i8 zeroext %4)
  %conv = sext i32 %call5 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 18
  %idxprom6 = sext i32 %sub to i64
  %arrayidx7 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom6
  %5 = load i8, i8* %arrayidx7, align 1, !tbaa !49
  %conv8 = trunc i64 %conv to i32
  %call9 = call i32 @LM93_IN_REL_FROM_REG(i8 zeroext %5, i32 0, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry, %land.lhs.true
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 11
  %idxprom11 = sext i32 %2 to i64
  %arrayidx12 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block7, i64 0, i64 %idxprom11
  %min = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx12, i32 0, i32 0
  %6 = load i8, i8* %min, align 2, !tbaa !50
  %call13 = call i32 @LM93_IN_FROM_REG(i32 %2, i8 zeroext %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call13.sink = phi i32 [ %call13, %if.else ], [ %call9, %if.then ]
  %conv14 = zext i32 %call13.sink to i64
  %call15 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28, i32 0, i32 0), i64 %conv14)
  %conv16 = sext i32 %call15 to i64
  ret i64 %conv16
}

; Function Attrs: nounwind uwtable
define internal i64 @store_in_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %sub = sub nsw i32 %2, 6
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4, !tbaa !54
  %tobool8 = icmp ne i32 %7, 0
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %land.lhs.true
  %vid10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 16
  %idxprom11 = sext i32 %sub to i64
  %arrayidx12 = getelementptr inbounds [2 x i8], [2 x i8]* %vid10, i64 0, i64 %idxprom11
  %8 = load i8, i8* %arrayidx12, align 1, !tbaa !49
  %call13 = call i32 @LM93_VID_FROM_REG(i8 zeroext %8)
  %conv14 = sext i32 %call13 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 18
  %idxprom15 = sext i32 %sub to i64
  %arrayidx16 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom15
  %9 = load i8, i8* %arrayidx16, align 1, !tbaa !49
  %conv17 = zext i8 %9 to i32
  %and = and i32 %conv17, 240
  %10 = load i64, i64* %val, align 8, !tbaa !68
  %conv18 = trunc i64 %10 to i32
  %conv19 = trunc i64 %conv14 to i32
  %call20 = call zeroext i8 @LM93_IN_REL_TO_REG(i32 %conv18, i32 0, i32 %conv19)
  %conv21 = zext i8 %call20 to i32
  %or = or i32 %and, %conv21
  %conv22 = trunc i32 %or to i8
  %vccp_limits23 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 18
  %idxprom24 = sext i32 %sub to i64
  %arrayidx25 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits23, i64 0, i64 %idxprom24
  store i8 %conv22, i8* %arrayidx25, align 1, !tbaa !49
  %add = add nsw i32 178, %sub
  %conv26 = trunc i32 %add to i8
  %vccp_limits27 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 18
  %idxprom28 = sext i32 %sub to i64
  %arrayidx29 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits27, i64 0, i64 %idxprom28
  %11 = load i8, i8* %arrayidx29, align 1, !tbaa !49
  %call30 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv26, i8 zeroext %11)
  br label %if.end42

if.else:                                          ; preds = %if.end, %land.lhs.true
  %12 = load i64, i64* %val, align 8, !tbaa !68
  %conv31 = trunc i64 %12 to i32
  %call32 = call zeroext i8 @LM93_IN_TO_REG(i32 %2, i32 %conv31)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 11
  %idxprom33 = sext i32 %2 to i64
  %arrayidx34 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block7, i64 0, i64 %idxprom33
  %min = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx34, i32 0, i32 0
  store i8 %call32, i8* %min, align 2, !tbaa !50
  %mul = mul nsw i32 %2, 2
  %add35 = add nsw i32 144, %mul
  %conv36 = trunc i32 %add35 to i8
  %block737 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 11
  %idxprom38 = sext i32 %2 to i64
  %arrayidx39 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block737, i64 0, i64 %idxprom38
  %min40 = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx39, i32 0, i32 0
  %13 = load i8, i8* %min40, align 2, !tbaa !50
  %call41 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv36, i8 zeroext %13)
  br label %if.end42

if.end42:                                         ; preds = %if.else, %if.then9
  %update_lock43 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock43)
  br label %cleanup

cleanup:                                          ; preds = %if.end42, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end42 ]
  %14 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_VID_FROM_REG(i8 zeroext %reg) #1 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 63
  %call = call i32 @vid_from_reg(i32 %and, i8 zeroext 100)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_IN_REL_FROM_REG(i8 zeroext %reg, i32 %upper, i32 %vid) #1 {
entry:
  %tobool = icmp ne i32 %upper, 0
  %conv = zext i8 %reg to i32
  %.sink1 = select i1 %tobool, i32 4, i32 0
  %.sink = select i1 %tobool, i32 12500, i32 -25000
  %shr2 = ashr i32 %conv, %.sink1
  %and3 = and i32 %shr2, 15
  %add4 = add nsw i32 %and3, 1
  %mul5 = mul nsw i32 %add4, %.sink
  %conv6 = sext i32 %mul5 to i64
  %mul7 = mul nsw i32 %vid, 1000
  %conv8 = sext i32 %mul7 to i64
  %add9 = add nsw i64 %conv8, %conv6
  %add10 = add nsw i64 %add9, 5000
  %div = sdiv i64 %add10, 10000
  %conv11 = trunc i64 %div to i32
  ret i32 %conv11
}

declare i32 @vid_from_reg(i32, i8 zeroext) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_IN_REL_TO_REG(i32 %val, i32 %upper, i32 %vid) #1 {
entry:
  %mul = mul nsw i32 %vid, 1000
  %mul1 = mul i32 %val, 10000
  %sub = sub i32 %mul, %mul1
  %conv = zext i32 %sub to i64
  %tobool = icmp ne i32 %upper, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %cmp = icmp slt i64 %conv, 12500
  %.conv = select i1 %cmp, i64 12500, i64 %conv
  %cmp3 = icmp sgt i64 %.conv, 200000
  %cond8 = select i1 %cmp3, i64 200000, i64 %.conv
  br label %cleanup

if.else:                                          ; preds = %entry
  %cmp14 = icmp slt i64 %conv, -400000
  %.conv1 = select i1 %cmp14, i64 -400000, i64 %conv
  %cmp21 = icmp sgt i64 %.conv1, -25000
  %cond26 = select i1 %cmp21, i64 -25000, i64 %.conv1
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then
  %.sink2 = phi i64 [ -25000, %if.else ], [ 12500, %if.then ]
  %cond26.sink = phi i64 [ %cond26, %if.else ], [ %cond8, %if.then ]
  %.sink = phi i64 [ 0, %if.else ], [ 4, %if.then ]
  %div27 = sdiv i64 %cond26.sink, %.sink2
  %sub28 = sub nsw i64 %div27, 1
  %shl29 = shl i64 %sub28, %.sink
  %conv30 = trunc i64 %shl29 to i8
  ret i8 %conv30
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_IN_TO_REG(i32 %nr, i32 %val) #1 {
entry:
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_min, i64 0, i64 %idxprom
  %0 = load i64, i64* %arrayidx, align 8, !tbaa !68
  %conv = trunc i64 %0 to i32
  %idxprom1 = sext i32 %nr to i64
  %arrayidx2 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_max, i64 0, i64 %idxprom1
  %1 = load i64, i64* %arrayidx2, align 8, !tbaa !68
  %conv3 = trunc i64 %1 to i32
  %cmp = icmp ult i32 %val, %conv
  %conv.val = select i1 %cmp, i32 %conv, i32 %val
  %cmp5 = icmp ugt i32 %conv.val, %conv3
  %cond10 = select i1 %cmp5, i32 %conv3, i32 %conv.val
  %conv11 = zext i32 %cond10 to i64
  %mul = mul nsw i64 %conv11, 1000
  %idxprom12 = sext i32 %nr to i64
  %arrayidx13 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_max, i64 0, i64 %idxprom12
  %2 = load i64, i64* %arrayidx13, align 8, !tbaa !68
  %mul14 = mul i64 %2, 1000
  %idxprom15 = sext i32 %nr to i64
  %arrayidx16 = getelementptr inbounds [16 x i64], [16 x i64]* @lm93_vin_val_min, i64 0, i64 %idxprom15
  %3 = load i64, i64* %arrayidx16, align 8, !tbaa !68
  %mul17 = mul i64 %3, 1000
  %sub = sub nsw i64 %mul14, %mul17
  %idxprom18 = sext i32 %nr to i64
  %arrayidx19 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_max, i64 0, i64 %idxprom18
  %4 = load i8, i8* %arrayidx19, align 1, !tbaa !49
  %conv20 = zext i8 %4 to i32
  %idxprom21 = sext i32 %nr to i64
  %arrayidx22 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom21
  %5 = load i8, i8* %arrayidx22, align 1, !tbaa !49
  %conv23 = zext i8 %5 to i32
  %sub24 = sub nsw i32 %conv20, %conv23
  %conv25 = sext i32 %sub24 to i64
  %div = sdiv i64 %sub, %conv25
  %idxprom26 = sext i32 %nr to i64
  %arrayidx27 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom26
  %6 = load i8, i8* %arrayidx27, align 1, !tbaa !49
  %conv28 = zext i8 %6 to i64
  %mul29 = mul nsw i64 %div, %conv28
  %sub30 = sub nsw i64 %mul17, %mul29
  %sub31 = sub nsw i64 %mul, %sub30
  %div32 = sdiv i64 %div, 2
  %add = add nsw i64 %sub31, %div32
  %div33 = sdiv i64 %add, %div
  %conv34 = trunc i64 %div33 to i8
  %idxprom37 = sext i32 %nr to i64
  %arrayidx38 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_min, i64 0, i64 %idxprom37
  %7 = load i8, i8* %arrayidx38, align 1, !tbaa !49
  %idxprom40 = sext i32 %nr to i64
  %arrayidx41 = getelementptr inbounds [16 x i8], [16 x i8]* @lm93_vin_reg_max, i64 0, i64 %idxprom40
  %8 = load i8, i8* %arrayidx41, align 1, !tbaa !49
  %conv42 = zext i8 %conv34 to i32
  %conv43 = zext i8 %7 to i32
  %cmp44 = icmp slt i32 %conv42, %conv43
  %conv34.sink = select i1 %cmp44, i8 %7, i8 %conv34
  %conv49 = zext i8 %conv34.sink to i32
  %conv52 = trunc i32 %conv49 to i8
  %conv54 = zext i8 %conv52 to i32
  %conv55 = zext i8 %8 to i32
  %cmp56 = icmp sgt i32 %conv54, %conv55
  %conv52.sink = select i1 %cmp56, i8 %8, i8 %conv52
  %conv61 = zext i8 %conv52.sink to i32
  %conv64 = trunc i32 %conv61 to i8
  ret i8 %conv64
}

declare i32 @kstrtoull(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_in_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sub = sub nsw i32 %2, 6
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4, !tbaa !54
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %vid2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 16
  %idxprom3 = sext i32 %sub to i64
  %arrayidx4 = getelementptr inbounds [2 x i8], [2 x i8]* %vid2, i64 0, i64 %idxprom3
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !49
  %call5 = call i32 @LM93_VID_FROM_REG(i8 zeroext %4)
  %conv = sext i32 %call5 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 18
  %idxprom6 = sext i32 %sub to i64
  %arrayidx7 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom6
  %5 = load i8, i8* %arrayidx7, align 1, !tbaa !49
  %conv8 = trunc i64 %conv to i32
  %call9 = call i32 @LM93_IN_REL_FROM_REG(i8 zeroext %5, i32 1, i32 %conv8)
  br label %if.end

if.else:                                          ; preds = %entry, %land.lhs.true
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 11
  %idxprom11 = sext i32 %2 to i64
  %arrayidx12 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block7, i64 0, i64 %idxprom11
  %max = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx12, i32 0, i32 1
  %6 = load i8, i8* %max, align 1, !tbaa !52
  %call13 = call i32 @LM93_IN_FROM_REG(i32 %2, i8 zeroext %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call13.sink = phi i32 [ %call13, %if.else ], [ %call9, %if.then ]
  %conv14 = zext i32 %call13.sink to i64
  %call15 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28, i32 0, i32 0), i64 %conv14)
  %conv16 = sext i32 %call15 to i64
  ret i64 %conv16
}

; Function Attrs: nounwind uwtable
define internal i64 @store_in_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %sub = sub nsw i32 %2, 6
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %.off = add i32 %2, -6
  %switch = icmp ult i32 %.off, 2
  br i1 %switch, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4, !tbaa !54
  %tobool8 = icmp ne i32 %7, 0
  br i1 %tobool8, label %if.then9, label %if.else

if.then9:                                         ; preds = %land.lhs.true
  %vid10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 16
  %idxprom11 = sext i32 %sub to i64
  %arrayidx12 = getelementptr inbounds [2 x i8], [2 x i8]* %vid10, i64 0, i64 %idxprom11
  %8 = load i8, i8* %arrayidx12, align 1, !tbaa !49
  %call13 = call i32 @LM93_VID_FROM_REG(i8 zeroext %8)
  %conv14 = sext i32 %call13 to i64
  %vccp_limits = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 18
  %idxprom15 = sext i32 %sub to i64
  %arrayidx16 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits, i64 0, i64 %idxprom15
  %9 = load i8, i8* %arrayidx16, align 1, !tbaa !49
  %conv17 = zext i8 %9 to i32
  %and = and i32 %conv17, 15
  %10 = load i64, i64* %val, align 8, !tbaa !68
  %conv18 = trunc i64 %10 to i32
  %conv19 = trunc i64 %conv14 to i32
  %call20 = call zeroext i8 @LM93_IN_REL_TO_REG(i32 %conv18, i32 1, i32 %conv19)
  %conv21 = zext i8 %call20 to i32
  %or = or i32 %and, %conv21
  %conv22 = trunc i32 %or to i8
  %vccp_limits23 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 18
  %idxprom24 = sext i32 %sub to i64
  %arrayidx25 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits23, i64 0, i64 %idxprom24
  store i8 %conv22, i8* %arrayidx25, align 1, !tbaa !49
  %add = add nsw i32 178, %sub
  %conv26 = trunc i32 %add to i8
  %vccp_limits27 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 18
  %idxprom28 = sext i32 %sub to i64
  %arrayidx29 = getelementptr inbounds [2 x i8], [2 x i8]* %vccp_limits27, i64 0, i64 %idxprom28
  %11 = load i8, i8* %arrayidx29, align 1, !tbaa !49
  %call30 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv26, i8 zeroext %11)
  br label %if.end42

if.else:                                          ; preds = %if.end, %land.lhs.true
  %12 = load i64, i64* %val, align 8, !tbaa !68
  %conv31 = trunc i64 %12 to i32
  %call32 = call zeroext i8 @LM93_IN_TO_REG(i32 %2, i32 %conv31)
  %block7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 11
  %idxprom33 = sext i32 %2 to i64
  %arrayidx34 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block7, i64 0, i64 %idxprom33
  %max = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx34, i32 0, i32 1
  store i8 %call32, i8* %max, align 1, !tbaa !52
  %mul = mul nsw i32 %2, 2
  %add35 = add nsw i32 145, %mul
  %conv36 = trunc i32 %add35 to i8
  %block737 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 11
  %idxprom38 = sext i32 %2 to i64
  %arrayidx39 = getelementptr inbounds [16 x %struct.anon.34], [16 x %struct.anon.34]* %block737, i64 0, i64 %idxprom38
  %max40 = getelementptr inbounds %struct.anon.34, %struct.anon.34* %arrayidx39, i32 0, i32 1
  %13 = load i8, i8* %max40, align 1, !tbaa !52
  %call41 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv36, i8 zeroext %13)
  br label %if.end42

if.end42:                                         ; preds = %if.else, %if.then9
  %update_lock43 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock43)
  br label %cleanup

cleanup:                                          ; preds = %if.end42, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end42 ]
  %14 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 6
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [6 x i8], [6 x i8]* %block2, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_FROM_REG(i8 zeroext %reg) #1 {
entry:
  %conv = sext i8 %reg to i32
  %mul = mul nsw i32 %conv, 1000
  ret i32 %mul
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim, i64 0, i64 %idxprom
  %min = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %min, align 2, !tbaa !50
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %call5 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %7)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim, i64 0, i64 %idxprom
  %min = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx, i32 0, i32 0
  store i8 %call5, i8* %min, align 2, !tbaa !50
  %mul = mul nsw i32 %2, 2
  %add = add nsw i32 120, %mul
  %conv6 = trunc i32 %add to i8
  %temp_lim7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 10
  %idxprom8 = sext i32 %2 to i64
  %arrayidx9 = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim7, i64 0, i64 %idxprom8
  %min10 = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx9, i32 0, i32 0
  %8 = load i8, i8* %min10, align 2, !tbaa !50
  %call11 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv6, i8 zeroext %8)
  %update_lock12 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock12)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtol(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoll(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_TEMP_TO_REG(i64 %temp) #1 {
entry:
  %cmp = icmp slt i64 %temp, -128000
  %.temp = select i1 %cmp, i64 -128000, i64 %temp
  %cmp1 = icmp sgt i64 %.temp, 127000
  %cond5 = select i1 %cmp1, i64 127000, i64 %.temp
  %conv = trunc i64 %cond5 to i32
  %cmp6 = icmp slt i32 %conv, 0
  %0 = zext i1 %cmp6 to i64
  %cond8 = select i1 %cmp6, i32 -500, i32 500
  %add = add nsw i32 %conv, %cond8
  %div = sdiv i32 %add, 1000
  %conv9 = trunc i32 %div to i8
  ret i8 %conv9
}

declare i32 @kstrtoll(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim, i64 0, i64 %idxprom
  %max = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx, i32 0, i32 1
  %3 = load i8, i8* %max, align 1, !tbaa !52
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %call5 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %7)
  %temp_lim = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 10
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim, i64 0, i64 %idxprom
  %max = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx, i32 0, i32 1
  store i8 %call5, i8* %max, align 1, !tbaa !52
  %mul = mul nsw i32 %2, 2
  %add = add nsw i32 121, %mul
  %conv6 = trunc i32 %add to i8
  %temp_lim7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 10
  %idxprom8 = sext i32 %2 to i64
  %arrayidx9 = getelementptr inbounds [4 x %struct.anon.33], [4 x %struct.anon.33]* %temp_lim7, i64 0, i64 %idxprom8
  %max10 = getelementptr inbounds %struct.anon.33, %struct.anon.33* %arrayidx9, i32 0, i32 1
  %8 = load i8, i8* %max10, align 1, !tbaa !52
  %call11 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv6, i8 zeroext %8)
  %update_lock12 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock12)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_base(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 14
  %base = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block10, i32 0, i32 0
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %base, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_base(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %call5 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %7)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 14
  %base = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block10, i32 0, i32 0
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %base, i64 0, i64 %idxprom
  store i8 %call5, i8* %arrayidx, align 1, !tbaa !49
  %add = add nsw i32 208, %2
  %conv6 = trunc i32 %add to i8
  %block107 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 14
  %base8 = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block107, i32 0, i32 0
  %idxprom9 = sext i32 %2 to i64
  %arrayidx10 = getelementptr inbounds [4 x i8], [4 x i8]* %base8, i64 0, i64 %idxprom9
  %8 = load i8, i8* %arrayidx10, align 1, !tbaa !49
  %call11 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv6, i8 zeroext %8)
  %update_lock12 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock12)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_boost(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 22
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call1 = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_boost(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtol(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %call5 = call zeroext i8 @LM93_TEMP_TO_REG(i64 %7)
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 22
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  store i8 %call5, i8* %arrayidx, align 1, !tbaa !49
  %add = add nsw i32 128, %2
  %conv6 = trunc i32 %add to i8
  %boost7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 22
  %idxprom8 = sext i32 %2 to i64
  %arrayidx9 = getelementptr inbounds [4 x i8], [4 x i8]* %boost7, i64 0, i64 %idxprom8
  %8 = load i8, i8* %arrayidx9, align 1, !tbaa !49
  %call10 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv6, i8 zeroext %8)
  %update_lock11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock11)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_boost_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %3 = load i8, i8* %sfc2, align 8, !tbaa !61
  %call1 = call i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %3, i32 %2)
  %call2 = call i32 @LM93_AUTO_BOOST_HYST_FROM_REGS(%struct.lm93_data* %call, i32 %2, i32 %call1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_boost_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call5 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 27
  store i8 %call5, i8* %sfc2, align 8, !tbaa !61
  %cmp = icmp slt i32 %2, 2
  %7 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %sfc27 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 27
  %8 = load i8, i8* %sfc27, align 8, !tbaa !61
  %conv8 = zext i8 %8 to i32
  %or = or i32 %conv8, %cond
  %conv9 = trunc i32 %or to i8
  store i8 %conv9, i8* %sfc27, align 8, !tbaa !61
  %sfc210 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 27
  %9 = load i8, i8* %sfc210, align 8, !tbaa !61
  %call11 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -67, i8 zeroext %9)
  %10 = load i64, i64* %val, align 8, !tbaa !68
  %call12 = call zeroext i8 @LM93_AUTO_BOOST_HYST_TO_REG(%struct.lm93_data* %5, i64 %10, i32 %2, i32 1)
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 23
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 %idxprom
  store i8 %call12, i8* %arrayidx, align 1, !tbaa !49
  %div13 = sdiv i32 %2, 2
  %add = add nsw i32 192, %div13
  %conv14 = trunc i32 %add to i8
  %boost_hyst15 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 23
  %div16 = sdiv i32 %2, 2
  %idxprom17 = sext i32 %div16 to i64
  %arrayidx18 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst15, i64 0, i64 %idxprom17
  %11 = load i8, i8* %arrayidx18, align 1, !tbaa !49
  %call19 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv14, i8 zeroext %11)
  %update_lock20 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock20)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %12 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %sfc2, i32 %nr) #1 {
entry:
  %conv = zext i8 %sfc2 to i32
  %cmp = icmp slt i32 %nr, 2
  %0 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %and = and i32 %conv, %cond
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_AUTO_BOOST_HYST_FROM_REGS(%struct.lm93_data* %data, i32 %nr, i32 %mode) #1 {
entry:
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nr, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %nr, 2
  br i1 %Pivot, label %sw.bb2, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %nr, 2
  br i1 %SwitchLeaf2, label %sw.bb8, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %nr, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 0
  %0 = load i8, i8* %arrayidx, align 2, !tbaa !49
  %conv = zext i8 %0 to i32
  br label %sw.epilog

sw.bb2:                                           ; preds = %NodeBlock
  %boost_hyst3 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx4 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst3, i64 0, i64 0
  %1 = load i8, i8* %arrayidx4, align 2, !tbaa !49
  %conv5 = zext i8 %1 to i32
  %shr = ashr i32 %conv5, 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %LeafBlock1
  %boost_hyst9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx10 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst9, i64 0, i64 1
  %2 = load i8, i8* %arrayidx10, align 1, !tbaa !49
  %conv11 = zext i8 %2 to i32
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %boost_hyst15 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx16 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst15, i64 0, i64 1
  %3 = load i8, i8* %arrayidx16, align 1, !tbaa !49
  %conv17 = zext i8 %3 to i32
  %shr18 = ashr i32 %conv17, 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb8, %sw.bb2, %sw.bb
  %shr18.sink = phi i32 [ %shr18, %sw.default ], [ %conv11, %sw.bb8 ], [ %shr, %sw.bb2 ], [ %conv, %sw.bb ]
  %and19 = and i32 %shr18.sink, 15
  %conv20 = trunc i32 %and19 to i8
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 22
  %idxprom = sext i32 %nr to i64
  %arrayidx21 = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx21, align 1, !tbaa !49
  %call = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %4)
  %call22 = call i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %conv20, i32 %mode)
  %sub = sub nsw i32 %call, %call22
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %reg, i32 %mode) #1 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %tobool = icmp ne i32 %mode, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 5, i32 10
  %mul = mul nsw i32 %and, %cond
  ret i32 %mul
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_AUTO_BOOST_HYST_TO_REG(%struct.lm93_data* %data, i64 %hyst, i32 %nr, i32 %mode) #1 {
entry:
  %boost = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 22
  %idxprom = sext i32 %nr to i64
  %arrayidx = getelementptr inbounds [4 x i8], [4 x i8]* %boost, i64 0, i64 %idxprom
  %0 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call = call i32 @LM93_TEMP_FROM_REG(i8 zeroext %0)
  %conv = sext i32 %call to i64
  %sub = sub nsw i64 %conv, %hyst
  %conv1 = trunc i64 %sub to i32
  %call2 = call zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %conv1, i32 %mode)
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %entry
  %Pivot4 = icmp slt i32 %nr, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %nr, 2
  br i1 %Pivot, label %sw.bb8, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %nr, 2
  br i1 %SwitchLeaf2, label %sw.bb17, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %nr, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %boost_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx3 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst, i64 0, i64 0
  %1 = load i8, i8* %arrayidx3, align 2, !tbaa !49
  %conv4 = zext i8 %1 to i32
  %and = and i32 %conv4, 240
  br label %sw.epilog

sw.bb8:                                           ; preds = %NodeBlock
  %conv9 = zext i8 %call2 to i32
  %shl = shl i32 %conv9, 4
  %and10 = and i32 %shl, 240
  %boost_hyst11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx12 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst11, i64 0, i64 0
  %2 = load i8, i8* %arrayidx12, align 2, !tbaa !49
  br label %sw.epilog

sw.bb17:                                          ; preds = %LeafBlock1
  %boost_hyst18 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx19 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst18, i64 0, i64 1
  %3 = load i8, i8* %arrayidx19, align 1, !tbaa !49
  %conv20 = zext i8 %3 to i32
  %and21 = and i32 %conv20, 240
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %conv27 = zext i8 %call2 to i32
  %shl28 = shl i32 %conv27, 4
  %and29 = and i32 %shl28, 240
  %boost_hyst30 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 23
  %arrayidx31 = getelementptr inbounds [2 x i8], [2 x i8]* %boost_hyst30, i64 0, i64 1
  %4 = load i8, i8* %arrayidx31, align 1, !tbaa !49
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb17, %sw.bb8, %sw.bb
  %.sink = phi i8 [ %4, %sw.default ], [ %call2, %sw.bb17 ], [ %2, %sw.bb8 ], [ %call2, %sw.bb ]
  %and29.sink = phi i32 [ %and29, %sw.default ], [ %and21, %sw.bb17 ], [ %and10, %sw.bb8 ], [ %and, %sw.bb ]
  %conv32 = zext i8 %.sink to i32
  %and33 = and i32 %conv32, 15
  %or34 = or i32 %and29.sink, %and33
  %conv35 = trunc i32 %or34 to i8
  ret i8 %conv35
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %off, i32 %mode) #1 {
entry:
  %tobool = icmp ne i32 %mode, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 5, i32 10
  %tobool1 = icmp ne i32 %mode, 0
  %1 = zext i1 %tobool1 to i64
  %cond2 = select i1 %tobool1, i32 75, i32 150
  %cmp = icmp slt i32 %off, 0
  %.off = select i1 %cmp, i32 0, i32 %off
  %cmp4 = icmp sgt i32 %.off, %cond2
  %cond8 = select i1 %cmp4, i32 %cond2, i32 %.off
  %div = sdiv i32 %cond, 2
  %add = add nsw i32 %cond8, %div
  %div9 = sdiv i32 %add, %cond
  %conv = trunc i32 %div9 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_offset(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %2 = load i8, i8* %index, align 8, !tbaa !69
  %conv = zext i8 %2 to i32
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !71
  %conv2 = zext i8 %3 to i32
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %4 = load i8, i8* %sfc2, align 8, !tbaa !61
  %call3 = call i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %4, i32 %conv)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 14
  %offset = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block10, i32 0, i32 1
  %idxprom = sext i32 %conv2 to i64
  %arrayidx = getelementptr inbounds [12 x i8], [12 x i8]* %offset, i64 0, i64 %idxprom
  %5 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call4 = call i32 @LM93_TEMP_AUTO_OFFSET_FROM_REG(i8 zeroext %5, i32 %conv, i32 %call3)
  %call5 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call4)
  %conv6 = sext i32 %call5 to i64
  ret i64 %conv6
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_offset(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute_2*
  %index = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 1
  %2 = load i8, i8* %index, align 8, !tbaa !69
  %conv = zext i8 %2 to i32
  %nr1 = getelementptr inbounds %struct.sensor_device_attribute_2, %struct.sensor_device_attribute_2* %1, i32 0, i32 2
  %3 = load i8, i8* %nr1, align 1, !tbaa !71
  %conv2 = zext i8 %3 to i32
  %4 = bitcast %struct.device* %dev to i8*
  %add.ptr5 = getelementptr inbounds i8, i8* %4, i64 -40
  %5 = bitcast i8* %add.ptr5 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %5)
  %6 = bitcast i8* %call to %struct.lm93_data*
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #5
  %call6 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv7 = sext i32 %call6 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call8 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %5, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 27
  store i8 %call8, i8* %sfc2, align 8, !tbaa !61
  %cmp = icmp slt i32 %conv, 2
  %8 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %sfc210 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 27
  %9 = load i8, i8* %sfc210, align 8, !tbaa !61
  %conv11 = zext i8 %9 to i32
  %or = or i32 %conv11, %cond
  %conv12 = trunc i32 %or to i8
  store i8 %conv12, i8* %sfc210, align 8, !tbaa !61
  %sfc213 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 27
  %10 = load i8, i8* %sfc213, align 8, !tbaa !61
  %call14 = call i32 @lm93_write_byte(%struct.i2c_client* %5, i8 zeroext -67, i8 zeroext %10)
  %block10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 14
  %offset = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block10, i32 0, i32 1
  %idxprom = sext i32 %conv2 to i64
  %arrayidx = getelementptr inbounds [12 x i8], [12 x i8]* %offset, i64 0, i64 %idxprom
  %11 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %12 = load i64, i64* %val, align 8, !tbaa !68
  %conv15 = trunc i64 %12 to i32
  %call16 = call zeroext i8 @LM93_TEMP_AUTO_OFFSET_TO_REG(i8 zeroext %11, i32 %conv15, i32 %conv, i32 1)
  %block1017 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 14
  %offset18 = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block1017, i32 0, i32 1
  %idxprom19 = sext i32 %conv2 to i64
  %arrayidx20 = getelementptr inbounds [12 x i8], [12 x i8]* %offset18, i64 0, i64 %idxprom19
  store i8 %call16, i8* %arrayidx20, align 1, !tbaa !49
  %add = add nsw i32 212, %conv2
  %conv21 = trunc i32 %add to i8
  %block1022 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 14
  %offset23 = getelementptr inbounds %struct.anon.35, %struct.anon.35* %block1022, i32 0, i32 1
  %idxprom24 = sext i32 %conv2 to i64
  %arrayidx25 = getelementptr inbounds [12 x i8], [12 x i8]* %offset23, i64 0, i64 %idxprom24
  %13 = load i8, i8* %arrayidx25, align 1, !tbaa !49
  %call26 = call i32 @lm93_write_byte(%struct.i2c_client* %5, i8 zeroext %conv21, i8 zeroext %13)
  %update_lock27 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %6, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock27)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv7, %if.then ], [ %count, %if.end ]
  %14 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %14) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_TEMP_AUTO_OFFSET_FROM_REG(i8 zeroext %reg, i32 %nr, i32 %mode) #1 {
entry:
  %cmp = icmp slt i32 %nr, 2
  %conv = zext i8 %reg to i32
  %shr = ashr i32 %conv, 4
  %shr.sink = select i1 %cmp, i32 %conv, i32 %shr
  %and3 = and i32 %shr.sink, 15
  %conv4 = trunc i32 %and3 to i8
  %call5 = call i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %conv4, i32 %mode)
  ret i32 %call5
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_TEMP_AUTO_OFFSET_TO_REG(i8 zeroext %old, i32 %off, i32 %nr, i32 %mode) #1 {
entry:
  %call = call zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %off, i32 %mode)
  %cmp = icmp slt i32 %nr, 2
  %conv4 = zext i8 %call to i32
  %shl = shl i32 %conv4, 4
  %conv = zext i8 %old to i32
  %shl.sink = select i1 %cmp, i32 %conv, i32 %shl
  %old.sink = select i1 %cmp, i8 %call, i8 %old
  %and5 = and i32 %shl.sink, 240
  %conv6 = zext i8 %old.sink to i32
  %and7 = and i32 %conv6, 15
  %or8 = or i32 %and5, %and7
  %conv9 = trunc i32 %or8 to i8
  ret i8 %conv9
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_pwm_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 24
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv = zext i8 %3 to i32
  %shr = ashr i32 %conv, 4
  %and = and i32 %shr, 15
  %conv1 = trunc i32 %and to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom2 = sext i32 %2 to i64
  %arrayidx3 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom2
  %arrayidx4 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx3, i64 0, i64 3
  %4 = load i8, i8* %arrayidx4, align 1, !tbaa !49
  %conv5 = zext i8 %4 to i32
  %and6 = and i32 %conv5, 7
  %tobool = icmp ne i32 %and6, 0
  %5 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call7 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv1, i32 %cond)
  %call8 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call7)
  %conv9 = sext i32 %call8 to i64
  ret i64 %conv9
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_pwm_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %div = sdiv i32 %2, 2
  %add = add nsw i32 195, %div
  %conv5 = trunc i32 %add to i8
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv5)
  %mul = mul nsw i32 %2, 4
  %add7 = add nsw i32 203, %mul
  %conv8 = trunc i32 %add7 to i8
  %call9 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv8)
  %conv10 = zext i8 %call6 to i32
  %and = and i32 %conv10, 15
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %conv11 = trunc i64 %7 to i32
  %conv12 = zext i8 %call9 to i32
  %and13 = and i32 %conv12, 7
  %tobool14 = icmp ne i32 %and13, 0
  %8 = zext i1 %tobool14 to i64
  %cond = select i1 %tobool14, i32 1, i32 0
  %call15 = call zeroext i8 @LM93_PWM_TO_REG(i32 %conv11, i32 %cond)
  %conv16 = zext i8 %call15 to i32
  %shl = shl i32 %conv16, 4
  %or = or i32 %and, %shl
  %conv17 = trunc i32 %or to i8
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 24
  %div18 = sdiv i32 %2, 2
  %idxprom = sext i32 %div18 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  store i8 %conv17, i8* %arrayidx, align 1, !tbaa !49
  %div19 = sdiv i32 %2, 2
  %add20 = add nsw i32 195, %div19
  %conv21 = trunc i32 %add20 to i8
  %call22 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv21, i8 zeroext %conv17)
  %update_lock23 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock23)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_PWM_FROM_REG(i8 zeroext %reg, i32 %freq) #1 {
entry:
  %idxprom = zext i32 %freq to i64
  %arrayidx = getelementptr inbounds [2 x [16 x i32]], [2 x [16 x i32]]* @lm93_pwm_map, i64 0, i64 %idxprom
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %idxprom1 = sext i32 %and to i64
  %arrayidx2 = getelementptr inbounds [16 x i32], [16 x i32]* %arrayidx, i64 0, i64 %idxprom1
  %0 = load i32, i32* %arrayidx2, align 4, !tbaa !54
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_PWM_TO_REG(i32 %pwm, i32 %freq) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = zext i32 %freq to i64
  %arrayidx = getelementptr inbounds [2 x [16 x i32]], [2 x [16 x i32]]* @lm93_pwm_map, i64 0, i64 %idxprom
  %idxprom1 = sext i32 %i.0 to i64
  %arrayidx2 = getelementptr inbounds [16 x i32], [16 x i32]* %arrayidx, i64 0, i64 %idxprom1
  %0 = load i32, i32* %arrayidx2, align 4, !tbaa !54
  %cmp3 = icmp sle i32 %pwm, %0
  br i1 %cmp3, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv = trunc i32 %i.0 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_temp_auto_offset_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %3 = load i8, i8* %sfc2, align 8, !tbaa !61
  %call1 = call i32 @LM93_TEMP_OFFSET_MODE_FROM_REG(i8 zeroext %3, i32 %2)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 24
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call2 = call i32 @LM93_TEMP_OFFSET_FROM_REG(i8 zeroext %4, i32 %call1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_temp_auto_offset_hyst(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call5 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 27
  store i8 %call5, i8* %sfc2, align 8, !tbaa !61
  %cmp = icmp slt i32 %2, 2
  %7 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 16, i32 32
  %sfc27 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 27
  %8 = load i8, i8* %sfc27, align 8, !tbaa !61
  %conv8 = zext i8 %8 to i32
  %or = or i32 %conv8, %cond
  %conv9 = trunc i32 %or to i8
  store i8 %conv9, i8* %sfc27, align 8, !tbaa !61
  %sfc210 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 27
  %9 = load i8, i8* %sfc210, align 8, !tbaa !61
  %call11 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -67, i8 zeroext %9)
  %auto_pwm_min_hyst = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 24
  %div = sdiv i32 %2, 2
  %idxprom = sext i32 %div to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst, i64 0, i64 %idxprom
  %10 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv12 = zext i8 %10 to i32
  %and = and i32 %conv12, 240
  %11 = load i64, i64* %val, align 8, !tbaa !68
  %conv13 = trunc i64 %11 to i32
  %call14 = call zeroext i8 @LM93_TEMP_OFFSET_TO_REG(i32 %conv13, i32 1)
  %conv15 = zext i8 %call14 to i32
  %and16 = and i32 %conv15, 15
  %or17 = or i32 %and, %and16
  %conv18 = trunc i32 %or17 to i8
  %auto_pwm_min_hyst19 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 24
  %div20 = sdiv i32 %2, 2
  %idxprom21 = sext i32 %div20 to i64
  %arrayidx22 = getelementptr inbounds [2 x i8], [2 x i8]* %auto_pwm_min_hyst19, i64 0, i64 %idxprom21
  store i8 %conv18, i8* %arrayidx22, align 1, !tbaa !49
  %div23 = sdiv i32 %2, 2
  %add = add nsw i32 195, %div23
  %conv24 = trunc i32 %add to i8
  %call25 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv24, i8 zeroext %conv18)
  %update_lock26 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock26)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %12 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_input(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 9
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i16], [4 x i16]* %block5, i64 0, i64 %idxprom
  %3 = load i16, i16* %arrayidx, align 2, !tbaa !53
  %call1 = call i32 @LM93_FAN_FROM_REG(i16 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_FAN_FROM_REG(i16 zeroext %regs) #1 {
entry:
  %conv = zext i16 %regs to i32
  %shr = ashr i32 %conv, 2
  %conv1 = trunc i32 %shr to i16
  %conv2 = zext i16 %conv1 to i32
  %cmp = icmp eq i32 %conv2, 0
  br i1 %cmp, label %cond.end10, label %cond.false

cond.false:                                       ; preds = %entry
  %conv4 = zext i16 %conv1 to i32
  %cmp5 = icmp eq i32 %conv4, 16383
  br i1 %cmp5, label %cond.end10, label %cond.false8

cond.false8:                                      ; preds = %cond.false
  %conv9 = zext i16 %conv1 to i32
  %div = sdiv i32 1350000, %conv9
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false8, %cond.false, %entry
  %cond11 = phi i32 [ -1, %entry ], [ %div, %cond.false8 ], [ 0, %cond.false ]
  ret i32 %cond11
}

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i64 0, i64 %idxprom
  %3 = load i16, i16* %arrayidx, align 2, !tbaa !53
  %call1 = call i32 @LM93_FAN_FROM_REG(i16 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_fan_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %call5 = call zeroext i16 @LM93_FAN_TO_REG(i64 %7)
  %block8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [4 x i16], [4 x i16]* %block8, i64 0, i64 %idxprom
  store i16 %call5, i16* %arrayidx, align 2, !tbaa !53
  %mul = mul nsw i32 %2, 2
  %add = add nsw i32 180, %mul
  %conv6 = trunc i32 %add to i8
  %block87 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 12
  %idxprom8 = sext i32 %2 to i64
  %arrayidx9 = getelementptr inbounds [4 x i16], [4 x i16]* %block87, i64 0, i64 %idxprom8
  %8 = load i16, i16* %arrayidx9, align 2, !tbaa !53
  %call10 = call i32 @lm93_write_word(%struct.i2c_client* %4, i8 zeroext %conv6, i16 zeroext %8)
  %update_lock11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock11)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @LM93_FAN_TO_REG(i64 %rpm) #1 {
entry:
  %cmp = icmp eq i64 %rpm, 0
  br i1 %cmp, label %if.end, label %if.else

if.else:                                          ; preds = %entry
  %cmp1 = icmp slt i64 %rpm, 1
  %.rpm = select i1 %cmp1, i64 1, i64 %rpm
  %cmp2 = icmp sgt i64 %.rpm, 1000000
  %cond6 = select i1 %cmp2, i64 1000000, i64 %.rpm
  %add = add nsw i64 1350000, %cond6
  %div = sdiv i64 %add, %cond6
  %cmp10 = icmp slt i64 %div, 1
  %.div = select i1 %cmp10, i64 1, i64 %div
  %cmp16 = icmp sgt i64 %.div, 16382
  %cond20 = select i1 %cmp16, i64 16382, i64 %.div
  %conv = trunc i64 %cond20 to i16
  br label %if.end

if.end:                                           ; preds = %entry, %if.else
  %count.0 = phi i16 [ %conv, %if.else ], [ 16383, %entry ]
  %conv21 = zext i16 %count.0 to i32
  %shl = shl i32 %conv21, 2
  %conv22 = trunc i32 %shl to i16
  ret i16 %conv22
}

; Function Attrs: nounwind uwtable
define internal i32 @lm93_write_word(%struct.i2c_client* %client, i8 zeroext %reg, i16 zeroext %value) #1 {
entry:
  %call = call i32 @i2c_smbus_write_word_data(%struct.i2c_client* %client, i8 zeroext %reg, i16 zeroext %value)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.i2c_client, %struct.i2c_client* %client, i32 0, i32 5
  %conv = zext i16 %value to i32
  %conv1 = zext i8 %reg to i32
  %call2 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.125, i32 0, i32 0), i32 %conv, i32 %conv1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 %call
}

declare i32 @i2c_smbus_write_word_data(%struct.i2c_client*, i8 zeroext, i16 zeroext) #2

; Function Attrs: nounwind uwtable
define internal i64 @show_fan_smart_tach(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %sf_tach_to_pwm = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 28
  %3 = load i8, i8* %sf_tach_to_pwm, align 1, !tbaa !62
  %conv = zext i8 %3 to i32
  %mul = mul nsw i32 %2, 2
  %shr = ashr i32 %conv, %mul
  %and = and i32 %shr, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 27
  %4 = load i8, i8* %sfc2, align 8, !tbaa !61
  %conv1 = zext i8 %4 to i32
  %shr2 = ashr i32 %conv1, %2
  %and3 = and i32 %shr2, 1
  %tobool4 = icmp ne i32 %and3, 0
  %conv5 = sext i32 %and to i64
  %conv5. = select i1 %tobool4, i64 %conv5, i64 0
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %rc.0 = phi i64 [ 0, %entry ], [ %conv5., %land.lhs.true ]
  %call6 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28, i32 0, i32 0), i64 %rc.0)
  %conv7 = sext i32 %call6 to i64
  ret i64 %conv7
}

; Function Attrs: nounwind uwtable
define internal i64 @store_fan_smart_tach(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %cmp = icmp ule i64 %7, 2
  br i1 %cmp, label %if.then6, label %if.end17

if.then6:                                         ; preds = %if.end
  %8 = load i64, i64* %val, align 8, !tbaa !68
  %tobool7 = icmp ne i64 %8, 0
  br i1 %tobool7, label %if.then8, label %if.end16

if.then8:                                         ; preds = %if.then6
  %9 = load i64, i64* %val, align 8, !tbaa !68
  %sub = sub i64 %9, 1
  %mul = mul i64 %sub, 4
  %add = add i64 203, %mul
  %conv9 = trunc i64 %add to i8
  %call10 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv9)
  %conv11 = zext i8 %call10 to i32
  %and = and i32 %conv11, 7
  %cmp12 = icmp eq i32 %and, 0
  br i1 %cmp12, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.then8
  store i64 0, i64* %val, align 8, !tbaa !68
  br label %if.end16

if.end16:                                         ; preds = %if.then8, %if.then14, %if.then6
  %10 = load i64, i64* %val, align 8, !tbaa !68
  call void @lm93_write_fan_smart_tach(%struct.i2c_client* %4, %struct.lm93_data* %5, i32 %2, i64 %10)
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end
  %update_lock18 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock18)
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end17 ]
  %11 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %11) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @lm93_write_fan_smart_tach(%struct.i2c_client* %client, %struct.lm93_data* %data, i32 %fan, i64 %value) #1 {
entry:
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -32)
  %sf_tach_to_pwm = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  store i8 %call, i8* %sf_tach_to_pwm, align 1, !tbaa !62
  %mul = mul nsw i32 %fan, 2
  %shl = shl i32 3, %mul
  %neg = xor i32 %shl, -1
  %sf_tach_to_pwm1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  %0 = load i8, i8* %sf_tach_to_pwm1, align 1, !tbaa !62
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, %neg
  %conv2 = trunc i32 %and to i8
  store i8 %conv2, i8* %sf_tach_to_pwm1, align 1, !tbaa !62
  %mul3 = mul nsw i32 %fan, 2
  %sh_prom = zext i32 %mul3 to i64
  %shl4 = shl i64 %value, %sh_prom
  %sf_tach_to_pwm5 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  %1 = load i8, i8* %sf_tach_to_pwm5, align 1, !tbaa !62
  %conv6 = zext i8 %1 to i64
  %or = or i64 %conv6, %shl4
  %conv7 = trunc i64 %or to i8
  store i8 %conv7, i8* %sf_tach_to_pwm5, align 1, !tbaa !62
  %sf_tach_to_pwm8 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 28
  %2 = load i8, i8* %sf_tach_to_pwm8, align 1, !tbaa !62
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -32, i8 zeroext %2)
  %call10 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  store i8 %call10, i8* %sfc2, align 8, !tbaa !61
  %tobool = icmp ne i64 %value, 0
  %shl11 = shl i32 1, %fan
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %sfc212 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %3 = load i8, i8* %sfc212, align 8, !tbaa !61
  %conv13 = zext i8 %3 to i32
  %or14 = or i32 %conv13, %shl11
  br label %if.end

if.else:                                          ; preds = %entry
  %neg17 = xor i32 %shl11, -1
  %sfc218 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %4 = load i8, i8* %sfc218, align 8, !tbaa !61
  %conv19 = zext i8 %4 to i32
  %and20 = and i32 %conv19, %neg17
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %and20.sink = phi i32 [ %and20, %if.else ], [ %or14, %if.then ]
  %sfc218.sink = phi i8* [ %sfc218, %if.else ], [ %sfc212, %if.then ]
  %conv21 = trunc i32 %and20.sink to i8
  store i8 %conv21, i8* %sfc218.sink, align 8, !tbaa !61
  %sfc222 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %5 = load i8, i8* %sfc222, align 8, !tbaa !61
  %call23 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -67, i8 zeroext %5)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 1
  %3 = load i8, i8* %arrayidx1, align 1, !tbaa !49
  %block92 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom3 = sext i32 %2 to i64
  %arrayidx4 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block92, i64 0, i64 %idxprom3
  %arrayidx5 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx4, i64 0, i64 3
  %4 = load i8, i8* %arrayidx5, align 1, !tbaa !49
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %pwm_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 29
  %idxprom6 = sext i32 %2 to i64
  %arrayidx7 = getelementptr inbounds [2 x i8], [2 x i8]* %pwm_override, i64 0, i64 %idxprom6
  %5 = load i8, i8* %arrayidx7, align 1, !tbaa !49
  %conv8 = zext i8 %5 to i64
  br label %if.end

if.else:                                          ; preds = %entry
  %conv9 = zext i8 %3 to i32
  %shr = ashr i32 %conv9, 4
  %conv10 = trunc i32 %shr to i8
  %conv11 = zext i8 %4 to i32
  %and12 = and i32 %conv11, 7
  %tobool13 = icmp ne i32 %and12, 0
  %6 = zext i1 %tobool13 to i64
  %cond = select i1 %tobool13, i32 1, i32 0
  %call14 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv10, i32 %cond)
  %conv15 = sext i32 %call14 to i64
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %rc.0 = phi i64 [ %conv8, %if.then ], [ %conv15, %if.else ]
  %call16 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28, i32 0, i32 0), i64 %rc.0)
  %conv17 = sext i32 %call16 to i64
  ret i64 %conv17
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 201, %mul
  %conv5 = trunc i32 %add to i8
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv5)
  %mul7 = mul nsw i32 %2, 4
  %add8 = add nsw i32 203, %mul7
  %conv9 = trunc i32 %add8 to i8
  %call10 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv9)
  %conv11 = zext i8 %call6 to i32
  %and = and i32 %conv11, 15
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %conv12 = trunc i64 %7 to i32
  %conv13 = zext i8 %call10 to i32
  %and14 = and i32 %conv13, 7
  %tobool15 = icmp ne i32 %and14, 0
  %8 = zext i1 %tobool15 to i64
  %cond = select i1 %tobool15, i32 1, i32 0
  %call16 = call zeroext i8 @LM93_PWM_TO_REG(i32 %conv12, i32 %cond)
  %conv17 = zext i8 %call16 to i32
  %shl = shl i32 %conv17, 4
  %or = or i32 %and, %shl
  %conv18 = trunc i32 %or to i8
  %conv19 = zext i8 %conv18 to i32
  %shr = ashr i32 %conv19, 4
  %conv20 = trunc i32 %shr to i8
  %conv21 = zext i8 %call10 to i32
  %and22 = and i32 %conv21, 7
  %tobool23 = icmp ne i32 %and22, 0
  %9 = zext i1 %tobool23 to i64
  %cond24 = select i1 %tobool23, i32 1, i32 0
  %call25 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv20, i32 %cond24)
  %conv26 = trunc i32 %call25 to i8
  %pwm_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 29
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %pwm_override, i64 0, i64 %idxprom
  store i8 %conv26, i8* %arrayidx, align 1, !tbaa !49
  %mul27 = mul nsw i32 %2, 4
  %add28 = add nsw i32 201, %mul27
  %conv29 = trunc i32 %add28 to i8
  %call30 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv29, i8 zeroext %conv18)
  %update_lock31 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock31)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %10 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_enable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 1
  %3 = load i8, i8* %arrayidx1, align 1, !tbaa !49
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv2 = zext i8 %3 to i32
  %and3 = and i32 %conv2, 240
  %cmp = icmp eq i32 %and3, 240
  %4 = zext i1 %cmp to i64
  %cond = select i1 %cmp, i32 0, i32 1
  %conv5 = sext i32 %cond to i64
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %rc.0 = phi i64 [ %conv5, %if.then ], [ 2, %entry ]
  %call6 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.28, i32 0, i32 0), i64 %rc.0)
  %conv7 = sext i32 %call6 to i64
  ret i64 %conv7
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_enable(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 201, %mul
  %conv5 = trunc i32 %add to i8
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv5)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  br label %NodeBlock3

NodeBlock3:                                       ; preds = %if.end
  %Pivot4 = icmp slt i64 %7, 1
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i64 %7, 2
  br i1 %Pivot, label %sw.bb9, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i64 %7, 2
  br i1 %SwitchLeaf2, label %sw.bb13, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i64 %7, 0
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %conv7 = zext i8 %call6 to i32
  %or = or i32 %conv7, 241
  br label %sw.epilog

sw.bb9:                                           ; preds = %NodeBlock
  %conv10 = zext i8 %call6 to i32
  %or11 = or i32 %conv10, 1
  br label %sw.epilog

sw.bb13:                                          ; preds = %LeafBlock1
  %conv14 = zext i8 %call6 to i32
  %and = and i32 %conv14, -2
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %update_lock16 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock16)
  br label %cleanup

sw.epilog:                                        ; preds = %sw.bb13, %sw.bb9, %sw.bb
  %and.sink = phi i32 [ %and, %sw.bb13 ], [ %or11, %sw.bb9 ], [ %or, %sw.bb ]
  %conv15 = trunc i32 %and.sink to i8
  %mul17 = mul nsw i32 %2, 4
  %add18 = add nsw i32 201, %mul17
  %conv19 = trunc i32 %add18 to i8
  %call20 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv19, i8 zeroext %conv15)
  %update_lock21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock21)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %sw.default, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ -22, %sw.default ], [ %count, %sw.epilog ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_freq(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 3
  %3 = load i8, i8* %arrayidx1, align 1, !tbaa !49
  %call2 = call i32 @LM93_PWM_FREQ_FROM_REG(i8 zeroext %3)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_freq(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 203, %mul
  %conv5 = trunc i32 %add to i8
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv5)
  %conv7 = zext i8 %call6 to i32
  %and = and i32 %conv7, 248
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %conv8 = trunc i64 %7 to i32
  %call9 = call zeroext i8 @LM93_PWM_FREQ_TO_REG(i32 %conv8)
  %conv10 = zext i8 %call9 to i32
  %or = or i32 %and, %conv10
  %conv11 = trunc i32 %or to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx12 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 3
  store i8 %conv11, i8* %arrayidx12, align 1, !tbaa !49
  %tobool13 = icmp ne i8 %conv11, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  call void @lm93_disable_fan_smart_tach(%struct.i2c_client* %4, %struct.lm93_data* %5, i32 %2)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end
  %mul16 = mul nsw i32 %2, 4
  %add17 = add nsw i32 203, %mul16
  %conv18 = trunc i32 %add17 to i8
  %call19 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv18, i8 zeroext %conv11)
  %update_lock20 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock20)
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end15 ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_PWM_FREQ_FROM_REG(i8 zeroext %reg) #1 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 7
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_pwm_freq_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !54
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_PWM_FREQ_TO_REG(i32 %freq) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 7, %entry ], [ %dec, %for.inc ]
  %cmp = icmp sgt i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_pwm_freq_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !54
  %cmp1 = icmp sle i32 %freq, %0
  br i1 %cmp1, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv = trunc i32 %i.0 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal void @lm93_disable_fan_smart_tach(%struct.i2c_client* %client, %struct.lm93_data* %data, i32 %pwm) #1 {
entry:
  %call = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -32)
  %conv = zext i8 %call to i32
  %shr = ashr i32 %conv, %pwm
  %and = and i32 %shr, 85
  %and1 = and i32 %and, 1
  %and2 = and i32 %and, 4
  %shr3 = ashr i32 %and2, 1
  %or = or i32 %and1, %shr3
  %and4 = and i32 %and, 16
  %shr5 = ashr i32 %and4, 2
  %or6 = or i32 %or, %shr5
  %and7 = and i32 %and, 64
  %shr8 = ashr i32 %and7, 3
  %or9 = or i32 %or6, %shr8
  %call10 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %client, i8 zeroext -67)
  %sfc2 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  store i8 %call10, i8* %sfc2, align 8, !tbaa !61
  %neg = xor i32 %or9, -1
  %sfc211 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %0 = load i8, i8* %sfc211, align 8, !tbaa !61
  %conv12 = zext i8 %0 to i32
  %and13 = and i32 %conv12, %neg
  %conv14 = trunc i32 %and13 to i8
  store i8 %conv14, i8* %sfc211, align 8, !tbaa !61
  %sfc215 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %data, i32 0, i32 27
  %1 = load i8, i8* %sfc215, align 8, !tbaa !61
  %call16 = call i32 @lm93_write_byte(%struct.i2c_client* %client, i8 zeroext -67, i8 zeroext %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_channels(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 0
  %3 = load i8, i8* %arrayidx1, align 4, !tbaa !49
  %conv = zext i8 %3 to i32
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %conv)
  %conv3 = sext i32 %call2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_channels(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %cmp = icmp ult i64 %7, 0
  %. = select i1 %cmp, i64 0, i64 %7
  %cmp7 = icmp ugt i64 %., 255
  %cond12 = select i1 %cmp7, i64 255, i64 %.
  %conv13 = trunc i64 %cond12 to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx14 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 0
  store i8 %conv13, i8* %arrayidx14, align 4, !tbaa !49
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 200, %mul
  %conv15 = trunc i32 %add to i8
  %block916 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 13
  %idxprom17 = sext i32 %2 to i64
  %arrayidx18 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block916, i64 0, i64 %idxprom17
  %arrayidx19 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx18, i64 0, i64 0
  %8 = load i8, i8* %arrayidx19, align 4, !tbaa !49
  %call20 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv15, i8 zeroext %8)
  %update_lock21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock21)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_spinup_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  %3 = load i8, i8* %arrayidx1, align 2, !tbaa !49
  %block92 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom3 = sext i32 %2 to i64
  %arrayidx4 = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block92, i64 0, i64 %idxprom3
  %arrayidx5 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx4, i64 0, i64 3
  %4 = load i8, i8* %arrayidx5, align 1, !tbaa !49
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 15
  %conv6 = trunc i32 %and to i8
  %conv7 = zext i8 %4 to i32
  %and8 = and i32 %conv7, 7
  %tobool = icmp ne i32 %and8, 0
  %5 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call9 = call i32 @LM93_PWM_FROM_REG(i8 zeroext %conv6, i32 %cond)
  %call10 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call9)
  %conv11 = sext i32 %call10 to i64
  ret i64 %conv11
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_spinup_min(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 202, %mul
  %conv5 = trunc i32 %add to i8
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv5)
  %mul7 = mul nsw i32 %2, 4
  %add8 = add nsw i32 203, %mul7
  %conv9 = trunc i32 %add8 to i8
  %call10 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv9)
  %conv11 = zext i8 %call6 to i32
  %and = and i32 %conv11, 240
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %conv12 = trunc i64 %7 to i32
  %conv13 = zext i8 %call10 to i32
  %and14 = and i32 %conv13, 7
  %tobool15 = icmp ne i32 %and14, 0
  %8 = zext i1 %tobool15 to i64
  %cond = select i1 %tobool15, i32 1, i32 0
  %call16 = call zeroext i8 @LM93_PWM_TO_REG(i32 %conv12, i32 %cond)
  %conv17 = zext i8 %call16 to i32
  %or = or i32 %and, %conv17
  %conv18 = trunc i32 %or to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx19 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  store i8 %conv18, i8* %arrayidx19, align 2, !tbaa !49
  %mul20 = mul nsw i32 %2, 4
  %add21 = add nsw i32 202, %mul20
  %conv22 = trunc i32 %add21 to i8
  %call23 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv22, i8 zeroext %conv18)
  %update_lock24 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock24)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_spinup_time(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx1 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  %3 = load i8, i8* %arrayidx1, align 2, !tbaa !49
  %call2 = call i32 @LM93_SPINUP_TIME_FROM_REG(i8 zeroext %3)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call2)
  %conv = sext i32 %call3 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_spinup_time(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %mul = mul nsw i32 %2, 4
  %add = add nsw i32 202, %mul
  %conv5 = trunc i32 %add to i8
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext %conv5)
  %conv7 = zext i8 %call6 to i32
  %and = and i32 %conv7, 31
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %conv8 = trunc i64 %7 to i32
  %call9 = call zeroext i8 @LM93_SPINUP_TIME_TO_REG(i32 %conv8)
  %conv10 = zext i8 %call9 to i32
  %shl = shl i32 %conv10, 5
  %and11 = and i32 %shl, 224
  %or = or i32 %and, %and11
  %conv12 = trunc i32 %or to i8
  %block9 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 13
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x [4 x i8]], [2 x [4 x i8]]* %block9, i64 0, i64 %idxprom
  %arrayidx13 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i64 0, i64 2
  store i8 %conv12, i8* %arrayidx13, align 2, !tbaa !49
  %mul14 = mul nsw i32 %2, 4
  %add15 = add nsw i32 202, %mul14
  %conv16 = trunc i32 %add15 to i8
  %call17 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv16, i8 zeroext %conv12)
  %update_lock18 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock18)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %8 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_SPINUP_TIME_FROM_REG(i8 zeroext %reg) #1 {
entry:
  %conv = zext i8 %reg to i32
  %shr = ashr i32 %conv, 5
  %and = and i32 %shr, 7
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_spinup_time_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !54
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_SPINUP_TIME_TO_REG(i32 %time) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* @lm93_spinup_time_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !54
  %cmp1 = icmp sle i32 %time, %0
  br i1 %cmp1, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv = trunc i32 %i.0 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_prochot_ramp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %pwm_ramp_ctl = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 25
  %0 = load i8, i8* %pwm_ramp_ctl, align 2, !tbaa !59
  %conv = zext i8 %0 to i32
  %shr = ashr i32 %conv, 4
  %and = and i32 %shr, 15
  %conv1 = trunc i32 %and to i8
  %call2 = call i32 @LM93_RAMP_FROM_REG(i8 zeroext %conv1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call2)
  %conv4 = sext i32 %call3 to i64
  ret i64 %conv4
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_prochot_ramp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %1)
  %2 = bitcast i8* %call to %struct.lm93_data*
  %3 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call2 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %1, i8 zeroext -65)
  %conv3 = zext i8 %call2 to i32
  %and = and i32 %conv3, 15
  %4 = load i64, i64* %val, align 8, !tbaa !68
  %conv4 = trunc i64 %4 to i32
  %call5 = call zeroext i8 @LM93_RAMP_TO_REG(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %shl = shl i32 %conv6, 4
  %and7 = and i32 %shl, 240
  %or = or i32 %and, %and7
  %conv8 = trunc i32 %or to i8
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -65, i8 zeroext %conv8)
  %update_lock10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_RAMP_FROM_REG(i8 zeroext %reg) #1 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %mul = mul nsw i32 %and, 5
  ret i32 %mul
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_RAMP_TO_REG(i32 %ramp) #1 {
entry:
  %cmp = icmp slt i32 %ramp, 0
  %.ramp = select i1 %cmp, i32 0, i32 %ramp
  %cmp1 = icmp sgt i32 %.ramp, 75
  %cond5 = select i1 %cmp1, i32 75, i32 %.ramp
  %add = add nsw i32 %cond5, 2
  %div = sdiv i32 %add, 5
  %conv = trunc i32 %div to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_pwm_auto_vrdhot_ramp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %pwm_ramp_ctl = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 25
  %0 = load i8, i8* %pwm_ramp_ctl, align 2, !tbaa !59
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %conv1 = trunc i32 %and to i8
  %call2 = call i32 @LM93_RAMP_FROM_REG(i8 zeroext %conv1)
  %call3 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call2)
  %conv4 = sext i32 %call3 to i64
  ret i64 %conv4
}

; Function Attrs: nounwind uwtable
define internal i64 @store_pwm_auto_vrdhot_ramp(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %1)
  %2 = bitcast i8* %call to %struct.lm93_data*
  %3 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call2 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %1, i8 zeroext -65)
  %conv3 = zext i8 %call2 to i32
  %and = and i32 %conv3, 240
  %4 = load i64, i64* %val, align 8, !tbaa !68
  %conv4 = trunc i64 %4 to i32
  %call5 = call zeroext i8 @LM93_RAMP_TO_REG(i32 %conv4)
  %conv6 = zext i8 %call5 to i32
  %and7 = and i32 %conv6, 15
  %or = or i32 %and, %and7
  %conv8 = trunc i32 %or to i8
  %call9 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -65, i8 zeroext %conv8)
  %update_lock10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock10)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ 0, %if.end ]
  %5 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_vid(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %vid = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 16
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %vid, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %call1 = call i32 @LM93_VID_FROM_REG(i8 zeroext %3)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 8
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x %struct.anon.32], [2 x %struct.anon.32]* %block4, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.32, %struct.anon.32* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %cur, align 1, !tbaa !50
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_avg(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block4 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 8
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x %struct.anon.32], [2 x %struct.anon.32]* %block4, i64 0, i64 %idxprom
  %avg = getelementptr inbounds %struct.anon.32, %struct.anon.32* %arrayidx, i32 0, i32 1
  %3 = load i8, i8* %avg, align 1, !tbaa !52
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %prochot_max = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max, i64 0, i64 %idxprom
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv = zext i8 %3 to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_max(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %call5 = call zeroext i8 @LM93_PROCHOT_TO_REG(i64 %7)
  %prochot_max = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 17
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max, i64 0, i64 %idxprom
  store i8 %call5, i8* %arrayidx, align 1, !tbaa !49
  %add = add nsw i32 176, %2
  %conv6 = trunc i32 %add to i8
  %prochot_max7 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 17
  %idxprom8 = sext i32 %2 to i64
  %arrayidx9 = getelementptr inbounds [2 x i8], [2 x i8]* %prochot_max7, i64 0, i64 %idxprom8
  %8 = load i8, i8* %arrayidx9, align 1, !tbaa !49
  %call10 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext %conv6, i8 zeroext %8)
  %update_lock11 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock11)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_PROCHOT_TO_REG(i64 %prochot) #1 {
entry:
  %cmp = icmp slt i64 %prochot, 0
  %.prochot = select i1 %cmp, i64 0, i64 %prochot
  %cmp1 = icmp sgt i64 %.prochot, 255
  %cond5 = select i1 %cmp1, i64 255, i64 %.prochot
  %conv = trunc i64 %cond5 to i8
  ret i8 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_override(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 20
  %3 = load i8, i8* %prochot_override, align 4, !tbaa !57
  %conv = zext i8 %3 to i32
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* @prochot_override_mask, i64 0, i64 %idxprom
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv1 = zext i8 %4 to i32
  %and = and i32 %conv, %conv1
  %tobool = icmp ne i32 %and, 0
  %5 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %cond)
  %conv3 = sext i32 %call2 to i64
  ret i64 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_override(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call4 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call4 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %tobool5 = icmp ne i64 %7, 0
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* @prochot_override_mask, i64 0, i64 %idxprom
  %8 = load i8, i8* %arrayidx, align 1, !tbaa !49
  %conv7 = zext i8 %8 to i32
  br i1 %tobool5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 20
  %9 = load i8, i8* %prochot_override, align 4, !tbaa !57
  %conv8 = zext i8 %9 to i32
  %or = or i32 %conv8, %conv7
  br label %if.end16

if.else:                                          ; preds = %if.end
  %neg = xor i32 %conv7, -1
  %prochot_override13 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 20
  %10 = load i8, i8* %prochot_override13, align 4, !tbaa !57
  %conv14 = zext i8 %10 to i32
  %and = and i32 %conv14, %neg
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then6
  %and.sink = phi i32 [ %and, %if.else ], [ %or, %if.then6 ]
  %prochot_override13.sink = phi i8* [ %prochot_override13, %if.else ], [ %prochot_override, %if.then6 ]
  %conv15 = trunc i32 %and.sink to i8
  store i8 %conv15, i8* %prochot_override13.sink, align 4, !tbaa !57
  %prochot_override17 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 20
  %11 = load i8, i8* %prochot_override17, align 4, !tbaa !57
  %call18 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -58, i8 zeroext %11)
  %update_lock19 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock19)
  br label %cleanup

cleanup:                                          ; preds = %if.end16, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end16 ]
  %12 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_interval(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %cmp = icmp eq i32 %2, 1
  %prochot_interval = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 21
  %3 = load i8, i8* %prochot_interval, align 1, !tbaa !58
  %conv = zext i8 %3 to i32
  %and5 = and i32 %conv, 15
  %and = and i32 %conv, 240
  %shr = ashr i32 %and, 4
  %and5.sink = select i1 %cmp, i32 %shr, i32 %and5
  %conv6 = trunc i32 %and5.sink to i8
  %call7 = call i32 @LM93_INTERVAL_FROM_REG(i8 zeroext %conv6)
  %call8 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call7)
  %conv9 = sext i32 %call8 to i64
  ret i64 %conv9
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_interval(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %3 = bitcast %struct.device* %dev to i8*
  %add.ptr3 = getelementptr inbounds i8, i8* %3, i64 -40
  %4 = bitcast i8* %add.ptr3 to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %4)
  %5 = bitcast i8* %call to %struct.lm93_data*
  %6 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %call5 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call5 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %call6 = call zeroext i8 @lm93_read_byte(%struct.i2c_client* %4, i8 zeroext -57)
  %cmp = icmp eq i32 %2, 1
  %conv9 = zext i8 %call6 to i32
  br i1 %cmp, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end
  %and = and i32 %conv9, 15
  %7 = load i64, i64* %val, align 8, !tbaa !68
  %call10 = call zeroext i8 @LM93_INTERVAL_TO_REG(i64 %7)
  %conv11 = zext i8 %call10 to i32
  %shl = shl i32 %conv11, 4
  %or = or i32 %and, %shl
  br label %if.end19

if.else:                                          ; preds = %if.end
  %and14 = and i32 %conv9, 240
  %8 = load i64, i64* %val, align 8, !tbaa !68
  %call15 = call zeroext i8 @LM93_INTERVAL_TO_REG(i64 %8)
  %conv16 = zext i8 %call15 to i32
  %or17 = or i32 %and14, %conv16
  br label %if.end19

if.end19:                                         ; preds = %if.else, %if.then8
  %or17.sink = phi i32 [ %or17, %if.else ], [ %or, %if.then8 ]
  %conv18 = trunc i32 %or17.sink to i8
  %prochot_interval = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 21
  store i8 %conv18, i8* %prochot_interval, align 1, !tbaa !58
  %call20 = call i32 @lm93_write_byte(%struct.i2c_client* %4, i8 zeroext -57, i8 zeroext %conv18)
  %update_lock21 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %5, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock21)
  br label %cleanup

cleanup:                                          ; preds = %if.end19, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end19 ]
  %9 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_INTERVAL_FROM_REG(i8 zeroext %reg) #1 {
entry:
  %conv = zext i8 %reg to i32
  %and = and i32 %conv, 15
  %idxprom = sext i32 %and to i64
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* @lm93_interval_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !54
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @LM93_INTERVAL_TO_REG(i64 %interval) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [10 x i32], [10 x i32]* @lm93_interval_map, i64 0, i64 %idxprom
  %0 = load i32, i32* %arrayidx, align 4, !tbaa !54
  %conv = sext i32 %0 to i64
  %cmp1 = icmp sle i64 %interval, %conv
  br i1 %cmp1, label %for.end, label %for.inc

for.inc:                                          ; preds = %for.body
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %conv3 = trunc i32 %i.0 to i8
  ret i8 %conv3
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_override_duty_cycle(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 20
  %0 = load i8, i8* %prochot_override, align 4, !tbaa !57
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 15
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %and)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_override_duty_cycle(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %1)
  %2 = bitcast i8* %call to %struct.lm93_data*
  %3 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %prochot_override = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 20
  %4 = load i8, i8* %prochot_override, align 4, !tbaa !57
  %conv2 = zext i8 %4 to i32
  %and = and i32 %conv2, 240
  %conv3 = sext i32 %and to i64
  %5 = load i64, i64* %val, align 8, !tbaa !68
  %cmp = icmp ult i64 %5, 0
  %. = select i1 %cmp, i64 0, i64 %5
  %cmp6 = icmp ugt i64 %., 15
  %cond11 = select i1 %cmp6, i64 15, i64 %.
  %or = or i64 %conv3, %cond11
  %conv12 = trunc i64 %or to i8
  %prochot_override13 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 20
  store i8 %conv12, i8* %prochot_override13, align 4, !tbaa !57
  %prochot_override14 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 20
  %6 = load i8, i8* %prochot_override14, align 4, !tbaa !57
  %call15 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -58, i8 zeroext %6)
  %update_lock16 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock16)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_prochot_short(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %config = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 15
  %0 = load i8, i8* %config, align 4, !tbaa !55
  %conv = zext i8 %0 to i32
  %and = and i32 %conv, 16
  %tobool = icmp ne i32 %and, 0
  %1 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %cond)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @store_prochot_short(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %val = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -40
  %1 = bitcast i8* %add.ptr to %struct.i2c_client*
  %call = call i8* @i2c_get_clientdata(%struct.i2c_client* %1)
  %2 = bitcast i8* %call to %struct.lm93_data*
  %3 = bitcast i64* %val to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #5
  %call1 = call i32 @kstrtoul(i8* %buf, i32 10, i64* %val)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end:                                           ; preds = %entry
  %update_lock = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_lock(%struct.mutex* %update_lock)
  %4 = load i64, i64* %val, align 8, !tbaa !68
  %tobool2 = icmp ne i64 %4, 0
  %config = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 15
  %5 = load i8, i8* %config, align 4, !tbaa !55
  %conv4 = zext i8 %5 to i32
  %and = and i32 %conv4, -17
  %or = or i32 %conv4, 16
  %and.sink = select i1 %tobool2, i32 %or, i32 %and
  %conv8 = trunc i32 %and.sink to i8
  store i8 %conv8, i8* %config, align 4, !tbaa !55
  %config10 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 15
  %6 = load i8, i8* %config10, align 4, !tbaa !55
  %call11 = call i32 @lm93_write_byte(%struct.i2c_client* %1, i8 zeroext -29, i8 zeroext %6)
  %update_lock12 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %2, i32 0, i32 1
  call void @mutex_unlock(%struct.mutex* %update_lock12)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i64 [ %conv, %if.then ], [ %count, %if.end ]
  %7 = bitcast i64* %val to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #5
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @show_vrdhot(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device_attribute* %attr to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sensor_device_attribute*
  %index = getelementptr inbounds %struct.sensor_device_attribute, %struct.sensor_device_attribute* %1, i32 0, i32 1
  %2 = load i32, i32* %index, align 8, !tbaa !63
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 5
  %host_status_1 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %block1, i32 0, i32 0
  %3 = load i8, i8* %host_status_1, align 1, !tbaa !72
  %conv = zext i8 %3 to i32
  %add = add nsw i32 %2, 4
  %shl = shl i32 1, %add
  %and = and i32 %conv, %shl
  %tobool = icmp ne i32 %and, 0
  %4 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %cond)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @show_gpio(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %gpi = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 19
  %0 = load i8, i8* %gpi, align 1, !tbaa !56
  %call1 = call i32 @LM93_GPI_FROM_REG(i8 zeroext %0)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_GPI_FROM_REG(i8 zeroext %reg) #1 {
entry:
  %conv = zext i8 %reg to i32
  %neg = xor i32 %conv, -1
  %and = and i32 %neg, 255
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define internal i64 @show_alarms(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call %struct.lm93_data* @lm93_update_device(%struct.device* %dev)
  %block1 = getelementptr inbounds %struct.lm93_data, %struct.lm93_data* %call, i32 0, i32 5
  %0 = bitcast %struct.block1_t* %block1 to i64*
  %1 = load i64, i64* %0, align 1
  %call1 = call i32 @LM93_ALARMS_FROM_REG(i64 %1)
  %call2 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i32 %call1)
  %conv = sext i32 %call2 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @LM93_ALARMS_FROM_REG(i64 %b1.coerce) #1 {
entry:
  %b1 = alloca %struct.block1_t, align 1
  %0 = bitcast %struct.block1_t* %b1 to i64*
  store i64 %b1.coerce, i64* %0, align 1
  %host_status_2 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 1
  %1 = load i8, i8* %host_status_2, align 1, !tbaa !73
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 63
  %2 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 0), align 4, !tbaa !54
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %host_status_4 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 3
  %3 = load i8, i8* %host_status_4, align 1, !tbaa !74
  %conv1 = zext i8 %3 to i32
  %and2 = and i32 %conv1, 16
  %shl = shl i32 %and2, 2
  br label %if.end

if.else:                                          ; preds = %entry
  %host_status_23 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 1
  %4 = load i8, i8* %host_status_23, align 1, !tbaa !73
  %conv4 = zext i8 %4 to i32
  %and5 = and i32 %conv4, 64
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %and5.sink = phi i32 [ %and5, %if.else ], [ %shl, %if.then ]
  %or6 = or i32 %and, %and5.sink
  %5 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @vccp_limit_type, i64 0, i64 1), align 4, !tbaa !54
  %tobool7 = icmp ne i32 %5, 0
  br i1 %tobool7, label %if.then8, label %if.else14

if.then8:                                         ; preds = %if.end
  %host_status_49 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 3
  %6 = load i8, i8* %host_status_49, align 1, !tbaa !74
  %conv10 = zext i8 %6 to i32
  %and11 = and i32 %conv10, 32
  %shl12 = shl i32 %and11, 2
  br label %if.end19

if.else14:                                        ; preds = %if.end
  %host_status_215 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 1
  %7 = load i8, i8* %host_status_215, align 1, !tbaa !73
  %conv16 = zext i8 %7 to i32
  %and17 = and i32 %conv16, 128
  br label %if.end19

if.end19:                                         ; preds = %if.else14, %if.then8
  %and17.sink = phi i32 [ %and17, %if.else14 ], [ %shl12, %if.then8 ]
  %or18 = or i32 %or6, %and17.sink
  %host_status_3 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 2
  %8 = load i8, i8* %host_status_3, align 1, !tbaa !75
  %conv20 = zext i8 %8 to i32
  %shl21 = shl i32 %conv20, 8
  %or22 = or i32 %or18, %shl21
  %fan_status = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 7
  %9 = load i8, i8* %fan_status, align 1, !tbaa !76
  %conv23 = zext i8 %9 to i32
  %and24 = and i32 %conv23, 15
  %shl25 = shl i32 %and24, 16
  %or26 = or i32 %or22, %shl25
  %p1_prochot_status = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 4
  %10 = load i8, i8* %p1_prochot_status, align 1, !tbaa !77
  %conv27 = zext i8 %10 to i32
  %and28 = and i32 %conv27, 128
  %shl29 = shl i32 %and28, 13
  %or30 = or i32 %or26, %shl29
  %p2_prochot_status = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 5
  %11 = load i8, i8* %p2_prochot_status, align 1, !tbaa !78
  %conv31 = zext i8 %11 to i32
  %and32 = and i32 %conv31, 128
  %shl33 = shl i32 %and32, 14
  %or34 = or i32 %or30, %shl33
  %host_status_435 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 3
  %12 = load i8, i8* %host_status_435, align 1, !tbaa !74
  %conv36 = zext i8 %12 to i32
  %and37 = and i32 %conv36, 252
  %shl38 = shl i32 %and37, 20
  %or39 = or i32 %or34, %shl38
  %host_status_1 = getelementptr inbounds %struct.block1_t, %struct.block1_t* %b1, i32 0, i32 0
  %13 = load i8, i8* %host_status_1, align 1, !tbaa !79
  %conv40 = zext i8 %13 to i32
  %and41 = and i32 %conv40, 7
  %shl42 = shl i32 %and41, 28
  %or43 = or i32 %or39, %shl42
  ret i32 %or43
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

declare void @hwmon_device_unregister(%struct.device*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @i2c_check_functionality(%struct.i2c_adapter* %adap, i32 %func) #0 {
entry:
  %call = call i32 @i2c_get_functionality(%struct.i2c_adapter* %adap)
  %and = and i32 %func, %call
  %cmp = icmp eq i32 %and, %func
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

declare i64 @strlcpy(i8*, i8*, i64) #2

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !4, i64 24}
!13 = !{!"i2c_client", !14, i64 0, !14, i64 2, !5, i64 4, !4, i64 24, !4, i64 32, !15, i64 40, !20, i64 480, !17, i64 488}
!14 = !{!"short", !5, i64 0}
!15 = !{!"device", !4, i64 0, !4, i64 8, !16, i64 16, !4, i64 80, !4, i64 88, !21, i64 96, !4, i64 136, !4, i64 144, !4, i64 152, !23, i64 160, !4, i64 248, !20, i64 256, !4, i64 264, !28, i64 272, !4, i64 280, !17, i64 288, !4, i64 304, !29, i64 312, !4, i64 328, !30, i64 336, !20, i64 344, !20, i64 348, !22, i64 352, !17, i64 360, !31, i64 376, !4, i64 408, !4, i64 416, !4, i64 424, !4, i64 432}
!16 = !{!"kobject", !4, i64 0, !17, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !18, i64 56, !20, i64 60, !20, i64 60, !20, i64 60, !20, i64 60, !20, i64 60}
!17 = !{!"list_head", !4, i64 0, !4, i64 8}
!18 = !{!"kref", !19, i64 0}
!19 = !{!"", !20, i64 0}
!20 = !{!"int", !5, i64 0}
!21 = !{!"mutex", !19, i64 0, !22, i64 4, !17, i64 8, !4, i64 24, !4, i64 32}
!22 = !{!"spinlock", !5, i64 0}
!23 = !{!"dev_pm_info", !24, i64 0, !20, i64 4, !20, i64 4, !25, i64 4, !25, i64 4, !25, i64 4, !25, i64 4, !22, i64 6, !17, i64 8, !26, i64 24, !4, i64 56, !25, i64 64, !25, i64 64, !4, i64 72, !4, i64 80}
!24 = !{!"pm_message", !20, i64 0}
!25 = !{!"_Bool", !5, i64 0}
!26 = !{!"completion", !20, i64 0, !27, i64 8}
!27 = !{!"__wait_queue_head", !22, i64 0, !17, i64 8}
!28 = !{!"long long", !5, i64 0}
!29 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!30 = !{!"acpi_dev_node", !4, i64 0}
!31 = !{!"klist_node", !4, i64 0, !17, i64 8, !18, i64 24}
!32 = !{!25, !25, i64 0}
!33 = !{i8 0, i8 2}
!34 = !{!35, !5, i64 64}
!35 = !{!"lm93_data", !4, i64 0, !21, i64 8, !36, i64 48, !4, i64 56, !5, i64 64, !37, i64 65, !5, i64 73, !5, i64 79, !5, i64 95, !5, i64 100, !5, i64 108, !5, i64 116, !5, i64 148, !5, i64 156, !38, i64 164, !5, i64 180, !5, i64 181, !5, i64 183, !5, i64 185, !5, i64 187, !5, i64 188, !5, i64 189, !5, i64 190, !5, i64 194, !5, i64 196, !5, i64 198, !5, i64 199, !5, i64 200, !5, i64 201, !5, i64 202}
!36 = !{!"long", !5, i64 0}
!37 = !{!"block1_t", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7}
!38 = !{!"", !5, i64 0, !5, i64 4}
!39 = !{!35, !4, i64 56}
!40 = !{!35, !4, i64 0}
!41 = !{!42, !4, i64 16}
!42 = !{!"i2c_adapter", !4, i64 0, !20, i64 8, !4, i64 16, !4, i64 24, !43, i64 32, !20, i64 64, !20, i64 68, !15, i64 72, !20, i64 512, !5, i64 516, !26, i64 568, !21, i64 600, !17, i64 640, !4, i64 656}
!43 = !{!"rt_mutex", !44, i64 0, !46, i64 8, !4, i64 24}
!44 = !{!"raw_spinlock", !45, i64 0}
!45 = !{!"arch_spinlock", !5, i64 0}
!46 = !{!"plist_head", !17, i64 0}
!47 = !{!48, !4, i64 16}
!48 = !{!"i2c_algorithm", !4, i64 0, !4, i64 8, !4, i64 16}
!49 = !{!5, !5, i64 0}
!50 = !{!51, !5, i64 0}
!51 = !{!"", !5, i64 0, !5, i64 1}
!52 = !{!51, !5, i64 1}
!53 = !{!14, !14, i64 0}
!54 = !{!20, !20, i64 0}
!55 = !{!35, !5, i64 180}
!56 = !{!35, !5, i64 187}
!57 = !{!35, !5, i64 188}
!58 = !{!35, !5, i64 189}
!59 = !{!35, !5, i64 198}
!60 = !{!35, !5, i64 199}
!61 = !{!35, !5, i64 200}
!62 = !{!35, !5, i64 201}
!63 = !{!64, !20, i64 32}
!64 = !{!"sensor_device_attribute", !65, i64 0, !20, i64 32}
!65 = !{!"device_attribute", !66, i64 0, !4, i64 16, !4, i64 24}
!66 = !{!"attribute", !4, i64 0, !14, i64 8}
!67 = !{!35, !36, i64 48}
!68 = !{!36, !36, i64 0}
!69 = !{!70, !5, i64 32}
!70 = !{!"sensor_device_attribute_2", !65, i64 0, !5, i64 32, !5, i64 33}
!71 = !{!70, !5, i64 33}
!72 = !{!35, !5, i64 65}
!73 = !{!37, !5, i64 1}
!74 = !{!37, !5, i64 3}
!75 = !{!37, !5, i64 2}
!76 = !{!37, !5, i64 7}
!77 = !{!37, !5, i64 4}
!78 = !{!37, !5, i64 5}
!79 = !{!37, !5, i64 0}
