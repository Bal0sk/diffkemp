; ModuleID = 'tests/kernel_modules/rfkill/rfkill_old.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.44 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.44 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.mutex = type { %union.anon.1, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8*, i8*, %struct.lockdep_map }
%union.anon.1 = type { i32 }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.arch_spinlock = type { %union.anon.1 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %union.anon.1, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.hlist_head, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, i8, i32, i32, i32, i32, i32, i32, i8, i32, i32, i64, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, %struct.load_weight, %struct.load_weight, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %union.anon.37, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %union.anon.1, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i64, %struct.callback_head, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %union.anon.1, %union.anon.1, i64, i64, %struct.memcg_batch_info, i32, %union.anon.1, %struct.uprobe_task*, i32, i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [64 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgprot*, %union.anon.1, %union.anon.1, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.task_struct*, %struct.file*, %struct.mmu_notifier_mm*, %struct.page*, %struct.cpumask, i64, i64, i64, i32, i32, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type opaque
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head, %struct.lockdep_map }
%struct.mm_rss_stat = type { [3 x %struct.pgprot] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %union.anon.1, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file = type { %union.anon.37, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.pgprot, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space*, i64 }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %union.anon.1, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.37, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %struct.pgprot, i8* }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %union.anon.1, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [44 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.pgprot, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, i8, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.load_weight*, void ()**, i32 }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.arch_spinlock, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.arch_spinlock, void ()*, void ()*, %struct.tracepoint_func* }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %union.anon.1, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.1, i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head, [3 x %struct.lockdep_map] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.pgprot }
%struct.shrink_control = type { i32, i64 }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.1, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.34, i64, %union.anon.1, %union.anon.1, %union.anon.1, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.36, i32, i32, %struct.hlist_head, %union.anon.1, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.load_weight*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.load_weight, %struct.load_weight, %struct.load_weight, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.34 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.42 }
%struct.pid = type { %union.anon.1, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.42 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.44, i32 }
%struct.swap_info_struct = type opaque
%union.anon.36 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %struct.pgprot, i32, i32, i8*, %struct.lockdep_map }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.mmu_notifier_mm = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.3, %union.anon.37, %struct.pgprot, i64 }
%struct.anon.3 = type { %struct.pgprot, %struct.pgprot }
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type { %struct.__wait_queue_head, %union.anon.1, i64*, %struct.page*, i64 }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.load_weight = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %union.anon.1, %union.anon.1, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %union.anon.1, i32, %union.anon.12, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %struct.pgprot, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.37, %struct.pgprot }
%union.anon.12 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%struct.user_struct = type { %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %union.anon.1, %struct.pgprot, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.pgprot }
%struct.user_namespace = type opaque
%struct.group_info = type { %union.anon.1, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.16 }
%union.anon.16 = type { %struct.exception_table_entry }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.19, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.22 }
%union.anon.19 = type { %struct.load_weight }
%union.anon.22 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %union.anon.1, %union.anon.1, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %struct.pgprot, [2 x %struct.if_dqinfo], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.load_weight, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.load_weight], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %struct.pgprot, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %struct.pgprot }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %struct.pgprot, i64 ()*, %struct.pgprot, %struct.pgprot }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %struct.pgprot, i32, i32, i64, i64, i64, %struct.pgprot, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %union.anon.1, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%union.anon.37 = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, i8* }
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.24 }
%union.anon.24 = type { %struct.anon.28, [80 x i8] }
%struct.anon.28 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.load_weight, %struct.load_weight, i64, i64, i32, i32, %struct.load_weight, %struct.load_weight, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.memcg_batch_info = type { i32, %struct.mem_cgroup*, i64, i64 }
%struct.mem_cgroup = type opaque
%struct.uprobe_task = type { i32, %struct.arch_uprobe_task, %struct.return_instance*, i32, %struct.uprobe*, i64, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.return_instance = type opaque
%struct.uprobe = type opaque
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class = type { %struct.list_head, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.anon.47 = type { i8, i8 }
%struct.workqueue_struct = type opaque
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.shrink_control*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %union.anon.44, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %union.anon.1, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %union.anon.1, %union.anon.1, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, %struct.pgprot, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8], %struct.lockdep_map }
%struct.tvec_base = type opaque
%struct.work_struct = type { %struct.pgprot, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.arch_spinlock }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.subsys_private = type opaque
%struct.miscdevice = type { i32, i8*, %struct.file_operations*, %struct.list_head, %struct.device*, %struct.device*, i8*, i16 }
%struct.input_handler = type { i8*, void (%struct.input_handle*, i32, i32, i32)*, void (%struct.input_handle*, %struct.input_value*, i32)*, i1 (%struct.input_handle*, i32, i32, i32)*, i1 (%struct.input_handler*, %struct.input_dev*)*, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)*, void (%struct.input_handle*)*, void (%struct.input_handle*)*, i8, i32, i8*, %struct.input_device_id*, %struct.list_head, %struct.list_head }
%struct.input_handle = type { i8*, i32, i8*, %struct.input_dev*, %struct.input_handler*, %struct.list_head, %struct.list_head }
%struct.input_dev = type { i8*, i8*, i8*, %struct.input_id, [1 x i64], [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i32, i32, i32, i8*, i32 (%struct.input_dev*, %struct.input_keymap_entry*, i32*)*, i32 (%struct.input_dev*, %struct.input_keymap_entry*)*, %struct.ff_device*, i32, %struct.timer_list, [2 x i32], %struct.input_mt*, %struct.input_absinfo*, [12 x i64], [1 x i64], [1 x i64], [1 x i64], i32 (%struct.input_dev*)*, void (%struct.input_dev*)*, i32 (%struct.input_dev*, %struct.file*)*, i32 (%struct.input_dev*, i32, i32, i32)*, %struct.input_handle*, %struct.spinlock, %struct.mutex, i32, i8, %struct.device, %struct.list_head, %struct.list_head, i32, i32, %struct.input_value*, i8 }
%struct.input_id = type { i16, i16, i16, i16 }
%struct.input_keymap_entry = type { i8, i8, i16, i32, [32 x i8] }
%struct.ff_device = type { i32 (%struct.input_dev*, %struct.ff_effect*, %struct.ff_effect*)*, i32 (%struct.input_dev*, i32)*, i32 (%struct.input_dev*, i32, i32)*, void (%struct.input_dev*, i16)*, void (%struct.input_dev*, i16)*, void (%struct.ff_device*)*, i8*, [2 x i64], %struct.mutex, i32, %struct.ff_effect*, [0 x %struct.file*] }
%struct.ff_effect = type { i16, i16, i16, %struct.ff_trigger, %struct.ff_trigger, %union.anon.47 }
%struct.ff_trigger = type { i16, i16 }
%union.anon.47 = type { %struct.ff_periodic_effect }
%struct.ff_periodic_effect = type { i16, i16, i16, i16, i16, %struct.input_id, i32, i16* }
%struct.input_mt = type opaque
%struct.input_absinfo = type { i32, i32, i32, i32, i32, i32 }
%struct.input_value = type { i16, i16, i32 }
%struct.input_device_id = type { i64, i16, i16, i16, i16, [1 x i64], [12 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [1 x i64], [2 x i64], [1 x i64], i64 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.rfkill = type { %struct.spinlock, i8*, i32, i64, i32, i8, i8, %struct.rfkill_ops*, i8*, %struct.led_trigger, i8*, %struct.device, %struct.list_head, %struct.delayed_work, %struct.work_struct, %struct.work_struct }
%struct.rfkill_ops = type { void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)*, i32 (i8*, i1)* }
%struct.led_trigger = type { i8*, void (%struct.led_classdev*)*, void (%struct.led_classdev*)*, %struct.rwlock_t, %struct.list_head, %struct.list_head }
%struct.led_classdev = type { i8*, i32, i32, i32, void (%struct.led_classdev*, i32)*, i32 (%struct.led_classdev*)*, i32 (%struct.led_classdev*, i64*, i64*)*, %struct.device*, %struct.list_head, i8*, i64, i64, %struct.timer_list, i32, %struct.work_struct, i32, %struct.rw_semaphore, %struct.led_trigger*, %struct.list_head, i8*, i8 }
%struct.rfkill_data = type { %struct.list_head, %struct.list_head, %struct.mutex, %struct.__wait_queue_head, i8 }
%struct.rfkill_int_event = type { %struct.list_head, %struct.rfkill_event }
%struct.rfkill_event = type { i32, i8, i8, i8, i8 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.pgprot, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.48 }
%union.anon.48 = type { %struct.anon.49 }
%struct.anon.49 = type { i32*, i32, i32, i32, i64, i32* }

@llvm.used = appending global [36 x i8*] [i8* getelementptr inbounds ([41 x i8], [41 x i8]* @__UNIQUE_ID_author95, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @__UNIQUE_ID_author96, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__UNIQUE_ID_description97, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license98, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_default_state to i8*), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__UNIQUE_ID_default_statetype117, i32 0, i32 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @__UNIQUE_ID_default_state119, i32 0, i32 0), i8* bitcast (i64* @__kcrctab_rfkill_get_led_trigger_name to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_get_led_trigger_name to i8*), i8* bitcast (i64* @__kcrctab_rfkill_set_led_trigger_name to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_led_trigger_name to i8*), i8* bitcast (i64* @__kcrctab_rfkill_set_hw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_hw_state to i8*), i8* bitcast (i64* @__kcrctab_rfkill_set_sw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_sw_state to i8*), i8* bitcast (i64* @__kcrctab_rfkill_init_sw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_init_sw_state to i8*), i8* bitcast (i64* @__kcrctab_rfkill_set_states to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_states to i8*), i8* bitcast (i64* @__kcrctab_rfkill_pause_polling to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_pause_polling to i8*), i8* bitcast (i64* @__kcrctab_rfkill_resume_polling to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_resume_polling to i8*), i8* bitcast (i64* @__kcrctab_rfkill_blocked to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_blocked to i8*), i8* bitcast (i64* @__kcrctab_rfkill_alloc to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_alloc to i8*), i8* bitcast (i64* @__kcrctab_rfkill_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_register to i8*), i8* bitcast (i64* @__kcrctab_rfkill_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_unregister to i8*), i8* bitcast (i64* @__kcrctab_rfkill_destroy to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_destroy to i8*), i8* bitcast (%struct.kernel_param* @__param_master_switch_mode to i8*), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @__UNIQUE_ID_master_switch_modetype38, i32 0, i32 0), i8* getelementptr inbounds ([102 x i8], [102 x i8]* @__UNIQUE_ID_master_switch_mode40, i32 0, i32 0)], section "llvm.metadata"
@__UNIQUE_ID_author95 = internal constant [41 x i8] c"author=Ivo van Doorn <IvDoorn@gmail.com>\00", section ".modinfo", align 1
@__UNIQUE_ID_author96 = internal constant [49 x i8] c"author=Johannes Berg <johannes@sipsolutions.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description97 = internal constant [30 x i8] c"description=RF switch support\00", section ".modinfo", align 1
@__UNIQUE_ID_license98 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__param_default_state = internal constant %struct.kernel_param { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__param_str_default_state, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 292, i16 -1, %union.anon.44 { i8* bitcast (i32* @rfkill_default_state to i8*) } }, section "__param", align 8
@__UNIQUE_ID_default_statetype117 = internal constant [28 x i8] c"parmtype=default_state:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_default_state119 = internal constant [76 x i8] c"parm=default_state:Default initial state for all radio types, 0 = radio off\00", section ".modinfo", align 1
@__kcrctab_rfkill_get_led_trigger_name = internal constant i64 ptrtoint (i8** @__crc_rfkill_get_led_trigger_name to i64), section "___kcrctab+rfkill_get_led_trigger_name", align 8
@__ksymtab_rfkill_get_led_trigger_name = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.rfkill*)* @rfkill_get_led_trigger_name to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_rfkill_get_led_trigger_name, i32 0, i32 0) }, section "___ksymtab+rfkill_get_led_trigger_name", align 8
@__kcrctab_rfkill_set_led_trigger_name = internal constant i64 ptrtoint (i8** @__crc_rfkill_set_led_trigger_name to i64), section "___kcrctab+rfkill_set_led_trigger_name", align 8
@__ksymtab_rfkill_set_led_trigger_name = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i8*)* @rfkill_set_led_trigger_name to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_rfkill_set_led_trigger_name, i32 0, i32 0) }, section "___ksymtab+rfkill_set_led_trigger_name", align 8
@__kcrctab_rfkill_set_hw_state = internal constant i64 ptrtoint (i8** @__crc_rfkill_set_hw_state to i64), section "___kcrctab+rfkill_set_hw_state", align 8
@__ksymtab_rfkill_set_hw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*, i1)* @rfkill_set_hw_state to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rfkill_set_hw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_set_hw_state", align 8
@__kcrctab_rfkill_set_sw_state = internal constant i64 ptrtoint (i8** @__crc_rfkill_set_sw_state to i64), section "___kcrctab+rfkill_set_sw_state", align 8
@__ksymtab_rfkill_set_sw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*, i1)* @rfkill_set_sw_state to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rfkill_set_sw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_set_sw_state", align 8
@__kcrctab_rfkill_init_sw_state = internal constant i64 ptrtoint (i8** @__crc_rfkill_init_sw_state to i64), section "___kcrctab+rfkill_init_sw_state", align 8
@__ksymtab_rfkill_init_sw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i1)* @rfkill_init_sw_state to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rfkill_init_sw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_init_sw_state", align 8
@__kcrctab_rfkill_set_states = internal constant i64 ptrtoint (i8** @__crc_rfkill_set_states to i64), section "___kcrctab+rfkill_set_states", align 8
@__ksymtab_rfkill_set_states = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i1, i1)* @rfkill_set_states to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rfkill_set_states, i32 0, i32 0) }, section "___ksymtab+rfkill_set_states", align 8
@__kcrctab_rfkill_pause_polling = internal constant i64 ptrtoint (i8** @__crc_rfkill_pause_polling to i64), section "___kcrctab+rfkill_pause_polling", align 8
@__ksymtab_rfkill_pause_polling = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_pause_polling to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rfkill_pause_polling, i32 0, i32 0) }, section "___ksymtab+rfkill_pause_polling", align 8
@__kcrctab_rfkill_resume_polling = internal constant i64 ptrtoint (i8** @__crc_rfkill_resume_polling to i64), section "___kcrctab+rfkill_resume_polling", align 8
@__ksymtab_rfkill_resume_polling = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_resume_polling to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_rfkill_resume_polling, i32 0, i32 0) }, section "___ksymtab+rfkill_resume_polling", align 8
@__kcrctab_rfkill_blocked = internal constant i64 ptrtoint (i8** @__crc_rfkill_blocked to i64), section "___kcrctab+rfkill_blocked", align 8
@__ksymtab_rfkill_blocked = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*)* @rfkill_blocked to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rfkill_blocked, i32 0, i32 0) }, section "___ksymtab+rfkill_blocked", align 8
@__kcrctab_rfkill_alloc = internal constant i64 ptrtoint (i8** @__crc_rfkill_alloc to i64), section "___kcrctab+rfkill_alloc", align 8
@__ksymtab_rfkill_alloc = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rfkill* (i8*, %struct.device*, i32, %struct.rfkill_ops*, i8*)* @rfkill_alloc to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rfkill_alloc, i32 0, i32 0) }, section "___ksymtab+rfkill_alloc", align 8
@__kcrctab_rfkill_register = internal constant i64 ptrtoint (i8** @__crc_rfkill_register to i64), section "___kcrctab+rfkill_register", align 8
@__ksymtab_rfkill_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rfkill*)* @rfkill_register to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rfkill_register, i32 0, i32 0) }, section "___ksymtab+rfkill_register", align 8
@__kcrctab_rfkill_unregister = internal constant i64 ptrtoint (i8** @__crc_rfkill_unregister to i64), section "___kcrctab+rfkill_unregister", align 8
@__ksymtab_rfkill_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_unregister to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rfkill_unregister, i32 0, i32 0) }, section "___ksymtab+rfkill_unregister", align 8
@__kcrctab_rfkill_destroy = internal constant i64 ptrtoint (i8** @__crc_rfkill_destroy to i64), section "___kcrctab+rfkill_destroy", align 8
@__ksymtab_rfkill_destroy = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_destroy to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rfkill_destroy, i32 0, i32 0) }, section "___ksymtab+rfkill_destroy", align 8
@__kstrtab_rfkill_destroy = internal constant [15 x i8] c"rfkill_destroy\00", section "__ksymtab_strings", align 1
@__crc_rfkill_destroy = extern_weak global i8*, align 8
@__kstrtab_rfkill_unregister = internal constant [18 x i8] c"rfkill_unregister\00", section "__ksymtab_strings", align 1
@.str = private unnamed_addr constant [18 x i8] c"net/rfkill/core.c\00", align 1
@rfkill_global_mutex = internal global %struct.mutex { %union.anon.1 { i32 1 }, %struct.spinlock { %union.anon.0 { %struct.raw_spinlock { %struct.arch_spinlock zeroinitializer, i32 -559067475, i32 -1, i8* inttoptr (i64 -1 to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.10, i32 0, i32 0), i32 0, i64 0 } } } }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), i64 80) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), i64 80) to %struct.list_head*) }, %struct.task_struct* null, i8* null, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), %struct.lockdep_map { %struct.lock_class_key* null, [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.11, i32 0, i32 0), i32 0, i64 0 } }, align 8
@rfkill_fds = internal global %struct.list_head { %struct.list_head* @rfkill_fds, %struct.list_head* @rfkill_fds }, align 8
@.str.10 = private unnamed_addr constant [30 x i8] c"rfkill_global_mutex.wait_lock\00", align 1
@.str.11 = private unnamed_addr constant [20 x i8] c"rfkill_global_mutex\00", align 1
@__crc_rfkill_unregister = extern_weak global i8*, align 8
@__kstrtab_rfkill_register = internal constant [16 x i8] c"rfkill_register\00", section "__ksymtab_strings", align 1
@rfkill_register.rfkill_no = internal global i64 0, align 8
@.str.2 = private unnamed_addr constant [10 x i8] c"rfkill%lu\00", align 1
@rfkill_list = internal global %struct.list_head { %struct.list_head* @rfkill_list, %struct.list_head* @rfkill_list }, align 8
@.str.3 = private unnamed_addr constant [30 x i8] c"(&(&rfkill->poll_work)->work)\00", align 1
@rfkill_register.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.5 = private unnamed_addr constant [31 x i8] c"(&(&rfkill->poll_work)->timer)\00", align 1
@rfkill_register.__key.4 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.7 = private unnamed_addr constant [23 x i8] c"(&rfkill->uevent_work)\00", align 1
@rfkill_register.__key.6 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.9 = private unnamed_addr constant [21 x i8] c"(&rfkill->sync_work)\00", align 1
@rfkill_register.__key.8 = internal global %struct.lock_class_key zeroinitializer, align 1
@rfkill_epo_lock_active = internal global i8 0, align 1
@rfkill_input_disabled = internal global %union.anon.1 zeroinitializer, align 4
@rfkill_global_states = internal global [9 x %struct.anon.47] zeroinitializer, align 16
@system_wq = external global %struct.workqueue_struct*, align 8
@__crc_rfkill_register = extern_weak global i8*, align 8
@__kstrtab_rfkill_alloc = internal constant [13 x i8] c"rfkill_alloc\00", section "__ksymtab_strings", align 1
@.str.1 = private unnamed_addr constant [24 x i8] c"&(&rfkill->lock)->rlock\00", align 1
@rfkill_alloc.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@rfkill_class = internal global %struct.class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), %struct.module* null, %struct.class_attribute* null, %struct.device_attribute* getelementptr inbounds ([9 x %struct.device_attribute], [9 x %struct.device_attribute]* @rfkill_dev_attrs, i32 0, i32 0), %struct.bin_attribute* null, %struct.kobject* null, i32 (%struct.device*, %struct.kobj_uevent_env*)* @rfkill_dev_uevent, i8* (%struct.device*, i16*)* null, void (%struct.class*)* null, void (%struct.device*)* @rfkill_release, i32 (%struct.device*, i32)* @rfkill_suspend, i32 (%struct.device*)* @rfkill_resume, %struct.kobj_ns_type_operations* null, i8* (%struct.device*)* null, %struct.dev_pm_ops* null, %struct.subsys_private* null }, align 8
@rfkill_dev_attrs = internal global [9 x %struct.device_attribute] [%struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_name_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.14, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_type_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_idx_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_persistent_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.17, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_state_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @rfkill_state_store }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.18, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_claim_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @rfkill_claim_store }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.19, i32 0, i32 0), i16 420, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_soft_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @rfkill_soft_store }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.20, i32 0, i32 0), i16 292, i8 0, %struct.lock_class_key* null, %struct.lock_class_key zeroinitializer }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_hard_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute zeroinitializer], align 16
@.str.31 = private unnamed_addr constant [15 x i8] c"RFKILL_NAME=%s\00", align 1
@.str.32 = private unnamed_addr constant [15 x i8] c"RFKILL_TYPE=%s\00", align 1
@.str.33 = private unnamed_addr constant [16 x i8] c"RFKILL_STATE=%d\00", align 1
@.str.29 = private unnamed_addr constant [4 x i8] c"nfc\00", align 1
@.str.28 = private unnamed_addr constant [3 x i8] c"fm\00", align 1
@.str.27 = private unnamed_addr constant [4 x i8] c"gps\00", align 1
@.str.26 = private unnamed_addr constant [5 x i8] c"wwan\00", align 1
@.str.25 = private unnamed_addr constant [6 x i8] c"wimax\00", align 1
@.str.24 = private unnamed_addr constant [14 x i8] c"ultrawideband\00", align 1
@.str.23 = private unnamed_addr constant [10 x i8] c"bluetooth\00", align 1
@.str.22 = private unnamed_addr constant [5 x i8] c"wlan\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.14 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.15 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.16 = private unnamed_addr constant [11 x i8] c"persistent\00", align 1
@.str.17 = private unnamed_addr constant [6 x i8] c"state\00", align 1
@.str.18 = private unnamed_addr constant [6 x i8] c"claim\00", align 1
@.str.19 = private unnamed_addr constant [5 x i8] c"soft\00", align 1
@.str.20 = private unnamed_addr constant [5 x i8] c"hard\00", align 1
@.str.30 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.21 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@__crc_rfkill_alloc = extern_weak global i8*, align 8
@__kstrtab_rfkill_blocked = internal constant [15 x i8] c"rfkill_blocked\00", section "__ksymtab_strings", align 1
@__crc_rfkill_blocked = extern_weak global i8*, align 8
@__kstrtab_rfkill_resume_polling = internal constant [22 x i8] c"rfkill_resume_polling\00", section "__ksymtab_strings", align 1
@__crc_rfkill_resume_polling = extern_weak global i8*, align 8
@__kstrtab_rfkill_pause_polling = internal constant [21 x i8] c"rfkill_pause_polling\00", section "__ksymtab_strings", align 1
@__crc_rfkill_pause_polling = extern_weak global i8*, align 8
@__kstrtab_rfkill_set_states = internal constant [18 x i8] c"rfkill_set_states\00", section "__ksymtab_strings", align 1
@__crc_rfkill_set_states = extern_weak global i8*, align 8
@__kstrtab_rfkill_init_sw_state = internal constant [21 x i8] c"rfkill_init_sw_state\00", section "__ksymtab_strings", align 1
@__crc_rfkill_init_sw_state = extern_weak global i8*, align 8
@__kstrtab_rfkill_set_sw_state = internal constant [20 x i8] c"rfkill_set_sw_state\00", section "__ksymtab_strings", align 1
@__crc_rfkill_set_sw_state = extern_weak global i8*, align 8
@__kstrtab_rfkill_set_hw_state = internal constant [20 x i8] c"rfkill_set_hw_state\00", section "__ksymtab_strings", align 1
@__crc_rfkill_set_hw_state = extern_weak global i8*, align 8
@__kstrtab_rfkill_set_led_trigger_name = internal constant [28 x i8] c"rfkill_set_led_trigger_name\00", section "__ksymtab_strings", align 1
@__crc_rfkill_set_led_trigger_name = extern_weak global i8*, align 8
@__kstrtab_rfkill_get_led_trigger_name = internal constant [28 x i8] c"rfkill_get_led_trigger_name\00", section "__ksymtab_strings", align 1
@__crc_rfkill_get_led_trigger_name = extern_weak global i8*, align 8
@__param_str_default_state = internal constant [14 x i8] c"default_state\00", align 1
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@rfkill_default_state = internal global i32 1, align 4
@rfkill_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@rfkill_miscdev = internal global %struct.miscdevice { i32 255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), %struct.file_operations* @rfkill_fops, %struct.list_head zeroinitializer, %struct.device* null, %struct.device* null, i8* null, i16 0 }, align 8
@rfkill_fops = internal constant %struct.file_operations { %struct.module* @__this_module, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @rfkill_fop_read, i64 (%struct.file*, i8*, i64, i64*)* @rfkill_fop_write, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @rfkill_fop_poll, i64 (%struct.file*, i32, i64)* @rfkill_fop_ioctl, i64 (%struct.file*, i32, i64)* @rfkill_fop_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rfkill_fop_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rfkill_fop_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@__this_module = external global %struct.module, align 8
@.str.40 = private unnamed_addr constant [33 x i8] c"\017rfkill: input handler enabled\0A\00", align 1
@.str.37 = private unnamed_addr constant [11 x i8] c"&data->mtx\00", align 1
@rfkill_fop_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.39 = private unnamed_addr constant [17 x i8] c"&data->read_wait\00", align 1
@rfkill_fop_open.__key.38 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.36 = private unnamed_addr constant [34 x i8] c"\017rfkill: input handler disabled\0A\00", align 1
@.str.34 = private unnamed_addr constant [62 x i8] c"/diffkemp/kernel/linux-3.10/arch/x86/include/asm/uaccess_64.h\00", align 1
@.str.35 = private unnamed_addr constant [27 x i8] c"Buffer overflow detected!\0A\00", align 1
@current_task = external global %struct.task_struct*, align 8
@__param_master_switch_mode = internal constant %struct.kernel_param { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__param_str_master_switch_mode, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 0, i16 -1, %union.anon.44 { i8* bitcast (i32* @rfkill_master_switch_mode to i8*) } }, section "__param", align 8
@__UNIQUE_ID_master_switch_modetype38 = internal constant [33 x i8] c"parmtype=master_switch_mode:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_master_switch_mode40 = internal constant [102 x i8] c"parm=master_switch_mode:SW_RFKILL_ALL ON should: 0=do nothing (only unlock); 1=restore; 2=unblock all\00", section ".modinfo", align 1
@__param_str_master_switch_mode = internal constant [19 x i8] c"master_switch_mode\00", align 16
@rfkill_master_switch_mode = internal global i32 2, align 4
@rfkill_master_switch_op = internal global i32 0, align 4
@rfkill_op_lock = internal global %struct.spinlock zeroinitializer, align 8
@.str.6 = private unnamed_addr constant [26 x i8] c"&(&rfkill_op_lock)->rlock\00", align 1
@rfkill_handler_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@jiffies = external global i64, align 8
@rfkill_last_scheduled = internal global i64 0, align 8
@rfkill_handler = internal global %struct.input_handler { i8* null, void (%struct.input_handle*, i32, i32, i32)* @rfkill_event.7, void (%struct.input_handle*, %struct.input_value*, i32)* null, i1 (%struct.input_handle*, i32, i32, i32)* null, i1 (%struct.input_handler*, %struct.input_dev*)* null, i32 (%struct.input_handler*, %struct.input_dev*, %struct.input_device_id*)* @rfkill_connect, void (%struct.input_handle*)* @rfkill_disconnect, void (%struct.input_handle*)* @rfkill_start, i8 0, i32 0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), %struct.input_device_id* getelementptr inbounds ([7 x %struct.input_device_id], [7 x %struct.input_device_id]* @rfkill_ids, i32 0, i32 0), %struct.list_head zeroinitializer, %struct.list_head zeroinitializer }, align 8
@.str.1.8 = private unnamed_addr constant [7 x i8] c"rfkill\00", align 1
@rfkill_ids = internal constant [7 x %struct.input_device_id] [%struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 70368744177664, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 35184372088832, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 140737488355328, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 18014398509481984, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 48, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 2], [12 x i64] [i64 0, i64 0, i64 0, i64 36028797018963968, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] zeroinitializer, i64 0 }, %struct.input_device_id { i64 4112, i16 0, i16 0, i16 0, i16 0, [1 x i64] [i64 32], [12 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [1 x i64] zeroinitializer, [2 x i64] zeroinitializer, [1 x i64] [i64 8], i64 0 }, %struct.input_device_id zeroinitializer], align 16
@rfkill_op = internal global i32 0, align 4
@rfkill_op_pending = internal global i8 0, align 1
@rfkill_op_work = internal global %struct.delayed_work { %struct.work_struct { %struct.pgprot { i64 137438953424 }, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.delayed_work* @rfkill_op_work to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.delayed_work* @rfkill_op_work to i8*), i64 8) to %struct.list_head*) }, void (%struct.work_struct*)* @rfkill_op_handler, %struct.lockdep_map { %struct.lock_class_key* bitcast (%struct.delayed_work* @rfkill_op_work to %struct.lock_class_key*), [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.2.12, i32 0, i32 0), i32 0, i64 0 } }, %struct.timer_list { %struct.list_head { %struct.list_head* null, %struct.list_head* inttoptr (i64 1953723489 to %struct.list_head*) }, i64 0, %struct.tvec_base* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.tvec_base* @boot_tvec_bases to i8*), i64 2) to %struct.tvec_base*), void (i64)* @delayed_work_timer_fn, i64 ptrtoint (%struct.delayed_work* @rfkill_op_work to i64), i32 -1, i32 0, i8* null, [16 x i8] zeroinitializer, %struct.lockdep_map { %struct.lock_class_key* bitcast ([23 x i8]* @.str.3.13 to %struct.lock_class_key*), [2 x %struct.lock_class*] zeroinitializer, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.3.13, i32 0, i32 0), i32 0, i64 0 } }, %struct.workqueue_struct* null, i32 0 }, align 8
@.str.2.12 = private unnamed_addr constant [22 x i8] c"(rfkill_op_work).work\00", align 1
@boot_tvec_bases = external global %struct.tvec_base, align 1
@.str.3.13 = private unnamed_addr constant [23 x i8] c"net/rfkill/input.c:140\00", align 1
@rfkill_sw_pending = internal global [1 x i64] zeroinitializer, align 8
@rfkill_sw_state = internal global [1 x i64] zeroinitializer, align 8
@.str.4 = private unnamed_addr constant [19 x i8] c"net/rfkill/input.c\00", align 1
@.str.5.14 = private unnamed_addr constant [70 x i8] c"Unknown requested operation %d! rfkill Emergency Power Off activated\0A\00", align 1

@init_module = alias i32 (), i32 ()* @rfkill_init
@cleanup_module = alias void (), void ()* @rfkill_exit

; Function Attrs: nounwind uwtable
define void @rfkill_destroy(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  call void @put_device(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @put_device(%struct.device*) #1

; Function Attrs: nounwind uwtable
define void @rfkill_unregister(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 1002, i64 12) #8, !srcloc !2
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !33
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.end9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %poll_work)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %do.end9
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call13 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %uevent_work)
  %sync_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %call14 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %sync_work)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  store i8 0, i8* %registered, align 4, !tbaa !35
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  call void @device_del(%struct.device* %dev)
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 1)
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @list_del_init(%struct.list_head* %node)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  call void @rfkill_led_trigger_unregister(%struct.rfkill* %rfkill)
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #2

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #1

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) #1

declare void @device_del(%struct.device*) #1

declare void @mutex_lock_nested(%struct.mutex*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_send_events(%struct.rfkill* %rfkill, i32 %op) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_fds, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !36
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr7 to %struct.rfkill_data*
  %list = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @rfkill_fds
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i8* @kzalloc(i64 24, i32 208)
  %3 = bitcast i8* %call to %struct.rfkill_int_event*
  %tobool = icmp ne %struct.rfkill_int_event* %3, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %ev1 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %3, i32 0, i32 1
  call void @rfkill_fill_event(%struct.rfkill_event* %ev1, %struct.rfkill* %rfkill, i32 %op)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  %list2 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %3, i32 0, i32 0
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %list2, %struct.list_head* %events)
  %mtx3 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx3)
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 3
  call void @__wake_up(%struct.__wait_queue_head* %read_wait, i32 1, i32 1, i8* null)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %list5 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list5, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #3 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_unregister(%struct.rfkill* %rfkill) #0 {
entry:
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  call void @led_trigger_unregister(%struct.led_trigger* %led_trigger)
  ret void
}

declare void @led_trigger_unregister(%struct.led_trigger*) #1

declare void @__list_del_entry(%struct.list_head*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !37
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !38
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_fill_event(%struct.rfkill_event* %ev, %struct.rfkill* %rfkill, i32 %op) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %0 = load i32, i32* %idx, align 8, !tbaa !39
  %idx1 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 0
  store i32 %0, i32* %idx1, align 1, !tbaa !40
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i32, i32* %type, align 8, !tbaa !42
  %conv = trunc i32 %1 to i8
  %type2 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  store i8 %conv, i8* %type2, align 1, !tbaa !43
  %conv3 = trunc i32 %op to i8
  %op4 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  store i8 %conv3, i8* %op4, align 1, !tbaa !44
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv6 = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #8
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call7 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %6 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %6, 1
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = trunc i32 %lnot.ext to i8
  %hard = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 4
  store i8 %conv11, i8* %hard, align 1, !tbaa !46
  %state12 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %7 = load i64, i64* %state12, align 8, !tbaa !45
  %and13 = and i64 %7, 6
  %tobool14 = icmp ne i64 %and13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = trunc i32 %lnot.ext18 to i8
  %soft = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  store i8 %conv19, i8* %soft, align 1, !tbaa !47
  %lock20 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock20, i64 %call7)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !38
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #1

declare void @__list_add(%struct.list_head*, %struct.list_head*, %struct.list_head*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #1 section ".spinlock.text"

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i8* @__kmalloc(i64, i32) #1

; Function Attrs: nounwind uwtable
define i32 @rfkill_register(%struct.rfkill* %rfkill) #0 {
entry:
  %.compoundliteral = alloca %struct.pgprot, align 8
  %.compoundliteral62 = alloca %struct.pgprot, align 8
  %.compoundliteral81 = alloca %struct.pgprot, align 8
  %dev1 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 941, i64 12) #8, !srcloc !48
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !35, !range !49
  %tobool11 = trunc i8 %0 to i1
  br i1 %tobool11, label %unlock, label %if.end13

if.end13:                                         ; preds = %do.end10
  %1 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !50
  %conv14 = trunc i64 %1 to i32
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  store i32 %conv14, i32* %idx, align 8, !tbaa !39
  %2 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !50
  %call = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i64 %2)
  %3 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !50
  %inc = add i64 %3, 1
  store i64 %inc, i64* @rfkill_register.rfkill_no, align 8, !tbaa !50
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %node, %struct.list_head* @rfkill_list)
  %call15 = call i32 @device_add(%struct.device* %dev1)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %remove, label %if.end18

if.end18:                                         ; preds = %if.end13
  %call19 = call i32 @rfkill_led_trigger_register(%struct.rfkill* %rfkill)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %devdel, label %if.end22

if.end22:                                         ; preds = %if.end18
  %registered23 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  store i8 1, i8* %registered23, align 4, !tbaa !35
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %poll_work27 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work28 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work27, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work28, i32 0, i32 0
  %counter = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral, i32 0, i32 0
  store i64 137438953408, i64* %counter, align 8, !tbaa !51
  %4 = bitcast %struct.pgprot* %data to i8*
  %5 = bitcast %struct.pgprot* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 8, i32 8, i1 false), !tbaa.struct !52
  %poll_work29 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work30 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work29, i32 0, i32 0
  %lockdep_map = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work30, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.3, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key, i32 0)
  %poll_work31 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work32 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work31, i32 0, i32 0
  %entry33 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work32, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry33)
  %poll_work35 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work36 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work35, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work36, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_poll, void (%struct.work_struct*)** %func, align 8, !tbaa !53
  %poll_work45 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work45, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.5, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key.4)
  %poll_work48 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %timer49 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work48, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer49, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !54
  %poll_work50 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %6 = ptrtoint %struct.delayed_work* %poll_work50 to i64
  %poll_work51 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %timer52 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work51, i32 0, i32 1
  %data53 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer52, i32 0, i32 4
  store i64 %6, i64* %data53, align 8, !tbaa !55
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  call void @__init_work(%struct.work_struct* %uevent_work, i32 0)
  %uevent_work60 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %data61 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work60, i32 0, i32 0
  %counter63 = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral62, i32 0, i32 0
  store i64 137438953408, i64* %counter63, align 8, !tbaa !51
  %7 = bitcast %struct.pgprot* %data61 to i8*
  %8 = bitcast %struct.pgprot* %.compoundliteral62 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false), !tbaa.struct !52
  %uevent_work64 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %lockdep_map65 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work64, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map65, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.7, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key.6, i32 0)
  %uevent_work66 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %entry67 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work66, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry67)
  %uevent_work69 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %func70 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work69, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_uevent_work, void (%struct.work_struct*)** %func70, align 8, !tbaa !53
  %sync_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  call void @__init_work(%struct.work_struct* %sync_work, i32 0)
  %sync_work79 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %data80 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work79, i32 0, i32 0
  %counter82 = getelementptr inbounds %struct.pgprot, %struct.pgprot* %.compoundliteral81, i32 0, i32 0
  store i64 137438953408, i64* %counter82, align 8, !tbaa !51
  %9 = bitcast %struct.pgprot* %data80 to i8*
  %10 = bitcast %struct.pgprot* %.compoundliteral81 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false), !tbaa.struct !52
  %sync_work83 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %lockdep_map84 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work83, i32 0, i32 3
  call void @lockdep_init_map(%struct.lockdep_map* %lockdep_map84, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.9, i32 0, i32 0), %struct.lock_class_key* @rfkill_register.__key.8, i32 0)
  %sync_work85 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %entry86 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work85, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry86)
  %sync_work88 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %func89 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work88, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_sync_work, void (%struct.work_struct*)** %func89, align 8, !tbaa !53
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %11 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %11, i32 0, i32 0
  %12 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !33
  %tobool96 = icmp ne void (%struct.rfkill*, i8*)* %12, null
  br i1 %tobool96, label %if.then97, label %if.end101

if.then97:                                        ; preds = %if.end22
  %poll_work98 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %call99 = call i64 @round_jiffies_relative(i64 1250)
  call void @schedule_delayed_work(%struct.delayed_work* %poll_work98, i64 %call99)
  br label %if.end101

if.end101:                                        ; preds = %if.then97, %if.end22
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  %13 = load i8, i8* %persistent, align 1, !tbaa !56, !range !49
  %tobool102 = trunc i8 %13 to i1
  br i1 %tobool102, label %lor.lhs.false, label %if.then105

lor.lhs.false:                                    ; preds = %if.end101
  %14 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !57, !range !49
  %tobool103 = trunc i8 %14 to i1
  br i1 %tobool103, label %if.then105, label %if.else

if.then105:                                       ; preds = %lor.lhs.false, %if.end101
  %sync_work106 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  call void @schedule_work(%struct.work_struct* %sync_work106)
  br label %if.end118

if.else:                                          ; preds = %lor.lhs.false
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %15 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %15, 2
  %tobool108 = icmp ne i64 %and, 0
  %lnot109 = xor i1 %tobool108, true
  %lnot111 = xor i1 %lnot109, true
  %frombool = zext i1 %lnot111 to i8
  %call113 = call i32 @atomic_read(%union.anon.1* @rfkill_input_disabled)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.end118, label %if.then115

if.then115:                                       ; preds = %if.else
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %16 = load i32, i32* %type, align 8, !tbaa !42
  %tobool116 = trunc i8 %frombool to i1
  call void @__rfkill_switch_all(i32 %16, i1 zeroext %tobool116)
  br label %if.end118

if.end118:                                        ; preds = %if.then115, %if.else, %if.then105
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 0)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

devdel:                                           ; preds = %if.end18
  %dev119 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  call void @device_del(%struct.device* %dev119)
  br label %remove

remove:                                           ; preds = %devdel, %if.end13
  %error.0 = phi i32 [ %call19, %devdel ], [ %call15, %if.end13 ]
  %node120 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @list_del_init(%struct.list_head* %node120)
  br label %unlock

unlock:                                           ; preds = %remove, %do.end10
  %error.1 = phi i32 [ %error.0, %remove ], [ -114, %do.end10 ]
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %unlock, %if.end118
  %retval.0 = phi i32 [ %error.1, %unlock ], [ 0, %if.end118 ]
  ret i32 %retval.0
}

declare i32 @dev_set_name(%struct.device*, i8*, ...) #1

declare i32 @device_add(%struct.device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_led_trigger_register(%struct.rfkill* %rfkill) #0 {
entry:
  %ledtrigname = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  %0 = load i8*, i8** %ledtrigname, align 8, !tbaa !58
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %call = call i8* @dev_name(%struct.device* %dev)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %entry
  %cond = phi i8* [ %call, %cond.false ], [ %0, %entry ]
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %name = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger, i32 0, i32 0
  store i8* %cond, i8** %name, align 8, !tbaa !59
  %led_trigger1 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %activate = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger1, i32 0, i32 1
  store void (%struct.led_classdev*)* @rfkill_led_trigger_activate, void (%struct.led_classdev*)** %activate, align 8, !tbaa !60
  %led_trigger2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %call3 = call i32 @led_trigger_register(%struct.led_trigger* %led_trigger2)
  ret i32 %call3
}

declare void @__init_work(%struct.work_struct*, i32) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

declare void @lockdep_init_map(%struct.lockdep_map*, i8*, %struct.lock_class_key*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_poll(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1408
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 7
  %2 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %2, i32 0, i32 0
  %3 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !33
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 8
  %4 = load i8*, i8** %data, align 8, !tbaa !61
  call void %3(%struct.rfkill* %1, i8* %4)
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 13
  %call = call i64 @round_jiffies_relative(i64 1250)
  call void @schedule_delayed_work(%struct.delayed_work* %poll_work, i64 %call)
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

declare void @delayed_work_timer_fn(i64) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_uevent_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1632
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  call void @rfkill_event(%struct.rfkill* %1)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_sync_work(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1712
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !42
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur1 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %cur1, align 2, !tbaa !62, !range !49
  %tobool = trunc i8 %3 to i1
  %frombool = zext i1 %tobool to i8
  %tobool2 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool2)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  ret void
}

declare i64 @round_jiffies_relative(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_delayed_work(%struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !36
  call void @queue_delayed_work(%struct.workqueue_struct* %0, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @schedule_work(%struct.work_struct* %work) #3 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !36
  call void @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %work)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !64
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @__rfkill_switch_all(i32 %type, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %tobool = trunc i8 %frombool to i1
  %idxprom = zext i32 %type to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx, i32 0, i32 0
  %frombool1 = zext i1 %tobool to i8
  store i8 %frombool1, i8* %cur, align 2, !tbaa !62
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !36
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %1, i64 -1392
  %2 = bitcast i8* %add.ptr9 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %type2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 2
  %3 = load i32, i32* %type2, align 8, !tbaa !42
  %cmp3 = icmp ne i32 %3, %type
  %cmp4 = icmp ne i32 %type, 0
  %or.cond = and i1 %cmp3, %cmp4
  br i1 %or.cond, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %tobool5 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %2, i1 zeroext %tobool5)
  br label %for.inc

for.inc:                                          ; preds = %if.end, %for.body
  %node7 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node7, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_set_block(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy41 = alloca i64, align 8
  %__dummy242 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %power_state = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 0
  %event = getelementptr inbounds %union.anon.1, %union.anon.1* %power_state, i32 0, i32 0
  %0 = load i32, i32* %event, align 8, !tbaa !65
  %and = and i32 %0, 6
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %1 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %query = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %1, i32 0, i32 1
  %2 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %query, align 8, !tbaa !66
  %tobool3 = icmp ne void (%struct.rfkill*, i8*)* %2, null
  br i1 %tobool3, label %if.then4, label %do.body8

if.then4:                                         ; preds = %if.end
  %ops5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %3 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops5, align 8, !tbaa !3
  %query6 = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %3, i32 0, i32 1
  %4 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %query6, align 8, !tbaa !66
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %5 = load i8*, i8** %data, align 8, !tbaa !61
  call void %4(%struct.rfkill* %rfkill, i8* %5)
  br label %do.body8

do.body8:                                         ; preds = %if.then4, %if.end
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv9 = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call10 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %10 = load i64, i64* %state, align 8, !tbaa !45
  %and13 = and i64 %10, 2
  %tobool14 = icmp ne i64 %and13, 0
  %frombool15 = zext i1 %tobool14 to i8
  %state16 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %11 = load i64, i64* %state16, align 8, !tbaa !45
  %and17 = and i64 %11, 2
  %tobool18 = icmp ne i64 %and17, 0
  %state20 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %12 = load i64, i64* %state20, align 8, !tbaa !45
  %and22 = and i64 %12, -5
  %or = or i64 %12, 4
  %and22.sink = select i1 %tobool18, i64 %or, i64 %and22
  store i64 %and22.sink, i64* %state20, align 8, !tbaa !45
  %tobool24 = trunc i8 %frombool to i1
  %state26 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %13 = load i64, i64* %state26, align 8, !tbaa !45
  %and30 = and i64 %13, -3
  %or27 = or i64 %13, 2
  %and30.sink = select i1 %tobool24, i64 %or27, i64 %and30
  store i64 %and30.sink, i64* %state26, align 8, !tbaa !45
  %state32 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %14 = load i64, i64* %state32, align 8, !tbaa !45
  %or33 = or i64 %14, 2147483648
  store i64 %or33, i64* %state32, align 8, !tbaa !45
  %lock34 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock34, i64 %call10)
  %ops35 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %15 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops35, align 8, !tbaa !3
  %set_block = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %15, i32 0, i32 2
  %16 = load i32 (i8*, i1)*, i32 (i8*, i1)** %set_block, align 8, !tbaa !67
  %data36 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %17 = load i8*, i8** %data36, align 8, !tbaa !61
  %tobool37 = trunc i8 %frombool to i1
  %call38 = call i32 %16(i8* %17, i1 zeroext %tobool37)
  %18 = bitcast i64* %__dummy41 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %18) #8
  %19 = bitcast i64* %__dummy242 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %19) #8
  %cmp43 = icmp eq i64* %__dummy41, %__dummy242
  %conv44 = zext i1 %cmp43 to i32
  %20 = bitcast i64* %__dummy242 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #8
  %21 = bitcast i64* %__dummy41 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %21) #8
  %lock46 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call47 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock46)
  %call48 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call47)
  %tobool53 = icmp ne i32 %call38, 0
  br i1 %tobool53, label %if.then54, label %if.end65

if.then54:                                        ; preds = %do.body8
  %state55 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %22 = load i64, i64* %state55, align 8, !tbaa !45
  %and56 = and i64 %22, 4
  %tobool57 = icmp ne i64 %and56, 0
  %state59 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %23 = load i64, i64* %state59, align 8, !tbaa !45
  %and63 = and i64 %23, -3
  %or60 = or i64 %23, 2
  %and63.sink = select i1 %tobool57, i64 %or60, i64 %and63
  store i64 %and63.sink, i64* %state59, align 8, !tbaa !45
  br label %if.end65

if.end65:                                         ; preds = %if.then54, %do.body8
  %state66 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %24 = load i64, i64* %state66, align 8, !tbaa !45
  %and67 = and i64 %24, -2147483649
  store i64 %and67, i64* %state66, align 8, !tbaa !45
  %state68 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %25 = load i64, i64* %state68, align 8, !tbaa !45
  %and69 = and i64 %25, -5
  store i64 %and69, i64* %state68, align 8, !tbaa !45
  %state70 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %26 = load i64, i64* %state70, align 8, !tbaa !45
  %and71 = and i64 %26, 2
  %tobool72 = icmp ne i64 %and71, 0
  %frombool73 = zext i1 %tobool72 to i8
  %lock74 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock74, i64 %call48)
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  %tobool75 = trunc i8 %frombool15 to i1
  %conv76 = zext i1 %tobool75 to i32
  %tobool77 = trunc i8 %frombool73 to i1
  %conv78 = zext i1 %tobool77 to i32
  %cmp79 = icmp ne i32 %conv76, %conv78
  br i1 %cmp79, label %if.then81, label %cleanup.cont

if.then81:                                        ; preds = %if.end65
  call void @rfkill_event(%struct.rfkill* %rfkill)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then81, %if.end65, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_event(%struct.rfkill* %rfkill) #0 {
entry:
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !35, !range !49
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %1 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %1, 7
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  call void @led_trigger_event(%struct.led_trigger* %led_trigger, i32 0)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end
  call void @led_trigger_event(%struct.led_trigger* %led_trigger, i32 255)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.else, %if.then2, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_event(%struct.rfkill* %rfkill) #0 {
entry:
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !35, !range !49
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i32 @kobject_uevent(%struct.kobject* %kobj, i32 2)
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 2)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

declare i32 @kobject_uevent(%struct.kobject*, i32) #1

declare void @led_trigger_event(%struct.led_trigger*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #3 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret void
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #3 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !68
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !68
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_activate(%struct.led_classdev* %led) #0 {
entry:
  %trigger = getelementptr inbounds %struct.led_classdev, %struct.led_classdev* %led, i32 0, i32 17
  %0 = load %struct.led_trigger*, %struct.led_trigger** %trigger, align 8, !tbaa !69
  %1 = bitcast %struct.led_trigger* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -120
  %2 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @rfkill_led_trigger_event(%struct.rfkill* %2)
  ret void
}

declare i32 @led_trigger_register(%struct.led_trigger*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #3 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !74
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define %struct.rfkill* @rfkill_alloc(i8* %name, %struct.device* %parent, i32 %type, %struct.rfkill_ops* %ops, i8* %ops_data) #0 {
entry:
  %tobool = icmp ne %struct.rfkill_ops* %ops, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 862)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %set_block = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %ops, i32 0, i32 2
  %0 = load i32 (i8*, i1)*, i32 (i8*, i1)** %set_block, align 8, !tbaa !67
  %tobool20 = icmp ne i32 (i8*, i1)* %0, null
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end18
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 865)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end18
  %tobool38 = icmp ne i32 %lnot.ext26, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %cleanup, label %if.end47

if.end47:                                         ; preds = %if.end36
  %tobool49 = icmp ne i8* %name, null
  %lnot50 = xor i1 %tobool49, true
  %lnot52 = xor i1 %lnot50, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %tobool56 = icmp ne i32 %lnot.ext55, 0
  %lnot57 = xor i1 %tobool56, true
  %lnot59 = xor i1 %lnot57, true
  %lnot.ext60 = zext i1 %lnot59 to i32
  %conv61 = sext i32 %lnot.ext60 to i64
  %expval62 = call i64 @llvm.expect.i64(i64 %conv61, i64 0)
  %tobool63 = icmp ne i64 %expval62, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end47
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 868)
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.end47
  %tobool67 = icmp ne i32 %lnot.ext55, 0
  %lnot68 = xor i1 %tobool67, true
  %lnot70 = xor i1 %lnot68, true
  %lnot.ext71 = zext i1 %lnot70 to i32
  %conv72 = sext i32 %lnot.ext71 to i64
  %expval73 = call i64 @llvm.expect.i64(i64 %conv72, i64 0)
  %tobool74 = icmp ne i64 %expval73, 0
  br i1 %tobool74, label %cleanup, label %if.end76

if.end76:                                         ; preds = %if.end65
  %cmp = icmp eq i32 %type, 0
  %cmp79 = icmp uge i32 %type, 9
  %.cmp79 = select i1 %cmp, i1 true, i1 %cmp79
  %lnot81 = xor i1 %.cmp79, true
  %lnot83 = xor i1 %lnot81, true
  %lnot.ext84 = zext i1 %lnot83 to i32
  %tobool85 = icmp ne i32 %lnot.ext84, 0
  %lnot86 = xor i1 %tobool85, true
  %lnot88 = xor i1 %lnot86, true
  %lnot.ext89 = zext i1 %lnot88 to i32
  %conv90 = sext i32 %lnot.ext89 to i64
  %expval91 = call i64 @llvm.expect.i64(i64 %conv90, i64 0)
  %tobool92 = icmp ne i64 %expval91, 0
  br i1 %tobool92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end76
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 871)
  br label %if.end94

if.end94:                                         ; preds = %if.then93, %if.end76
  %tobool96 = icmp ne i32 %lnot.ext84, 0
  %lnot97 = xor i1 %tobool96, true
  %lnot99 = xor i1 %lnot97, true
  %lnot.ext100 = zext i1 %lnot99 to i32
  %conv101 = sext i32 %lnot.ext100 to i64
  %expval102 = call i64 @llvm.expect.i64(i64 %conv101, i64 0)
  %tobool103 = icmp ne i64 %expval102, 0
  br i1 %tobool103, label %cleanup, label %if.end105

if.end105:                                        ; preds = %if.end94
  %call = call i8* @kzalloc(i64 1792, i32 208)
  %1 = bitcast i8* %call to %struct.rfkill*
  %tobool106 = icmp ne %struct.rfkill* %1, null
  br i1 %tobool106, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end105
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %call109 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %lock111 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock111, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  call void @__raw_spin_lock_init(%struct.raw_spinlock* %rlock, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.1, i32 0, i32 0), %struct.lock_class_key* @rfkill_alloc.__key)
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 12
  call void @INIT_LIST_HEAD(%struct.list_head* %node)
  %type114 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  store i32 %type, i32* %type114, align 8, !tbaa !42
  %name115 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  store i8* %name, i8** %name115, align 8, !tbaa !75
  %ops116 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 7
  store %struct.rfkill_ops* %ops, %struct.rfkill_ops** %ops116, align 8, !tbaa !3
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 8
  store i8* %ops_data, i8** %data, align 8, !tbaa !61
  %dev117 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 11
  %class = getelementptr inbounds %struct.device, %struct.device* %dev117, i32 0, i32 25
  store %struct.class* @rfkill_class, %struct.class** %class, align 8, !tbaa !76
  %parent118 = getelementptr inbounds %struct.device, %struct.device* %dev117, i32 0, i32 0
  store %struct.device* %parent, %struct.device** %parent118, align 8, !tbaa !77
  call void @device_initialize(%struct.device* %dev117)
  br label %cleanup

cleanup:                                          ; preds = %do.body, %if.end105, %if.end94, %if.end65, %if.end36, %if.end
  %retval.0 = phi %struct.rfkill* [ %1, %do.body ], [ null, %if.end ], [ null, %if.end36 ], [ null, %if.end65 ], [ null, %if.end94 ], [ null, %if.end105 ]
  ret %struct.rfkill* %retval.0
}

declare void @warn_slowpath_null(i8*, i32) #1

declare void @__raw_spin_lock_init(%struct.raw_spinlock*, i8*, %struct.lock_class_key*) #1

declare void @device_initialize(%struct.device*) #1

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_dev_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %name = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  %2 = load i8*, i8** %name, align 8, !tbaa !75
  %call = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.31, i32 0, i32 0), i8* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %3 = load i32, i32* %type, align 8, !tbaa !42
  %call1 = call i8* @rfkill_get_type_str(i32 %3)
  %call2 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.32, i32 0, i32 0), i8* %call1)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %cleanup, label %do.body6

do.body6:                                         ; preds = %if.end
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #8
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %6 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %call8 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call9 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call8)
  %state12 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %8 = load i64, i64* %state12, align 8, !tbaa !45
  %conv13 = trunc i64 %8 to i32
  %lock14 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock14, i64 %call9)
  %conv15 = zext i32 %conv13 to i64
  %call16 = call zeroext i8 @user_state_from_blocked(i64 %conv15)
  %conv17 = zext i8 %call16 to i32
  %call18 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.33, i32 0, i32 0), i32 %conv17)
  br label %cleanup

cleanup:                                          ; preds = %do.body6, %if.end, %entry
  %retval.0 = phi i32 [ %call18, %do.body6 ], [ %call, %entry ], [ %call2, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_release(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %2 = bitcast %struct.rfkill* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_suspend(%struct.device* %dev, i32 %state.coerce) #0 {
entry:
  %state = alloca %union.anon.1, align 4
  %coerce.dive = getelementptr inbounds %union.anon.1, %union.anon.1* %state, i32 0, i32 0
  store i32 %state.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @rfkill_pause_polling(%struct.rfkill* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_resume(%struct.device* %dev) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 6
  %2 = load i8, i8* %persistent, align 1, !tbaa !56, !range !49
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %3 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %3, 2
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %frombool = zext i1 %lnot2 to i8
  %tobool3 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @rfkill_resume_polling(%struct.rfkill* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define void @rfkill_resume_polling(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 797, i64 12) #8, !srcloc !78
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !33
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.end12, label %return

if.end12:                                         ; preds = %do.end9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work, i32 0, i32 0
  call void @schedule_work(%struct.work_struct* %work)
  br label %return

return:                                           ; preds = %if.end12, %do.end9
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_pause_polling(%struct.rfkill* %rfkill) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 786, i64 12) #8, !srcloc !79
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !3
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !33
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.end12, label %return

if.end12:                                         ; preds = %do.end9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %poll_work)
  br label %return

return:                                           ; preds = %if.end12, %do.end9
  ret void
}

declare void @kfree(i8*) #1

declare i32 @add_uevent_var(%struct.kobj_uevent_env*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i8* @rfkill_get_type_str(i32 %type) #0 {
entry:
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body1

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_590()
  br label %do.body1

do.body1:                                         ; preds = %if.then, %entry
  %tobool2 = trunc i8 0 to i1
  %conv = zext i1 %tobool2 to i32
  %mul = mul nsw i32 2, %conv
  %sub = sub nsw i32 1, %mul
  %0 = zext i32 %sub to i64
  switch i32 %type, label %do.body12 [
    i32 1, label %sw.epilog
    i32 2, label %sw.bb5
    i32 3, label %sw.bb6
    i32 4, label %sw.bb7
    i32 5, label %sw.bb8
    i32 6, label %sw.bb9
    i32 7, label %sw.bb10
    i32 8, label %sw.bb11
  ]

sw.bb5:                                           ; preds = %do.body1
  br label %sw.epilog

sw.bb6:                                           ; preds = %do.body1
  br label %sw.epilog

sw.bb7:                                           ; preds = %do.body1
  br label %sw.epilog

sw.bb8:                                           ; preds = %do.body1
  br label %sw.epilog

sw.bb9:                                           ; preds = %do.body1
  br label %sw.epilog

sw.bb10:                                          ; preds = %do.body1
  br label %sw.epilog

sw.bb11:                                          ; preds = %do.body1
  br label %sw.epilog

do.body12:                                        ; preds = %do.body1
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 610, i64 12) #8, !srcloc !80
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %do.body12
  br label %do.body13

sw.epilog:                                        ; preds = %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %do.body1
  %retval.0 = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.29, i32 0, i32 0), %sw.bb11 ], [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.28, i32 0, i32 0), %sw.bb10 ], [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.27, i32 0, i32 0), %sw.bb9 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i32 0, i32 0), %sw.bb8 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.25, i32 0, i32 0), %sw.bb7 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.24, i32 0, i32 0), %sw.bb6 ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.23, i32 0, i32 0), %sw.bb5 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.22, i32 0, i32 0), %do.body1 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i8 @user_state_from_blocked(i64 %state) #0 {
entry:
  %and = and i64 %state, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and1 = and i64 %state, 2
  %tobool2 = icmp ne i64 %and1, 0
  %. = select i1 %tobool2, i8 0, i8 1
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i8 [ 2, %entry ], [ %., %if.end ]
  ret i8 %retval.0
}

declare void @__compiletime_assert_590() #1

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_name_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %name = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  %2 = load i8*, i8** %name, align 8, !tbaa !75
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.21, i32 0, i32 0), i8* %2)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_type_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !42
  %call = call i8* @rfkill_get_type_str(i32 %2)
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.21, i32 0, i32 0), i8* %call)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_idx_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 4
  %2 = load i32, i32* %idx, align 8, !tbaa !39
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.30, i32 0, i32 0), i32 %2)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_persistent_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 6
  %2 = load i8, i8* %persistent, align 1, !tbaa !56, !range !49
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.30, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_state_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %2 = load i64, i64* %state, align 8, !tbaa !45
  %call = call zeroext i8 @user_state_from_blocked(i64 %2)
  %conv = zext i8 %call to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.30, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_state_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %state = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %2 = bitcast i64* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %call = call zeroext i1 @capable(i32 12)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @kstrtoul(i8* %buf, i32 0, i64* %state)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %state, align 8, !tbaa !50
  %cmp = icmp ne i64 %3, 0
  %4 = load i64, i64* %state, align 8
  %cmp5 = icmp ne i64 %4, 1
  %or.cond = and i1 %cmp, %cmp5
  br i1 %or.cond, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end3
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %5 = load i64, i64* %state, align 8, !tbaa !50
  %cmp9 = icmp eq i64 %5, 0
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %cmp9)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end8, %if.end3, %if.then2, %entry
  %retval.0 = phi i64 [ %conv, %if.then2 ], [ %count, %if.end8 ], [ -1, %entry ], [ -22, %if.end3 ]
  %6 = bitcast i64* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_claim_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.30, i32 0, i32 0), i32 0)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_claim_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  ret i64 -95
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_soft_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %2 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %2, 2
  %tobool = icmp ne i64 %and, 0
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.30, i32 0, i32 0), i32 %cond)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_soft_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #0 {
entry:
  %state = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %2 = bitcast i64* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %call = call zeroext i1 @capable(i32 12)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @kstrtoul(i8* %buf, i32 0, i64* %state)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %state, align 8, !tbaa !50
  %cmp = icmp ugt i64 %3, 1
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end3
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %4 = load i64, i64* %state, align 8, !tbaa !50
  %tobool7 = icmp ne i64 %4, 0
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool7)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.end3, %if.then2, %entry
  %retval.0 = phi i64 [ %conv, %if.then2 ], [ %count, %if.end6 ], [ -1, %entry ], [ -22, %if.end3 ]
  %5 = bitcast i64* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_hard_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #0 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -256
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %2 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %2, 1
  %tobool = icmp ne i64 %and, 0
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.30, i32 0, i32 0), i32 %cond)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

declare i32 @sprintf(i8*, i8*, ...) #1

declare zeroext i1 @capable(i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #3 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #1

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_blocked(%struct.rfkill* %rfkill) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state5, align 8, !tbaa !45
  %conv6 = trunc i64 %4 to i32
  %lock7 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock7, i64 %call2)
  %conv8 = zext i32 %conv6 to i64
  %and = and i64 %conv8, 7
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  ret i1 %lnot9
}

; Function Attrs: nounwind uwtable
define void @rfkill_set_states(%struct.rfkill* %rfkill, i1 zeroext %sw, i1 zeroext %hw) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %sw to i8
  %frombool1 = zext i1 %hw to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.body12

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 550, i64 12) #8, !srcloc !81
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.body12:                                        ; preds = %entry
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv13 = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call14 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %4, 2
  %tobool19 = icmp ne i64 %and, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %frombool24 = zext i1 %lnot22 to i8
  %state25 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %5 = load i64, i64* %state25, align 8, !tbaa !45
  %and26 = and i64 %5, 1
  %tobool27 = icmp ne i64 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %frombool32 = zext i1 %lnot30 to i8
  %tobool33 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool33)
  %tobool34 = trunc i8 %frombool1 to i1
  %state36 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %6 = load i64, i64* %state36, align 8, !tbaa !45
  %and38 = and i64 %6, -2
  %or = or i64 %6, 1
  %and38.sink = select i1 %tobool34, i64 %or, i64 %and38
  store i64 %and38.sink, i64* %state36, align 8, !tbaa !45
  %lock40 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock40, i64 %call14)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %7 = load i8, i8* %registered, align 4, !tbaa !35, !range !49
  %tobool41 = trunc i8 %7 to i1
  br i1 %tobool41, label %if.else43, label %if.then42

if.then42:                                        ; preds = %do.body12
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  store i8 1, i8* %persistent, align 1, !tbaa !56
  br label %if.end59

if.else43:                                        ; preds = %do.body12
  %tobool44 = trunc i8 %frombool24 to i1
  %conv45 = zext i1 %tobool44 to i32
  %tobool46 = trunc i8 %frombool to i1
  %conv47 = zext i1 %tobool46 to i32
  %cmp48 = icmp ne i32 %conv45, %conv47
  br i1 %cmp48, label %if.then56, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else43
  %tobool50 = trunc i8 %frombool32 to i1
  %conv51 = zext i1 %tobool50 to i32
  %tobool52 = trunc i8 %frombool1 to i1
  %conv53 = zext i1 %tobool52 to i32
  %cmp54 = icmp ne i32 %conv51, %conv53
  br i1 %cmp54, label %if.then56, label %if.end58

if.then56:                                        ; preds = %lor.lhs.false, %if.else43
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  call void @schedule_work(%struct.work_struct* %uevent_work)
  br label %if.end58

if.end58:                                         ; preds = %if.then56, %lor.lhs.false
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.then42
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %0 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %0, 2147483648
  %tobool = icmp ne i64 %and, 0
  %. = select i1 %tobool, i32 4, i32 2
  %tobool1 = trunc i8 %frombool to i1
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %entry
  %conv = zext i32 %. to i64
  %state3 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %1 = load i64, i64* %state3, align 8, !tbaa !45
  %or = or i64 %1, %conv
  store i64 %or, i64* %state3, align 8, !tbaa !45
  br label %if.end7

if.else:                                          ; preds = %entry
  %neg = xor i32 %., -1
  %conv4 = zext i32 %neg to i64
  %state5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %2 = load i64, i64* %state5, align 8, !tbaa !45
  %and6 = and i64 %2, %conv4
  store i64 %and6, i64* %state5, align 8, !tbaa !45
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_init_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body10

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 535, i64 12) #8, !srcloc !82
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body10:                                        ; preds = %entry
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !35, !range !49
  %tobool11 = trunc i8 %0 to i1
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %do.body20, label %do.body30

do.body20:                                        ; preds = %do.body10
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 536, i64 12) #8, !srcloc !83
  br label %do.body21

do.body21:                                        ; preds = %do.body21, %do.body20
  br label %do.body21

do.body30:                                        ; preds = %do.body10
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv31 = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call32 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %tobool37 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool37)
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  store i8 1, i8* %persistent, align 1, !tbaa !56
  %lock38 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock38, i64 %call32)
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body11

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 510, i64 12) #8, !srcloc !84
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body11:                                        ; preds = %entry
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv12 = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call13 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %4, 2
  %tobool18 = icmp ne i64 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %frombool23 = zext i1 %lnot21 to i8
  %tobool24 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool24)
  %state25 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %5 = load i64, i64* %state25, align 8, !tbaa !45
  %and26 = and i64 %5, 1
  %tobool27 = icmp ne i64 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %frombool32 = zext i1 %lnot30 to i8
  %tobool33 = trunc i8 %frombool to i1
  %tobool35 = trunc i8 %frombool32 to i1
  %6 = select i1 %tobool33, i1 true, i1 %tobool35
  %frombool37 = zext i1 %6 to i8
  %lock38 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock38, i64 %call13)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %7 = load i8, i8* %registered, align 4, !tbaa !35, !range !49
  %tobool39 = trunc i8 %7 to i1
  br i1 %tobool39, label %if.end42, label %cleanup

if.end42:                                         ; preds = %do.body11
  %tobool43 = trunc i8 %frombool23 to i1
  %conv44 = zext i1 %tobool43 to i32
  %tobool45 = trunc i8 %frombool37 to i1
  %conv46 = zext i1 %tobool45 to i32
  %cmp47 = icmp ne i32 %conv44, %conv46
  br i1 %cmp47, label %land.lhs.true, label %if.end52

land.lhs.true:                                    ; preds = %if.end42
  %tobool49 = trunc i8 %frombool32 to i1
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %land.lhs.true
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  call void @schedule_work(%struct.work_struct* %uevent_work)
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %land.lhs.true, %if.end42
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  br label %cleanup

cleanup:                                          ; preds = %if.end52, %do.body11
  %tobool53 = trunc i8 %frombool37 to i1
  ret i1 %tobool53
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #0 {
entry:
  %change = alloca i8, align 1
  %frombool = zext i1 %blocked to i8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %change) #8
  %tobool = trunc i8 %frombool to i1
  %call = call zeroext i1 @__rfkill_set_hw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool, i8* %change)
  %frombool1 = zext i1 %call to i8
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !35, !range !49
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %change, align 1, !tbaa !57, !range !49
  %tobool4 = trunc i8 %1 to i1
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  call void @schedule_work(%struct.work_struct* %uevent_work)
  br label %cleanup

cleanup:                                          ; preds = %if.then5, %if.end, %entry
  %tobool8 = trunc i8 %frombool1 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %change) #8
  ret i1 %tobool8
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @__rfkill_set_hw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked, i8* %change) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body11

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 244, i64 12) #8, !srcloc !85
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body11:                                        ; preds = %entry
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv12 = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call13 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state, align 8, !tbaa !45
  %and = and i64 %4, 1
  %tobool18 = icmp ne i64 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %frombool23 = zext i1 %lnot21 to i8
  %tobool24 = trunc i8 %frombool to i1
  %state26 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %5 = load i64, i64* %state26, align 8, !tbaa !45
  %and28 = and i64 %5, -2
  %or = or i64 %5, 1
  %and28.sink = select i1 %tobool24, i64 %or, i64 %and28
  store i64 %and28.sink, i64* %state26, align 8, !tbaa !45
  %tobool30 = trunc i8 %frombool23 to i1
  %conv31 = zext i1 %tobool30 to i32
  %tobool32 = trunc i8 %frombool to i1
  %conv33 = zext i1 %tobool32 to i32
  %cmp34 = icmp ne i32 %conv31, %conv33
  %frombool36 = zext i1 %cmp34 to i8
  store i8 %frombool36, i8* %change, align 1, !tbaa !57
  %state37 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %6 = load i64, i64* %state37, align 8, !tbaa !45
  %and38 = and i64 %6, 7
  %tobool39 = icmp ne i64 %and38, 0
  %lnot40 = xor i1 %tobool39, true
  %lnot42 = xor i1 %lnot40, true
  %frombool44 = zext i1 %lnot42 to i8
  %lock45 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock45, i64 %call13)
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  %tobool46 = trunc i8 %frombool44 to i1
  ret i1 %tobool46
}

; Function Attrs: nounwind uwtable
define void @rfkill_set_led_trigger_name(%struct.rfkill* %rfkill, i8* %name) #0 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 161, i64 12) #8, !srcloc !86
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ledtrigname = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  store i8* %name, i8** %ledtrigname, align 8, !tbaa !58
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @rfkill_get_led_trigger_name(%struct.rfkill* %rfkill) #0 {
entry:
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %name = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !59
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @rfkill_switch_all(i32 %type, i1 zeroext %blocked) #0 {
entry:
  %frombool = zext i1 %blocked to i8
  %call = call i32 @atomic_read(%union.anon.1* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %0 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !57, !range !49
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %tobool3 = trunc i8 %frombool to i1
  call void @__rfkill_switch_all(i32 %type, i1 zeroext %tobool3)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %return

return:                                           ; preds = %if.end4, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_epo() #0 {
entry:
  %call = call i32 @atomic_read(%union.anon.1* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  store i8 1, i8* @rfkill_epo_lock_active, align 1, !tbaa !57
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %next.sink = phi %struct.list_head** [ %next, %for.body ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !36
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %1, i64 -1392
  %2 = bitcast i8* %add.ptr4 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @rfkill_set_block(%struct.rfkill* %2, i1 zeroext true)
  %node2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond5

for.cond5:                                        ; preds = %for.body7, %for.end
  %i.0 = phi i32 [ 0, %for.end ], [ %inc, %for.body7 ]
  %cmp6 = icmp slt i32 %i.0, 9
  br i1 %cmp6, label %for.body7, label %for.end15

for.body7:                                        ; preds = %for.cond5
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %cur, align 2, !tbaa !62, !range !49
  %tobool8 = trunc i8 %3 to i1
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom9
  %sav = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx10, i32 0, i32 1
  %frombool = zext i1 %tobool8 to i8
  store i8 %frombool, i8* %sav, align 1, !tbaa !87
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom11
  %cur13 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx12, i32 0, i32 0
  store i8 1, i8* %cur13, align 2, !tbaa !62
  %inc = add nsw i32 %i.0, 1
  br label %for.cond5

for.end15:                                        ; preds = %for.cond5
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end15, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_restore_states() #0 {
entry:
  %call = call i32 @atomic_read(%union.anon.1* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  store i8 0, i8* @rfkill_epo_lock_active, align 1, !tbaa !57
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom
  %sav = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx, i32 0, i32 1
  %0 = load i8, i8* %sav, align 1, !tbaa !87, !range !49
  %tobool1 = trunc i8 %0 to i1
  call void @__rfkill_switch_all(i32 %i.0, i1 zeroext %tobool1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_remove_epo_lock() #0 {
entry:
  %call = call i32 @atomic_read(%union.anon.1* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  store i8 0, i8* @rfkill_epo_lock_active, align 1, !tbaa !57
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %return

return:                                           ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_is_epo_lock_active() #0 {
entry:
  %0 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !57, !range !49
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_get_global_sw_state(i32 %type) #0 {
entry:
  %idxprom = zext i32 %type to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx, i32 0, i32 0
  %0 = load i8, i8* %cur, align 2, !tbaa !62, !range !49
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_init() #6 section ".init.text" {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  br label %for.body

for.body:                                         ; preds = %for.cond
  %0 = load i32, i32* @rfkill_default_state, align 4, !tbaa !64
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx, i32 0, i32 0
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %cur, align 2, !tbaa !62
  %inc = add nsw i32 %i.0, 1
  br label %for.cond
}

declare i32 @__class_register(%struct.class*, %struct.lock_class_key*) #1

declare i32 @misc_register(%struct.miscdevice*) #1

declare void @class_unregister(%struct.class*) #1

declare i32 @misc_deregister(%struct.miscdevice*) #1

declare i64 @no_llseek(%struct.file*, i64, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_read(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #0 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  br label %while.cond

while.cond:                                       ; preds = %if.end21, %entry
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %2 = load i32, i32* %f_flags, align 8, !tbaa !93
  %and = and i32 %2, 2048
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %out, label %if.end

if.end:                                           ; preds = %while.body
  %mtx2 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx2)
  %call3 = call zeroext i1 @rfkill_readable(%struct.rfkill_data* %1)
  br i1 %call3, label %if.end17, label %do.body

do.body:                                          ; preds = %if.end
  %3 = bitcast %struct.__wait_queue* %__wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %3) #8
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !94
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %call5 = call %struct.task_struct* @get_current()
  %4 = bitcast %struct.task_struct* %call5 to i8*
  store i8* %4, i8** %private, align 8, !tbaa !96
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !97
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list6 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list6, %struct.list_head** %next, align 8, !tbaa !37
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list7 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list7, %struct.list_head** %prev, align 8, !tbaa !38
  br label %for.cond

for.cond:                                         ; preds = %if.then14, %do.body
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @prepare_to_wait(%struct.__wait_queue_head* %read_wait, %struct.__wait_queue* %__wait, i32 1)
  %call8 = call zeroext i1 @rfkill_readable(%struct.rfkill_data* %1)
  br i1 %call8, label %for.end, label %if.end10

if.end10:                                         ; preds = %for.cond
  %call11 = call %struct.task_struct* @get_current()
  %call12 = call i32 @signal_pending(%struct.task_struct* %call11)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %for.end, label %if.then14

if.then14:                                        ; preds = %if.end10
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %if.end10, %for.cond
  %__ret.0 = phi i32 [ 0, %for.cond ], [ -512, %if.end10 ]
  %read_wait16 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @finish_wait(%struct.__wait_queue_head* %read_wait16, %struct.__wait_queue* %__wait)
  %5 = bitcast %struct.__wait_queue* %__wait to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %5) #8
  br label %if.end17

if.end17:                                         ; preds = %for.end, %if.end
  %__ret.1 = phi i32 [ 0, %if.end ], [ %__ret.0, %for.end ]
  %mtx18 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx18, i32 0)
  %tobool19 = icmp ne i32 %__ret.1, 0
  br i1 %tobool19, label %out, label %if.end21

if.end21:                                         ; preds = %if.end17
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %events22 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %events22, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !37
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr to %struct.rfkill_int_event*
  %cmp = icmp ult i64 8, %count
  %.count = select i1 %cmp, i64 8, i64 %count
  %conv = trunc i64 %.count to i32
  %ev26 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %8, i32 0, i32 1
  %9 = bitcast %struct.rfkill_event* %ev26 to i8*
  %conv27 = trunc i64 %.count to i32
  %call28 = call i32 @copy_to_user(i8* %buf, i8* %9, i32 %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  %ret.0 = select i1 %tobool29, i32 -14, i32 %conv
  %list = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %8, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %10 = bitcast %struct.rfkill_int_event* %8 to i8*
  call void @kfree(i8* %10)
  br label %out

out:                                              ; preds = %while.end, %if.end17, %while.body
  %ret.1 = phi i32 [ %ret.0, %while.end ], [ -11, %while.body ], [ %__ret.1, %if.end17 ]
  %mtx32 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx32)
  %conv33 = sext i32 %ret.1 to i64
  ret i64 %conv33
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_write(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #0 {
entry:
  %ev = alloca %struct.rfkill_event, align 1
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %0 = bitcast %struct.rfkill_event* %ev to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %cmp = icmp ult i64 %count, 7
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  store i64 %count, i64* %_min1, align 8, !tbaa !50
  %2 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #8
  store i64 8, i64* %_min2, align 8, !tbaa !50
  %cmp1 = icmp eq i64* %_min1, %_min2
  %conv = zext i1 %cmp1 to i32
  %3 = load i64, i64* %_min1, align 8, !tbaa !50
  %4 = load i64, i64* %_min2, align 8, !tbaa !50
  %cmp2 = icmp ult i64 %3, %4
  %5 = load i64, i64* %_min1, align 8
  %6 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp2, i64 %5, i64 %6
  %7 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #8
  %8 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #8
  %9 = bitcast %struct.rfkill_event* %ev to i8*
  %call = call i64 @copy_from_user(i8* %9, i8* %buf, i64 %cond)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %op = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %10 = load i8, i8* %op, align 1, !tbaa !44
  %conv6 = zext i8 %10 to i32
  %cmp7 = icmp ne i32 %conv6, 2
  br i1 %cmp7, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.end5
  %op9 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %11 = load i8, i8* %op9, align 1, !tbaa !44
  %conv10 = zext i8 %11 to i32
  %cmp11 = icmp ne i32 %conv10, 3
  br i1 %cmp11, label %cleanup, label %if.end14

if.end14:                                         ; preds = %land.lhs.true, %if.end5
  %type = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %12 = load i8, i8* %type, align 1, !tbaa !43
  %conv15 = zext i8 %12 to i32
  %cmp16 = icmp sge i32 %conv15, 9
  br i1 %cmp16, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end14
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %op20 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %13 = load i8, i8* %op20, align 1, !tbaa !44
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 3
  br i1 %cmp22, label %if.then24, label %if.end41

if.then24:                                        ; preds = %if.end19
  %type25 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %14 = load i8, i8* %type25, align 1, !tbaa !43
  %conv26 = zext i8 %14 to i32
  %cmp27 = icmp eq i32 %conv26, 0
  br i1 %cmp27, label %if.then29, label %if.else

if.then29:                                        ; preds = %if.then24
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then29
  %i.0 = phi i32 [ 0, %if.then29 ], [ %inc, %for.body ]
  %cmp30 = icmp ult i32 %i.0, 9
  br i1 %cmp30, label %for.body, label %if.end41

for.body:                                         ; preds = %for.cond
  %soft = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %15 = load i8, i8* %soft, align 1, !tbaa !47
  %tobool32 = icmp ne i8 %15, 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx, i32 0, i32 0
  %frombool = zext i1 %tobool32 to i8
  store i8 %frombool, i8* %cur, align 2, !tbaa !62
  %inc = add i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.then24
  %soft33 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %16 = load i8, i8* %soft33, align 1, !tbaa !47
  %tobool34 = icmp ne i8 %16, 0
  %type35 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %17 = load i8, i8* %type35, align 1, !tbaa !43
  %idxprom36 = zext i8 %17 to i64
  %arrayidx37 = getelementptr inbounds [9 x %struct.anon.47], [9 x %struct.anon.47]* @rfkill_global_states, i64 0, i64 %idxprom36
  %cur38 = getelementptr inbounds %struct.anon.47, %struct.anon.47* %arrayidx37, i32 0, i32 0
  %frombool39 = zext i1 %tobool34 to i8
  store i8 %frombool39, i8* %cur38, align 2, !tbaa !62
  br label %if.end41

if.end41:                                         ; preds = %if.else, %for.cond, %if.end19
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc71, %if.end41
  %next.sink = phi %struct.list_head** [ %next, %for.inc71 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end41 ]
  %18 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !36
  %19 = bitcast %struct.list_head* %18 to i8*
  %add.ptr75 = getelementptr inbounds i8, i8* %19, i64 -1392
  %20 = bitcast i8* %add.ptr75 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 12
  %cmp44 = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp44, label %for.body46, label %for.end76

for.body46:                                       ; preds = %for.cond43
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 4
  %21 = load i32, i32* %idx, align 8, !tbaa !39
  %idx47 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 0
  %22 = load i32, i32* %idx47, align 1, !tbaa !40
  %cmp48 = icmp ne i32 %21, %22
  br i1 %cmp48, label %land.lhs.true50, label %if.end56

land.lhs.true50:                                  ; preds = %for.body46
  %op51 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %23 = load i8, i8* %op51, align 1, !tbaa !44
  %conv52 = zext i8 %23 to i32
  %cmp53 = icmp ne i32 %conv52, 3
  br i1 %cmp53, label %for.inc71, label %if.end56

if.end56:                                         ; preds = %land.lhs.true50, %for.body46
  %type57 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 2
  %24 = load i32, i32* %type57, align 8, !tbaa !42
  %type58 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %25 = load i8, i8* %type58, align 1, !tbaa !43
  %conv59 = zext i8 %25 to i32
  %cmp60 = icmp ne i32 %24, %conv59
  br i1 %cmp60, label %land.lhs.true62, label %if.end68

land.lhs.true62:                                  ; preds = %if.end56
  %type63 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %26 = load i8, i8* %type63, align 1, !tbaa !43
  %conv64 = zext i8 %26 to i32
  %cmp65 = icmp ne i32 %conv64, 0
  br i1 %cmp65, label %for.inc71, label %if.end68

if.end68:                                         ; preds = %land.lhs.true62, %if.end56
  %soft69 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %27 = load i8, i8* %soft69, align 1, !tbaa !47
  %tobool70 = icmp ne i8 %27, 0
  call void @rfkill_set_block(%struct.rfkill* %20, i1 zeroext %tobool70)
  br label %for.inc71

for.inc71:                                        ; preds = %if.end68, %land.lhs.true62, %land.lhs.true50
  %node73 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node73, i32 0, i32 0
  br label %for.cond43

for.end76:                                        ; preds = %for.cond43
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %for.end76, %if.end14, %land.lhs.true, %if.end, %entry
  %retval.0 = phi i64 [ %cond, %for.end76 ], [ -22, %entry ], [ -14, %if.end ], [ -22, %land.lhs.true ], [ -22, %if.end14 ]
  %28 = bitcast %struct.rfkill_event* %ev to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #8
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %read_wait, %struct.poll_table_struct* %wait)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 260, i32 65
  %mtx1 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx1)
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %shr = lshr i32 %cmd, 8
  %and = and i32 %shr, 255
  %cmp = icmp ne i32 %and, 82
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %shr1 = lshr i32 %cmd, 0
  %and2 = and i32 %shr1, 255
  %cmp3 = icmp ne i32 %and2, 1
  br i1 %cmp3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  %input_handler = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  %2 = load i8, i8* %input_handler, align 8, !tbaa !98, !range !49
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end12, label %if.then6

if.then6:                                         ; preds = %if.end5
  %call = call i32 @atomic_add_return(i32 1, %union.anon.1* @rfkill_input_disabled)
  %cmp7 = icmp eq i32 %call, 1
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.then6
  %call9 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.36, i32 0, i32 0))
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.then6
  %input_handler11 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  store i8 1, i8* %input_handler11, align 8, !tbaa !98
  br label %if.end12

if.end12:                                         ; preds = %if.end10, %if.end5
  %mtx13 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx13)
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.end, %entry
  %retval.0 = phi i64 [ 0, %if.end12 ], [ -38, %entry ], [ -38, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_open(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %call = call i8* @kzalloc(i64 296, i32 208)
  %0 = bitcast i8* %call to %struct.rfkill_data*
  %tobool = icmp ne %struct.rfkill_data* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %events)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @__mutex_init(%struct.mutex* %mtx, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.37, i32 0, i32 0), %struct.lock_class_key* @rfkill_fop_open.__key)
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 3
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %read_wait, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.39, i32 0, i32 0), %struct.lock_class_key* @rfkill_fop_open.__key.38)
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %mtx4 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx4, i32 0)
  br label %for.cond

for.cond:                                         ; preds = %if.end9, %if.end
  %next.sink = phi %struct.list_head** [ %next, %if.end9 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end ]
  %1 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !36
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr15 = getelementptr inbounds i8, i8* %2, i64 -1392
  %3 = bitcast i8* %add.ptr15 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %3, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call6 = call i8* @kzalloc(i64 24, i32 208)
  %4 = bitcast i8* %call6 to %struct.rfkill_int_event*
  %tobool7 = icmp ne %struct.rfkill_int_event* %4, null
  br i1 %tobool7, label %if.end9, label %free

if.end9:                                          ; preds = %for.body
  %ev10 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %4, i32 0, i32 1
  call void @rfkill_fill_event(%struct.rfkill_event* %ev10, %struct.rfkill* %3, i32 0)
  %list = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %4, i32 0, i32 0
  %events11 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %events11)
  %node13 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %3, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node13, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %list16 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 0
  call void @list_add(%struct.list_head* %list16, %struct.list_head* @rfkill_fds)
  %mtx17 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx17)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %5 = bitcast %struct.rfkill_data* %0 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %5, i8** %private_data, align 8, !tbaa !88
  %call18 = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %file)
  br label %cleanup

free:                                             ; preds = %for.body
  %mtx19 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx19)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %mtx20 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_destroy(%struct.mutex* %mtx20)
  %events22 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %events22, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !37
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr25 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr25 to %struct.rfkill_int_event*
  br label %for.cond31

for.cond31:                                       ; preds = %for.body35, %free
  %.sink = phi %struct.rfkill_int_event* [ %11, %for.body35 ], [ %8, %free ]
  %ev.0 = phi %struct.rfkill_int_event* [ %8, %free ], [ %11, %for.body35 ]
  %list38 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %.sink, i32 0, i32 0
  %next39 = getelementptr inbounds %struct.list_head, %struct.list_head* %list38, i32 0, i32 0
  %9 = load %struct.list_head*, %struct.list_head** %next39, align 8, !tbaa !100
  %10 = bitcast %struct.list_head* %9 to i8*
  %add.ptr41 = getelementptr inbounds i8, i8* %10, i64 0
  %11 = bitcast i8* %add.ptr41 to %struct.rfkill_int_event*
  %list32 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %ev.0, i32 0, i32 0
  %events33 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  %cmp34 = icmp ne %struct.list_head* %list32, %events33
  br i1 %cmp34, label %for.body35, label %for.end42

for.body35:                                       ; preds = %for.cond31
  %12 = bitcast %struct.rfkill_int_event* %ev.0 to i8*
  call void @kfree(i8* %12)
  br label %for.cond31

for.end42:                                        ; preds = %for.cond31
  %13 = bitcast %struct.rfkill_data* %0 to i8*
  call void @kfree(i8* %13)
  br label %cleanup

cleanup:                                          ; preds = %for.end42, %for.end, %entry
  %retval.0 = phi i32 [ -12, %for.end42 ], [ %call18, %for.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_release(%struct.inode* %inode, %struct.file* %file) #0 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !88
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  call void @mutex_lock_nested(%struct.mutex* @rfkill_global_mutex, i32 0)
  %list = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_destroy(%struct.mutex* %mtx)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !37
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.rfkill_int_event*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.rfkill_int_event* [ %7, %for.body ], [ %4, %entry ]
  %ev.0 = phi %struct.rfkill_int_event* [ %4, %entry ], [ %7, %for.body ]
  %list10 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %.sink, i32 0, i32 0
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %list10, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !100
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr13 to %struct.rfkill_int_event*
  %list7 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %ev.0, i32 0, i32 0
  %events8 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %list7, %events8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = bitcast %struct.rfkill_int_event* %ev.0 to i8*
  call void @kfree(i8* %8)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %input_handler = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  %9 = load i8, i8* %input_handler, align 8, !tbaa !98, !range !49
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then, label %if.end17

if.then:                                          ; preds = %for.end
  %call = call i32 @atomic_sub_return(i32 1, %union.anon.1* @rfkill_input_disabled)
  %cmp14 = icmp eq i32 %call, 0
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.then
  %call16 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.40, i32 0, i32 0))
  br label %if.end17

if.end17:                                         ; preds = %if.then15, %if.then, %for.end
  %10 = bitcast %struct.rfkill_data* %1 to i8*
  call void @kfree(i8* %10)
  ret i32 0
}

declare void @list_del(%struct.list_head*) #1

declare void @mutex_destroy(%struct.mutex*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_return(i32 %i, %union.anon.1* %v) #3 {
entry:
  %sub = sub nsw i32 0, %i
  %call = call i32 @atomic_add_return(i32 %sub, %union.anon.1* %v)
  ret i32 %call
}

declare i32 @printk(i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return(i32 %i, %union.anon.1* %v) #3 {
entry:
  %counter = getelementptr inbounds %union.anon.1, %union.anon.1* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #8, !srcloc !102
  %add = add nsw i32 %i, %0
  ret i32 %add
}

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !37
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i32 @nonseekable_open(%struct.inode*, %struct.file*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #3 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !103
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !103
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #3 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !37
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #3 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end24

if.else:                                          ; preds = %entry
  %tobool8 = icmp ne i32 1, 0
  %lnot9 = xor i1 %tobool8, true
  %lnot11 = xor i1 %lnot9, true
  %lnot.ext12 = zext i1 %lnot11 to i32
  %conv13 = sext i32 %lnot.ext12 to i64
  %expval14 = call i64 @llvm.expect.i64(i64 %conv13, i64 0)
  %tobool15 = icmp ne i64 %expval14, 0
  br i1 %tobool15, label %if.then16, label %if.end

if.then16:                                        ; preds = %if.else
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.34, i32 0, i32 0), i32 66, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.35, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then16, %if.else
  %tobool17 = icmp ne i32 1, 0
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  br label %if.end24

if.end24:                                         ; preds = %if.end, %if.then
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %if.end ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #7

declare void @might_fault() #1

declare i64 @_copy_from_user(i8*, i8*, i32) #1

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @rfkill_readable(%struct.rfkill_data* %data) #0 {
entry:
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %data, i32 0, i32 2
  call void @mutex_lock_nested(%struct.mutex* %mtx, i32 0)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %data, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  %mtx1 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %data, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx1)
  %tobool2 = trunc i8 %frombool to i1
  ret i1 %tobool2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #5 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !105
  ret %struct.task_struct* %0
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #1

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #3 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare void @schedule() #1

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @copy_to_user(i8* %dst, i8* %src, i32 %size) #5 {
entry:
  call void @might_fault()
  %call = call i64 @_copy_to_user(i8* %dst, i8* %src, i32 %size)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare i64 @_copy_to_user(i8*, i8*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #3 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !106
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #3 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #3 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #8, !srcloc !135
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_exit() #6 section ".exit.text" {
entry:
  call void @rfkill_handler_exit()
  %call = call i32 @misc_deregister(%struct.miscdevice* @rfkill_miscdev)
  call void @class_unregister(%struct.class* @rfkill_class)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @rfkill_handler_init() #6 section ".init.text" {
entry:
  %0 = load i32, i32* @rfkill_master_switch_mode, align 4, !tbaa !136
  switch i32 %0, label %return [
    i32 2, label %sw.bb
    i32 1, label %sw.epilog
    i32 0, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb2, %sw.bb, %entry
  %.sink = phi i32 [ 2, %sw.bb2 ], [ 3, %sw.bb ], [ 1, %entry ]
  store i32 %.sink, i32* @rfkill_master_switch_op, align 4, !tbaa !136
  %call = call %struct.raw_spinlock* @spinlock_check.4(%struct.spinlock* @rfkill_op_lock)
  call void @__raw_spin_lock_init(%struct.raw_spinlock* getelementptr inbounds (%struct.spinlock, %struct.spinlock* @rfkill_op_lock, i32 0, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0), %struct.lock_class_key* @rfkill_handler_init.__key)
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !50
  %call5 = call i64 @msecs_to_jiffies(i32 200)
  %sub = sub i64 %1, %call5
  %sub6 = sub i64 %sub, 1
  store i64 %sub6, i64* @rfkill_last_scheduled, align 8, !tbaa !50
  %call7 = call i32 @input_register_handler(%struct.input_handler* @rfkill_handler)
  br label %return

return:                                           ; preds = %sw.epilog, %entry
  %retval.0 = phi i32 [ %call7, %sw.epilog ], [ -22, %entry ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check.4(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

declare i64 @msecs_to_jiffies(i32) #1

declare i32 @input_register_handler(%struct.input_handler*) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_event.7(%struct.input_handle* %handle, i32 %type, i32 %code, i32 %data) #0 {
entry:
  %cmp = icmp eq i32 %type, 1
  %cmp1 = icmp eq i32 %data, 1
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  switch i32 %code, label %if.end10 [
    i32 238, label %sw.bb
    i32 237, label %sw.bb2
    i32 239, label %sw.bb3
    i32 246, label %sw.bb4
    i32 247, label %sw.bb5
  ]

sw.bb:                                            ; preds = %if.then
  call void @rfkill_schedule_toggle(i32 1)
  br label %if.end10

sw.bb2:                                           ; preds = %if.then
  call void @rfkill_schedule_toggle(i32 2)
  br label %if.end10

sw.bb3:                                           ; preds = %if.then
  call void @rfkill_schedule_toggle(i32 3)
  br label %if.end10

sw.bb4:                                           ; preds = %if.then
  call void @rfkill_schedule_toggle(i32 4)
  br label %if.end10

sw.bb5:                                           ; preds = %if.then
  call void @rfkill_schedule_toggle(i32 0)
  br label %if.end10

if.else:                                          ; preds = %entry
  %cmp6 = icmp eq i32 %type, 5
  %cmp8 = icmp eq i32 %code, 3
  %or.cond1 = and i1 %cmp6, %cmp8
  br i1 %or.cond1, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.else
  call void @rfkill_schedule_evsw_rfkillall(i32 %data)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.else, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_connect(%struct.input_handler* %handler, %struct.input_dev* %dev, %struct.input_device_id* %id) #0 {
entry:
  %call = call i8* @kzalloc.15(i64 72, i32 208)
  %0 = bitcast i8* %call to %struct.input_handle*
  %tobool = icmp ne %struct.input_handle* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %dev1 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %0, i32 0, i32 3
  store %struct.input_dev* %dev, %struct.input_dev** %dev1, align 8, !tbaa !137
  %handler2 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %0, i32 0, i32 4
  store %struct.input_handler* %handler, %struct.input_handler** %handler2, align 8, !tbaa !139
  %name = getelementptr inbounds %struct.input_handle, %struct.input_handle* %0, i32 0, i32 2
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.1.8, i32 0, i32 0), i8** %name, align 8, !tbaa !140
  %call3 = call i32 @input_register_handle(%struct.input_handle* %0)
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %err_free_handle, label %if.end6

if.end6:                                          ; preds = %if.end
  %call7 = call i32 @input_open_device(%struct.input_handle* %0)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %err_unregister_handle, label %cleanup

err_unregister_handle:                            ; preds = %if.end6
  call void @input_unregister_handle(%struct.input_handle* %0)
  br label %err_free_handle

err_free_handle:                                  ; preds = %err_unregister_handle, %if.end
  %error.0 = phi i32 [ %call7, %err_unregister_handle ], [ %call3, %if.end ]
  %1 = bitcast %struct.input_handle* %0 to i8*
  call void @kfree(i8* %1)
  br label %cleanup

cleanup:                                          ; preds = %err_free_handle, %if.end6, %entry
  %retval.0 = phi i32 [ %error.0, %err_free_handle ], [ -12, %entry ], [ 0, %if.end6 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_disconnect(%struct.input_handle* %handle) #0 {
entry:
  call void @input_close_device(%struct.input_handle* %handle)
  call void @input_unregister_handle(%struct.input_handle* %handle)
  %0 = bitcast %struct.input_handle* %handle to i8*
  call void @kfree(i8* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_start(%struct.input_handle* %handle) #0 {
entry:
  %dev = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %0 = load %struct.input_dev*, %struct.input_dev** %dev, align 8, !tbaa !137
  %event_lock = getelementptr inbounds %struct.input_dev, %struct.input_dev* %0, i32 0, i32 35
  call void @spin_lock_irq(%struct.spinlock* %event_lock)
  %dev1 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %1 = load %struct.input_dev*, %struct.input_dev** %dev1, align 8, !tbaa !137
  %evbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %1, i32 0, i32 5
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %evbit, i32 0, i32 0
  %call = call i32 @constant_test_bit(i32 5, i64* %arraydecay)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.true7, label %if.end

cond.true7:                                       ; preds = %entry
  %dev8 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %2 = load %struct.input_dev*, %struct.input_dev** %dev8, align 8, !tbaa !137
  %swbit = getelementptr inbounds %struct.input_dev, %struct.input_dev* %2, i32 0, i32 13
  %arraydecay9 = getelementptr inbounds [1 x i64], [1 x i64]* %swbit, i32 0, i32 0
  %call10 = call i32 @constant_test_bit(i32 3, i64* %arraydecay9)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then, label %if.end

if.then:                                          ; preds = %cond.true7
  %dev18 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %3 = load %struct.input_dev*, %struct.input_dev** %dev18, align 8, !tbaa !137
  %sw = getelementptr inbounds %struct.input_dev, %struct.input_dev* %3, i32 0, i32 29
  %arraydecay19 = getelementptr inbounds [1 x i64], [1 x i64]* %sw, i32 0, i32 0
  %call20 = call i32 @constant_test_bit(i32 3, i64* %arraydecay19)
  call void @rfkill_schedule_evsw_rfkillall(i32 %call20)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.true7, %entry
  %dev21 = getelementptr inbounds %struct.input_handle, %struct.input_handle* %handle, i32 0, i32 3
  %4 = load %struct.input_dev*, %struct.input_dev** %dev21, align 8, !tbaa !137
  %event_lock22 = getelementptr inbounds %struct.input_dev, %struct.input_dev* %4, i32 0, i32 35
  call void @spin_unlock_irq(%struct.spinlock* %event_lock22)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @constant_test_bit(i32 %nr, i64* %addr) #5 {
entry:
  %rem = urem i32 %nr, 64
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %div = udiv i32 %nr, 64
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds i64, i64* %addr, i64 %idxprom
  %0 = load volatile i64, i64* %arrayidx, align 8, !tbaa !50
  %and = and i64 %shl, %0
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_evsw_rfkillall(i32 %state) #0 {
entry:
  %tobool = icmp ne i32 %state, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load i32, i32* @rfkill_master_switch_op, align 4, !tbaa !136
  call void @rfkill_schedule_global_op(i32 %0)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @rfkill_schedule_global_op(i32 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irq(%struct.spinlock* %lock) #3 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irq(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @_raw_spin_unlock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_global_op(i32 %op) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %call = call %struct.raw_spinlock* @spinlock_check.4(%struct.spinlock* @rfkill_op_lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  store i32 %op, i32* @rfkill_op, align 4, !tbaa !136
  store i8 1, i8* @rfkill_op_pending, align 1, !tbaa !57
  %cmp5 = icmp eq i32 %op, 0
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %call7 = call zeroext i1 @rfkill_is_epo_lock_active()
  br i1 %call7, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !36
  call void @mod_delayed_work(%struct.workqueue_struct* %4, %struct.delayed_work* @rfkill_op_work, i64 0)
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !50
  store i64 %5, i64* @rfkill_last_scheduled, align 8, !tbaa !50
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  call void @rfkill_schedule_ratelimited()
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @spin_unlock_irqrestore.9(%struct.spinlock* @rfkill_op_lock, i64 %call2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @mod_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @mod_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_ratelimited() #0 {
entry:
  %0 = load i64, i64* @rfkill_last_scheduled, align 8, !tbaa !50
  %call = call i64 @rfkill_ratelimit(i64 %0)
  %call1 = call zeroext i1 @schedule_delayed_work.10(%struct.delayed_work* @rfkill_op_work, i64 %call)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load volatile i64, i64* @jiffies, align 8, !tbaa !50
  store i64 %1, i64* @rfkill_last_scheduled, align 8, !tbaa !50
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore.9(%struct.spinlock* %lock, i64 %flags) #3 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_ratelimit(i64 %last) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy1 = alloca i64, align 8
  %__dummy22 = alloca i64, align 8
  %call = call i64 @msecs_to_jiffies(i32 200)
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %4 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #8
  %5 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #8
  %cmp3 = icmp eq i64* %__dummy1, %__dummy22
  %conv4 = zext i1 %cmp3 to i32
  %6 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #8
  %7 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #8
  %add = add i64 %last, %call
  %8 = load volatile i64, i64* @jiffies, align 8, !tbaa !50
  %sub = sub nsw i64 %add, %8
  %cmp8 = icmp slt i64 %sub, 0
  br i1 %cmp8, label %cond.end, label %cond.false

cond.false:                                       ; preds = %land.lhs.true, %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %land.lhs.true
  %cond = phi i64 [ %call, %cond.false ], [ 0, %land.lhs.true ]
  ret i64 %cond
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @schedule_delayed_work.10(%struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !36
  %call = call zeroext i1 @queue_delayed_work.11(%struct.workqueue_struct* %0, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_delayed_work.11(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 4096, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

declare zeroext i1 @mod_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @rfkill_op_handler(%struct.work_struct* %work) #0 {
entry:
  call void @spin_lock_irq(%struct.spinlock* @rfkill_op_lock)
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !57, !range !49
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %do.body
  %1 = load i32, i32* @rfkill_op, align 4, !tbaa !136
  store i8 0, i8* @rfkill_op_pending, align 1, !tbaa !57
  call void @llvm.memset.p0i8.i64(i8* bitcast ([1 x i64]* @rfkill_sw_pending to i8*), i8 0, i64 8, i32 8, i1 false)
  call void @spin_unlock_irq(%struct.spinlock* @rfkill_op_lock)
  call void @__rfkill_handle_global_op(i32 %1)
  call void @spin_lock_irq(%struct.spinlock* @rfkill_op_lock)
  %2 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !57, !range !49
  %tobool1 = trunc i8 %2 to i1
  br i1 %tobool1, label %do.cond, label %if.end3

if.end3:                                          ; preds = %if.then, %do.body
  %call = call zeroext i1 @rfkill_is_epo_lock_active()
  br i1 %call, label %do.cond, label %if.end5

if.end5:                                          ; preds = %if.end3
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %i.0 = phi i32 [ 0, %if.end5 ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 9
  br i1 %cmp, label %for.body, label %do.cond

for.body:                                         ; preds = %for.cond
  %call6 = call i32 @__test_and_clear_bit(i32 %i.0, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_pending, i32 0, i32 0))
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %for.inc

if.then8:                                         ; preds = %for.body
  %call9 = call i32 @__test_and_clear_bit(i32 %i.0, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_state, i32 0, i32 0))
  %tobool10 = icmp ne i32 %call9, 0
  %frombool = zext i1 %tobool10 to i8
  call void @spin_unlock_irq(%struct.spinlock* @rfkill_op_lock)
  %tobool11 = trunc i8 %frombool to i1
  call void @__rfkill_handle_normal_op(i32 %i.0, i1 zeroext %tobool11)
  call void @spin_lock_irq(%struct.spinlock* @rfkill_op_lock)
  br label %for.inc

for.inc:                                          ; preds = %if.then8, %for.body
  %inc = add i32 %i.0, 1
  br label %for.cond

do.cond:                                          ; preds = %for.cond, %if.end3, %if.then
  %3 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !57, !range !49
  %tobool13 = trunc i8 %3 to i1
  br i1 %tobool13, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  call void @spin_unlock_irq(%struct.spinlock* @rfkill_op_lock)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #4

; Function Attrs: nounwind uwtable
define internal void @__rfkill_handle_global_op(i32 %op) #0 {
entry:
  switch i32 %op, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  call void @rfkill_epo()
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  call void @rfkill_restore_states()
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  call void @rfkill_remove_epo_lock()
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  call void @rfkill_remove_epo_lock()
  br label %for.cond

for.cond:                                         ; preds = %for.body, %sw.bb3
  %i.0 = phi i32 [ 0, %sw.bb3 ], [ %inc, %for.body ]
  %cmp = icmp ult i32 %i.0, 9
  br i1 %cmp, label %for.body, label %sw.epilog

for.body:                                         ; preds = %for.cond
  call void @rfkill_switch_all(i32 %i.0, i1 zeroext false)
  %inc = add i32 %i.0, 1
  br label %for.cond

sw.default:                                       ; preds = %entry
  call void @rfkill_epo()
  %tobool = icmp ne i32 1, 0
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %sw.default
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.4, i32 0, i32 0), i32 81, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.5.14, i32 0, i32 0), i32 %op)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.default
  %tobool6 = icmp ne i32 1, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %for.cond, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__test_and_clear_bit(i32 %nr, i64* %addr) #3 {
entry:
  %0 = call i32 asm sideeffect "btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #8, !srcloc !141
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @__rfkill_handle_normal_op(i32 %type, i1 zeroext %complement) #0 {
entry:
  %frombool = zext i1 %complement to i8
  %call = call zeroext i1 @rfkill_get_global_sw_state(i32 %type)
  %frombool1 = zext i1 %call to i8
  %tobool = trunc i8 %frombool to i1
  %tobool2 = trunc i8 %frombool1 to i1
  %lnot = xor i1 %tobool2, true
  %frombool3 = zext i1 %lnot to i8
  %blocked.0 = select i1 %tobool, i8 %frombool3, i8 %frombool1
  %tobool4 = trunc i8 %blocked.0 to i1
  call void @rfkill_switch_all(i32 %type, i1 zeroext %tobool4)
  ret void
}

declare void @_raw_spin_lock_irq(%struct.raw_spinlock*) #1 section ".spinlock.text"

declare void @input_close_device(%struct.input_handle*) #1

declare void @input_unregister_handle(%struct.input_handle*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc.15(i64 %size, i32 %flags) #3 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc.16(i64 %size, i32 %or)
  ret i8* %call
}

declare i32 @input_register_handle(%struct.input_handle*) #1

declare i32 @input_open_device(%struct.input_handle*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc.16(i64 %size, i32 %flags) #5 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_schedule_toggle(i32 %type) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %call = call zeroext i1 @rfkill_is_epo_lock_active()
  br i1 %call, label %cleanup.cont, label %do.body1

do.body1:                                         ; preds = %entry
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #8
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #8
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #8
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #8
  %call2 = call %struct.raw_spinlock* @spinlock_check.4(%struct.spinlock* @rfkill_op_lock)
  %call3 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call2)
  %4 = load i8, i8* @rfkill_op_pending, align 1, !tbaa !57, !range !49
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %do.body1
  call void @__set_bit(i32 %type, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_pending, i32 0, i32 0))
  call void @__change_bit(i32 %type, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @rfkill_sw_state, i32 0, i32 0))
  call void @rfkill_schedule_ratelimited()
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %do.body1
  call void @spin_unlock_irqrestore.9(%struct.spinlock* @rfkill_op_lock, i64 %call3)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end7, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__set_bit(i32 %nr, i64* %addr) #3 {
entry:
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #8, !srcloc !142
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__change_bit(i32 %nr, i64* %addr) #3 {
entry:
  call void asm sideeffect "btc $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #8, !srcloc !143
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_handler_exit() #6 section ".exit.text" {
entry:
  call void @input_unregister_handler(%struct.input_handler* @rfkill_handler)
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* @rfkill_op_work)
  ret void
}

declare void @input_unregister_handler(%struct.input_handler*) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone speculatable }
attributes #8 = { nounwind }

!llvm.ident = !{!0, !0}
!llvm.module.flags = !{!1}

!0 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 -2144385753, i32 -2144385728, i32 -2144385458, i32 -2144385661, i32 -2144385630, i32 -2144385600}
!3 = !{!4, !8, i64 104}
!4 = !{!"rfkill", !5, i64 0, !8, i64 72, !6, i64 80, !9, i64 88, !10, i64 96, !11, i64 100, !11, i64 101, !8, i64 104, !8, i64 112, !12, i64 120, !8, i64 248, !16, i64 256, !15, i64 1392, !32, i64 1408, !26, i64 1632, !26, i64 1712}
!5 = !{!"spinlock", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}
!8 = !{!"any pointer", !6, i64 0}
!9 = !{!"long", !6, i64 0}
!10 = !{!"int", !6, i64 0}
!11 = !{!"_Bool", !6, i64 0}
!12 = !{!"led_trigger", !8, i64 0, !8, i64 8, !8, i64 16, !13, i64 24, !15, i64 96, !15, i64 112}
!13 = !{!"", !6, i64 0, !10, i64 8, !10, i64 12, !8, i64 16, !14, i64 24}
!14 = !{!"lockdep_map", !8, i64 0, !6, i64 8, !8, i64 24, !10, i64 32, !9, i64 40}
!15 = !{!"list_head", !8, i64 0, !8, i64 8}
!16 = !{!"device", !8, i64 0, !8, i64 8, !17, i64 16, !8, i64 80, !8, i64 88, !20, i64 96, !8, i64 264, !8, i64 272, !8, i64 280, !21, i64 288, !8, i64 880, !10, i64 888, !8, i64 896, !28, i64 904, !8, i64 912, !15, i64 920, !8, i64 936, !29, i64 944, !8, i64 960, !30, i64 968, !10, i64 976, !10, i64 980, !5, i64 984, !15, i64 1056, !31, i64 1072, !8, i64 1104, !8, i64 1112, !8, i64 1120, !8, i64 1128}
!17 = !{!"kobject", !8, i64 0, !15, i64 8, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !18, i64 56, !10, i64 60, !10, i64 60, !10, i64 60, !10, i64 60, !10, i64 60}
!18 = !{!"kref", !19, i64 0}
!19 = !{!"", !10, i64 0}
!20 = !{!"mutex", !19, i64 0, !5, i64 8, !15, i64 80, !8, i64 96, !8, i64 104, !8, i64 112, !14, i64 120}
!21 = !{!"dev_pm_info", !22, i64 0, !10, i64 4, !10, i64 4, !11, i64 4, !11, i64 4, !11, i64 4, !11, i64 4, !5, i64 8, !15, i64 80, !23, i64 96, !8, i64 192, !11, i64 200, !11, i64 200, !25, i64 208, !9, i64 336, !26, i64 344, !24, i64 424, !19, i64 512, !19, i64 516, !10, i64 520, !10, i64 520, !10, i64 520, !10, i64 520, !10, i64 520, !10, i64 520, !10, i64 521, !10, i64 521, !10, i64 521, !10, i64 521, !10, i64 521, !6, i64 524, !6, i64 528, !10, i64 532, !10, i64 536, !9, i64 544, !9, i64 552, !9, i64 560, !9, i64 568, !8, i64 576, !8, i64 584}
!22 = !{!"pm_message", !10, i64 0}
!23 = !{!"completion", !10, i64 0, !24, i64 8}
!24 = !{!"__wait_queue_head", !5, i64 0, !15, i64 72}
!25 = !{!"timer_list", !15, i64 0, !9, i64 16, !8, i64 24, !8, i64 32, !9, i64 40, !10, i64 48, !10, i64 52, !8, i64 56, !6, i64 64, !14, i64 80}
!26 = !{!"work_struct", !27, i64 0, !15, i64 8, !8, i64 24, !14, i64 32}
!27 = !{!"", !9, i64 0}
!28 = !{!"long long", !6, i64 0}
!29 = !{!"dev_archdata", !8, i64 0, !8, i64 8}
!30 = !{!"acpi_dev_node", !8, i64 0}
!31 = !{!"klist_node", !8, i64 0, !15, i64 8, !18, i64 24}
!32 = !{!"delayed_work", !26, i64 0, !25, i64 80, !8, i64 208, !10, i64 216}
!33 = !{!34, !8, i64 0}
!34 = !{!"rfkill_ops", !8, i64 0, !8, i64 8, !8, i64 16}
!35 = !{!4, !11, i64 100}
!36 = !{!8, !8, i64 0}
!37 = !{!15, !8, i64 0}
!38 = !{!15, !8, i64 8}
!39 = !{!4, !10, i64 96}
!40 = !{!41, !10, i64 0}
!41 = !{!"rfkill_event", !10, i64 0, !6, i64 4, !6, i64 5, !6, i64 6, !6, i64 7}
!42 = !{!4, !6, i64 80}
!43 = !{!41, !6, i64 4}
!44 = !{!41, !6, i64 5}
!45 = !{!4, !9, i64 88}
!46 = !{!41, !6, i64 7}
!47 = !{!41, !6, i64 6}
!48 = !{i32 -2144390790, i32 -2144390765, i32 -2144390495, i32 -2144390698, i32 -2144390667, i32 -2144390637}
!49 = !{i8 0, i8 2}
!50 = !{!9, !9, i64 0}
!51 = !{!27, !9, i64 0}
!52 = !{i64 0, i64 8, !50}
!53 = !{!26, !8, i64 24}
!54 = !{!25, !8, i64 32}
!55 = !{!25, !9, i64 40}
!56 = !{!4, !11, i64 101}
!57 = !{!11, !11, i64 0}
!58 = !{!4, !8, i64 248}
!59 = !{!4, !8, i64 120}
!60 = !{!4, !8, i64 128}
!61 = !{!4, !8, i64 112}
!62 = !{!63, !11, i64 0}
!63 = !{!"", !11, i64 0, !11, i64 1}
!64 = !{!10, !10, i64 0}
!65 = !{!4, !10, i64 544}
!66 = !{!34, !8, i64 8}
!67 = !{!34, !8, i64 16}
!68 = !{!16, !8, i64 80}
!69 = !{!70, !8, i64 464}
!70 = !{!"led_classdev", !8, i64 0, !10, i64 8, !10, i64 12, !10, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !15, i64 56, !8, i64 72, !9, i64 80, !9, i64 88, !25, i64 96, !10, i64 224, !26, i64 232, !10, i64 312, !71, i64 320, !8, i64 464, !15, i64 472, !8, i64 488, !11, i64 496}
!71 = !{!"rw_semaphore", !9, i64 0, !72, i64 8, !15, i64 80, !14, i64 96}
!72 = !{!"raw_spinlock", !73, i64 0, !10, i64 4, !10, i64 8, !8, i64 16, !14, i64 24}
!73 = !{!"arch_spinlock", !6, i64 0}
!74 = !{!17, !8, i64 0}
!75 = !{!4, !8, i64 72}
!76 = !{!16, !8, i64 1104}
!77 = !{!16, !8, i64 0}
!78 = !{i32 -2144398578, i32 -2144398553, i32 -2144398283, i32 -2144398486, i32 -2144398455, i32 -2144398425}
!79 = !{i32 -2144404341, i32 -2144404316, i32 -2144404046, i32 -2144404249, i32 -2144404218, i32 -2144404188}
!80 = !{i32 -2144410601, i32 -2144410576, i32 -2144410306, i32 -2144410509, i32 -2144410478, i32 -2144410448}
!81 = !{i32 -2144414058, i32 -2144414033, i32 -2144413763, i32 -2144413966, i32 -2144413935, i32 -2144413905}
!82 = !{i32 -2144416628, i32 -2144416603, i32 -2144416333, i32 -2144416536, i32 -2144416505, i32 -2144416475}
!83 = !{i32 -2144416118, i32 -2144416093, i32 -2144415823, i32 -2144416026, i32 -2144415995, i32 -2144415965}
!84 = !{i32 -2144418712, i32 -2144418687, i32 -2144418417, i32 -2144418620, i32 -2144418589, i32 -2144418559}
!85 = !{i32 -2144424418, i32 -2144424393, i32 -2144424123, i32 -2144424326, i32 -2144424295, i32 -2144424265}
!86 = !{i32 -2144427918, i32 -2144427893, i32 -2144427623, i32 -2144427826, i32 -2144427795, i32 -2144427765}
!87 = !{!63, !11, i64 1}
!88 = !{!89, !8, i64 304}
!89 = !{!"file", !6, i64 0, !90, i64 16, !8, i64 32, !8, i64 40, !5, i64 48, !10, i64 120, !27, i64 128, !10, i64 136, !10, i64 140, !28, i64 144, !91, i64 152, !8, i64 248, !92, i64 256, !28, i64 288, !8, i64 296, !8, i64 304, !15, i64 312, !15, i64 328, !8, i64 344, !9, i64 352}
!90 = !{!"path", !8, i64 0, !8, i64 8}
!91 = !{!"fown_struct", !13, i64 0, !8, i64 72, !6, i64 80, !10, i64 84, !10, i64 88, !10, i64 92}
!92 = !{!"file_ra_state", !9, i64 0, !10, i64 8, !10, i64 12, !10, i64 16, !10, i64 20, !28, i64 24}
!93 = !{!89, !10, i64 136}
!94 = !{!95, !10, i64 0}
!95 = !{!"__wait_queue", !10, i64 0, !8, i64 8, !8, i64 16, !15, i64 24}
!96 = !{!95, !8, i64 8}
!97 = !{!95, !8, i64 16}
!98 = !{!99, !11, i64 288}
!99 = !{!"rfkill_data", !15, i64 0, !15, i64 16, !20, i64 32, !24, i64 200, !11, i64 288}
!100 = !{!101, !8, i64 0}
!101 = !{!"rfkill_int_event", !15, i64 0, !41, i64 16}
!102 = !{i32 -2146190397, i32 -2146190358, i32 -2146190337, i32 -2146190300, i32 -2146190277, i32 -2146190268}
!103 = !{!104, !8, i64 0}
!104 = !{!"poll_table_struct", !8, i64 0, !9, i64 8}
!105 = !{i32 -2146733041}
!106 = !{!107, !8, i64 8}
!107 = !{!"task_struct", !9, i64 0, !8, i64 8, !19, i64 16, !10, i64 20, !10, i64 24, !108, i64 32, !10, i64 40, !10, i64 44, !10, i64 48, !10, i64 52, !10, i64 56, !10, i64 60, !8, i64 64, !109, i64 72, !114, i64 448, !8, i64 520, !115, i64 528, !6, i64 536, !10, i64 540, !10, i64 544, !10, i64 548, !116, i64 552, !117, i64 1064, !15, i64 1096, !118, i64 1112, !8, i64 1152, !8, i64 1160, !10, i64 1168, !10, i64 1172, !10, i64 1176, !10, i64 1180, !10, i64 1184, !10, i64 1188, !10, i64 1192, !10, i64 1196, !10, i64 1196, !10, i64 1196, !10, i64 1196, !10, i64 1196, !10, i64 1196, !10, i64 1200, !10, i64 1204, !9, i64 1208, !8, i64 1216, !8, i64 1224, !15, i64 1232, !15, i64 1248, !8, i64 1264, !15, i64 1272, !15, i64 1288, !6, i64 1304, !15, i64 1376, !8, i64 1392, !8, i64 1400, !8, i64 1408, !9, i64 1416, !9, i64 1424, !9, i64 1432, !9, i64 1440, !9, i64 1448, !119, i64 1456, !9, i64 1472, !9, i64 1480, !120, i64 1488, !120, i64 1504, !9, i64 1520, !9, i64 1528, !121, i64 1536, !6, i64 1560, !8, i64 1608, !8, i64 1616, !6, i64 1624, !10, i64 1640, !10, i64 1644, !122, i64 1648, !9, i64 1656, !123, i64 1664, !8, i64 1848, !8, i64 1856, !8, i64 1864, !8, i64 1872, !8, i64 1880, !126, i64 1888, !126, i64 1896, !126, i64 1904, !127, i64 1912, !9, i64 1936, !9, i64 1944, !8, i64 1952, !8, i64 1960, !8, i64 1968, !8, i64 1976, !8, i64 1984, !10, i64 1992, !10, i64 1996, !128, i64 2000, !10, i64 2016, !10, i64 2020, !5, i64 2024, !72, i64 2096, !129, i64 2168, !8, i64 2184, !8, i64 2192, !10, i64 2200, !9, i64 2208, !9, i64 2216, !10, i64 2224, !10, i64 2228, !10, i64 2232, !10, i64 2236, !9, i64 2240, !9, i64 2248, !10, i64 2256, !10, i64 2260, !10, i64 2264, !10, i64 2268, !28, i64 2272, !10, i64 2280, !10, i64 2284, !6, i64 2288, !10, i64 4976, !8, i64 4984, !8, i64 4992, !8, i64 5000, !8, i64 5008, !8, i64 5016, !8, i64 5024, !9, i64 5032, !8, i64 5040, !130, i64 5048, !28, i64 5104, !28, i64 5112, !9, i64 5120, !126, i64 5128, !131, i64 5256, !10, i64 5260, !10, i64 5264, !8, i64 5272, !15, i64 5280, !8, i64 5296, !8, i64 5304, !15, i64 5312, !8, i64 5328, !6, i64 5336, !20, i64 5352, !15, i64 5520, !8, i64 5536, !124, i64 5544, !124, i64 5546, !10, i64 5548, !10, i64 5552, !10, i64 5556, !28, i64 5560, !132, i64 5568, !132, i64 5584, !8, i64 5600, !133, i64 5608, !8, i64 5624, !10, i64 5632, !10, i64 5636, !10, i64 5640, !9, i64 5648, !10, i64 5656, !6, i64 5664, !9, i64 9504, !9, i64 9512, !10, i64 9520, !8, i64 9528, !28, i64 9536, !19, i64 9544, !19, i64 9548, !9, i64 9552, !9, i64 9560, !134, i64 9568, !10, i64 9600, !19, i64 9604, !8, i64 9608, !10, i64 9616, !10, i64 9620}
!108 = !{!"llist_node", !8, i64 0}
!109 = !{!"sched_entity", !110, i64 0, !111, i64 16, !15, i64 40, !10, i64 56, !28, i64 64, !28, i64 72, !28, i64 80, !28, i64 88, !28, i64 96, !112, i64 104, !8, i64 320, !8, i64 328, !8, i64 336, !113, i64 344}
!110 = !{!"load_weight", !9, i64 0, !9, i64 8}
!111 = !{!"rb_node", !9, i64 0, !8, i64 8, !8, i64 16}
!112 = !{!"sched_statistics", !28, i64 0, !28, i64 8, !28, i64 16, !28, i64 24, !28, i64 32, !28, i64 40, !28, i64 48, !28, i64 56, !28, i64 64, !28, i64 72, !28, i64 80, !28, i64 88, !28, i64 96, !28, i64 104, !28, i64 112, !28, i64 120, !28, i64 128, !28, i64 136, !28, i64 144, !28, i64 152, !28, i64 160, !28, i64 168, !28, i64 176, !28, i64 184, !28, i64 192, !28, i64 200, !28, i64 208}
!113 = !{!"sched_avg", !10, i64 0, !10, i64 4, !28, i64 8, !28, i64 16, !9, i64 24}
!114 = !{!"sched_rt_entity", !15, i64 0, !9, i64 16, !9, i64 24, !10, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !8, i64 64}
!115 = !{!"hlist_head", !8, i64 0}
!116 = !{!"cpumask", !6, i64 0}
!117 = !{!"sched_info", !9, i64 0, !28, i64 8, !28, i64 16, !28, i64 24}
!118 = !{!"plist_node", !10, i64 0, !15, i64 8, !15, i64 24}
!119 = !{!"cputime", !9, i64 0, !9, i64 8}
!120 = !{!"timespec", !9, i64 0, !9, i64 8}
!121 = !{!"task_cputime", !9, i64 0, !9, i64 8, !28, i64 16}
!122 = !{!"sysv_sem", !8, i64 0}
!123 = !{!"thread_struct", !6, i64 0, !9, i64 24, !9, i64 32, !9, i64 40, !124, i64 48, !124, i64 50, !124, i64 52, !124, i64 54, !9, i64 56, !9, i64 64, !6, i64 72, !9, i64 104, !9, i64 112, !9, i64 120, !9, i64 128, !9, i64 136, !125, i64 144, !8, i64 160, !9, i64 168, !10, i64 176}
!124 = !{!"short", !6, i64 0}
!125 = !{!"fpu", !10, i64 0, !10, i64 4, !8, i64 8}
!126 = !{!"", !6, i64 0}
!127 = !{!"sigpending", !15, i64 0, !126, i64 16}
!128 = !{!"seccomp", !10, i64 0, !8, i64 8}
!129 = !{!"plist_head", !15, i64 0}
!130 = !{!"task_io_accounting", !28, i64 0, !28, i64 8, !28, i64 16, !28, i64 24, !28, i64 32, !28, i64 40, !28, i64 48}
!131 = !{!"seqcount", !10, i64 0}
!132 = !{!"callback_head", !8, i64 0, !8, i64 8}
!133 = !{!"page_frag", !8, i64 0, !10, i64 8, !10, i64 12}
!134 = !{!"memcg_batch_info", !10, i64 0, !8, i64 8, !9, i64 16, !9, i64 24}
!135 = !{i32 350445, i32 350456}
!136 = !{!6, !6, i64 0}
!137 = !{!138, !8, i64 24}
!138 = !{!"input_handle", !8, i64 0, !10, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !15, i64 40, !15, i64 56}
!139 = !{!138, !8, i64 32}
!140 = !{!138, !8, i64 16}
!141 = !{i32 356840, i32 356852}
!142 = !{i32 351485}
!143 = !{i32 353751}
