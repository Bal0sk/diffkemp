; ModuleID = 'net/rfkill/core.bc'
source_filename = "net/rfkill/core.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.42 }
%union.anon.42 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.atomic_t = type { i32 }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type opaque
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.file = type { %union.anon.36, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.36 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.39, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.37, i8* }
%union.anon.37 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.page = type { i64, %struct.address_space*, %struct.anon.22, %union.anon.28, %union.anon.30, [8 x i8] }
%struct.anon.22 = type { %union.anon.23, %union.anon.24 }
%union.anon.23 = type { i64 }
%union.anon.24 = type { i64 }
%union.anon.28 = type { %struct.list_head }
%union.anon.30 = type { i64 }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.34, i32 }
%union.anon.34 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.39 = type { %struct.list_head }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.33, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.35, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.32 = type { i32 }
%union.anon.33 = type { %struct.callback_head }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.40 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.40 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.31, i32 }
%union.anon.31 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.35 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.2, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.4, %union.anon.5 }
%union.anon.2 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.3 = type { i64 }
%union.anon.4 = type { %struct.list_head }
%union.anon.5 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.6 }
%union.anon.6 = type { %struct.anon.7 }
%struct.anon.7 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.9, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.12 }
%union.anon.9 = type { %struct.anon.10 }
%struct.anon.10 = type { i64, i64 }
%union.anon.12 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.14 }
%union.anon.14 = type { %struct.anon.18, [80 x i8] }
%struct.anon.18 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.anon.43 = type { i8, i8 }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.subsys_private = type opaque
%struct.miscdevice = type { i32, i8*, %struct.file_operations*, %struct.list_head, %struct.device*, %struct.device*, i8*, i16 }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.workqueue_struct = type opaque
%struct.rfkill = type { %struct.spinlock, i8*, i32, i64, i32, i8, i8, %struct.rfkill_ops*, i8*, %struct.led_trigger, i8*, %struct.device, %struct.list_head, %struct.delayed_work, %struct.work_struct, %struct.work_struct }
%struct.rfkill_ops = type { void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)*, i32 (i8*, i1)* }
%struct.led_trigger = type { i8*, void (%struct.led_classdev*)*, void (%struct.led_classdev*)*, %struct.rwlock_t, %struct.list_head, %struct.list_head }
%struct.led_classdev = type { i8*, i32, i32, i32, void (%struct.led_classdev*, i32)*, i32 (%struct.led_classdev*)*, i32 (%struct.led_classdev*, i64*, i64*)*, %struct.device*, %struct.list_head, i8*, i64, i64, %struct.timer_list, i32, %struct.work_struct, i32, %struct.rw_semaphore, %struct.led_trigger*, %struct.list_head, i8*, i8 }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.rfkill_data = type { %struct.list_head, %struct.list_head, %struct.mutex, %struct.__wait_queue_head, i8 }
%struct.rfkill_int_event = type { %struct.list_head, %struct.rfkill_event }
%struct.rfkill_event = type { i32, i8, i8, i8, i8 }
%struct.__wait_queue = type { i32, i8*, i32 (%struct.__wait_queue*, i32, i32, i8*)*, %struct.list_head }
%struct.thread_info = type { %struct.task_struct*, %struct.exec_domain*, i32, i32, i32, i32, %struct.mm_segment_t, %struct.restart_block, i8*, i8 }
%struct.exec_domain = type { i8*, void (i32, %struct.pt_regs*)*, i8, i8, i64*, i64*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.map_segment*, %struct.module*, %struct.exec_domain* }
%struct.pt_regs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.map_segment = type opaque
%struct.mm_segment_t = type { i64 }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.44 }
%union.anon.44 = type { %struct.anon.45 }
%struct.anon.45 = type { i32*, i32, i32, i32, i64, i32* }

@__param_str_default_state = internal constant [21 x i8] c"rfkill.default_state\00", align 16
@param_ops_uint = external global %struct.kernel_param_ops, align 8
@rfkill_default_state = internal global i32 1, align 4
@__param_default_state = internal constant %struct.kernel_param { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__param_str_default_state, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 292, i16 -1, %union.anon.42 { i8* bitcast (i32* @rfkill_default_state to i8*) } }, section "__param", align 8
@__kstrtab_rfkill_get_led_trigger_name = internal constant [28 x i8] c"rfkill_get_led_trigger_name\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_get_led_trigger_name = internal constant %struct.kernel_symbol { i64 ptrtoint (i8* (%struct.rfkill*)* @rfkill_get_led_trigger_name to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_rfkill_get_led_trigger_name, i32 0, i32 0) }, section "___ksymtab+rfkill_get_led_trigger_name", align 8
@.str = private unnamed_addr constant [18 x i8] c"net/rfkill/core.c\00", align 1
@__kstrtab_rfkill_set_led_trigger_name = internal constant [28 x i8] c"rfkill_set_led_trigger_name\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_set_led_trigger_name = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i8*)* @rfkill_set_led_trigger_name to i64), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__kstrtab_rfkill_set_led_trigger_name, i32 0, i32 0) }, section "___ksymtab+rfkill_set_led_trigger_name", align 8
@rfkill_input_disabled = internal global %struct.atomic_t zeroinitializer, align 4
@rfkill_global_mutex = internal global %struct.mutex { %struct.atomic_t { i32 1 }, %struct.spinlock zeroinitializer, %struct.list_head { %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), i64 8) to %struct.list_head*), %struct.list_head* bitcast (i8* getelementptr (i8, i8* bitcast (%struct.mutex* @rfkill_global_mutex to i8*), i64 8) to %struct.list_head*) }, %struct.task_struct* null, i8* null }, align 8
@rfkill_epo_lock_active = internal global i8 0, align 1
@rfkill_list = internal global %struct.list_head { %struct.list_head* @rfkill_list, %struct.list_head* @rfkill_list }, align 8
@rfkill_global_states = internal global [9 x %struct.anon.43] zeroinitializer, align 16
@__kstrtab_rfkill_set_hw_state = internal constant [20 x i8] c"rfkill_set_hw_state\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_set_hw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*, i1)* @rfkill_set_hw_state to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rfkill_set_hw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_set_hw_state", align 8
@__kstrtab_rfkill_set_sw_state = internal constant [20 x i8] c"rfkill_set_sw_state\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_set_sw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*, i1)* @rfkill_set_sw_state to i64), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__kstrtab_rfkill_set_sw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_set_sw_state", align 8
@__kstrtab_rfkill_init_sw_state = internal constant [21 x i8] c"rfkill_init_sw_state\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_init_sw_state = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i1)* @rfkill_init_sw_state to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rfkill_init_sw_state, i32 0, i32 0) }, section "___ksymtab+rfkill_init_sw_state", align 8
@__kstrtab_rfkill_set_states = internal constant [18 x i8] c"rfkill_set_states\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_set_states = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*, i1, i1)* @rfkill_set_states to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rfkill_set_states, i32 0, i32 0) }, section "___ksymtab+rfkill_set_states", align 8
@__kstrtab_rfkill_pause_polling = internal constant [21 x i8] c"rfkill_pause_polling\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_pause_polling = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_pause_polling to i64), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__kstrtab_rfkill_pause_polling, i32 0, i32 0) }, section "___ksymtab+rfkill_pause_polling", align 8
@__kstrtab_rfkill_resume_polling = internal constant [22 x i8] c"rfkill_resume_polling\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_resume_polling = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_resume_polling to i64), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__kstrtab_rfkill_resume_polling, i32 0, i32 0) }, section "___ksymtab+rfkill_resume_polling", align 8
@__kstrtab_rfkill_blocked = internal constant [15 x i8] c"rfkill_blocked\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_blocked = internal constant %struct.kernel_symbol { i64 ptrtoint (i1 (%struct.rfkill*)* @rfkill_blocked to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rfkill_blocked, i32 0, i32 0) }, section "___ksymtab+rfkill_blocked", align 8
@rfkill_class = internal global %struct.class { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0), %struct.module* null, %struct.class_attribute* null, %struct.device_attribute* getelementptr inbounds ([9 x %struct.device_attribute], [9 x %struct.device_attribute]* @rfkill_dev_attrs, i32 0, i32 0), %struct.bin_attribute* null, %struct.kobject* null, i32 (%struct.device*, %struct.kobj_uevent_env*)* @rfkill_dev_uevent, i8* (%struct.device*, i16*)* null, void (%struct.class*)* null, void (%struct.device*)* @rfkill_release, i32 (%struct.device*, i32)* @rfkill_suspend, i32 (%struct.device*)* @rfkill_resume, %struct.kobj_ns_type_operations* null, i8* (%struct.device*)* null, %struct.dev_pm_ops* null, %struct.subsys_private* null }, align 8
@__kstrtab_rfkill_alloc = internal constant [13 x i8] c"rfkill_alloc\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_alloc = internal constant %struct.kernel_symbol { i64 ptrtoint (%struct.rfkill* (i8*, %struct.device*, i32, %struct.rfkill_ops*, i8*)* @rfkill_alloc to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_rfkill_alloc, i32 0, i32 0) }, section "___ksymtab+rfkill_alloc", align 8
@rfkill_register.rfkill_no = internal global i64 0, align 8
@.str.1 = private unnamed_addr constant [10 x i8] c"rfkill%lu\00", align 1
@__kstrtab_rfkill_register = internal constant [16 x i8] c"rfkill_register\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_register = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.rfkill*)* @rfkill_register to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_rfkill_register, i32 0, i32 0) }, section "___ksymtab+rfkill_register", align 8
@__kstrtab_rfkill_unregister = internal constant [18 x i8] c"rfkill_unregister\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_unregister = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_unregister to i64), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__kstrtab_rfkill_unregister, i32 0, i32 0) }, section "___ksymtab+rfkill_unregister", align 8
@__kstrtab_rfkill_destroy = internal constant [15 x i8] c"rfkill_destroy\00", section "__ksymtab_strings", align 1
@__ksymtab_rfkill_destroy = internal constant %struct.kernel_symbol { i64 ptrtoint (void (%struct.rfkill*)* @rfkill_destroy to i64), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__kstrtab_rfkill_destroy, i32 0, i32 0) }, section "___ksymtab+rfkill_destroy", align 8
@__initcall_rfkill_init4 = internal global i32 ()* @rfkill_init, section ".initcall4.init", align 8
@rfkill_miscdev = internal global %struct.miscdevice { i32 255, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0), %struct.file_operations* @rfkill_fops, %struct.list_head zeroinitializer, %struct.device* null, %struct.device* null, i8* null, i16 0 }, align 8
@__exitcall_rfkill_exit = internal global void ()* @rfkill_exit, section ".exitcall.exit", align 8
@smp_ops = external global %struct.smp_ops, align 8
@system_wq = external global %struct.workqueue_struct*, align 8
@.str.2 = private unnamed_addr constant [7 x i8] c"rfkill\00", align 1
@rfkill_dev_attrs = internal global [9 x %struct.device_attribute] [%struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_name_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_type_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_idx_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.6, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_persistent_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_state_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @rfkill_state_store }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.8, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_claim_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @rfkill_claim_store }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9, i32 0, i32 0), i16 420 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_soft_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* @rfkill_soft_store }, %struct.device_attribute { %struct.attribute { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.10, i32 0, i32 0), i16 292 }, i64 (%struct.device*, %struct.device_attribute*, i8*)* @rfkill_hard_show, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* null }, %struct.device_attribute zeroinitializer], align 16
@.str.3 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"type\00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"index\00", align 1
@.str.6 = private unnamed_addr constant [11 x i8] c"persistent\00", align 1
@.str.7 = private unnamed_addr constant [6 x i8] c"state\00", align 1
@.str.8 = private unnamed_addr constant [6 x i8] c"claim\00", align 1
@.str.9 = private unnamed_addr constant [5 x i8] c"soft\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"hard\00", align 1
@.str.11 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.12 = private unnamed_addr constant [5 x i8] c"wlan\00", align 1
@.str.13 = private unnamed_addr constant [10 x i8] c"bluetooth\00", align 1
@.str.14 = private unnamed_addr constant [14 x i8] c"ultrawideband\00", align 1
@.str.15 = private unnamed_addr constant [6 x i8] c"wimax\00", align 1
@.str.16 = private unnamed_addr constant [5 x i8] c"wwan\00", align 1
@.str.17 = private unnamed_addr constant [4 x i8] c"gps\00", align 1
@.str.18 = private unnamed_addr constant [3 x i8] c"fm\00", align 1
@.str.19 = private unnamed_addr constant [4 x i8] c"nfc\00", align 1
@.str.20 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.21 = private unnamed_addr constant [15 x i8] c"RFKILL_NAME=%s\00", align 1
@.str.22 = private unnamed_addr constant [15 x i8] c"RFKILL_TYPE=%s\00", align 1
@.str.23 = private unnamed_addr constant [16 x i8] c"RFKILL_STATE=%d\00", align 1
@rfkill_fds = internal global %struct.list_head { %struct.list_head* @rfkill_fds, %struct.list_head* @rfkill_fds }, align 8
@rfkill_init.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@rfkill_fops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* @rfkill_fop_read, i64 (%struct.file*, i8*, i64, i64*)* @rfkill_fop_write, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* @rfkill_fop_poll, i64 (%struct.file*, i32, i64)* @rfkill_fop_ioctl, i64 (%struct.file*, i32, i64)* @rfkill_fop_ioctl, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rfkill_fop_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @rfkill_fop_release, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@current_task = external global %struct.task_struct*, align 8
@.str.24 = private unnamed_addr constant [34 x i8] c"\017rfkill: input handler disabled\0A\00", align 1
@rfkill_fop_open.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.25 = private unnamed_addr constant [11 x i8] c"&data->mtx\00", align 1
@rfkill_fop_open.__key.26 = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.27 = private unnamed_addr constant [17 x i8] c"&data->read_wait\00", align 1
@.str.28 = private unnamed_addr constant [33 x i8] c"\017rfkill: input handler enabled\0A\00", align 1
@llvm.used = appending global [17 x i8*] [i8* bitcast (%struct.kernel_param* @__param_default_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_get_led_trigger_name to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_led_trigger_name to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_hw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_sw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_init_sw_state to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_set_states to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_pause_polling to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_resume_polling to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_blocked to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_alloc to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_register to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_unregister to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_rfkill_destroy to i8*), i8* bitcast (i32 ()** @__initcall_rfkill_init4 to i8*), i8* bitcast (void ()* @rfkill_exit to i8*), i8* bitcast (void ()** @__exitcall_rfkill_exit to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @rfkill_get_led_trigger_name(%struct.rfkill* %rfkill) #1 {
entry:
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %name = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !12
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @rfkill_set_led_trigger_name(%struct.rfkill* %rfkill, i8* %name) #1 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 161, i64 12) #7, !srcloc !38
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ledtrigname = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  store i8* %name, i8** %ledtrigname, align 8, !tbaa !39
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #2

; Function Attrs: nounwind uwtable
define void @rfkill_switch_all(i32 %type, i1 zeroext %blocked) #1 {
entry:
  %frombool = zext i1 %blocked to i8
  %call = call i32 @atomic_read(%struct.atomic_t* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %0 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !40, !range !41
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %if.end4, label %if.then2

if.then2:                                         ; preds = %if.end
  %tobool3 = trunc i8 %frombool to i1
  call void @__rfkill_switch_all(i32 %type, i1 zeroext %tobool3)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %return

return:                                           ; preds = %entry, %if.end4
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !42
  ret i32 %0
}

declare void @mutex_lock(%struct.mutex*) #3

; Function Attrs: nounwind uwtable
define internal void @__rfkill_switch_all(i32 %type, i1 zeroext %blocked) #1 {
entry:
  %frombool = zext i1 %blocked to i8
  %tobool = trunc i8 %frombool to i1
  %idxprom = zext i32 %type to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx, i32 0, i32 0
  %frombool1 = zext i1 %tobool to i8
  store i8 %frombool1, i8* %cur, align 2, !tbaa !43
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !45
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr9 = getelementptr inbounds i8, i8* %1, i64 -568
  %2 = bitcast i8* %add.ptr9 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %type2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 2
  %3 = load i32, i32* %type2, align 8, !tbaa !46
  %cmp3 = icmp ne i32 %3, %type
  %cmp4 = icmp ne i32 %type, 0
  %or.cond = and i1 %cmp3, %cmp4
  br i1 %or.cond, label %for.inc, label %if.end

if.end:                                           ; preds = %for.body
  %tobool5 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %2, i1 zeroext %tobool5)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %node7 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node7, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #3

; Function Attrs: nounwind uwtable
define void @rfkill_epo() #1 {
entry:
  %call = call i32 @atomic_read(%struct.atomic_t* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  store i8 1, i8* @rfkill_epo_lock_active, align 1, !tbaa !40
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %next.sink = phi %struct.list_head** [ %next, %for.body ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !45
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr4 = getelementptr inbounds i8, i8* %1, i64 -568
  %2 = bitcast i8* %add.ptr4 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  call void @rfkill_set_block(%struct.rfkill* %2, i1 zeroext true)
  %node2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %2, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node2, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %for.cond5

for.cond5:                                        ; preds = %for.body7, %for.end
  %i.0 = phi i32 [ 0, %for.end ], [ %inc, %for.body7 ]
  %cmp6 = icmp slt i32 %i.0, 9
  br i1 %cmp6, label %for.body7, label %for.end15

for.body7:                                        ; preds = %for.cond5
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %cur, align 2, !tbaa !43, !range !41
  %tobool8 = trunc i8 %3 to i1
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom9
  %sav = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx10, i32 0, i32 1
  %frombool = zext i1 %tobool8 to i8
  store i8 %frombool, i8* %sav, align 1, !tbaa !47
  %idxprom11 = sext i32 %i.0 to i64
  %arrayidx12 = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom11
  %cur13 = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx12, i32 0, i32 0
  store i8 1, i8* %cur13, align 2, !tbaa !43
  %inc = add nsw i32 %i.0, 1
  br label %for.cond5

for.end15:                                        ; preds = %for.cond5
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end15, %entry
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #4

; Function Attrs: nounwind uwtable
define internal void @rfkill_set_block(%struct.rfkill* %rfkill, i1 zeroext %blocked) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy41 = alloca i64, align 8
  %__dummy242 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %power = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 9
  %power_state = getelementptr inbounds %struct.dev_pm_info, %struct.dev_pm_info* %power, i32 0, i32 0
  %event = getelementptr inbounds %struct.pm_message, %struct.pm_message* %power_state, i32 0, i32 0
  %0 = load i32, i32* %event, align 8, !tbaa !48
  %and = and i32 %0, 6
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %1 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !49
  %query = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %1, i32 0, i32 1
  %2 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %query, align 8, !tbaa !50
  %tobool3 = icmp ne void (%struct.rfkill*, i8*)* %2, null
  br i1 %tobool3, label %if.then4, label %do.body8

if.then4:                                         ; preds = %if.end
  %ops5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %3 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops5, align 8, !tbaa !49
  %query6 = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %3, i32 0, i32 1
  %4 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %query6, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %5 = load i8*, i8** %data, align 8, !tbaa !52
  call void %4(%struct.rfkill* %rfkill, i8* %5)
  br label %do.body8

do.body8:                                         ; preds = %if.then4, %if.end
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv9 = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #7
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call10 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %10 = load i64, i64* %state, align 8, !tbaa !53
  %and13 = and i64 %10, 2
  %tobool14 = icmp ne i64 %and13, 0
  %frombool15 = zext i1 %tobool14 to i8
  %state16 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %11 = load i64, i64* %state16, align 8, !tbaa !53
  %and17 = and i64 %11, 2
  %tobool18 = icmp ne i64 %and17, 0
  %state20 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %12 = load i64, i64* %state20, align 8, !tbaa !53
  %and22 = and i64 %12, -5
  %or = or i64 %12, 4
  %and22.sink = select i1 %tobool18, i64 %or, i64 %and22
  store i64 %and22.sink, i64* %state20, align 8, !tbaa !53
  %tobool24 = trunc i8 %frombool to i1
  %state26 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %13 = load i64, i64* %state26, align 8, !tbaa !53
  %and30 = and i64 %13, -3
  %or27 = or i64 %13, 2
  %and30.sink = select i1 %tobool24, i64 %or27, i64 %and30
  store i64 %and30.sink, i64* %state26, align 8, !tbaa !53
  %state32 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %14 = load i64, i64* %state32, align 8, !tbaa !53
  %or33 = or i64 %14, 2147483648
  store i64 %or33, i64* %state32, align 8, !tbaa !53
  %lock34 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock34, i64 %call10)
  %ops35 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %15 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops35, align 8, !tbaa !49
  %set_block = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %15, i32 0, i32 2
  %16 = load i32 (i8*, i1)*, i32 (i8*, i1)** %set_block, align 8, !tbaa !54
  %data36 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 8
  %17 = load i8*, i8** %data36, align 8, !tbaa !52
  %tobool37 = trunc i8 %frombool to i1
  %call38 = call i32 %16(i8* %17, i1 zeroext %tobool37)
  %18 = bitcast i64* %__dummy41 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %18) #7
  %19 = bitcast i64* %__dummy242 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %19) #7
  %cmp43 = icmp eq i64* %__dummy41, %__dummy242
  %conv44 = zext i1 %cmp43 to i32
  %20 = bitcast i64* %__dummy242 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %20) #7
  %21 = bitcast i64* %__dummy41 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %21) #7
  %lock46 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call47 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock46)
  %call48 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call47)
  %tobool53 = icmp ne i32 %call38, 0
  br i1 %tobool53, label %if.then54, label %if.end65

if.then54:                                        ; preds = %do.body8
  %state55 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %22 = load i64, i64* %state55, align 8, !tbaa !53
  %and56 = and i64 %22, 4
  %tobool57 = icmp ne i64 %and56, 0
  %state59 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %23 = load i64, i64* %state59, align 8, !tbaa !53
  %and63 = and i64 %23, -3
  %or60 = or i64 %23, 2
  %and63.sink = select i1 %tobool57, i64 %or60, i64 %and63
  store i64 %and63.sink, i64* %state59, align 8, !tbaa !53
  br label %if.end65

if.end65:                                         ; preds = %if.then54, %do.body8
  %state66 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %24 = load i64, i64* %state66, align 8, !tbaa !53
  %and67 = and i64 %24, -2147483649
  store i64 %and67, i64* %state66, align 8, !tbaa !53
  %state68 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %25 = load i64, i64* %state68, align 8, !tbaa !53
  %and69 = and i64 %25, -5
  store i64 %and69, i64* %state68, align 8, !tbaa !53
  %state70 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %26 = load i64, i64* %state70, align 8, !tbaa !53
  %and71 = and i64 %26, 2
  %tobool72 = icmp ne i64 %and71, 0
  %frombool73 = zext i1 %tobool72 to i8
  %lock74 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock74, i64 %call48)
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  %tobool75 = trunc i8 %frombool15 to i1
  %conv76 = zext i1 %tobool75 to i32
  %tobool77 = trunc i8 %frombool73 to i1
  %conv78 = zext i1 %tobool77 to i32
  %cmp79 = icmp ne i32 %conv76, %conv78
  br i1 %cmp79, label %if.then81, label %cleanup.cont

if.then81:                                        ; preds = %if.end65
  call void @rfkill_event(%struct.rfkill* %rfkill)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %entry, %if.then81, %if.end65
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_restore_states() #1 {
entry:
  %call = call i32 @atomic_read(%struct.atomic_t* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  store i8 0, i8* @rfkill_epo_lock_active, align 1, !tbaa !40
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.end
  %i.0 = phi i32 [ 0, %if.end ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom
  %sav = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx, i32 0, i32 1
  %0 = load i8, i8* %sav, align 1, !tbaa !47, !range !41
  %tobool1 = trunc i8 %0 to i1
  call void @__rfkill_switch_all(i32 %i.0, i1 zeroext %tobool1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_remove_epo_lock() #1 {
entry:
  %call = call i32 @atomic_read(%struct.atomic_t* @rfkill_input_disabled)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  store i8 0, i8* @rfkill_epo_lock_active, align 1, !tbaa !40
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_is_epo_lock_active() #1 {
entry:
  %0 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !40, !range !41
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_get_global_sw_state(i32 %type) #1 {
entry:
  %idxprom = zext i32 %type to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx, i32 0, i32 0
  %0 = load i8, i8* %cur, align 2, !tbaa !43, !range !41
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_set_hw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #1 {
entry:
  %change = alloca i8, align 1
  %frombool = zext i1 %blocked to i8
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %change) #7
  %tobool = trunc i8 %frombool to i1
  %call = call zeroext i1 @__rfkill_set_hw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool, i8* %change)
  %frombool1 = zext i1 %call to i8
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !55, !range !41
  %tobool2 = trunc i8 %0 to i1
  br i1 %tobool2, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %1 = load i8, i8* %change, align 1, !tbaa !40, !range !41
  %tobool4 = trunc i8 %1 to i1
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call6 = call zeroext i1 @schedule_work(%struct.work_struct* %uevent_work)
  br label %cleanup

cleanup:                                          ; preds = %entry, %if.end, %if.then5
  %tobool8 = trunc i8 %frombool1 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %change) #7
  ret i1 %tobool8
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @__rfkill_set_hw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked, i8* %change) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body11

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 244, i64 12) #7, !srcloc !56
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body11:                                        ; preds = %entry
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv12 = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call13 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %4, 1
  %tobool18 = icmp ne i64 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %frombool23 = zext i1 %lnot21 to i8
  %tobool24 = trunc i8 %frombool to i1
  %state26 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %5 = load i64, i64* %state26, align 8, !tbaa !53
  %and28 = and i64 %5, -2
  %or = or i64 %5, 1
  %and28.sink = select i1 %tobool24, i64 %or, i64 %and28
  store i64 %and28.sink, i64* %state26, align 8, !tbaa !53
  %tobool30 = trunc i8 %frombool23 to i1
  %conv31 = zext i1 %tobool30 to i32
  %tobool32 = trunc i8 %frombool to i1
  %conv33 = zext i1 %tobool32 to i32
  %cmp34 = icmp ne i32 %conv31, %conv33
  %frombool36 = zext i1 %cmp34 to i8
  store i8 %frombool36, i8* %change, align 1, !tbaa !40
  %state37 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %6 = load i64, i64* %state37, align 8, !tbaa !53
  %and38 = and i64 %6, 7
  %tobool39 = icmp ne i64 %and38, 0
  %lnot40 = xor i1 %tobool39, true
  %lnot42 = xor i1 %lnot40, true
  %frombool44 = zext i1 %lnot42 to i8
  %lock45 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock45, i64 %call13)
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  %tobool46 = trunc i8 %frombool44 to i1
  ret i1 %tobool46
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @schedule_work(%struct.work_struct* %work) #0 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !45
  %call = call zeroext i1 @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %work)
  ret i1 %call
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body11

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 510, i64 12) #7, !srcloc !57
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body11:                                        ; preds = %entry
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv12 = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call13 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %4, 2
  %tobool18 = icmp ne i64 %and, 0
  %lnot19 = xor i1 %tobool18, true
  %lnot21 = xor i1 %lnot19, true
  %frombool23 = zext i1 %lnot21 to i8
  %tobool24 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool24)
  %state25 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %5 = load i64, i64* %state25, align 8, !tbaa !53
  %and26 = and i64 %5, 1
  %tobool27 = icmp ne i64 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %frombool32 = zext i1 %lnot30 to i8
  %tobool33 = trunc i8 %frombool to i1
  %tobool35 = trunc i8 %frombool32 to i1
  %6 = select i1 %tobool33, i1 true, i1 %tobool35
  %frombool37 = zext i1 %6 to i8
  %lock38 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock38, i64 %call13)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %7 = load i8, i8* %registered, align 4, !tbaa !55, !range !41
  %tobool39 = trunc i8 %7 to i1
  br i1 %tobool39, label %if.end42, label %cleanup

if.end42:                                         ; preds = %do.body11
  %tobool43 = trunc i8 %frombool23 to i1
  %conv44 = zext i1 %tobool43 to i32
  %tobool45 = trunc i8 %frombool37 to i1
  %conv46 = zext i1 %tobool45 to i32
  %cmp47 = icmp ne i32 %conv44, %conv46
  br i1 %cmp47, label %land.lhs.true, label %if.end52

land.lhs.true:                                    ; preds = %if.end42
  %tobool49 = trunc i8 %frombool32 to i1
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %land.lhs.true
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call51 = call zeroext i1 @schedule_work(%struct.work_struct* %uevent_work)
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %land.lhs.true, %if.end42
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  br label %cleanup

cleanup:                                          ; preds = %do.body11, %if.end52
  %tobool53 = trunc i8 %frombool37 to i1
  ret i1 %tobool53
}

declare i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock*) #3 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

; Function Attrs: nounwind uwtable
define internal void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #1 {
entry:
  %frombool = zext i1 %blocked to i8
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %0 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %0, 2147483648
  %tobool = icmp ne i64 %and, 0
  %. = select i1 %tobool, i32 4, i32 2
  %tobool1 = trunc i8 %frombool to i1
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %entry
  %conv = zext i32 %. to i64
  %state3 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %1 = load i64, i64* %state3, align 8, !tbaa !53
  %or = or i64 %1, %conv
  store i64 %or, i64* %state3, align 8, !tbaa !53
  br label %if.end7

if.else:                                          ; preds = %entry
  %neg = xor i32 %., -1
  %conv4 = zext i32 %neg to i64
  %state5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %2 = load i64, i64* %state5, align 8, !tbaa !53
  %and6 = and i64 %2, %conv4
  store i64 %and6, i64* %state5, align 8, !tbaa !53
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then2
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_irqrestore(%struct.spinlock* %lock, i64 %flags) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %4 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock* %rlock, i64 %flags)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_event(%struct.rfkill* %rfkill) #1 {
entry:
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !55, !range !41
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %1 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %1, 7
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  call void @led_trigger_event(%struct.led_trigger* %led_trigger, i32 0)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end
  call void @led_trigger_event(%struct.led_trigger* %led_trigger, i32 255)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %entry, %if.else, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_init_sw_state(%struct.rfkill* %rfkill, i1 zeroext %blocked) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %blocked to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.body10

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 535, i64 12) #7, !srcloc !58
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.body10:                                        ; preds = %entry
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !55, !range !41
  %tobool11 = trunc i8 %0 to i1
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %do.body20, label %do.body30

do.body20:                                        ; preds = %do.body10
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 536, i64 12) #7, !srcloc !59
  br label %do.body21

do.body21:                                        ; preds = %do.body21, %do.body20
  br label %do.body21

do.body30:                                        ; preds = %do.body10
  %1 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv31 = zext i1 %cmp to i32
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call32 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %tobool37 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool37)
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  store i8 1, i8* %persistent, align 1, !tbaa !60
  %lock38 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock38, i64 %call32)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_set_states(%struct.rfkill* %rfkill, i1 zeroext %sw, i1 zeroext %hw) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %frombool = zext i1 %sw to i8
  %frombool1 = zext i1 %hw to i8
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.body12

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 550, i64 12) #7, !srcloc !61
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.body12:                                        ; preds = %entry
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv13 = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call14 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %4, 2
  %tobool19 = icmp ne i64 %and, 0
  %lnot20 = xor i1 %tobool19, true
  %lnot22 = xor i1 %lnot20, true
  %frombool24 = zext i1 %lnot22 to i8
  %state25 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %5 = load i64, i64* %state25, align 8, !tbaa !53
  %and26 = and i64 %5, 1
  %tobool27 = icmp ne i64 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %frombool32 = zext i1 %lnot30 to i8
  %tobool33 = trunc i8 %frombool to i1
  call void @__rfkill_set_sw_state(%struct.rfkill* %rfkill, i1 zeroext %tobool33)
  %tobool34 = trunc i8 %frombool1 to i1
  %state36 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %6 = load i64, i64* %state36, align 8, !tbaa !53
  %and38 = and i64 %6, -2
  %or = or i64 %6, 1
  %and38.sink = select i1 %tobool34, i64 %or, i64 %and38
  store i64 %and38.sink, i64* %state36, align 8, !tbaa !53
  %lock40 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock40, i64 %call14)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %7 = load i8, i8* %registered, align 4, !tbaa !55, !range !41
  %tobool41 = trunc i8 %7 to i1
  br i1 %tobool41, label %if.else43, label %if.then42

if.then42:                                        ; preds = %do.body12
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  store i8 1, i8* %persistent, align 1, !tbaa !60
  br label %if.end59

if.else43:                                        ; preds = %do.body12
  %tobool44 = trunc i8 %frombool24 to i1
  %conv45 = zext i1 %tobool44 to i32
  %tobool46 = trunc i8 %frombool to i1
  %conv47 = zext i1 %tobool46 to i32
  %cmp48 = icmp ne i32 %conv45, %conv47
  br i1 %cmp48, label %if.then56, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else43
  %tobool50 = trunc i8 %frombool32 to i1
  %conv51 = zext i1 %tobool50 to i32
  %tobool52 = trunc i8 %frombool1 to i1
  %conv53 = zext i1 %tobool52 to i32
  %cmp54 = icmp ne i32 %conv51, %conv53
  br i1 %cmp54, label %if.then56, label %if.end58

if.then56:                                        ; preds = %lor.lhs.false, %if.else43
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call57 = call zeroext i1 @schedule_work(%struct.work_struct* %uevent_work)
  br label %if.end58

if.end58:                                         ; preds = %if.then56, %lor.lhs.false
  call void @rfkill_led_trigger_event(%struct.rfkill* %rfkill)
  br label %if.end59

if.end59:                                         ; preds = %if.end58, %if.then42
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_pause_polling(%struct.rfkill* %rfkill) #1 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 786, i64 12) #7, !srcloc !62
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !49
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !63
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.end12, label %return

if.end12:                                         ; preds = %do.end9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %poll_work)
  br label %return

return:                                           ; preds = %do.end9, %if.end12
  ret void
}

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #3

; Function Attrs: nounwind uwtable
define void @rfkill_resume_polling(%struct.rfkill* %rfkill) #1 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 797, i64 12) #7, !srcloc !64
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !49
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !63
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.end12, label %return

if.end12:                                         ; preds = %do.end9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work, i32 0, i32 0
  %call = call zeroext i1 @schedule_work(%struct.work_struct* %work)
  br label %return

return:                                           ; preds = %do.end9, %if.end12
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @rfkill_blocked(%struct.rfkill* %rfkill) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %1 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %2 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call2 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state5 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %4 = load i64, i64* %state5, align 8, !tbaa !53
  %conv6 = trunc i64 %4 to i32
  %lock7 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock7, i64 %call2)
  %conv8 = zext i32 %conv6 to i64
  %and = and i64 %conv8, 7
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  ret i1 %lnot9
}

; Function Attrs: nounwind uwtable
define %struct.rfkill* @rfkill_alloc(i8* %name, %struct.device* %parent, i32 %type, %struct.rfkill_ops* %ops, i8* %ops_data) #1 {
entry:
  %.compoundliteral = alloca %struct.raw_spinlock, align 2
  %tobool = icmp ne %struct.rfkill_ops* %ops, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool3 = icmp ne i32 %lnot.ext, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 862)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %tobool9 = icmp ne i32 %lnot.ext, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %cleanup, label %if.end18

if.end18:                                         ; preds = %if.end
  %set_block = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %ops, i32 0, i32 2
  %0 = load i32 (i8*, i1)*, i32 (i8*, i1)** %set_block, align 8, !tbaa !54
  %tobool20 = icmp ne i32 (i8*, i1)* %0, null
  %lnot21 = xor i1 %tobool20, true
  %lnot23 = xor i1 %lnot21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %tobool27 = icmp ne i32 %lnot.ext26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.end18
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 865)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %if.end18
  %tobool38 = icmp ne i32 %lnot.ext26, 0
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %cleanup, label %if.end47

if.end47:                                         ; preds = %if.end36
  %tobool49 = icmp ne i8* %name, null
  %lnot50 = xor i1 %tobool49, true
  %lnot52 = xor i1 %lnot50, true
  %lnot54 = xor i1 %lnot52, true
  %lnot.ext55 = zext i1 %lnot54 to i32
  %tobool56 = icmp ne i32 %lnot.ext55, 0
  %lnot57 = xor i1 %tobool56, true
  %lnot59 = xor i1 %lnot57, true
  %lnot.ext60 = zext i1 %lnot59 to i32
  %conv61 = sext i32 %lnot.ext60 to i64
  %expval62 = call i64 @llvm.expect.i64(i64 %conv61, i64 0)
  %tobool63 = icmp ne i64 %expval62, 0
  br i1 %tobool63, label %if.then64, label %if.end65

if.then64:                                        ; preds = %if.end47
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 868)
  br label %if.end65

if.end65:                                         ; preds = %if.then64, %if.end47
  %tobool67 = icmp ne i32 %lnot.ext55, 0
  %lnot68 = xor i1 %tobool67, true
  %lnot70 = xor i1 %lnot68, true
  %lnot.ext71 = zext i1 %lnot70 to i32
  %conv72 = sext i32 %lnot.ext71 to i64
  %expval73 = call i64 @llvm.expect.i64(i64 %conv72, i64 0)
  %tobool74 = icmp ne i64 %expval73, 0
  br i1 %tobool74, label %cleanup, label %if.end76

if.end76:                                         ; preds = %if.end65
  %cmp = icmp eq i32 %type, 0
  %cmp79 = icmp uge i32 %type, 9
  %.cmp79 = select i1 %cmp, i1 true, i1 %cmp79
  %lnot81 = xor i1 %.cmp79, true
  %lnot83 = xor i1 %lnot81, true
  %lnot.ext84 = zext i1 %lnot83 to i32
  %tobool85 = icmp ne i32 %lnot.ext84, 0
  %lnot86 = xor i1 %tobool85, true
  %lnot88 = xor i1 %lnot86, true
  %lnot.ext89 = zext i1 %lnot88 to i32
  %conv90 = sext i32 %lnot.ext89 to i64
  %expval91 = call i64 @llvm.expect.i64(i64 %conv90, i64 0)
  %tobool92 = icmp ne i64 %expval91, 0
  br i1 %tobool92, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end76
  call void @warn_slowpath_null(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 871)
  br label %if.end94

if.end94:                                         ; preds = %if.then93, %if.end76
  %tobool96 = icmp ne i32 %lnot.ext84, 0
  %lnot97 = xor i1 %tobool96, true
  %lnot99 = xor i1 %lnot97, true
  %lnot.ext100 = zext i1 %lnot99 to i32
  %conv101 = sext i32 %lnot.ext100 to i64
  %expval102 = call i64 @llvm.expect.i64(i64 %conv101, i64 0)
  %tobool103 = icmp ne i64 %expval102, 0
  br i1 %tobool103, label %cleanup, label %if.end105

if.end105:                                        ; preds = %if.end94
  %call = call i8* @kzalloc(i64 776, i32 208)
  %1 = bitcast i8* %call to %struct.rfkill*
  %tobool106 = icmp ne %struct.rfkill* %1, null
  br i1 %tobool106, label %do.body, label %cleanup

do.body:                                          ; preds = %if.end105
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %call109 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %lock111 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %2 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock111, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %2 to %struct.raw_spinlock*
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %.compoundliteral, i32 0, i32 0
  %3 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %raw_lock, i32 0, i32 0
  %head_tail = bitcast %union.anon.1* %3 to i16*
  store i16 0, i16* %head_tail, align 2, !tbaa !65
  %4 = bitcast %struct.raw_spinlock* %rlock to i8*
  %5 = bitcast %struct.raw_spinlock* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 2, i32 2, i1 false), !tbaa.struct !66
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 12
  call void @INIT_LIST_HEAD(%struct.list_head* %node)
  %type114 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  store i32 %type, i32* %type114, align 8, !tbaa !46
  %name115 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  store i8* %name, i8** %name115, align 8, !tbaa !69
  %ops116 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 7
  store %struct.rfkill_ops* %ops, %struct.rfkill_ops** %ops116, align 8, !tbaa !49
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 8
  store i8* %ops_data, i8** %data, align 8, !tbaa !52
  %dev117 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 11
  %class = getelementptr inbounds %struct.device, %struct.device* %dev117, i32 0, i32 25
  store %struct.class* @rfkill_class, %struct.class** %class, align 8, !tbaa !70
  %parent118 = getelementptr inbounds %struct.device, %struct.device* %dev117, i32 0, i32 0
  store %struct.device* %parent, %struct.device** %parent118, align 8, !tbaa !71
  call void @device_initialize(%struct.device* %dev117)
  br label %cleanup

cleanup:                                          ; preds = %if.end105, %if.end94, %if.end65, %if.end36, %if.end, %do.body
  %retval.0 = phi %struct.rfkill* [ %1, %do.body ], [ null, %if.end ], [ null, %if.end36 ], [ null, %if.end65 ], [ null, %if.end94 ], [ null, %if.end105 ]
  ret %struct.rfkill* %retval.0
}

declare void @warn_slowpath_null(i8*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kzalloc(i64 %size, i32 %flags) #0 {
entry:
  %or = or i32 %flags, 32768
  %call = call i8* @kmalloc(i64 %size, i32 %or)
  ret i8* %call
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #4

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !72
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !73
  ret void
}

declare void @device_initialize(%struct.device*) #3

; Function Attrs: nounwind uwtable
define i32 @rfkill_register(%struct.rfkill* %rfkill) #1 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %.compoundliteral57 = alloca %struct.atomic64_t, align 8
  %.compoundliteral74 = alloca %struct.atomic64_t, align 8
  %dev1 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %do.body5, label %do.end10

do.body5:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 941, i64 12) #7, !srcloc !74
  br label %do.body6

do.body6:                                         ; preds = %do.body6, %do.body5
  br label %do.body6

do.end10:                                         ; preds = %entry
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !55, !range !41
  %tobool11 = trunc i8 %0 to i1
  br i1 %tobool11, label %unlock, label %if.end13

if.end13:                                         ; preds = %do.end10
  %1 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !75
  %conv14 = trunc i64 %1 to i32
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  store i32 %conv14, i32* %idx, align 8, !tbaa !76
  %2 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !75
  %call = call i32 (%struct.device*, i8*, ...) @dev_set_name(%struct.device* %dev1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.1, i32 0, i32 0), i64 %2)
  %3 = load i64, i64* @rfkill_register.rfkill_no, align 8, !tbaa !75
  %inc = add i64 %3, 1
  store i64 %inc, i64* @rfkill_register.rfkill_no, align 8, !tbaa !75
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @list_add_tail(%struct.list_head* %node, %struct.list_head* @rfkill_list)
  %call15 = call i32 @device_add(%struct.device* %dev1)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %remove, label %if.end18

if.end18:                                         ; preds = %if.end13
  %call19 = call i32 @rfkill_led_trigger_register(%struct.rfkill* %rfkill)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %devdel, label %if.end22

if.end22:                                         ; preds = %if.end18
  %registered23 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  store i8 1, i8* %registered23, align 4, !tbaa !55
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %poll_work27 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work28 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work27, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work28, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !77
  %4 = bitcast %struct.atomic64_t* %data to i8*
  %5 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* %5, i64 8, i32 8, i1 false), !tbaa.struct !78
  %poll_work29 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work30 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work29, i32 0, i32 0
  %entry31 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work30, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry31)
  %poll_work33 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %work34 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work33, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work34, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_poll, void (%struct.work_struct*)** %func, align 8, !tbaa !79
  %poll_work42 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work42, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* null, %struct.lock_class_key* null)
  %poll_work43 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %timer44 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work43, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer44, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !80
  %poll_work45 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %6 = ptrtoint %struct.delayed_work* %poll_work45 to i64
  %poll_work46 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %timer47 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %poll_work46, i32 0, i32 1
  %data48 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer47, i32 0, i32 4
  store i64 %6, i64* %data48, align 8, !tbaa !81
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  call void @__init_work(%struct.work_struct* %uevent_work, i32 0)
  %uevent_work55 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %data56 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work55, i32 0, i32 0
  %counter58 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral57, i32 0, i32 0
  store i64 68719476704, i64* %counter58, align 8, !tbaa !77
  %7 = bitcast %struct.atomic64_t* %data56 to i8*
  %8 = bitcast %struct.atomic64_t* %.compoundliteral57 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false), !tbaa.struct !78
  %uevent_work59 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %entry60 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work59, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry60)
  %uevent_work62 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %func63 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %uevent_work62, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_uevent_work, void (%struct.work_struct*)** %func63, align 8, !tbaa !79
  %sync_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  call void @__init_work(%struct.work_struct* %sync_work, i32 0)
  %sync_work72 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %data73 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work72, i32 0, i32 0
  %counter75 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral74, i32 0, i32 0
  store i64 68719476704, i64* %counter75, align 8, !tbaa !77
  %9 = bitcast %struct.atomic64_t* %data73 to i8*
  %10 = bitcast %struct.atomic64_t* %.compoundliteral74 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false), !tbaa.struct !78
  %sync_work76 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %entry77 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work76, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry77)
  %sync_work79 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %func80 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %sync_work79, i32 0, i32 2
  store void (%struct.work_struct*)* @rfkill_sync_work, void (%struct.work_struct*)** %func80, align 8, !tbaa !79
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %11 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !49
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %11, i32 0, i32 0
  %12 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !63
  %tobool87 = icmp ne void (%struct.rfkill*, i8*)* %12, null
  br i1 %tobool87, label %if.then88, label %if.end92

if.then88:                                        ; preds = %if.end22
  %poll_work89 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %call90 = call i64 @round_jiffies_relative(i64 5000)
  %call91 = call zeroext i1 @schedule_delayed_work(%struct.delayed_work* %poll_work89, i64 %call90)
  br label %if.end92

if.end92:                                         ; preds = %if.then88, %if.end22
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 6
  %13 = load i8, i8* %persistent, align 1, !tbaa !60, !range !41
  %tobool93 = trunc i8 %13 to i1
  br i1 %tobool93, label %lor.lhs.false, label %if.then96

lor.lhs.false:                                    ; preds = %if.end92
  %14 = load i8, i8* @rfkill_epo_lock_active, align 1, !tbaa !40, !range !41
  %tobool94 = trunc i8 %14 to i1
  br i1 %tobool94, label %if.then96, label %if.else

if.then96:                                        ; preds = %lor.lhs.false, %if.end92
  %sync_work97 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %call98 = call zeroext i1 @schedule_work(%struct.work_struct* %sync_work97)
  br label %if.end109

if.else:                                          ; preds = %lor.lhs.false
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %15 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %15, 2
  %tobool99 = icmp ne i64 %and, 0
  %lnot100 = xor i1 %tobool99, true
  %lnot102 = xor i1 %lnot100, true
  %frombool = zext i1 %lnot102 to i8
  %call104 = call i32 @atomic_read(%struct.atomic_t* @rfkill_input_disabled)
  %tobool105 = icmp ne i32 %call104, 0
  br i1 %tobool105, label %if.end109, label %if.then106

if.then106:                                       ; preds = %if.else
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %16 = load i32, i32* %type, align 8, !tbaa !46
  %tobool107 = trunc i8 %frombool to i1
  call void @__rfkill_switch_all(i32 %16, i1 zeroext %tobool107)
  br label %if.end109

if.end109:                                        ; preds = %if.else, %if.then106, %if.then96
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 0)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

devdel:                                           ; preds = %if.end18
  %dev110 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  call void @device_del(%struct.device* %dev110)
  br label %remove

remove:                                           ; preds = %if.end13, %devdel
  %error.0 = phi i32 [ %call19, %devdel ], [ %call15, %if.end13 ]
  %node111 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @list_del_init(%struct.list_head* %node111)
  br label %unlock

unlock:                                           ; preds = %do.end10, %remove
  %error.1 = phi i32 [ %error.0, %remove ], [ -114, %do.end10 ]
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %unlock, %if.end109
  %retval.0 = phi i32 [ %error.1, %unlock ], [ 0, %if.end109 ]
  ret i32 %retval.0
}

declare i32 @dev_set_name(%struct.device*, i8*, ...) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add_tail(%struct.list_head* %new, %struct.list_head* %head) #0 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !73
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %0, %struct.list_head* %head)
  ret void
}

declare i32 @device_add(%struct.device*) #3

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_led_trigger_register(%struct.rfkill* %rfkill) #1 {
entry:
  %ledtrigname = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 10
  %0 = load i8*, i8** %ledtrigname, align 8, !tbaa !39
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %call = call i8* @dev_name(%struct.device* %dev)
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi i8* [ %call, %cond.false ], [ %0, %entry ]
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %name = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger, i32 0, i32 0
  store i8* %cond, i8** %name, align 8, !tbaa !12
  %led_trigger1 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %activate = getelementptr inbounds %struct.led_trigger, %struct.led_trigger* %led_trigger1, i32 0, i32 1
  store void (%struct.led_classdev*)* @rfkill_led_trigger_activate, void (%struct.led_classdev*)** %activate, align 8, !tbaa !82
  %led_trigger2 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  %call3 = call i32 @led_trigger_register(%struct.led_trigger* %led_trigger2)
  ret i32 %call3
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__init_work(%struct.work_struct* %work, i32 %onstack) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_poll(%struct.work_struct* %work) #1 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -584
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 7
  %2 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !49
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %2, i32 0, i32 0
  %3 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !63
  %data = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 8
  %4 = load i8*, i8** %data, align 8, !tbaa !52
  call void %3(%struct.rfkill* %1, i8* %4)
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 13
  %call = call i64 @round_jiffies_relative(i64 5000)
  %call1 = call zeroext i1 @schedule_delayed_work(%struct.delayed_work* %poll_work, i64 %call)
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #3

declare void @delayed_work_timer_fn(i64) #3

; Function Attrs: nounwind uwtable
define internal void @rfkill_uevent_work(%struct.work_struct* %work) #1 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -712
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  call void @rfkill_event(%struct.rfkill* %1)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_sync_work(%struct.work_struct* %work) #1 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -744
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !46
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur1 = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx, i32 0, i32 0
  %3 = load i8, i8* %cur1, align 2, !tbaa !43, !range !41
  %tobool = trunc i8 %3 to i1
  %frombool = zext i1 %tobool to i8
  %tobool2 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool2)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @schedule_delayed_work(%struct.delayed_work* %dwork, i64 %delay) #0 {
entry:
  %0 = load %struct.workqueue_struct*, %struct.workqueue_struct** @system_wq, align 8, !tbaa !45
  %call = call zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %0, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

declare i64 @round_jiffies_relative(i64) #3

; Function Attrs: nounwind uwtable
define internal void @rfkill_send_events(%struct.rfkill* %rfkill, i32 %op) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %next.sink = phi %struct.list_head** [ %next, %for.inc ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_fds, i32 0, i32 0), %entry ]
  %0 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !45
  %1 = bitcast %struct.list_head* %0 to i8*
  %add.ptr7 = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr7 to %struct.rfkill_data*
  %list = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 0
  %cmp = icmp ne %struct.list_head* %list, @rfkill_fds
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i8* @kzalloc(i64 24, i32 208)
  %3 = bitcast i8* %call to %struct.rfkill_int_event*
  %tobool = icmp ne %struct.rfkill_int_event* %3, null
  br i1 %tobool, label %if.end, label %for.inc

if.end:                                           ; preds = %for.body
  %ev1 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %3, i32 0, i32 1
  call void @rfkill_fill_event(%struct.rfkill_event* %ev1, %struct.rfkill* %rfkill, i32 %op)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 2
  call void @mutex_lock(%struct.mutex* %mtx)
  %list2 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %3, i32 0, i32 0
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %list2, %struct.list_head* %events)
  %mtx3 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx3)
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 3
  call void @__wake_up(%struct.__wait_queue_head* %read_wait, i32 1, i32 1, i8* null)
  br label %for.inc

for.inc:                                          ; preds = %for.body, %if.end
  %list5 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %2, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list5, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @device_del(%struct.device*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del_init(%struct.list_head* %entry1) #0 {
entry:
  call void @__list_del_entry(%struct.list_head* %entry1)
  call void @INIT_LIST_HEAD(%struct.list_head* %entry1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_unregister(%struct.rfkill* %rfkill) #1 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %do.body4, label %do.end9

do.body4:                                         ; preds = %entry
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 1002, i64 12) #7, !srcloc !83
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %do.body4
  br label %do.body5

do.end9:                                          ; preds = %entry
  %ops = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 7
  %0 = load %struct.rfkill_ops*, %struct.rfkill_ops** %ops, align 8, !tbaa !49
  %poll = getelementptr inbounds %struct.rfkill_ops, %struct.rfkill_ops* %0, i32 0, i32 0
  %1 = load void (%struct.rfkill*, i8*)*, void (%struct.rfkill*, i8*)** %poll, align 8, !tbaa !63
  %tobool10 = icmp ne void (%struct.rfkill*, i8*)* %1, null
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.end9
  %poll_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 13
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %poll_work)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %do.end9
  %uevent_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 14
  %call13 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %uevent_work)
  %sync_work = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 15
  %call14 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %sync_work)
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  store i8 0, i8* %registered, align 4, !tbaa !55
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  call void @device_del(%struct.device* %dev)
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 1)
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 12
  call void @list_del_init(%struct.list_head* %node)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  call void @rfkill_led_trigger_unregister(%struct.rfkill* %rfkill)
  ret void
}

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) #3

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_unregister(%struct.rfkill* %rfkill) #1 {
entry:
  %led_trigger = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 9
  call void @led_trigger_unregister(%struct.led_trigger* %led_trigger)
  ret void
}

; Function Attrs: nounwind uwtable
define void @rfkill_destroy(%struct.rfkill* %rfkill) #1 {
entry:
  %tobool = icmp ne %struct.rfkill* %rfkill, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  call void @put_device(%struct.device* %dev)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @put_device(%struct.device*) #3

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_init() #1 section ".init.text" {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %cmp = icmp slt i32 %i.0, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %0 = load i32, i32* @rfkill_default_state, align 4, !tbaa !42
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx, i32 0, i32 0
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %cur, align 2, !tbaa !43
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call = call i32 @__class_register(%struct.class* @rfkill_class, %struct.lock_class_key* @rfkill_init.__key)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %out, label %if.end

if.end:                                           ; preds = %for.end
  %call2 = call i32 @misc_register(%struct.miscdevice* @rfkill_miscdev)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @class_unregister(%struct.class* @rfkill_class)
  br label %out

if.end5:                                          ; preds = %if.end
  %call6 = call i32 @rfkill_handler_init()
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %out

if.then8:                                         ; preds = %if.end5
  %call9 = call i32 @misc_deregister(%struct.miscdevice* @rfkill_miscdev)
  call void @class_unregister(%struct.class* @rfkill_class)
  br label %out

out:                                              ; preds = %if.end5, %for.end, %if.then8, %if.then4
  %error.0 = phi i32 [ %call2, %if.then4 ], [ %call6, %if.then8 ], [ %call, %for.end ], [ %call6, %if.end5 ]
  ret i32 %error.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_exit() #1 section ".exit.text" {
entry:
  call void @rfkill_handler_exit()
  %call = call i32 @misc_deregister(%struct.miscdevice* @rfkill_miscdev)
  call void @class_unregister(%struct.class* @rfkill_class)
  ret void
}

declare void @rfkill_handler_exit() #3

declare i32 @misc_deregister(%struct.miscdevice*) #3

declare void @class_unregister(%struct.class*) #3

; Function Attrs: nounwind uwtable
define internal void @rfkill_event(%struct.rfkill* %rfkill) #1 {
entry:
  %registered = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 5
  %0 = load i8, i8* %registered, align 4, !tbaa !55, !range !41
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %dev = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 11
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i32 @kobject_uevent(%struct.kobject* %kobj, i32 2)
  call void @rfkill_send_events(%struct.rfkill* %rfkill, i32 2)
  br label %return

return:                                           ; preds = %entry, %if.end
  ret void
}

declare i32 @kobject_uevent(%struct.kobject*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #0 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 64, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret i1 %call
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #3

declare void @_raw_spin_unlock_irqrestore(%struct.raw_spinlock*, i64) #3 section ".spinlock.text"

declare void @led_trigger_event(%struct.led_trigger*, i32) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @kmalloc(i64 %size, i32 %flags) #5 {
entry:
  %call = call i8* @__kmalloc(i64 %size, i32 %flags)
  ret i8* %call
}

declare i8* @__kmalloc(i64, i32) #3

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_dev_uevent(%struct.device* %dev, %struct.kobj_uevent_env* %env) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %name = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  %2 = load i8*, i8** %name, align 8, !tbaa !69
  %call = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.21, i32 0, i32 0), i8* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %3 = load i32, i32* %type, align 8, !tbaa !46
  %call1 = call i8* @rfkill_get_type_str(i32 %3)
  %call2 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.22, i32 0, i32 0), i8* %call1)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %cleanup, label %do.body6

do.body6:                                         ; preds = %if.end
  %4 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %6 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %7 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  %call8 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call9 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call8)
  %state12 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %8 = load i64, i64* %state12, align 8, !tbaa !53
  %conv13 = trunc i64 %8 to i32
  %lock14 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock14, i64 %call9)
  %conv15 = zext i32 %conv13 to i64
  %call16 = call zeroext i8 @user_state_from_blocked(i64 %conv15)
  %conv17 = zext i8 %call16 to i32
  %call18 = call i32 (%struct.kobj_uevent_env*, i8*, ...) @add_uevent_var(%struct.kobj_uevent_env* %env, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.23, i32 0, i32 0), i32 %conv17)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %do.body6
  %retval.0 = phi i32 [ %call18, %do.body6 ], [ %call, %entry ], [ %call2, %if.end ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_release(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %2 = bitcast %struct.rfkill* %1 to i8*
  call void @kfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_suspend(%struct.device* %dev, i32 %state.coerce) #1 {
entry:
  %state = alloca %struct.pm_message, align 4
  %coerce.dive = getelementptr inbounds %struct.pm_message, %struct.pm_message* %state, i32 0, i32 0
  store i32 %state.coerce, i32* %coerce.dive, align 4
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @rfkill_pause_polling(%struct.rfkill* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_resume(%struct.device* %dev) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 6
  %2 = load i8, i8* %persistent, align 1, !tbaa !60, !range !41
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %3 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %3, 2
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %frombool = zext i1 %lnot2 to i8
  %tobool3 = trunc i8 %frombool to i1
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @rfkill_resume_polling(%struct.rfkill* %1)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_name_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %name = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 1
  %2 = load i8*, i8** %name, align 8, !tbaa !69
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i8* %2)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_type_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 2
  %2 = load i32, i32* %type, align 8, !tbaa !46
  %call = call i8* @rfkill_get_type_str(i32 %2)
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.11, i32 0, i32 0), i8* %call)
  %conv = sext i32 %call1 to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_idx_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 4
  %2 = load i32, i32* %idx, align 8, !tbaa !76
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0), i32 %2)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_persistent_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %persistent = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 6
  %2 = load i8, i8* %persistent, align 1, !tbaa !60, !range !41
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0), i32 %conv)
  %conv1 = sext i32 %call to i64
  ret i64 %conv1
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_state_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %2 = load i64, i64* %state, align 8, !tbaa !53
  %call = call zeroext i8 @user_state_from_blocked(i64 %2)
  %conv = zext i8 %call to i32
  %call1 = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0), i32 %conv)
  %conv2 = sext i32 %call1 to i64
  ret i64 %conv2
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_state_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %state = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %2 = bitcast i64* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %call = call zeroext i1 @capable(i32 12)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @kstrtoul(i8* %buf, i32 0, i64* %state)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %state, align 8, !tbaa !75
  %cmp = icmp ne i64 %3, 0
  %4 = load i64, i64* %state, align 8
  %cmp5 = icmp ne i64 %4, 1
  %or.cond = and i1 %cmp, %cmp5
  br i1 %or.cond, label %cleanup, label %if.end8

if.end8:                                          ; preds = %if.end3
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %5 = load i64, i64* %state, align 8, !tbaa !75
  %cmp9 = icmp eq i64 %5, 0
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %cmp9)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %entry, %if.end8, %if.then2
  %retval.0 = phi i64 [ %conv, %if.then2 ], [ %count, %if.end8 ], [ -1, %entry ], [ -22, %if.end3 ]
  %6 = bitcast i64* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_claim_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0), i32 0)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_claim_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  ret i64 -95
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_soft_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %2 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %2, 2
  %tobool = icmp ne i64 %and, 0
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0), i32 %cond)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_soft_store(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf, i64 %count) #1 {
entry:
  %state = alloca i64, align 8
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %2 = bitcast i64* %state to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %call = call zeroext i1 @capable(i32 12)
  br i1 %call, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @kstrtoul(i8* %buf, i32 0, i64* %state)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %conv = sext i32 %call1 to i64
  br label %cleanup

if.end3:                                          ; preds = %if.end
  %3 = load i64, i64* %state, align 8, !tbaa !75
  %cmp = icmp ugt i64 %3, 1
  br i1 %cmp, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end3
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %4 = load i64, i64* %state, align 8, !tbaa !75
  %tobool7 = icmp ne i64 %4, 0
  call void @rfkill_set_block(%struct.rfkill* %1, i1 zeroext %tobool7)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %entry, %if.end6, %if.then2
  %retval.0 = phi i64 [ %conv, %if.then2 ], [ %count, %if.end6 ], [ -1, %entry ], [ -22, %if.end3 ]
  %5 = bitcast i64* %state to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_hard_show(%struct.device* %dev, %struct.device_attribute* %attr, i8* %buf) #1 {
entry:
  %0 = bitcast %struct.device* %dev to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -128
  %1 = bitcast i8* %add.ptr to %struct.rfkill*
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %1, i32 0, i32 3
  %2 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %2, 1
  %tobool = icmp ne i64 %and, 0
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 1, i32 0
  %call = call i32 (i8*, i8*, ...) @sprintf(i8* %buf, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0), i32 %cond)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

declare i32 @sprintf(i8*, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal i8* @rfkill_get_type_str(i32 %type) #1 {
entry:
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body1

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_590()
  br label %do.body1

do.body1:                                         ; preds = %entry, %if.then
  %tobool2 = trunc i8 0 to i1
  %conv = zext i1 %tobool2 to i32
  %mul = mul nsw i32 2, %conv
  %sub = sub nsw i32 1, %mul
  %0 = zext i32 %sub to i64
  br label %NodeBlock13

NodeBlock13:                                      ; preds = %do.body1
  %Pivot14 = icmp slt i32 %type, 5
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %type, 7
  br i1 %Pivot12, label %NodeBlock5, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %type, 8
  br i1 %Pivot10, label %sw.bb10, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %type, 8
  br i1 %SwitchLeaf8, label %sw.bb11, label %NewDefault

NodeBlock5:                                       ; preds = %NodeBlock11
  %Pivot6 = icmp slt i32 %type, 6
  br i1 %Pivot6, label %sw.bb8, label %sw.bb9

NodeBlock3:                                       ; preds = %NodeBlock13
  %Pivot4 = icmp slt i32 %type, 3
  br i1 %Pivot4, label %NodeBlock, label %NodeBlock1

NodeBlock1:                                       ; preds = %NodeBlock3
  %Pivot2 = icmp slt i32 %type, 4
  br i1 %Pivot2, label %sw.bb6, label %sw.bb7

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %type, 2
  br i1 %Pivot, label %LeafBlock, label %sw.bb5

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %type, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb5:                                           ; preds = %NodeBlock
  br label %sw.epilog

sw.bb6:                                           ; preds = %NodeBlock1
  br label %sw.epilog

sw.bb7:                                           ; preds = %NodeBlock1
  br label %sw.epilog

sw.bb8:                                           ; preds = %NodeBlock5
  br label %sw.epilog

sw.bb9:                                           ; preds = %NodeBlock5
  br label %sw.epilog

sw.bb10:                                          ; preds = %NodeBlock9
  br label %sw.epilog

sw.bb11:                                          ; preds = %LeafBlock7
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock7, %LeafBlock
  br label %do.body12

do.body12:                                        ; preds = %NewDefault
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str, i32 0, i32 0), i32 610, i64 12) #7, !srcloc !84
  br label %do.body13

do.body13:                                        ; preds = %do.body13, %do.body12
  br label %do.body13

sw.epilog:                                        ; preds = %LeafBlock, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5
  %retval.0 = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.19, i32 0, i32 0), %sw.bb11 ], [ getelementptr inbounds ([3 x i8], [3 x i8]* @.str.18, i32 0, i32 0), %sw.bb10 ], [ getelementptr inbounds ([4 x i8], [4 x i8]* @.str.17, i32 0, i32 0), %sw.bb9 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.16, i32 0, i32 0), %sw.bb8 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.15, i32 0, i32 0), %sw.bb7 ], [ getelementptr inbounds ([14 x i8], [14 x i8]* @.str.14, i32 0, i32 0), %sw.bb6 ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @.str.13, i32 0, i32 0), %sw.bb5 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.12, i32 0, i32 0), %LeafBlock ]
  ret i8* %retval.0
}

declare void @__compiletime_assert_590() #3

; Function Attrs: nounwind uwtable
define internal zeroext i8 @user_state_from_blocked(i64 %state) #1 {
entry:
  %and = and i64 %state, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %and1 = and i64 %state, 2
  %tobool2 = icmp ne i64 %and1, 0
  %. = select i1 %tobool2, i8 0, i8 1
  br label %return

return:                                           ; preds = %if.end, %entry
  %retval.0 = phi i8 [ 2, %entry ], [ %., %if.end ]
  ret i8 %retval.0
}

declare zeroext i1 @capable(i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #3

declare i32 @add_uevent_var(%struct.kobj_uevent_env*, i8*, ...) #3

declare void @kfree(i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_add(%struct.list_head* %new, %struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %new, %struct.list_head** %prev1, align 8, !tbaa !73
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !72
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %new, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev3, align 8, !tbaa !73
  %next4 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %new, %struct.list_head** %next4, align 8, !tbaa !72
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @dev_name(%struct.device* %dev) #0 {
entry:
  %init_name = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %0 = load i8*, i8** %init_name, align 8, !tbaa !85
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %init_name1 = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 3
  %1 = load i8*, i8** %init_name1, align 8, !tbaa !85
  br label %return

if.end:                                           ; preds = %entry
  %kobj = getelementptr inbounds %struct.device, %struct.device* %dev, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj)
  br label %return

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %1, %if.then ], [ %call, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @rfkill_led_trigger_activate(%struct.led_classdev* %led) #1 {
entry:
  %trigger = getelementptr inbounds %struct.led_classdev, %struct.led_classdev* %led, i32 0, i32 17
  %0 = load %struct.led_trigger*, %struct.led_trigger** %trigger, align 8, !tbaa !86
  %1 = bitcast %struct.led_trigger* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -56
  %2 = bitcast i8* %add.ptr to %struct.rfkill*
  call void @rfkill_led_trigger_event(%struct.rfkill* %2)
  ret void
}

declare i32 @led_trigger_register(%struct.led_trigger*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @kobject_name(%struct.kobject* %kobj) #0 {
entry:
  %name = getelementptr inbounds %struct.kobject, %struct.kobject* %kobj, i32 0, i32 0
  %0 = load i8*, i8** %name, align 8, !tbaa !91
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #0 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 64, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #3

; Function Attrs: nounwind uwtable
define internal void @rfkill_fill_event(%struct.rfkill_event* %ev, %struct.rfkill* %rfkill, i32 %op) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 4
  %0 = load i32, i32* %idx, align 8, !tbaa !76
  %idx1 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 0
  store i32 %0, i32* %idx1, align 1, !tbaa !92
  %type = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 2
  %1 = load i32, i32* %type, align 8, !tbaa !46
  %conv = trunc i32 %1 to i8
  %type2 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  store i8 %conv, i8* %type2, align 1, !tbaa !94
  %conv3 = trunc i32 %op to i8
  %op4 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  store i8 %conv3, i8* %op4, align 1, !tbaa !95
  %2 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv6 = zext i1 %cmp to i32
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %4) #7
  %5 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %lock = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  %call = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock)
  %call7 = call i64 @_raw_spin_lock_irqsave(%struct.raw_spinlock* %call)
  %state = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %6 = load i64, i64* %state, align 8, !tbaa !53
  %and = and i64 %6, 1
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = trunc i32 %lnot.ext to i8
  %hard = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 4
  store i8 %conv11, i8* %hard, align 1, !tbaa !96
  %state12 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 3
  %7 = load i64, i64* %state12, align 8, !tbaa !53
  %and13 = and i64 %7, 6
  %tobool14 = icmp ne i64 %and13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = trunc i32 %lnot.ext18 to i8
  %soft = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  store i8 %conv19, i8* %soft, align 1, !tbaa !97
  %lock20 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %rfkill, i32 0, i32 0
  call void @spin_unlock_irqrestore(%struct.spinlock* %lock20, i64 %call7)
  ret void
}

declare void @__wake_up(%struct.__wait_queue_head*, i32, i32, i8*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del_entry(%struct.list_head* %entry1) #0 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !73
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !72
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__list_del(%struct.list_head* %prev, %struct.list_head* %next) #0 {
entry:
  %prev1 = getelementptr inbounds %struct.list_head, %struct.list_head* %next, i32 0, i32 1
  store %struct.list_head* %prev, %struct.list_head** %prev1, align 8, !tbaa !73
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %prev, i32 0, i32 0
  store %struct.list_head* %next, %struct.list_head** %next2, align 8, !tbaa !72
  ret void
}

declare void @led_trigger_unregister(%struct.led_trigger*) #3

declare i32 @__class_register(%struct.class*, %struct.lock_class_key*) #3

declare i32 @misc_register(%struct.miscdevice*) #3

declare i32 @rfkill_handler_init() #3

declare i64 @no_llseek(%struct.file*, i64, i32) #3

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_read(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #1 {
entry:
  %__wait = alloca %struct.__wait_queue, align 8
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !98
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock(%struct.mutex* %mtx)
  br label %while.cond

while.cond:                                       ; preds = %if.end21, %entry
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %f_flags = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 7
  %2 = load i32, i32* %f_flags, align 8, !tbaa !103
  %and = and i32 %2, 2048
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %out, label %if.end

if.end:                                           ; preds = %while.body
  %mtx2 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx2)
  %call3 = call zeroext i1 @rfkill_readable(%struct.rfkill_data* %1)
  br i1 %call3, label %if.end17, label %do.body

do.body:                                          ; preds = %if.end
  %3 = bitcast %struct.__wait_queue* %__wait to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* %3) #7
  %flags = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 0
  store i32 0, i32* %flags, align 8, !tbaa !104
  %private = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 1
  %call5 = call %struct.task_struct* @get_current()
  %4 = bitcast %struct.task_struct* %call5 to i8*
  store i8* %4, i8** %private, align 8, !tbaa !106
  %func = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 2
  store i32 (%struct.__wait_queue*, i32, i32, i8*)* @autoremove_wake_function, i32 (%struct.__wait_queue*, i32, i32, i8*)** %func, align 8, !tbaa !107
  %task_list = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 0
  %task_list6 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list6, %struct.list_head** %next, align 8, !tbaa !72
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %task_list, i32 0, i32 1
  %task_list7 = getelementptr inbounds %struct.__wait_queue, %struct.__wait_queue* %__wait, i32 0, i32 3
  store %struct.list_head* %task_list7, %struct.list_head** %prev, align 8, !tbaa !73
  br label %for.cond

for.cond:                                         ; preds = %if.then14, %do.body
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @prepare_to_wait(%struct.__wait_queue_head* %read_wait, %struct.__wait_queue* %__wait, i32 1)
  %call8 = call zeroext i1 @rfkill_readable(%struct.rfkill_data* %1)
  br i1 %call8, label %for.end, label %if.end10

if.end10:                                         ; preds = %for.cond
  %call11 = call %struct.task_struct* @get_current()
  %call12 = call i32 @signal_pending(%struct.task_struct* %call11)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %for.end, label %if.then14

if.then14:                                        ; preds = %if.end10
  call void @schedule()
  br label %for.cond

for.end:                                          ; preds = %if.end10, %for.cond
  %__ret.0 = phi i32 [ 0, %for.cond ], [ -512, %if.end10 ]
  %read_wait16 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @finish_wait(%struct.__wait_queue_head* %read_wait16, %struct.__wait_queue* %__wait)
  %5 = bitcast %struct.__wait_queue* %__wait to i8*
  call void @llvm.lifetime.end.p0i8(i64 40, i8* %5) #7
  br label %if.end17

if.end17:                                         ; preds = %for.end, %if.end
  %__ret.1 = phi i32 [ 0, %if.end ], [ %__ret.0, %for.end ]
  %mtx18 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock(%struct.mutex* %mtx18)
  %tobool19 = icmp ne i32 %__ret.1, 0
  br i1 %tobool19, label %out, label %if.end21

if.end21:                                         ; preds = %if.end17
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %events22 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %events22, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !72
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr to %struct.rfkill_int_event*
  %cmp = icmp ult i64 8, %count
  %.count = select i1 %cmp, i64 8, i64 %count
  %conv = trunc i64 %.count to i32
  %ev26 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %8, i32 0, i32 1
  %9 = bitcast %struct.rfkill_event* %ev26 to i8*
  %conv27 = trunc i64 %.count to i32
  %call28 = call i32 @copy_to_user(i8* %buf, i8* %9, i32 %conv27)
  %tobool29 = icmp ne i32 %call28, 0
  %ret.0 = select i1 %tobool29, i32 -14, i32 %conv
  %list = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %8, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  %10 = bitcast %struct.rfkill_int_event* %8 to i8*
  call void @kfree(i8* %10)
  br label %out

out:                                              ; preds = %if.end17, %while.body, %while.end
  %ret.1 = phi i32 [ %ret.0, %while.end ], [ -11, %while.body ], [ %__ret.1, %if.end17 ]
  %mtx32 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx32)
  %conv33 = sext i32 %ret.1 to i64
  ret i64 %conv33
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_write(%struct.file* %file, i8* %buf, i64 %count, i64* %pos) #1 {
entry:
  %ev = alloca %struct.rfkill_event, align 1
  %_min1 = alloca i64, align 8
  %_min2 = alloca i64, align 8
  %0 = bitcast %struct.rfkill_event* %ev to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %cmp = icmp ult i64 %count, 7
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %1 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  store i64 %count, i64* %_min1, align 8, !tbaa !75
  %2 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  store i64 8, i64* %_min2, align 8, !tbaa !75
  %cmp1 = icmp eq i64* %_min1, %_min2
  %conv = zext i1 %cmp1 to i32
  %3 = load i64, i64* %_min1, align 8, !tbaa !75
  %4 = load i64, i64* %_min2, align 8, !tbaa !75
  %cmp2 = icmp ult i64 %3, %4
  %5 = load i64, i64* %_min1, align 8
  %6 = load i64, i64* %_min2, align 8
  %cond = select i1 %cmp2, i64 %5, i64 %6
  %7 = bitcast i64* %_min2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  %8 = bitcast i64* %_min1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #7
  %9 = bitcast %struct.rfkill_event* %ev to i8*
  %call = call i64 @copy_from_user(i8* %9, i8* %buf, i64 %cond)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %op = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %10 = load i8, i8* %op, align 1, !tbaa !95
  %conv6 = zext i8 %10 to i32
  %cmp7 = icmp ne i32 %conv6, 2
  br i1 %cmp7, label %land.lhs.true, label %if.end14

land.lhs.true:                                    ; preds = %if.end5
  %op9 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %11 = load i8, i8* %op9, align 1, !tbaa !95
  %conv10 = zext i8 %11 to i32
  %cmp11 = icmp ne i32 %conv10, 3
  br i1 %cmp11, label %cleanup, label %if.end14

if.end14:                                         ; preds = %land.lhs.true, %if.end5
  %type = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %12 = load i8, i8* %type, align 1, !tbaa !94
  %conv15 = zext i8 %12 to i32
  %cmp16 = icmp sge i32 %conv15, 9
  br i1 %cmp16, label %cleanup, label %if.end19

if.end19:                                         ; preds = %if.end14
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %op20 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %13 = load i8, i8* %op20, align 1, !tbaa !95
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 3
  br i1 %cmp22, label %if.then24, label %if.end41

if.then24:                                        ; preds = %if.end19
  %type25 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %14 = load i8, i8* %type25, align 1, !tbaa !94
  %conv26 = zext i8 %14 to i32
  %cmp27 = icmp eq i32 %conv26, 0
  br i1 %cmp27, label %if.then29, label %if.else

if.then29:                                        ; preds = %if.then24
  br label %for.cond

for.cond:                                         ; preds = %for.body, %if.then29
  %i.0 = phi i32 [ 0, %if.then29 ], [ %inc, %for.body ]
  %cmp30 = icmp ult i32 %i.0, 9
  br i1 %cmp30, label %for.body, label %if.end41

for.body:                                         ; preds = %for.cond
  %soft = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %15 = load i8, i8* %soft, align 1, !tbaa !97
  %tobool32 = icmp ne i8 %15, 0
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom
  %cur = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx, i32 0, i32 0
  %frombool = zext i1 %tobool32 to i8
  store i8 %frombool, i8* %cur, align 2, !tbaa !43
  %inc = add i32 %i.0, 1
  br label %for.cond

if.else:                                          ; preds = %if.then24
  %soft33 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %16 = load i8, i8* %soft33, align 1, !tbaa !97
  %tobool34 = icmp ne i8 %16, 0
  %type35 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %17 = load i8, i8* %type35, align 1, !tbaa !94
  %idxprom36 = zext i8 %17 to i64
  %arrayidx37 = getelementptr inbounds [9 x %struct.anon.43], [9 x %struct.anon.43]* @rfkill_global_states, i64 0, i64 %idxprom36
  %cur38 = getelementptr inbounds %struct.anon.43, %struct.anon.43* %arrayidx37, i32 0, i32 0
  %frombool39 = zext i1 %tobool34 to i8
  store i8 %frombool39, i8* %cur38, align 2, !tbaa !43
  br label %if.end41

if.end41:                                         ; preds = %if.else, %for.cond, %if.end19
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc71, %if.end41
  %next.sink = phi %struct.list_head** [ %next, %for.inc71 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end41 ]
  %18 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !45
  %19 = bitcast %struct.list_head* %18 to i8*
  %add.ptr75 = getelementptr inbounds i8, i8* %19, i64 -568
  %20 = bitcast i8* %add.ptr75 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 12
  %cmp44 = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp44, label %for.body46, label %for.end76

for.body46:                                       ; preds = %for.cond43
  %idx = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 4
  %21 = load i32, i32* %idx, align 8, !tbaa !76
  %idx47 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 0
  %22 = load i32, i32* %idx47, align 1, !tbaa !92
  %cmp48 = icmp ne i32 %21, %22
  br i1 %cmp48, label %land.lhs.true50, label %if.end56

land.lhs.true50:                                  ; preds = %for.body46
  %op51 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 2
  %23 = load i8, i8* %op51, align 1, !tbaa !95
  %conv52 = zext i8 %23 to i32
  %cmp53 = icmp ne i32 %conv52, 3
  br i1 %cmp53, label %for.inc71, label %if.end56

if.end56:                                         ; preds = %land.lhs.true50, %for.body46
  %type57 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 2
  %24 = load i32, i32* %type57, align 8, !tbaa !46
  %type58 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %25 = load i8, i8* %type58, align 1, !tbaa !94
  %conv59 = zext i8 %25 to i32
  %cmp60 = icmp ne i32 %24, %conv59
  br i1 %cmp60, label %land.lhs.true62, label %if.end68

land.lhs.true62:                                  ; preds = %if.end56
  %type63 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 1
  %26 = load i8, i8* %type63, align 1, !tbaa !94
  %conv64 = zext i8 %26 to i32
  %cmp65 = icmp ne i32 %conv64, 0
  br i1 %cmp65, label %for.inc71, label %if.end68

if.end68:                                         ; preds = %land.lhs.true62, %if.end56
  %soft69 = getelementptr inbounds %struct.rfkill_event, %struct.rfkill_event* %ev, i32 0, i32 3
  %27 = load i8, i8* %soft69, align 1, !tbaa !97
  %tobool70 = icmp ne i8 %27, 0
  call void @rfkill_set_block(%struct.rfkill* %20, i1 zeroext %tobool70)
  br label %for.inc71

for.inc71:                                        ; preds = %land.lhs.true62, %land.lhs.true50, %if.end68
  %node73 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %20, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node73, i32 0, i32 0
  br label %for.cond43

for.end76:                                        ; preds = %for.cond43
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  br label %cleanup

cleanup:                                          ; preds = %if.end14, %land.lhs.true, %if.end, %entry, %for.end76
  %retval.0 = phi i64 [ %cond, %for.end76 ], [ -22, %entry ], [ -14, %if.end ], [ -22, %land.lhs.true ], [ -22, %if.end14 ]
  %28 = bitcast %struct.rfkill_event* %ev to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %28) #7
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_poll(%struct.file* %file, %struct.poll_table_struct* %wait) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !98
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 3
  call void @poll_wait(%struct.file* %file, %struct.__wait_queue_head* %read_wait, %struct.poll_table_struct* %wait)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock(%struct.mutex* %mtx)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  %. = select i1 %tobool, i32 260, i32 65
  %mtx1 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx1)
  ret i32 %.
}

; Function Attrs: nounwind uwtable
define internal i64 @rfkill_fop_ioctl(%struct.file* %file, i32 %cmd, i64 %arg) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !98
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  %shr = lshr i32 %cmd, 8
  %and = and i32 %shr, 255
  %cmp = icmp ne i32 %and, 82
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %shr1 = lshr i32 %cmd, 0
  %and2 = and i32 %shr1, 255
  %cmp3 = icmp ne i32 %and2, 1
  br i1 %cmp3, label %cleanup, label %if.end5

if.end5:                                          ; preds = %if.end
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_lock(%struct.mutex* %mtx)
  %input_handler = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  %2 = load i8, i8* %input_handler, align 8, !tbaa !108, !range !41
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.end12, label %if.then6

if.then6:                                         ; preds = %if.end5
  %call = call i32 @atomic_add_return(i32 1, %struct.atomic_t* @rfkill_input_disabled)
  %cmp7 = icmp eq i32 %call, 1
  br i1 %cmp7, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.then6
  %call9 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.24, i32 0, i32 0))
  br label %if.end10

if.end10:                                         ; preds = %if.then8, %if.then6
  %input_handler11 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  store i8 1, i8* %input_handler11, align 8, !tbaa !108
  br label %if.end12

if.end12:                                         ; preds = %if.end10, %if.end5
  %mtx13 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx13)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %if.end12
  %retval.0 = phi i64 [ 0, %if.end12 ], [ -38, %entry ], [ -38, %if.end ]
  ret i64 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_open(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %call = call i8* @kzalloc(i64 104, i32 208)
  %0 = bitcast i8* %call to %struct.rfkill_data*
  %tobool = icmp ne %struct.rfkill_data* %0, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %events)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @__mutex_init(%struct.mutex* %mtx, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.25, i32 0, i32 0), %struct.lock_class_key* @rfkill_fop_open.__key)
  %read_wait = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 3
  call void @__init_waitqueue_head(%struct.__wait_queue_head* %read_wait, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0), %struct.lock_class_key* @rfkill_fop_open.__key.26)
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %mtx4 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_lock(%struct.mutex* %mtx4)
  br label %for.cond

for.cond:                                         ; preds = %if.end9, %if.end
  %next.sink = phi %struct.list_head** [ %next, %if.end9 ], [ getelementptr inbounds (%struct.list_head, %struct.list_head* @rfkill_list, i32 0, i32 0), %if.end ]
  %1 = load %struct.list_head*, %struct.list_head** %next.sink, align 8, !tbaa !45
  %2 = bitcast %struct.list_head* %1 to i8*
  %add.ptr15 = getelementptr inbounds i8, i8* %2, i64 -568
  %3 = bitcast i8* %add.ptr15 to %struct.rfkill*
  %node = getelementptr inbounds %struct.rfkill, %struct.rfkill* %3, i32 0, i32 12
  %cmp = icmp ne %struct.list_head* %node, @rfkill_list
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call6 = call i8* @kzalloc(i64 24, i32 208)
  %4 = bitcast i8* %call6 to %struct.rfkill_int_event*
  %tobool7 = icmp ne %struct.rfkill_int_event* %4, null
  br i1 %tobool7, label %if.end9, label %free

if.end9:                                          ; preds = %for.body
  %ev10 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %4, i32 0, i32 1
  call void @rfkill_fill_event(%struct.rfkill_event* %ev10, %struct.rfkill* %3, i32 0)
  %list = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %4, i32 0, i32 0
  %events11 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  call void @list_add_tail(%struct.list_head* %list, %struct.list_head* %events11)
  %node13 = getelementptr inbounds %struct.rfkill, %struct.rfkill* %3, i32 0, i32 12
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %node13, i32 0, i32 0
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %list16 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 0
  call void @list_add(%struct.list_head* %list16, %struct.list_head* @rfkill_fds)
  %mtx17 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx17)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %5 = bitcast %struct.rfkill_data* %0 to i8*
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  store i8* %5, i8** %private_data, align 8, !tbaa !98
  %call18 = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %file)
  br label %cleanup

free:                                             ; preds = %for.body
  %mtx19 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx19)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %mtx20 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 2
  call void @mutex_destroy(%struct.mutex* %mtx20)
  %events22 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  %next23 = getelementptr inbounds %struct.list_head, %struct.list_head* %events22, i32 0, i32 0
  %6 = load %struct.list_head*, %struct.list_head** %next23, align 8, !tbaa !72
  %7 = bitcast %struct.list_head* %6 to i8*
  %add.ptr25 = getelementptr inbounds i8, i8* %7, i64 0
  %8 = bitcast i8* %add.ptr25 to %struct.rfkill_int_event*
  br label %for.cond31

for.cond31:                                       ; preds = %for.body35, %free
  %.sink = phi %struct.rfkill_int_event* [ %11, %for.body35 ], [ %8, %free ]
  %ev.0 = phi %struct.rfkill_int_event* [ %8, %free ], [ %11, %for.body35 ]
  %list38 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %.sink, i32 0, i32 0
  %next39 = getelementptr inbounds %struct.list_head, %struct.list_head* %list38, i32 0, i32 0
  %9 = load %struct.list_head*, %struct.list_head** %next39, align 8, !tbaa !110
  %10 = bitcast %struct.list_head* %9 to i8*
  %add.ptr41 = getelementptr inbounds i8, i8* %10, i64 0
  %11 = bitcast i8* %add.ptr41 to %struct.rfkill_int_event*
  %list32 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %ev.0, i32 0, i32 0
  %events33 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %0, i32 0, i32 1
  %cmp34 = icmp ne %struct.list_head* %list32, %events33
  br i1 %cmp34, label %for.body35, label %for.end42

for.body35:                                       ; preds = %for.cond31
  %12 = bitcast %struct.rfkill_int_event* %ev.0 to i8*
  call void @kfree(i8* %12)
  br label %for.cond31

for.end42:                                        ; preds = %for.cond31
  %13 = bitcast %struct.rfkill_data* %0 to i8*
  call void @kfree(i8* %13)
  br label %cleanup

cleanup:                                          ; preds = %entry, %for.end42, %for.end
  %retval.0 = phi i32 [ -12, %for.end42 ], [ %call18, %for.end ], [ -12, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @rfkill_fop_release(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %private_data = getelementptr inbounds %struct.file, %struct.file* %file, i32 0, i32 15
  %0 = load i8*, i8** %private_data, align 8, !tbaa !98
  %1 = bitcast i8* %0 to %struct.rfkill_data*
  call void @mutex_lock(%struct.mutex* @rfkill_global_mutex)
  %list = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 0
  call void @list_del(%struct.list_head* %list)
  call void @mutex_unlock(%struct.mutex* @rfkill_global_mutex)
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 2
  call void @mutex_destroy(%struct.mutex* %mtx)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %events, i32 0, i32 0
  %2 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !72
  %3 = bitcast %struct.list_head* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 0
  %4 = bitcast i8* %add.ptr to %struct.rfkill_int_event*
  br label %for.cond

for.cond:                                         ; preds = %for.body, %entry
  %.sink = phi %struct.rfkill_int_event* [ %7, %for.body ], [ %4, %entry ]
  %ev.0 = phi %struct.rfkill_int_event* [ %4, %entry ], [ %7, %for.body ]
  %list10 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %.sink, i32 0, i32 0
  %next11 = getelementptr inbounds %struct.list_head, %struct.list_head* %list10, i32 0, i32 0
  %5 = load %struct.list_head*, %struct.list_head** %next11, align 8, !tbaa !110
  %6 = bitcast %struct.list_head* %5 to i8*
  %add.ptr13 = getelementptr inbounds i8, i8* %6, i64 0
  %7 = bitcast i8* %add.ptr13 to %struct.rfkill_int_event*
  %list7 = getelementptr inbounds %struct.rfkill_int_event, %struct.rfkill_int_event* %ev.0, i32 0, i32 0
  %events8 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 1
  %cmp = icmp ne %struct.list_head* %list7, %events8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = bitcast %struct.rfkill_int_event* %ev.0 to i8*
  call void @kfree(i8* %8)
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %input_handler = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %1, i32 0, i32 4
  %9 = load i8, i8* %input_handler, align 8, !tbaa !108, !range !41
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then, label %if.end17

if.then:                                          ; preds = %for.end
  %call = call i32 @atomic_sub_return(i32 1, %struct.atomic_t* @rfkill_input_disabled)
  %cmp14 = icmp eq i32 %call, 0
  br i1 %cmp14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.then
  %call16 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.28, i32 0, i32 0))
  br label %if.end17

if.end17:                                         ; preds = %if.then, %if.then15, %for.end
  %10 = bitcast %struct.rfkill_data* %1 to i8*
  call void @kfree(i8* %10)
  ret i32 0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @list_empty(%struct.list_head* %head) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !72
  %cmp = icmp eq %struct.list_head* %0, %head
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @rfkill_readable(%struct.rfkill_data* %data) #1 {
entry:
  %mtx = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %data, i32 0, i32 2
  call void @mutex_lock(%struct.mutex* %mtx)
  %events = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %data, i32 0, i32 1
  %call = call i32 @list_empty(%struct.list_head* %events)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  %mtx1 = getelementptr inbounds %struct.rfkill_data, %struct.rfkill_data* %data, i32 0, i32 2
  call void @mutex_unlock(%struct.mutex* %mtx1)
  %tobool2 = trunc i8 %frombool to i1
  ret i1 %tobool2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #5 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #2, !srcloc !112
  ret %struct.task_struct* %0
}

declare i32 @autoremove_wake_function(%struct.__wait_queue*, i32, i32, i8*) #3

declare void @prepare_to_wait(%struct.__wait_queue_head*, %struct.__wait_queue*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @signal_pending(%struct.task_struct* %p) #0 {
entry:
  %call = call i32 @test_tsk_thread_flag(%struct.task_struct* %p, i32 2)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %conv2 = trunc i64 %expval to i32
  ret i32 %conv2
}

declare void @schedule() #3

declare void @finish_wait(%struct.__wait_queue_head*, %struct.__wait_queue*) #3

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @copy_to_user(i8* %dst, i8* %src, i32 %size) #5 {
entry:
  call void @might_fault()
  %call = call i64 @_copy_to_user(i8* %dst, i8* %src, i32 %size)
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_del(%struct.list_head* %entry1) #0 {
entry:
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  %0 = load %struct.list_head*, %struct.list_head** %prev, align 8, !tbaa !73
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  %1 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !72
  call void @__list_del(%struct.list_head* %0, %struct.list_head* %1)
  %next2 = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 0
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 1048832 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %next2, align 8, !tbaa !72
  %prev3 = getelementptr inbounds %struct.list_head, %struct.list_head* %entry1, i32 0, i32 1
  store %struct.list_head* bitcast (i8* getelementptr (i8, i8* inttoptr (i64 2097664 to i8*), i64 -2401263026318606336) to %struct.list_head*), %struct.list_head** %prev3, align 8, !tbaa !73
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_tsk_thread_flag(%struct.task_struct* %tsk, i32 %flag) #0 {
entry:
  %stack = getelementptr inbounds %struct.task_struct, %struct.task_struct* %tsk, i32 0, i32 1
  %0 = load i8*, i8** %stack, align 8, !tbaa !113
  %1 = bitcast i8* %0 to %struct.thread_info*
  %call = call i32 @test_ti_thread_flag(%struct.thread_info* %1, i32 %flag)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_ti_thread_flag(%struct.thread_info* %ti, i32 %flag) #0 {
entry:
  %flags = getelementptr inbounds %struct.thread_info, %struct.thread_info* %ti, i32 0, i32 2
  %0 = bitcast i32* %flags to i64*
  %call = call i32 @variable_test_bit(i32 %flag, i64* %0)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !139
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @might_fault() #0 {
entry:
  %call = call i32 @_cond_resched()
  ret void
}

declare i64 @_copy_to_user(i8*, i8*, i32) #3

declare i32 @_cond_resched() #3

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @copy_from_user(i8* %to, i8* %from, i64 %n) #0 {
entry:
  %0 = call i64 @llvm.objectsize.i64.p0i8(i8* %to, i1 false, i1 true)
  %conv = trunc i64 %0 to i32
  call void @might_fault()
  %cmp = icmp eq i32 %conv, -1
  %conv2 = sext i32 %conv to i64
  %cmp3 = icmp uge i64 %conv2, %n
  %1 = select i1 %cmp, i1 true, i1 %cmp3
  %lnot = xor i1 %1, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %conv7 = trunc i64 %n to i32
  %call = call i64 @_copy_from_user(i8* %to, i8* %from, i32 %conv7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %n.addr.0 = phi i64 [ %call, %if.then ], [ %n, %entry ]
  ret i64 %n.addr.0
}

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.objectsize.i64.p0i8(i8*, i1, i1) #6

declare i64 @_copy_from_user(i8*, i8*, i32) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @poll_wait(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p) #0 {
entry:
  %tobool = icmp ne %struct.poll_table_struct* %p, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %_qproc = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %0 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc, align 8, !tbaa !140
  %tobool1 = icmp ne void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)* %0, null
  %tobool3 = icmp ne %struct.__wait_queue_head* %wait_address, null
  %or.cond = and i1 %tobool1, %tobool3
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %_qproc4 = getelementptr inbounds %struct.poll_table_struct, %struct.poll_table_struct* %p, i32 0, i32 0
  %1 = load void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)** %_qproc4, align 8, !tbaa !140
  call void %1(%struct.file* %filp, %struct.__wait_queue_head* %wait_address, %struct.poll_table_struct* %p)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_add_return(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; xaddl $0, $1\0A", "=r,=*m,0,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32 %i, i32* %counter) #7, !srcloc !142
  %add = add nsw i32 %i, %0
  ret i32 %add
}

declare i32 @printk(i8*, ...) #3

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #3

declare void @__init_waitqueue_head(%struct.__wait_queue_head*, i8*, %struct.lock_class_key*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @list_add(%struct.list_head* %new, %struct.list_head* %head) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %head, i32 0, i32 0
  %0 = load %struct.list_head*, %struct.list_head** %next, align 8, !tbaa !72
  call void @__list_add(%struct.list_head* %new, %struct.list_head* %head, %struct.list_head* %0)
  ret void
}

declare i32 @nonseekable_open(%struct.inode*, %struct.file*) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @mutex_destroy(%struct.mutex* %lock) #0 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_sub_return(i32 %i, %struct.atomic_t* %v) #0 {
entry:
  %sub = sub nsw i32 0, %i
  %call = call i32 @atomic_add_return(i32 %sub, %struct.atomic_t* %v)
  ret i32 %call
}

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !4, i64 56}
!13 = !{!"rfkill", !14, i64 0, !4, i64 8, !5, i64 16, !15, i64 24, !16, i64 32, !17, i64 36, !17, i64 37, !4, i64 40, !4, i64 48, !18, i64 56, !4, i64 120, !21, i64 128, !20, i64 568, !34, i64 584, !35, i64 712, !35, i64 744}
!14 = !{!"spinlock", !5, i64 0}
!15 = !{!"long", !5, i64 0}
!16 = !{!"int", !5, i64 0}
!17 = !{!"_Bool", !5, i64 0}
!18 = !{!"led_trigger", !4, i64 0, !4, i64 8, !4, i64 16, !19, i64 24, !20, i64 32, !20, i64 48}
!19 = !{!"", !5, i64 0}
!20 = !{!"list_head", !4, i64 0, !4, i64 8}
!21 = !{!"device", !4, i64 0, !4, i64 8, !22, i64 16, !4, i64 80, !4, i64 88, !25, i64 96, !4, i64 136, !4, i64 144, !4, i64 152, !26, i64 160, !4, i64 248, !16, i64 256, !4, i64 264, !30, i64 272, !4, i64 280, !20, i64 288, !4, i64 304, !31, i64 312, !4, i64 328, !32, i64 336, !16, i64 344, !16, i64 348, !14, i64 352, !20, i64 360, !33, i64 376, !4, i64 408, !4, i64 416, !4, i64 424, !4, i64 432}
!22 = !{!"kobject", !4, i64 0, !20, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !23, i64 56, !16, i64 60, !16, i64 60, !16, i64 60, !16, i64 60, !16, i64 60}
!23 = !{!"kref", !24, i64 0}
!24 = !{!"", !16, i64 0}
!25 = !{!"mutex", !24, i64 0, !14, i64 4, !20, i64 8, !4, i64 24, !4, i64 32}
!26 = !{!"dev_pm_info", !27, i64 0, !16, i64 4, !16, i64 4, !17, i64 4, !17, i64 4, !17, i64 4, !17, i64 4, !14, i64 6, !20, i64 8, !28, i64 24, !4, i64 56, !17, i64 64, !17, i64 64, !4, i64 72, !4, i64 80}
!27 = !{!"pm_message", !16, i64 0}
!28 = !{!"completion", !16, i64 0, !29, i64 8}
!29 = !{!"__wait_queue_head", !14, i64 0, !20, i64 8}
!30 = !{!"long long", !5, i64 0}
!31 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!32 = !{!"acpi_dev_node", !4, i64 0}
!33 = !{!"klist_node", !4, i64 0, !20, i64 8, !23, i64 24}
!34 = !{!"delayed_work", !35, i64 0, !37, i64 32, !4, i64 112, !16, i64 120}
!35 = !{!"work_struct", !36, i64 0, !20, i64 8, !4, i64 24}
!36 = !{!"", !15, i64 0}
!37 = !{!"timer_list", !20, i64 0, !15, i64 16, !4, i64 24, !4, i64 32, !15, i64 40, !16, i64 48, !16, i64 52, !4, i64 56, !5, i64 64}
!38 = !{i32 -2145073073, i32 -2145073048, i32 -2145072778, i32 -2145072981, i32 -2145072950, i32 -2145072920}
!39 = !{!13, !4, i64 120}
!40 = !{!17, !17, i64 0}
!41 = !{i8 0, i8 2}
!42 = !{!16, !16, i64 0}
!43 = !{!44, !17, i64 0}
!44 = !{!"", !17, i64 0, !17, i64 1}
!45 = !{!4, !4, i64 0}
!46 = !{!13, !5, i64 16}
!47 = !{!44, !17, i64 1}
!48 = !{!13, !16, i64 288}
!49 = !{!13, !4, i64 40}
!50 = !{!51, !4, i64 8}
!51 = !{!"rfkill_ops", !4, i64 0, !4, i64 8, !4, i64 16}
!52 = !{!13, !4, i64 48}
!53 = !{!13, !15, i64 24}
!54 = !{!51, !4, i64 16}
!55 = !{!13, !17, i64 36}
!56 = !{i32 -2145070070, i32 -2145070045, i32 -2145069775, i32 -2145069978, i32 -2145069947, i32 -2145069917}
!57 = !{i32 -2145064959, i32 -2145064934, i32 -2145064664, i32 -2145064867, i32 -2145064836, i32 -2145064806}
!58 = !{i32 -2145063278, i32 -2145063253, i32 -2145062983, i32 -2145063186, i32 -2145063155, i32 -2145063125}
!59 = !{i32 -2145062768, i32 -2145062743, i32 -2145062473, i32 -2145062676, i32 -2145062645, i32 -2145062615}
!60 = !{!13, !17, i64 37}
!61 = !{i32 -2145061118, i32 -2145061093, i32 -2145060823, i32 -2145061026, i32 -2145060995, i32 -2145060965}
!62 = !{i32 -2145051886, i32 -2145051861, i32 -2145051591, i32 -2145051794, i32 -2145051763, i32 -2145051733}
!63 = !{!51, !4, i64 0}
!64 = !{i32 -2145050594, i32 -2145050569, i32 -2145050299, i32 -2145050502, i32 -2145050471, i32 -2145050441}
!65 = !{!5, !5, i64 0}
!66 = !{i64 0, i64 2, !67, i64 0, i64 1, !65, i64 1, i64 1, !65}
!67 = !{!68, !68, i64 0}
!68 = !{!"short", !5, i64 0}
!69 = !{!13, !4, i64 8}
!70 = !{!21, !4, i64 408}
!71 = !{!21, !4, i64 0}
!72 = !{!20, !4, i64 0}
!73 = !{!20, !4, i64 8}
!74 = !{i32 -2145043855, i32 -2145043830, i32 -2145043560, i32 -2145043763, i32 -2145043732, i32 -2145043702}
!75 = !{!15, !15, i64 0}
!76 = !{!13, !16, i64 32}
!77 = !{!36, !15, i64 0}
!78 = !{i64 0, i64 8, !75}
!79 = !{!35, !4, i64 24}
!80 = !{!37, !4, i64 32}
!81 = !{!37, !15, i64 40}
!82 = !{!13, !4, i64 64}
!83 = !{i32 -2145039841, i32 -2145039816, i32 -2145039546, i32 -2145039749, i32 -2145039718, i32 -2145039688}
!84 = !{i32 -2145058050, i32 -2145058025, i32 -2145057755, i32 -2145057958, i32 -2145057927, i32 -2145057897}
!85 = !{!21, !4, i64 80}
!86 = !{!87, !4, i64 256}
!87 = !{!"led_classdev", !4, i64 0, !16, i64 8, !16, i64 12, !16, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !20, i64 56, !4, i64 72, !15, i64 80, !15, i64 88, !37, i64 96, !16, i64 176, !35, i64 184, !16, i64 216, !88, i64 224, !4, i64 256, !20, i64 264, !4, i64 280, !17, i64 288}
!88 = !{!"rw_semaphore", !15, i64 0, !89, i64 8, !20, i64 16}
!89 = !{!"raw_spinlock", !90, i64 0}
!90 = !{!"arch_spinlock", !5, i64 0}
!91 = !{!22, !4, i64 0}
!92 = !{!93, !16, i64 0}
!93 = !{!"rfkill_event", !16, i64 0, !5, i64 4, !5, i64 5, !5, i64 6, !5, i64 7}
!94 = !{!93, !5, i64 4}
!95 = !{!93, !5, i64 5}
!96 = !{!93, !5, i64 7}
!97 = !{!93, !5, i64 6}
!98 = !{!99, !4, i64 168}
!99 = !{!"file", !5, i64 0, !100, i64 16, !4, i64 32, !4, i64 40, !14, i64 48, !16, i64 52, !36, i64 56, !16, i64 64, !16, i64 68, !30, i64 72, !101, i64 80, !4, i64 112, !102, i64 120, !30, i64 152, !4, i64 160, !4, i64 168, !20, i64 176, !20, i64 192, !4, i64 208}
!100 = !{!"path", !4, i64 0, !4, i64 8}
!101 = !{!"fown_struct", !19, i64 0, !4, i64 8, !5, i64 16, !16, i64 20, !16, i64 24, !16, i64 28}
!102 = !{!"file_ra_state", !15, i64 0, !16, i64 8, !16, i64 12, !16, i64 16, !16, i64 20, !30, i64 24}
!103 = !{!99, !16, i64 64}
!104 = !{!105, !16, i64 0}
!105 = !{!"__wait_queue", !16, i64 0, !4, i64 8, !4, i64 16, !20, i64 24}
!106 = !{!105, !4, i64 8}
!107 = !{!105, !4, i64 16}
!108 = !{!109, !17, i64 96}
!109 = !{!"rfkill_data", !20, i64 0, !20, i64 16, !25, i64 32, !29, i64 72, !17, i64 96}
!110 = !{!111, !4, i64 0}
!111 = !{!"rfkill_int_event", !20, i64 0, !93, i64 16}
!112 = !{i32 -2146945639}
!113 = !{!114, !4, i64 8}
!114 = !{!"task_struct", !15, i64 0, !4, i64 8, !24, i64 16, !16, i64 20, !16, i64 24, !115, i64 32, !16, i64 40, !16, i64 44, !16, i64 48, !16, i64 52, !16, i64 56, !16, i64 60, !4, i64 64, !116, i64 72, !121, i64 448, !4, i64 496, !5, i64 504, !16, i64 508, !16, i64 512, !16, i64 516, !122, i64 520, !123, i64 528, !20, i64 560, !124, i64 576, !4, i64 616, !4, i64 624, !125, i64 632, !16, i64 648, !16, i64 652, !16, i64 656, !16, i64 660, !16, i64 664, !16, i64 668, !16, i64 672, !16, i64 672, !16, i64 672, !16, i64 672, !16, i64 672, !16, i64 672, !16, i64 676, !16, i64 680, !4, i64 688, !4, i64 696, !20, i64 704, !20, i64 720, !4, i64 736, !20, i64 744, !20, i64 760, !5, i64 776, !20, i64 848, !4, i64 864, !4, i64 872, !4, i64 880, !15, i64 888, !15, i64 896, !15, i64 904, !15, i64 912, !15, i64 920, !126, i64 928, !15, i64 944, !15, i64 952, !127, i64 960, !127, i64 976, !15, i64 992, !15, i64 1000, !128, i64 1008, !5, i64 1032, !4, i64 1080, !4, i64 1088, !5, i64 1096, !16, i64 1112, !16, i64 1116, !129, i64 1120, !130, i64 1128, !4, i64 1312, !4, i64 1320, !4, i64 1328, !4, i64 1336, !4, i64 1344, !19, i64 1352, !19, i64 1360, !19, i64 1368, !132, i64 1376, !15, i64 1400, !15, i64 1408, !4, i64 1416, !4, i64 1424, !4, i64 1432, !4, i64 1440, !4, i64 1448, !16, i64 1456, !16, i64 1460, !133, i64 1464, !16, i64 1480, !16, i64 1484, !14, i64 1488, !89, i64 1490, !134, i64 1496, !4, i64 1512, !4, i64 1520, !4, i64 1528, !4, i64 1536, !4, i64 1544, !4, i64 1552, !4, i64 1560, !15, i64 1568, !4, i64 1576, !135, i64 1584, !30, i64 1640, !30, i64 1648, !15, i64 1656, !19, i64 1664, !136, i64 1672, !16, i64 1676, !16, i64 1680, !4, i64 1688, !20, i64 1696, !4, i64 1712, !4, i64 1720, !20, i64 1728, !4, i64 1744, !5, i64 1752, !25, i64 1768, !20, i64 1808, !4, i64 1824, !68, i64 1832, !68, i64 1834, !137, i64 1840, !4, i64 1856, !138, i64 1864, !4, i64 1880, !16, i64 1888, !16, i64 1892, !15, i64 1896, !15, i64 1904, !15, i64 1912, !15, i64 1920, !15, i64 1928, !24, i64 1936}
!115 = !{!"llist_node", !4, i64 0}
!116 = !{!"sched_entity", !117, i64 0, !118, i64 16, !20, i64 40, !16, i64 56, !30, i64 64, !30, i64 72, !30, i64 80, !30, i64 88, !30, i64 96, !119, i64 104, !4, i64 320, !4, i64 328, !4, i64 336, !120, i64 344}
!117 = !{!"load_weight", !15, i64 0, !15, i64 8}
!118 = !{!"rb_node", !15, i64 0, !4, i64 8, !4, i64 16}
!119 = !{!"sched_statistics", !30, i64 0, !30, i64 8, !30, i64 16, !30, i64 24, !30, i64 32, !30, i64 40, !30, i64 48, !30, i64 56, !30, i64 64, !30, i64 72, !30, i64 80, !30, i64 88, !30, i64 96, !30, i64 104, !30, i64 112, !30, i64 120, !30, i64 128, !30, i64 136, !30, i64 144, !30, i64 152, !30, i64 160, !30, i64 168, !30, i64 176, !30, i64 184, !30, i64 192, !30, i64 200, !30, i64 208}
!120 = !{!"sched_avg", !16, i64 0, !16, i64 4, !30, i64 8, !30, i64 16, !15, i64 24}
!121 = !{!"sched_rt_entity", !20, i64 0, !15, i64 16, !15, i64 24, !16, i64 32, !4, i64 40}
!122 = !{!"cpumask", !5, i64 0}
!123 = !{!"sched_info", !15, i64 0, !30, i64 8, !30, i64 16, !30, i64 24}
!124 = !{!"plist_node", !16, i64 0, !20, i64 8, !20, i64 24}
!125 = !{!"task_rss_stat", !16, i64 0, !5, i64 4}
!126 = !{!"cputime", !15, i64 0, !15, i64 8}
!127 = !{!"timespec", !15, i64 0, !15, i64 8}
!128 = !{!"task_cputime", !15, i64 0, !15, i64 8, !30, i64 16}
!129 = !{!"sysv_sem", !4, i64 0}
!130 = !{!"thread_struct", !5, i64 0, !15, i64 24, !15, i64 32, !15, i64 40, !68, i64 48, !68, i64 50, !68, i64 52, !68, i64 54, !15, i64 56, !15, i64 64, !5, i64 72, !15, i64 104, !15, i64 112, !15, i64 120, !15, i64 128, !15, i64 136, !131, i64 144, !4, i64 160, !15, i64 168, !16, i64 176}
!131 = !{!"fpu", !16, i64 0, !16, i64 4, !4, i64 8}
!132 = !{!"sigpending", !20, i64 0, !19, i64 16}
!133 = !{!"seccomp", !16, i64 0, !4, i64 8}
!134 = !{!"plist_head", !20, i64 0}
!135 = !{!"task_io_accounting", !30, i64 0, !30, i64 8, !30, i64 16, !30, i64 24, !30, i64 32, !30, i64 40, !30, i64 48}
!136 = !{!"seqcount", !16, i64 0}
!137 = !{!"callback_head", !4, i64 0, !4, i64 8}
!138 = !{!"page_frag", !4, i64 0, !16, i64 8, !16, i64 12}
!139 = !{i32 164233, i32 164244}
!140 = !{!141, !4, i64 0}
!141 = !{!"poll_table_struct", !4, i64 0, !15, i64 8}
!142 = !{i32 -2146781804, i32 -2146781765, i32 -2146781744, i32 -2146781707, i32 -2146781684, i32 -2146781675}
