; ModuleID = 'drivers/i2c/algos/i2c-algo-bit.bc'
source_filename = "drivers/i2c/algos/i2c-algo-bit.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm "\09.section \22___kcrctab+i2c_bit_algo\22, \22a\22\09"
module asm "\09.weak\09__crc_i2c_bit_algo\09"
module asm "\09.long\09__crc_i2c_bit_algo\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+i2c_bit_add_bus\22, \22a\22\09"
module asm "\09.weak\09__crc_i2c_bit_add_bus\09"
module asm "\09.long\09__crc_i2c_bit_add_bus\09"
module asm "\09.previous\09\09\09\09\09"
module asm "\09.section \22___kcrctab+i2c_bit_add_numbered_bus\22, \22a\22\09"
module asm "\09.weak\09__crc_i2c_bit_add_numbered_bus\09"
module asm "\09.long\09__crc_i2c_bit_add_numbered_bus\09"
module asm "\09.previous\09\09\09\09\09"

%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, %struct.kernel_symbol*, i32*, i32, i32, %struct.kernel_symbol*, i32*, i8, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [56 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, i32, i64*, i8, i8, %struct.klp_modinfo*, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, void ()**, i32, [36 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, %struct.delayed_work, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qspinlock = type { %struct.atomic_t }
%struct.lockdep_map = type { %struct.lock_class_key*, [2 x %struct.lock_class*], i8*, i32, i64 }
%struct.lock_class_key = type { [8 x %struct.lockdep_subclass_key] }
%struct.lockdep_subclass_key = type { i8 }
%struct.lock_class = type { %struct.hlist_node, %struct.list_head, %struct.lockdep_subclass_key*, i32, i32, i64, [13 x %struct.stack_trace], %struct.list_head, %struct.list_head, i32, i64, i8*, i32, [4 x i64], [4 x i64] }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.stack_trace = type { i32, i32, i64*, i32 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16, i8, %struct.lock_class_key*, %struct.lock_class_key }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.lockdep_map, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)*, %struct.lock_class_key }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.49, %struct.list_head, %struct.list_head, %union.anon.50 }
%struct.seqcount = type { i32, %struct.lockdep_map }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.lockref = type { %union.anon.47 }
%union.anon.47 = type { %struct.anon.48 }
%struct.anon.48 = type { %struct.spinlock, i32 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, [32 x i8], %struct.list_lru, [40 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.5, i32 }
%union.anon.5 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.6, %union.anon.32, %union.anon.33, %union.anon.37, %union.anon.41, %struct.mem_cgroup* }
%union.anon.6 = type { %struct.address_space* }
%union.anon.32 = type { i64 }
%union.anon.33 = type { i64 }
%union.anon.37 = type { %struct.list_head }
%union.anon.41 = type { i64 }
%struct.mem_cgroup = type opaque
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct*, %struct.lockdep_map }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, i64, i8, %struct.list_head, i32, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, i64, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, %struct.mutex_waiter*, i32, i64, i64, i32, i32, i32, i32, i64, i64, i32, i32, i32, i32, i64, i32, i32, [48 x %struct.held_lock], i32, i32, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, i32, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, i32, i32, i32, i32, i64, i64, i64, i64, %struct.callback_head, %struct.list_head, %struct.numa_group*, i64*, i64, [3 x i64], i64, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64, i32, i32, i8*, %struct.kcov*, %struct.mem_cgroup*, i32, i32, i32, %struct.uprobe_task*, i32, i32, i64, i32, %struct.task_struct*, %struct.atomic_t, %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [8 x i8], [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [128 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, %struct.cpumask*, %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.task_struct*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, %struct.cpumask, i64, i64, i32, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.7, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon.7 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_userfaultfd_ctx = type { %struct.userfaultfd_ctx* }
%struct.userfaultfd_ctx = type opaque
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16, i8* }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type { %struct.xol_area* }
%struct.xol_area = type opaque
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.8 }
%union.anon.8 = type { %struct.anon.9 }
%struct.anon.9 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.mutex_waiter = type { %struct.list_head, %struct.task_struct*, %struct.ww_acquire_ctx*, i8* }
%struct.ww_acquire_ctx = type opaque
%struct.held_lock = type { i64, i64, %struct.lockdep_map*, %struct.lockdep_map*, i64, i64, i32, i32 }
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.12 }
%union.anon.12 = type { %struct.anon.16, [80 x i8] }
%struct.anon.16 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [16 x i64] }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.numa_group = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.kcov = type opaque
%struct.uprobe_task = type { i32, %union.anon.22, %struct.uprobe*, i64, %struct.return_instance*, i32 }
%union.anon.22 = type { %struct.anon.23 }
%struct.anon.23 = type { %struct.arch_uprobe_task, i64 }
%struct.arch_uprobe_task = type { i64, i32, i32 }
%struct.uprobe = type opaque
%struct.return_instance = type { %struct.uprobe*, i64, i64, i64, i8, %struct.return_instance* }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type opaque
%struct.list_lru = type { %struct.list_lru_node*, %struct.list_head }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, %struct.list_lru_memcg*, [24 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%struct.list_lru_memcg = type { [0 x %struct.list_lru_one*] }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)*, %struct.lockdep_map }
%union.anon.49 = type { %struct.list_head }
%union.anon.50 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.42, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.bdi_writeback*, i32, i16, i16, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.43, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.46, i32, i32, %struct.hlist_head, %struct.fscrypt_info*, i8* }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.42 = type { i32 }
%struct.timespec = type { i64, i64 }
%struct.bdi_writeback = type opaque
%union.anon.43 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.iov_iter = type opaque
%struct.swap_info_struct = type opaque
%union.anon.46 = type { %struct.pipe_inode_info* }
%struct.fscrypt_info = type opaque
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type opaque
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.44 }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.44 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock, i32, i32, i8*, %struct.lockdep_map }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.cred = type { %struct.atomic_t, %struct.atomic_t, i8*, i32, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.52, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.53, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.54, %union.anon.56, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.52 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.53 = type { i64 }
%union.anon.54 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.56 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.vm_operations_struct = type opaque
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32, %struct.lockdep_map }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head, i8*, %struct.lockdep_map }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.51 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.51 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.klp_modinfo = type { %struct.elf64_hdr, %struct.elf64_shdr*, i8*, i32 }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%struct.i2c_adapter = type { %struct.module*, i32, %struct.i2c_algorithm*, i8*, %struct.i2c_lock_operations*, %struct.rt_mutex, %struct.rt_mutex, i32, i32, %struct.device, i32, [48 x i8], %struct.completion, %struct.mutex, %struct.list_head, %struct.i2c_bus_recovery_info*, %struct.i2c_adapter_quirks*, %struct.irq_domain* }
%struct.i2c_algorithm = type { {}*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_client*)*, i32 (%struct.i2c_client*)* }
%struct.i2c_lock_operations = type { void (%struct.i2c_adapter*, i32)*, i32 (%struct.i2c_adapter*, i32)*, void (%struct.i2c_adapter*, i32)* }
%struct.rt_mutex = type { %struct.raw_spinlock, %struct.rb_root, %struct.rb_node*, %struct.task_struct*, i32, i8*, i8*, i32, i8* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.dev_pin_info*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.cma*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head, %struct.pm_domain_data* }
%struct.pm_domain_data = type opaque
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.dev_pin_info = type { %struct.pinctrl*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state*, %struct.pinctrl_state* }
%struct.pinctrl = type opaque
%struct.pinctrl_state = type opaque
%struct.dma_map_ops = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.cma = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.i2c_bus_recovery_info = type { i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*, i32)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }
%struct.i2c_adapter_quirks = type { i64, i32, i16, i16, i16, i16 }
%struct.irq_domain = type { %struct.list_head, i8*, %struct.irq_domain_ops*, i8*, i32, %struct.fwnode_handle*, i32, %struct.irq_domain_chip_generic*, %struct.irq_domain*, i64, i32, i32, %struct.radix_tree_root, [0 x i32] }
%struct.irq_domain_ops = type { i32 (%struct.irq_domain*, %struct.device_node*, i32)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i32)*, i32 (%struct.irq_domain*, i32, i64)*, void (%struct.irq_domain*, i32)*, i32 (%struct.irq_domain*, %struct.device_node*, i32*, i32, i64*, i32*)*, i32 (%struct.irq_domain*, i32, i32, i8*)*, void (%struct.irq_domain*, i32, i32)*, void (%struct.irq_domain*, %struct.irq_data*)*, void (%struct.irq_domain*, %struct.irq_data*)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i64*, i32*)* }
%struct.irq_fwspec = type { %struct.fwnode_handle*, i32, [16 x i32] }
%struct.irq_data = type opaque
%struct.irq_domain_chip_generic = type opaque
%struct.i2c_msg = type { i16, i16, i16, i8* }
%union.i2c_smbus_data = type { i16, [32 x i8] }
%struct.i2c_client = type { i16, i16, [20 x i8], %struct.i2c_adapter*, %struct.device, i32, %struct.list_head, i32 (%struct.i2c_client*, i32, i8*)* }
%struct.i2c_algo_bit_data = type { i8*, void (i8*, i32)*, void (i8*, i32)*, i32 (i8*)*, i32 (i8*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }
%struct._ddebug = type { i8*, i8*, i8*, i8*, i32 }

@__param_str_bit_test = internal constant [9 x i8] c"bit_test\00", align 1
@__this_module = external global %struct.module, align 64
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@bit_test = internal global i32 0, align 4
@__param_bit_test = internal constant %struct.kernel_param { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__param_str_bit_test, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @bit_test to i8*) } }, section "__param", align 8
@__UNIQUE_ID_bit_testtype8 = internal constant [22 x i8] c"parmtype=bit_test:int\00", section ".modinfo", align 1
@__UNIQUE_ID_bit_test9 = internal constant [63 x i8] c"parm=bit_test:lines testing - 0 off; 1 report; 2 fail if stuck\00", section ".modinfo", align 1
@__param_str_i2c_debug = internal constant [10 x i8] c"i2c_debug\00", align 1
@i2c_debug = internal global i32 1, align 4
@__param_i2c_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__param_str_i2c_debug, i32 0, i32 0), %struct.module* @__this_module, %struct.kernel_param_ops* @param_ops_int, i16 420, i8 -1, i8 0, %union.anon.51 { i8* bitcast (i32* @i2c_debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_i2c_debugtype10 = internal constant [23 x i8] c"parmtype=i2c_debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_i2c_debug11 = internal constant [72 x i8] c"parm=i2c_debug:debug level - 0 off; 1 normal; 2 verbose; 3 very verbose\00", section ".modinfo", align 1
@i2c_bit_algo = constant { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_client*)*, i32 (%struct.i2c_client*)* } { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)* @bit_xfer, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)* null, i32 (%struct.i2c_adapter*)* @bit_func, i32 (%struct.i2c_client*)* null, i32 (%struct.i2c_client*)* null }, align 8
@__kstrtab_i2c_bit_algo = internal constant [13 x i8] c"i2c_bit_algo\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_algo = internal constant %struct.kernel_symbol { i64 ptrtoint ({ i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_client*)*, i32 (%struct.i2c_client*)* }* @i2c_bit_algo to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_i2c_bit_algo, i32 0, i32 0) }, section "___ksymtab+i2c_bit_algo", align 8
@__kstrtab_i2c_bit_add_bus = internal constant [16 x i8] c"i2c_bit_add_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_bus to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_i2c_bit_add_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_bus", align 8
@__kstrtab_i2c_bit_add_numbered_bus = internal constant [25 x i8] c"i2c_bit_add_numbered_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_numbered_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_numbered_bus to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_i2c_bit_add_numbered_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_numbered_bus", align 8
@__UNIQUE_ID_author12 = internal constant [47 x i8] c"author=Simon G. Vogl <simon@tk.uni-linz.ac.at>\00", section ".modinfo", align 1
@__UNIQUE_ID_description13 = internal constant [42 x i8] c"description=I2C-Bus bit-banging algorithm\00", section ".modinfo", align 1
@__UNIQUE_ID_license14 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@bit_xfer.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), i8 37, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str = private unnamed_addr constant [13 x i8] c"i2c_algo_bit\00", align 1
@__func__.bit_xfer = private unnamed_addr constant [9 x i8] c"bit_xfer\00", align 1
@.str.1 = private unnamed_addr constant [33 x i8] c"drivers/i2c/algos/i2c-algo-bit.c\00", align 1
@.str.2 = private unnamed_addr constant [26 x i8] c"emitting start condition\0A\00", align 1
@bit_xfer.descriptor.3 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0), i8 45, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.4 = private unnamed_addr constant [35 x i8] c"emitting repeated start condition\0A\00", align 1
@bit_xfer.descriptor.5 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.6, i32 0, i32 0), i8 52, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.6 = private unnamed_addr constant [37 x i8] c"NAK from device addr 0x%02x msg #%d\0A\00", align 1
@bit_xfer.descriptor.7 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8, i32 0, i32 0), i8 61, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.8 = private unnamed_addr constant [16 x i8] c"read %d byte%s\0A\00", align 1
@.str.9 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.10 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@bit_xfer.descriptor.11 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.12, i32 0, i32 0), i8 72, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.12 = private unnamed_addr constant [17 x i8] c"wrote %d byte%s\0A\00", align 1
@bit_xfer.descriptor.13 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.bit_xfer, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0), i8 83, i8 2, i8 4, i8 0 }, section "__verbose", align 8
@.str.14 = private unnamed_addr constant [25 x i8] c"emitting stop condition\0A\00", align 1
@jiffies = external global i64, align 8
@sclhi.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @__func__.sclhi, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.15, i32 0, i32 0), i8 114, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@__func__.sclhi = private unnamed_addr constant [6 x i8] c"sclhi\00", align 1
@.str.15 = private unnamed_addr constant [53 x i8] c"i2c-algo-bit: needed %ld jiffies for SCL to go high\0A\00", align 1
@bit_doAddress.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.bit_doAddress, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16, i32 0, i32 0), i8 -19, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@__func__.bit_doAddress = private unnamed_addr constant [14 x i8] c"bit_doAddress\00", align 1
@.str.16 = private unnamed_addr constant [11 x i8] c"addr0: %d\0A\00", align 1
@.str.17 = private unnamed_addr constant [31 x i8] c"died at extended address code\0A\00", align 1
@.str.18 = private unnamed_addr constant [26 x i8] c"died at 2nd address code\0A\00", align 1
@bit_doAddress.descriptor.19 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @__func__.bit_doAddress, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0), i8 -2, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.20 = private unnamed_addr constant [31 x i8] c"died at repeated address code\0A\00", align 1
@try_address.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.try_address, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0), i8 91, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@__func__.try_address = private unnamed_addr constant [12 x i8] c"try_address\00", align 1
@try_address.descriptor.21 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.try_address, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0), i8 95, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@try_address.descriptor.22 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__func__.try_address, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.23, i32 0, i32 0), i8 102, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@.str.23 = private unnamed_addr constant [42 x i8] c"Used %d tries to %s client at 0x%02x: %s\0A\00", align 1
@.str.24 = private unnamed_addr constant [10 x i8] c"read from\00", align 1
@.str.25 = private unnamed_addr constant [9 x i8] c"write to\00", align 1
@.str.26 = private unnamed_addr constant [8 x i8] c"success\00", align 1
@.str.27 = private unnamed_addr constant [17 x i8] c"failed, timeout?\00", align 1
@i2c_outb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.i2c_outb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.28, i32 0, i32 0), i8 -81, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@__func__.i2c_outb = private unnamed_addr constant [9 x i8] c"i2c_outb\00", align 1
@.str.28 = private unnamed_addr constant [38 x i8] c"i2c_outb: 0x%02x, timeout at bit #%d\0A\00", align 1
@i2c_outb.descriptor.29 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.i2c_outb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.30, i32 0, i32 0), i8 -67, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.30 = private unnamed_addr constant [34 x i8] c"i2c_outb: 0x%02x, timeout at ack\0A\00", align 1
@i2c_outb.descriptor.31 = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @__func__.i2c_outb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.32, i32 0, i32 0), i8 -58, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@.str.32 = private unnamed_addr constant [21 x i8] c"i2c_outb: 0x%02x %s\0A\00", align 1
@.str.33 = private unnamed_addr constant [2 x i8] c"A\00", align 1
@.str.34 = private unnamed_addr constant [3 x i8] c"NA\00", align 1
@.str.35 = private unnamed_addr constant [38 x i8] c"readbytes: invalid block length (%d)\0A\00", align 1
@readbytes.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @__func__.readbytes, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36, i32 0, i32 0), i8 -52, i8 1, i8 4, i8 0 }, section "__verbose", align 8
@__func__.readbytes = private unnamed_addr constant [10 x i8] c"readbytes\00", align 1
@.str.36 = private unnamed_addr constant [22 x i8] c"readbytes: 0x%02x %s\0A\00", align 1
@.str.37 = private unnamed_addr constant [13 x i8] c"(no ack/nak)\00", align 1
@i2c_inb.descriptor = internal global { i8*, i8*, i8*, i8*, i8, i8, i8, i8 } { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @__func__.i2c_inb, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.38, i32 0, i32 0), i8 -37, i8 0, i8 4, i8 0 }, section "__verbose", align 8
@__func__.i2c_inb = private unnamed_addr constant [8 x i8] c"i2c_inb\00", align 1
@.str.38 = private unnamed_addr constant [29 x i8] c"i2c_inb: timeout at bit #%d\0A\00", align 1
@.str.39 = private unnamed_addr constant [28 x i8] c"readbytes: ack/nak timeout\0A\00", align 1
@.str.40 = private unnamed_addr constant [25 x i8] c"sendbytes: NAK bailout.\0A\00", align 1
@.str.41 = private unnamed_addr constant [21 x i8] c"sendbytes: error %d\0A\00", align 1
@i2c_bit_quirk_no_clk_stretch = internal constant %struct.i2c_adapter_quirks { i64 16, i32 0, i16 0, i16 0, i16 0, i16 0 }, align 8
@.str.42 = private unnamed_addr constant [35 x i8] c"Not I2C compliant: can't read SCL\0A\00", align 1
@.str.43 = private unnamed_addr constant [23 x i8] c"Bus may be unreliable\0A\00", align 1
@.str.44 = private unnamed_addr constant [45 x i8] c"\016%s: Testing SDA only, SCL is not readable\0A\00", align 1
@.str.45 = private unnamed_addr constant [45 x i8] c"\014%s: bus seems to be busy (scl=%d, sda=%d)\0A\00", align 1
@.str.46 = private unnamed_addr constant [23 x i8] c"\014%s: SDA stuck high!\0A\00", align 1
@.str.47 = private unnamed_addr constant [49 x i8] c"\014%s: SCL unexpected low while pulling SDA low!\0A\00", align 1
@.str.48 = private unnamed_addr constant [22 x i8] c"\014%s: SDA stuck low!\0A\00", align 1
@.str.49 = private unnamed_addr constant [50 x i8] c"\014%s: SCL unexpected low while pulling SDA high!\0A\00", align 1
@.str.50 = private unnamed_addr constant [23 x i8] c"\014%s: SCL stuck high!\0A\00", align 1
@.str.51 = private unnamed_addr constant [49 x i8] c"\014%s: SDA unexpected low while pulling SCL low!\0A\00", align 1
@.str.52 = private unnamed_addr constant [22 x i8] c"\014%s: SCL stuck low!\0A\00", align 1
@.str.53 = private unnamed_addr constant [50 x i8] c"\014%s: SDA unexpected low while pulling SCL high!\0A\00", align 1
@.str.54 = private unnamed_addr constant [15 x i8] c"\016%s: Test OK\0A\00", align 1
@llvm.used = appending global [12 x i8*] [i8* bitcast (%struct.kernel_param* @__param_bit_test to i8*), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__UNIQUE_ID_bit_testtype8, i32 0, i32 0), i8* getelementptr inbounds ([63 x i8], [63 x i8]* @__UNIQUE_ID_bit_test9, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_i2c_debug to i8*), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__UNIQUE_ID_i2c_debugtype10, i32 0, i32 0), i8* getelementptr inbounds ([72 x i8], [72 x i8]* @__UNIQUE_ID_i2c_debug11, i32 0, i32 0), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_algo to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_bus to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_numbered_bus to i8*), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @__UNIQUE_ID_author12, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @__UNIQUE_ID_description13, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @__UNIQUE_ID_license14, i32 0, i32 0)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define internal i32 @bit_xfer(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msgs, i32 %num) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !37
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %do.body

if.then:                                          ; preds = %entry
  %pre_xfer1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer1, align 8, !tbaa !37
  %call = call i32 %3(%struct.i2c_adapter* %i2c_adap)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %do.body

do.body:                                          ; preds = %entry, %if.then
  %4 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp4 = icmp sge i32 %4, 3
  br i1 %cmp4, label %do.body7, label %do.end17

do.body7:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool8 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %do.end17

if.then11:                                        ; preds = %do.body7
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0))
  br label %do.end17

do.end17:                                         ; preds = %do.body7, %if.then11, %do.body
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end17
  %i.0 = phi i32 [ 0, %do.end17 ], [ %inc, %for.inc ]
  %cmp18 = icmp slt i32 %i.0, %num
  br i1 %cmp18, label %for.body, label %do.body193

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msgs, i64 %idxprom
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %5 = load i16, i16* %flags, align 2, !tbaa !40
  %conv20 = zext i16 %5 to i32
  %and21 = and i32 %conv20, 4096
  %conv22 = trunc i32 %and21 to i16
  %flags23 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %6 = load i16, i16* %flags23, align 2, !tbaa !40
  %conv24 = zext i16 %6 to i32
  %and25 = and i32 %conv24, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.end96, label %if.then27

if.then27:                                        ; preds = %for.body
  %tobool28 = icmp ne i32 %i.0, 0
  br i1 %tobool28, label %do.body30, label %if.end58

do.body30:                                        ; preds = %if.then27
  %7 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp31 = icmp sge i32 %7, 3
  br i1 %cmp31, label %do.body35, label %do.end57

do.body35:                                        ; preds = %do.body30
  %bf.load36 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.3 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr37 = lshr i32 %bf.load36, 18
  %bf.clear38 = and i32 %bf.lshr37, 255
  %and39 = and i32 %bf.clear38, 1
  %tobool40 = icmp ne i32 %and39, 0
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 1)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %if.then48, label %do.end57

if.then48:                                        ; preds = %do.body35
  %dev49 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.3 to %struct._ddebug*), %struct.device* %dev49, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0))
  br label %do.end57

do.end57:                                         ; preds = %do.body35, %if.then48, %do.body30
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %1)
  br label %if.end58

if.end58:                                         ; preds = %do.end57, %if.then27
  %call59 = call i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp60 = icmp eq i32 %call59, 0
  %tobool62 = icmp ne i16 %conv22, 0
  %or.cond = or i1 %cmp60, %tobool62
  br i1 %or.cond, label %if.end96, label %do.body64

do.body64:                                        ; preds = %if.end58
  %8 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp65 = icmp sge i32 %8, 1
  br i1 %cmp65, label %do.body69, label %do.body193

do.body69:                                        ; preds = %do.body64
  %bf.load70 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.5 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr71 = lshr i32 %bf.load70, 18
  %bf.clear72 = and i32 %bf.lshr71, 255
  %and73 = and i32 %bf.clear72, 1
  %tobool74 = icmp ne i32 %and73, 0
  %lnot75 = xor i1 %tobool74, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %conv79 = sext i32 %lnot.ext78 to i64
  %expval80 = call i64 @llvm.expect.i64(i64 %conv79, i64 1)
  %tobool81 = icmp ne i64 %expval80, 0
  br i1 %tobool81, label %if.then82, label %do.body193

if.then82:                                        ; preds = %do.body69
  %dev83 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %idxprom84 = sext i32 %i.0 to i64
  %arrayidx85 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msgs, i64 %idxprom84
  %addr = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx85, i32 0, i32 0
  %9 = load i16, i16* %addr, align 8, !tbaa !43
  %conv86 = zext i16 %9 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.5 to %struct._ddebug*), %struct.device* %dev83, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.6, i32 0, i32 0), i32 %conv86, i32 %i.0)
  br label %do.body193

if.end96:                                         ; preds = %if.end58, %for.body
  %flags97 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %10 = load i16, i16* %flags97, align 2, !tbaa !40
  %conv98 = zext i16 %10 to i32
  %and99 = and i32 %conv98, 1
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %if.then101, label %if.else

if.then101:                                       ; preds = %if.end96
  %call102 = call i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp103 = icmp sge i32 %call102, 1
  %11 = load i32, i32* @i2c_debug, align 4
  %cmp107 = icmp sge i32 %11, 2
  %or.cond1 = and i1 %cmp103, %cmp107
  br i1 %or.cond1, label %do.body111, label %if.end136

do.body111:                                       ; preds = %if.then101
  %bf.load112 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.7 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr113 = lshr i32 %bf.load112, 18
  %bf.clear114 = and i32 %bf.lshr113, 255
  %and115 = and i32 %bf.clear114, 1
  %tobool116 = icmp ne i32 %and115, 0
  %lnot117 = xor i1 %tobool116, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  %expval122 = call i64 @llvm.expect.i64(i64 %conv121, i64 1)
  %tobool123 = icmp ne i64 %expval122, 0
  br i1 %tobool123, label %if.then124, label %if.end136

if.then124:                                       ; preds = %do.body111
  %dev125 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %cmp126 = icmp eq i32 %call102, 1
  %12 = zext i1 %cmp126 to i64
  %cond = select i1 %cmp126, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.10, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.7 to %struct._ddebug*), %struct.device* %dev125, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.8, i32 0, i32 0), i32 %call102, i8* %cond)
  br label %if.end136

if.end136:                                        ; preds = %if.then124, %do.body111, %if.then101
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %13 = load i16, i16* %len, align 4, !tbaa !44
  %conv137 = zext i16 %13 to i32
  %cmp138 = icmp slt i32 %call102, %conv137
  br i1 %cmp138, label %if.then140, label %for.inc

if.then140:                                       ; preds = %if.end136
  %cmp141 = icmp sge i32 %call102, 0
  %.call102 = select i1 %cmp141, i32 -5, i32 %call102
  br label %do.body193

if.else:                                          ; preds = %if.end96
  %call146 = call i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp147 = icmp sge i32 %call146, 1
  %14 = load i32, i32* @i2c_debug, align 4
  %cmp151 = icmp sge i32 %14, 2
  %or.cond2 = and i1 %cmp147, %cmp151
  br i1 %or.cond2, label %do.body155, label %if.end181

do.body155:                                       ; preds = %if.else
  %bf.load156 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.11 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr157 = lshr i32 %bf.load156, 18
  %bf.clear158 = and i32 %bf.lshr157, 255
  %and159 = and i32 %bf.clear158, 1
  %tobool160 = icmp ne i32 %and159, 0
  %lnot161 = xor i1 %tobool160, true
  %lnot163 = xor i1 %lnot161, true
  %lnot.ext164 = zext i1 %lnot163 to i32
  %conv165 = sext i32 %lnot.ext164 to i64
  %expval166 = call i64 @llvm.expect.i64(i64 %conv165, i64 1)
  %tobool167 = icmp ne i64 %expval166, 0
  br i1 %tobool167, label %if.then168, label %if.end181

if.then168:                                       ; preds = %do.body155
  %dev169 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %cmp170 = icmp eq i32 %call146, 1
  %15 = zext i1 %cmp170 to i64
  %cond172 = select i1 %cmp170, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.10, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.11 to %struct._ddebug*), %struct.device* %dev169, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.12, i32 0, i32 0), i32 %call146, i8* %cond172)
  br label %if.end181

if.end181:                                        ; preds = %if.then168, %do.body155, %if.else
  %len182 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %16 = load i16, i16* %len182, align 4, !tbaa !44
  %conv183 = zext i16 %16 to i32
  %cmp184 = icmp slt i32 %call146, %conv183
  br i1 %cmp184, label %if.then186, label %for.inc

if.then186:                                       ; preds = %if.end181
  %cmp187 = icmp sge i32 %call146, 0
  %.call146 = select i1 %cmp187, i32 -5, i32 %call146
  br label %do.body193

for.inc:                                          ; preds = %if.end136, %if.end181
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.body193:                                       ; preds = %if.then140, %if.then186, %do.body69, %if.then82, %do.body64, %for.cond
  %ret.2 = phi i32 [ %.call102, %if.then140 ], [ %.call146, %if.then186 ], [ %call59, %do.body69 ], [ %call59, %if.then82 ], [ %call59, %do.body64 ], [ %i.0, %for.cond ]
  %17 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp194 = icmp sge i32 %17, 3
  br i1 %cmp194, label %do.body198, label %do.end220

do.body198:                                       ; preds = %do.body193
  %bf.load199 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.13 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr200 = lshr i32 %bf.load199, 18
  %bf.clear201 = and i32 %bf.lshr200, 255
  %and202 = and i32 %bf.clear201, 1
  %tobool203 = icmp ne i32 %and202, 0
  %lnot204 = xor i1 %tobool203, true
  %lnot206 = xor i1 %lnot204, true
  %lnot.ext207 = zext i1 %lnot206 to i32
  %conv208 = sext i32 %lnot.ext207 to i64
  %expval209 = call i64 @llvm.expect.i64(i64 %conv208, i64 1)
  %tobool210 = icmp ne i64 %expval209, 0
  br i1 %tobool210, label %if.then211, label %do.end220

if.then211:                                       ; preds = %do.body198
  %dev212 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_xfer.descriptor.13 to %struct._ddebug*), %struct.device* %dev212, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0))
  br label %do.end220

do.end220:                                        ; preds = %do.body198, %if.then211, %do.body193
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %18 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !45
  %tobool221 = icmp ne void (%struct.i2c_adapter*)* %18, null
  br i1 %tobool221, label %if.then222, label %cleanup

if.then222:                                       ; preds = %do.end220
  %post_xfer223 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %19 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer223, align 8, !tbaa !45
  call void %19(%struct.i2c_adapter* %i2c_adap)
  br label %cleanup

cleanup:                                          ; preds = %do.end220, %if.then222, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %ret.2, %if.then222 ], [ %ret.2, %do.end220 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_func(%struct.i2c_adapter* %adap) #0 {
entry:
  ret i32 268402719
}

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_bus(%struct.i2c_adapter* %adap) #0 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_adapter)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* %add_adapter) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %2 = load i32, i32* @bit_test, align 4, !tbaa !39
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %call = call i32 @test_bus(%struct.i2c_adapter* %adap)
  %3 = load i32, i32* @bit_test, align 4, !tbaa !39
  %cmp = icmp sge i32 %3, 2
  %cmp1 = icmp slt i32 %call, 0
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.then, %entry
  %algo = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 2
  store %struct.i2c_algorithm* bitcast ({ i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_client*)*, i32 (%struct.i2c_client*)* }* @i2c_bit_algo to %struct.i2c_algorithm*), %struct.i2c_algorithm** %algo, align 8, !tbaa !46
  %retries = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 8
  store i32 3, i32* %retries, align 4, !tbaa !47
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !48
  %cmp4 = icmp eq i32 (i8*)* %4, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %quirks = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 16
  store %struct.i2c_adapter_quirks* @i2c_bit_quirk_no_clk_stretch, %struct.i2c_adapter_quirks** %quirks, align 8, !tbaa !49
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %call7 = call i32 %add_adapter(%struct.i2c_adapter* %adap)
  %cmp8 = icmp slt i32 %call7, 0
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %getscl11 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %5 = load i32 (i8*)*, i32 (i8*)** %getscl11, align 8, !tbaa !48
  %cmp12 = icmp eq i32 (i8*)* %5, null
  br i1 %cmp12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %if.end10
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.42, i32 0, i32 0))
  %dev14 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev14, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.43, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then13, %if.end6, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ %call7, %if.end6 ], [ 0, %if.then13 ], [ 0, %if.end10 ]
  ret i32 %retval.0
}

declare i32 @i2c_add_adapter(%struct.i2c_adapter*) #1

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_numbered_bus(%struct.i2c_adapter* %adap) #0 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_numbered_adapter)
  ret i32 %call
}

declare i32 @i2c_add_numbered_adapter(%struct.i2c_adapter*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #3

declare void @__dynamic_dev_dbg(%struct._ddebug*, %struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal void @i2c_start(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !51
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !52
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @i2c_repstart(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  call void @sdahi(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !51
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !52
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #0 {
entry:
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %0 = load i16, i16* %flags1, align 2, !tbaa !40
  %flags2 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %1 = load i16, i16* %flags2, align 2, !tbaa !40
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 4096
  %conv3 = trunc i32 %and to i16
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %2 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %3 = bitcast i8* %2 to %struct.i2c_algo_bit_data*
  %conv4 = zext i16 %conv3 to i32
  %tobool = icmp ne i32 %conv4, 0
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %retries5 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 8
  %4 = load i32, i32* %retries5, align 4, !tbaa !47
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi i32 [ %4, %cond.false ], [ 0, %entry ]
  %conv6 = zext i16 %0 to i32
  %and7 = and i32 %conv6, 16
  %tobool8 = icmp ne i32 %and7, 0
  %addr9 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %5 = load i16, i16* %addr9, align 8, !tbaa !43
  %conv10 = zext i16 %5 to i32
  br i1 %tobool8, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %shr = ashr i32 %conv10, 7
  %and11 = and i32 %shr, 6
  %or = or i32 240, %and11
  %conv12 = trunc i32 %or to i8
  %6 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp = icmp sge i32 %6, 2
  br i1 %cmp, label %do.body16, label %do.end28

do.body16:                                        ; preds = %if.then
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and17 = and i32 %bf.clear, 1
  %tobool18 = icmp ne i32 %and17, 0
  %lnot = xor i1 %tobool18, true
  %lnot19 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv20 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv20, i64 1)
  %tobool21 = icmp ne i64 %expval, 0
  br i1 %tobool21, label %if.then22, label %do.end28

if.then22:                                        ; preds = %do.body16
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %conv23 = zext i8 %conv12 to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.16, i32 0, i32 0), i32 %conv23)
  br label %do.end28

do.end28:                                         ; preds = %do.body16, %if.then22, %if.then
  %call = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv12, i32 %cond)
  %cmp29 = icmp eq i32 %call, 1
  %tobool31 = icmp ne i16 %conv3, 0
  %or.cond = or i1 %cmp29, %tobool31
  br i1 %or.cond, label %if.end34, label %if.then32

if.then32:                                        ; preds = %do.end28
  %dev33 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev33, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.17, i32 0, i32 0))
  br label %cleanup

if.end34:                                         ; preds = %do.end28
  %addr35 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %7 = load i16, i16* %addr35, align 8, !tbaa !43
  %conv36 = zext i16 %7 to i32
  %and37 = and i32 %conv36, 255
  %conv38 = trunc i32 %and37 to i8
  %call39 = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv38)
  %cmp40 = icmp eq i32 %call39, 1
  %tobool43 = icmp ne i16 %conv3, 0
  %or.cond1 = or i1 %cmp40, %tobool43
  br i1 %or.cond1, label %if.end46, label %if.then44

if.then44:                                        ; preds = %if.end34
  %dev45 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev45, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.18, i32 0, i32 0))
  br label %cleanup

if.end46:                                         ; preds = %if.end34
  %conv47 = zext i16 %0 to i32
  %and48 = and i32 %conv47, 1
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %do.body51, label %if.end116

do.body51:                                        ; preds = %if.end46
  %8 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp52 = icmp sge i32 %8, 3
  br i1 %cmp52, label %do.body56, label %do.end78

do.body56:                                        ; preds = %do.body51
  %bf.load57 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor.19 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr58 = lshr i32 %bf.load57, 18
  %bf.clear59 = and i32 %bf.lshr58, 255
  %and60 = and i32 %bf.clear59, 1
  %tobool61 = icmp ne i32 %and60, 0
  %lnot62 = xor i1 %tobool61, true
  %lnot64 = xor i1 %lnot62, true
  %lnot.ext65 = zext i1 %lnot64 to i32
  %conv66 = sext i32 %lnot.ext65 to i64
  %expval67 = call i64 @llvm.expect.i64(i64 %conv66, i64 1)
  %tobool68 = icmp ne i64 %expval67, 0
  br i1 %tobool68, label %if.then69, label %do.end78

if.then69:                                        ; preds = %do.body56
  %dev70 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @bit_doAddress.descriptor.19 to %struct._ddebug*), %struct.device* %dev70, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.4, i32 0, i32 0))
  br label %do.end78

do.end78:                                         ; preds = %do.body56, %if.then69, %do.body51
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %3)
  %conv79 = zext i8 %conv12 to i32
  %or80 = or i32 %conv79, 1
  %conv81 = trunc i32 %or80 to i8
  %call82 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv81, i32 %cond)
  %cmp83 = icmp eq i32 %call82, 1
  %tobool86 = icmp ne i16 %conv3, 0
  %or.cond2 = or i1 %cmp83, %tobool86
  br i1 %or.cond2, label %if.end116, label %if.then87

if.then87:                                        ; preds = %do.end78
  %dev88 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev88, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.20, i32 0, i32 0))
  br label %cleanup

if.else:                                          ; preds = %cond.end
  %shl = shl i32 %conv10, 1
  %conv93 = trunc i32 %shl to i8
  %conv94 = zext i16 %0 to i32
  %and95 = and i32 %conv94, 1
  %tobool96 = icmp ne i32 %and95, 0
  %conv98 = zext i8 %conv93 to i32
  %or99 = or i32 %conv98, 1
  %conv100 = trunc i32 %or99 to i8
  %addr.0 = select i1 %tobool96, i8 %conv100, i8 %conv93
  %conv102 = zext i16 %0 to i32
  %and103 = and i32 %conv102, 8192
  %tobool104 = icmp ne i32 %and103, 0
  %conv106 = zext i8 %addr.0 to i32
  %xor = xor i32 %conv106, 1
  %conv107 = trunc i32 %xor to i8
  %addr.1 = select i1 %tobool104, i8 %conv107, i8 %addr.0
  %call109 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr.1, i32 %cond)
  %cmp110 = icmp eq i32 %call109, 1
  %tobool113 = icmp ne i16 %conv3, 0
  %or.cond3 = or i1 %cmp110, %tobool113
  br i1 %or.cond3, label %if.end116, label %cleanup

if.end116:                                        ; preds = %if.else, %if.end46, %do.end78
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.end116, %if.then87, %if.then44, %if.then32
  %retval.0 = phi i32 [ 0, %if.end116 ], [ -5, %if.then87 ], [ -6, %if.then44 ], [ -6, %if.then32 ], [ -6, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #0 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !53
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !44
  %conv = zext i16 %1 to i32
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags1, align 2, !tbaa !40
  %conv2 = zext i16 %2 to i32
  br label %while.cond

while.cond:                                       ; preds = %if.end56, %entry
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.end56 ]
  %rdcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.end56 ]
  %count.0 = phi i32 [ %conv, %entry ], [ %count.1, %if.end56 ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %call = call i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap)
  %cmp4 = icmp sge i32 %call, 0
  br i1 %cmp4, label %if.then, label %cleanup

if.then:                                          ; preds = %while.body
  %conv6 = trunc i32 %call to i8
  store i8 %conv6, i8* %temp.0, align 1, !tbaa !54
  %inc = add nsw i32 %rdcount.0, 1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %dec = add nsw i32 %count.0, -1
  %cmp7 = icmp eq i32 %inc, 1
  %and = and i32 %conv2, 1024
  %tobool = icmp ne i32 %and, 0
  %or.cond = and i1 %cmp7, %tobool
  br i1 %or.cond, label %if.then9, label %do.body

if.then9:                                         ; preds = %if.then
  %cmp10 = icmp sle i32 %call, 0
  %cmp12 = icmp sgt i32 %call, 32
  %or.cond1 = or i1 %cmp10, %cmp12
  br i1 %or.cond1, label %if.then14, label %if.end20

if.then14:                                        ; preds = %if.then9
  %and15 = and i32 %conv2, 2048
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then14
  %call18 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 0)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.then14
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.35, i32 0, i32 0), i32 %call)
  br label %cleanup

if.end20:                                         ; preds = %if.then9
  %add = add nsw i32 %dec, %call
  %len21 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %3 = load i16, i16* %len21, align 4, !tbaa !44
  %conv22 = zext i16 %3 to i32
  %add23 = add nsw i32 %conv22, %call
  %conv24 = trunc i32 %add23 to i16
  store i16 %conv24, i16* %len21, align 4, !tbaa !44
  br label %do.body

do.body:                                          ; preds = %if.then, %if.end20
  %count.1 = phi i32 [ %add, %if.end20 ], [ %dec, %if.then ]
  %4 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp26 = icmp sge i32 %4, 2
  br i1 %cmp26, label %do.body30, label %do.end47

do.body30:                                        ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @readbytes.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and31 = and i32 %bf.clear, 1
  %tobool32 = icmp ne i32 %and31, 0
  %lnot = xor i1 %tobool32, true
  %lnot33 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot33 to i32
  %conv34 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv34, i64 1)
  %tobool35 = icmp ne i64 %expval, 0
  br i1 %tobool35, label %if.then36, label %do.end47

if.then36:                                        ; preds = %do.body30
  %dev37 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %and38 = and i32 %conv2, 2048
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.then36
  %tobool40 = icmp ne i32 %count.1, 0
  %5 = zext i1 %tobool40 to i64
  %cond = select i1 %tobool40, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %if.then36, %cond.false
  %cond41 = phi i8* [ %cond, %cond.false ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @.str.37, i32 0, i32 0), %if.then36 ]
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @readbytes.descriptor to %struct._ddebug*), %struct.device* %dev37, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.36, i32 0, i32 0), i32 %call, i8* %cond41)
  br label %do.end47

do.end47:                                         ; preds = %do.body30, %cond.end, %do.body
  %and48 = and i32 %conv2, 2048
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %if.end56, label %if.then50

if.then50:                                        ; preds = %do.end47
  %call51 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %count.1)
  %cmp52 = icmp slt i32 %call51, 0
  br i1 %cmp52, label %cleanup, label %if.end56

if.end56:                                         ; preds = %if.then50, %do.end47
  br label %while.cond

cleanup:                                          ; preds = %while.body, %while.cond, %if.then50, %if.end19
  %retval.0 = phi i32 [ -71, %if.end19 ], [ %call51, %if.then50 ], [ %rdcount.0, %while.cond ], [ %rdcount.0, %while.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #0 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !53
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !44
  %conv = zext i16 %1 to i32
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags, align 2, !tbaa !40
  %conv1 = zext i16 %2 to i32
  %and = and i32 %conv1, 4096
  %conv2 = trunc i32 %and to i16
  br label %while.cond

while.cond:                                       ; preds = %if.then, %entry
  %count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.then ]
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.then ]
  %wrcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.then ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i8, i8* %temp.0, align 1, !tbaa !54
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %3)
  %cmp5 = icmp sgt i32 %call, 0
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %conv7 = zext i16 %conv2 to i32
  %tobool = icmp ne i32 %conv7, 0
  %cmp8 = icmp eq i32 %call, 0
  %or.cond = and i1 %tobool, %cmp8
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.body
  %dec = add nsw i32 %count.0, -1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %inc = add nsw i32 %wrcount.0, 1
  br label %while.cond

if.else:                                          ; preds = %lor.lhs.false
  %cmp10 = icmp eq i32 %call, 0
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  br i1 %cmp10, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.40, i32 0, i32 0))
  br label %cleanup

if.else13:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.41, i32 0, i32 0), i32 %call)
  br label %cleanup

cleanup:                                          ; preds = %while.cond, %if.else13, %if.then12
  %retval.0 = phi i32 [ -5, %if.then12 ], [ %call, %if.else13 ], [ %wrcount.0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @i2c_stop(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  call void @sdalo(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !51
  call void %0(i8* %1, i32 1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !52
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare void @__udelay(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @scllo(%struct.i2c_algo_bit_data* %adap) #4 {
entry:
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !55
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !51
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !52
  %div = sdiv i32 %2, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdahi(%struct.i2c_algo_bit_data* %adap) #4 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !51
  call void %0(i8* %1, i32 1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !52
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sclhi(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy5 = alloca i64, align 8
  %__dummy26 = alloca i64, align 8
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !55
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !51
  call void %0(i8* %1, i32 1)
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %2 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !48
  %tobool = icmp ne i32 (i8*)* %2, null
  br i1 %tobool, label %if.end, label %done

if.end:                                           ; preds = %entry
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !56
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.end
  %getscl1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl1, align 8, !tbaa !48
  %data2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %5 = load i8*, i8** %data2, align 8, !tbaa !51
  %call = call i32 %4(i8* %5)
  %tobool3 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool3, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #6
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #6
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #6
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #6
  %tobool4 = icmp ne i32 1, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %while.body
  %10 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #6
  %11 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #6
  %cmp7 = icmp eq i64* %__dummy5, %__dummy26
  %conv8 = zext i1 %cmp7 to i32
  %12 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #6
  %13 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #6
  %timeout = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 8
  %14 = load i32, i32* %timeout, align 4, !tbaa !57
  %conv12 = sext i32 %14 to i64
  %add = add i64 %3, %conv12
  %15 = load volatile i64, i64* @jiffies, align 8, !tbaa !56
  %sub = sub i64 %add, %15
  %cmp13 = icmp slt i64 %sub, 0
  br i1 %cmp13, label %if.then15, label %if.end22

if.then15:                                        ; preds = %land.lhs.true
  %getscl16 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %16 = load i32 (i8*)*, i32 (i8*)** %getscl16, align 8, !tbaa !48
  %data17 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %17 = load i8*, i8** %data17, align 8, !tbaa !51
  %call18 = call i32 %16(i8* %17)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %while.end, label %cleanup

if.end22:                                         ; preds = %land.lhs.true, %while.body
  call void @cpu_relax()
  br label %while.cond

while.end:                                        ; preds = %while.cond, %if.then15
  %18 = load volatile i64, i64* @jiffies, align 8, !tbaa !56
  %cmp23 = icmp ne i64 %18, %3
  %19 = load i32, i32* @i2c_debug, align 4
  %cmp26 = icmp sge i32 %19, 3
  %or.cond = and i1 %cmp23, %cmp26
  br i1 %or.cond, label %do.body, label %done

do.body:                                          ; preds = %while.end
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @sclhi.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool29 = icmp ne i32 %and, 0
  %lnot30 = xor i1 %tobool29, true
  %lnot31 = xor i1 %lnot30, true
  %lnot.ext = zext i1 %lnot31 to i32
  %conv32 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv32, i64 1)
  %tobool33 = icmp ne i64 %expval, 0
  br i1 %tobool33, label %if.then34, label %done

if.then34:                                        ; preds = %do.body
  %20 = load volatile i64, i64* @jiffies, align 8, !tbaa !56
  %sub35 = sub i64 %20, %3
  call void (%struct._ddebug*, i8*, ...) @__dynamic_pr_debug(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @sclhi.descriptor to %struct._ddebug*), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.15, i32 0, i32 0), i64 %sub35)
  br label %done

done:                                             ; preds = %while.end, %if.then34, %do.body, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %21 = load i32, i32* %udelay, align 8, !tbaa !52
  %conv38 = sext i32 %21 to i64
  call void @__udelay(i64 %conv38)
  br label %cleanup

cleanup:                                          ; preds = %if.then15, %done
  %retval.0 = phi i32 [ 0, %done ], [ -110, %if.then15 ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @cpu_relax() #5 {
entry:
  call void @rep_nop()
  ret void
}

declare void @__dynamic_pr_debug(%struct._ddebug*, i8*, ...) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @rep_nop() #5 {
entry:
  call void asm sideeffect "rep; nop", "~{memory},~{dirflag},~{fpsr},~{flags}"() #6, !srcloc !58
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr, i32 %retries) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %do.end44, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %do.end44 ]
  %ret.0 = phi i32 [ 0, %entry ], [ %call, %do.end44 ]
  %cmp = icmp sle i32 %i.0, %retries
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr)
  %cmp1 = icmp eq i32 %call, 1
  %cmp2 = icmp eq i32 %i.0, %retries
  %or.cond = or i1 %cmp1, %cmp2
  br i1 %or.cond, label %for.end, label %do.body

do.body:                                          ; preds = %for.body
  %2 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp3 = icmp sge i32 %2, 3
  br i1 %cmp3, label %do.body6, label %do.end15

do.body6:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %do.end15

if.then9:                                         ; preds = %do.body6
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0))
  br label %do.end15

do.end15:                                         ; preds = %do.body6, %if.then9, %do.body
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %3 = load i32, i32* %udelay, align 8, !tbaa !52
  %conv16 = sext i32 %3 to i64
  call void @__udelay(i64 %conv16)
  call void @yield()
  %4 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp18 = icmp sge i32 %4, 3
  br i1 %cmp18, label %do.body22, label %do.end44

do.body22:                                        ; preds = %do.end15
  %bf.load23 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.21 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr24 = lshr i32 %bf.load23, 18
  %bf.clear25 = and i32 %bf.lshr24, 255
  %and26 = and i32 %bf.clear25, 1
  %tobool27 = icmp ne i32 %and26, 0
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot.ext31 = zext i1 %lnot30 to i32
  %conv32 = sext i32 %lnot.ext31 to i64
  %expval33 = call i64 @llvm.expect.i64(i64 %conv32, i64 1)
  %tobool34 = icmp ne i64 %expval33, 0
  br i1 %tobool34, label %if.then35, label %do.end44

if.then35:                                        ; preds = %do.body22
  %dev36 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.21 to %struct._ddebug*), %struct.device* %dev36, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.2, i32 0, i32 0))
  br label %do.end44

do.end44:                                         ; preds = %do.body22, %if.then35, %do.end15
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %ret.1 = phi i32 [ %call, %for.body ], [ %ret.0, %for.cond ]
  %tobool45 = icmp ne i32 %i.0, 0
  %tobool46 = icmp ne i32 %ret.1, 0
  %or.cond1 = and i1 %tobool45, %tobool46
  %5 = load i32, i32* @i2c_debug, align 4
  %cmp49 = icmp sge i32 %5, 1
  %or.cond2 = and i1 %or.cond1, %cmp49
  br i1 %or.cond2, label %do.body53, label %if.end83

do.body53:                                        ; preds = %for.end
  %bf.load54 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.22 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr55 = lshr i32 %bf.load54, 18
  %bf.clear56 = and i32 %bf.lshr55, 255
  %and57 = and i32 %bf.clear56, 1
  %tobool58 = icmp ne i32 %and57, 0
  %lnot59 = xor i1 %tobool58, true
  %lnot61 = xor i1 %lnot59, true
  %lnot.ext62 = zext i1 %lnot61 to i32
  %conv63 = sext i32 %lnot.ext62 to i64
  %expval64 = call i64 @llvm.expect.i64(i64 %conv63, i64 1)
  %tobool65 = icmp ne i64 %expval64, 0
  br i1 %tobool65, label %if.then66, label %if.end83

if.then66:                                        ; preds = %do.body53
  %dev67 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %add = add nsw i32 %i.0, 1
  %conv68 = zext i8 %addr to i32
  %and69 = and i32 %conv68, 1
  %tobool70 = icmp ne i32 %and69, 0
  %6 = zext i1 %tobool70 to i64
  %cond = select i1 %tobool70, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.25, i32 0, i32 0)
  %conv71 = zext i8 %addr to i32
  %shr = ashr i32 %conv71, 1
  %cmp72 = icmp eq i32 %ret.1, 1
  %7 = zext i1 %cmp72 to i64
  %cond74 = select i1 %cmp72, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.27, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @try_address.descriptor.22 to %struct._ddebug*), %struct.device* %dev67, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.23, i32 0, i32 0), i32 %add, i8* %cond, i32 %shr, i8* %cond74)
  br label %if.end83

if.end83:                                         ; preds = %if.then66, %do.body53, %for.end
  ret i32 %ret.1
}

declare void @dev_err(%struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %c) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %if.end20, %entry
  %i.0 = phi i32 [ 7, %entry ], [ %dec, %if.end20 ]
  %cmp = icmp sge i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %conv = zext i8 %c to i32
  %shr = ashr i32 %conv, %i.0
  %and = and i32 %shr, 1
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !51
  call void %2(i8* %3, i32 %and)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !52
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv1 = sext i32 %div to i64
  call void @__udelay(i64 %conv1)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %do.body, label %if.end20

do.body:                                          ; preds = %for.body
  %5 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp4 = icmp sge i32 %5, 1
  br i1 %cmp4, label %do.body8, label %cleanup

do.body8:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and9 = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and9, 0
  %lnot = xor i1 %tobool, true
  %lnot10 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 1)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %do.body8
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %conv14 = zext i8 %c to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.28, i32 0, i32 0), i32 %conv14, i32 %i.0)
  br label %cleanup

if.end20:                                         ; preds = %for.body
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call21 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp22 = icmp slt i32 %call21, 0
  br i1 %cmp22, label %do.body25, label %if.end54

do.body25:                                        ; preds = %for.end
  %6 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp26 = icmp sge i32 %6, 1
  br i1 %cmp26, label %do.body30, label %cleanup

do.body30:                                        ; preds = %do.body25
  %bf.load31 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.29 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr32 = lshr i32 %bf.load31, 18
  %bf.clear33 = and i32 %bf.lshr32, 255
  %and34 = and i32 %bf.clear33, 1
  %tobool35 = icmp ne i32 %and34, 0
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %expval41 = call i64 @llvm.expect.i64(i64 %conv40, i64 1)
  %tobool42 = icmp ne i64 %expval41, 0
  br i1 %tobool42, label %if.then43, label %cleanup

if.then43:                                        ; preds = %do.body30
  %dev44 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %conv45 = zext i8 %c to i32
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.29 to %struct._ddebug*), %struct.device* %dev44, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.30, i32 0, i32 0), i32 %conv45)
  br label %cleanup

if.end54:                                         ; preds = %for.end
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %7 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !59
  %data55 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %8 = load i8*, i8** %data55, align 8, !tbaa !51
  %call56 = call i32 %7(i8* %8)
  %tobool57 = icmp ne i32 %call56, 0
  %lnot58 = xor i1 %tobool57, true
  %lnot.ext59 = zext i1 %lnot58 to i32
  %9 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp61 = icmp sge i32 %9, 2
  br i1 %cmp61, label %do.body65, label %do.end89

do.body65:                                        ; preds = %if.end54
  %bf.load66 = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.31 to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr67 = lshr i32 %bf.load66, 18
  %bf.clear68 = and i32 %bf.lshr67, 255
  %and69 = and i32 %bf.clear68, 1
  %tobool70 = icmp ne i32 %and69, 0
  %lnot71 = xor i1 %tobool70, true
  %lnot73 = xor i1 %lnot71, true
  %lnot.ext74 = zext i1 %lnot73 to i32
  %conv75 = sext i32 %lnot.ext74 to i64
  %expval76 = call i64 @llvm.expect.i64(i64 %conv75, i64 1)
  %tobool77 = icmp ne i64 %expval76, 0
  br i1 %tobool77, label %if.then78, label %do.end89

if.then78:                                        ; preds = %do.body65
  %dev79 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %conv80 = zext i8 %c to i32
  %tobool81 = icmp ne i32 %lnot.ext59, 0
  %10 = zext i1 %tobool81 to i64
  %cond = select i1 %tobool81, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.33, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0)
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_outb.descriptor.31 to %struct._ddebug*), %struct.device* %dev79, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.32, i32 0, i32 0), i32 %conv80, i8* %cond)
  br label %do.end89

do.end89:                                         ; preds = %do.body65, %if.then78, %if.end54
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %do.body25, %if.then43, %do.body30, %do.body, %if.then13, %do.body8, %do.end89
  %retval.0 = phi i32 [ %lnot.ext59, %do.end89 ], [ -110, %do.body8 ], [ -110, %if.then13 ], [ -110, %do.body ], [ -110, %do.body30 ], [ -110, %if.then43 ], [ -110, %do.body25 ]
  ret i32 %retval.0
}

declare void @yield() #1

; Function Attrs: nounwind uwtable
define internal i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %if.end14, %entry
  %indata.0 = phi i8 [ 0, %entry ], [ %indata.1, %if.end14 ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end14 ]
  %cmp = icmp slt i32 %i.0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %do.body, label %if.end14

do.body:                                          ; preds = %for.body
  %2 = load i32, i32* @i2c_debug, align 4, !tbaa !39
  %cmp2 = icmp sge i32 %2, 1
  br i1 %cmp2, label %do.body5, label %cleanup

do.body5:                                         ; preds = %do.body
  %bf.load = load i32, i32* getelementptr inbounds (%struct._ddebug, %struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_inb.descriptor to %struct._ddebug*), i32 0, i32 4), align 8
  %bf.lshr = lshr i32 %bf.load, 18
  %bf.clear = and i32 %bf.lshr, 255
  %and = and i32 %bf.clear, 1
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then8, label %cleanup

if.then8:                                         ; preds = %do.body5
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %sub = sub nsw i32 7, %i.0
  call void (%struct._ddebug*, %struct.device*, i8*, ...) @__dynamic_dev_dbg(%struct._ddebug* bitcast ({ i8*, i8*, i8*, i8*, i8, i8, i8, i8 }* @i2c_inb.descriptor to %struct._ddebug*), %struct.device* %dev, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.38, i32 0, i32 0), i32 %sub)
  br label %cleanup

if.end14:                                         ; preds = %for.body
  %conv15 = zext i8 %indata.0 to i32
  %mul = mul nsw i32 %conv15, 2
  %conv16 = trunc i32 %mul to i8
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %3 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !59
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %4 = load i8*, i8** %data, align 8, !tbaa !51
  %call17 = call i32 %3(i8* %4)
  %tobool18 = icmp ne i32 %call17, 0
  %conv20 = zext i8 %conv16 to i32
  %or = or i32 %conv20, 1
  %conv21 = trunc i32 %or to i8
  %indata.1 = select i1 %tobool18, i8 %conv21, i8 %conv16
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 2
  %5 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !55
  %data23 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %6 = load i8*, i8** %data23, align 8, !tbaa !51
  call void %5(i8* %6, i32 0)
  %cmp24 = icmp eq i32 %i.0, 7
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %7 = load i32, i32* %udelay, align 8, !tbaa !52
  %div = sdiv i32 %7, 2
  %cond = select i1 %cmp24, i32 %div, i32 %7
  %conv27 = sext i32 %cond to i64
  call void @__udelay(i64 %conv27)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv28 = zext i8 %indata.0 to i32
  br label %cleanup

cleanup:                                          ; preds = %do.body, %if.then8, %do.body5, %for.end
  %retval.0 = phi i32 [ %conv28, %for.end ], [ -110, %do.body5 ], [ -110, %if.then8 ], [ -110, %do.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %is_ack) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %tobool = icmp ne i32 %is_ack, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !51
  call void %2(i8* %3, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !52
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.39, i32 0, i32 0))
  br label %cleanup

if.end3:                                          ; preds = %if.end
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.then2
  %retval.0 = phi i32 [ -110, %if.then2 ], [ 0, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdalo(%struct.i2c_algo_bit_data* %adap) #4 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !50
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !51
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !52
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @test_bus(%struct.i2c_adapter* %i2c_adap) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %name1 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 11
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %name1, i32 0, i32 0
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !37
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %pre_xfer2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer2, align 8, !tbaa !37
  %call = call i32 %3(%struct.i2c_adapter* %i2c_adap)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.then, %entry
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !48
  %cmp5 = icmp eq i32 (i8*)* %4, null
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.44, i32 0, i32 0), i8* %arraydecay)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %5 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !59
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %6 = load i8*, i8** %data, align 8, !tbaa !51
  %call9 = call i32 %5(i8* %6)
  %getscl10 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %7 = load i32 (i8*)*, i32 (i8*)** %getscl10, align 8, !tbaa !48
  %cmp11 = icmp eq i32 (i8*)* %7, null
  br i1 %cmp11, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end8
  %getscl12 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %8 = load i32 (i8*)*, i32 (i8*)** %getscl12, align 8, !tbaa !48
  %data13 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %9 = load i8*, i8** %data13, align 8, !tbaa !51
  %call14 = call i32 %8(i8* %9)
  br label %cond.end

cond.end:                                         ; preds = %if.end8, %cond.false
  %cond = phi i32 [ %call14, %cond.false ], [ 1, %if.end8 ]
  %tobool15 = icmp ne i32 %cond, 0
  %tobool16 = icmp ne i32 %call9, 0
  %or.cond = and i1 %tobool15, %tobool16
  br i1 %or.cond, label %if.end19, label %if.then17

if.then17:                                        ; preds = %cond.end
  %call18 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.45, i32 0, i32 0), i8* %arraydecay, i32 %cond, i32 %call9)
  br label %bailout

if.end19:                                         ; preds = %cond.end
  call void @sdalo(%struct.i2c_algo_bit_data* %1)
  %getsda20 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %10 = load i32 (i8*)*, i32 (i8*)** %getsda20, align 8, !tbaa !59
  %data21 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %11 = load i8*, i8** %data21, align 8, !tbaa !51
  %call22 = call i32 %10(i8* %11)
  %getscl23 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %12 = load i32 (i8*)*, i32 (i8*)** %getscl23, align 8, !tbaa !48
  %cmp24 = icmp eq i32 (i8*)* %12, null
  br i1 %cmp24, label %cond.end30, label %cond.false26

cond.false26:                                     ; preds = %if.end19
  %getscl27 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %13 = load i32 (i8*)*, i32 (i8*)** %getscl27, align 8, !tbaa !48
  %data28 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %14 = load i8*, i8** %data28, align 8, !tbaa !51
  %call29 = call i32 %13(i8* %14)
  br label %cond.end30

cond.end30:                                       ; preds = %if.end19, %cond.false26
  %cond31 = phi i32 [ %call29, %cond.false26 ], [ 1, %if.end19 ]
  %tobool32 = icmp ne i32 %call22, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %cond.end30
  %call34 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.46, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end35:                                         ; preds = %cond.end30
  %tobool36 = icmp ne i32 %cond31, 0
  br i1 %tobool36, label %if.end39, label %if.then37

if.then37:                                        ; preds = %if.end35
  %call38 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.47, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end39:                                         ; preds = %if.end35
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %getsda40 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %15 = load i32 (i8*)*, i32 (i8*)** %getsda40, align 8, !tbaa !59
  %data41 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %16 = load i8*, i8** %data41, align 8, !tbaa !51
  %call42 = call i32 %15(i8* %16)
  %getscl43 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %17 = load i32 (i8*)*, i32 (i8*)** %getscl43, align 8, !tbaa !48
  %cmp44 = icmp eq i32 (i8*)* %17, null
  br i1 %cmp44, label %cond.end50, label %cond.false46

cond.false46:                                     ; preds = %if.end39
  %getscl47 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %18 = load i32 (i8*)*, i32 (i8*)** %getscl47, align 8, !tbaa !48
  %data48 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %19 = load i8*, i8** %data48, align 8, !tbaa !51
  %call49 = call i32 %18(i8* %19)
  br label %cond.end50

cond.end50:                                       ; preds = %if.end39, %cond.false46
  %cond51 = phi i32 [ %call49, %cond.false46 ], [ 1, %if.end39 ]
  %tobool52 = icmp ne i32 %call42, 0
  br i1 %tobool52, label %if.end55, label %if.then53

if.then53:                                        ; preds = %cond.end50
  %call54 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.48, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end55:                                         ; preds = %cond.end50
  %tobool56 = icmp ne i32 %cond51, 0
  br i1 %tobool56, label %if.end59, label %if.then57

if.then57:                                        ; preds = %if.end55
  %call58 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.49, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end59:                                         ; preds = %if.end55
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %getsda60 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %20 = load i32 (i8*)*, i32 (i8*)** %getsda60, align 8, !tbaa !59
  %data61 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %21 = load i8*, i8** %data61, align 8, !tbaa !51
  %call62 = call i32 %20(i8* %21)
  %getscl63 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %22 = load i32 (i8*)*, i32 (i8*)** %getscl63, align 8, !tbaa !48
  %cmp64 = icmp eq i32 (i8*)* %22, null
  br i1 %cmp64, label %cond.end70, label %cond.false66

cond.false66:                                     ; preds = %if.end59
  %getscl67 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %23 = load i32 (i8*)*, i32 (i8*)** %getscl67, align 8, !tbaa !48
  %data68 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %24 = load i8*, i8** %data68, align 8, !tbaa !51
  %call69 = call i32 %23(i8* %24)
  br label %cond.end70

cond.end70:                                       ; preds = %if.end59, %cond.false66
  %cond71 = phi i32 [ %call69, %cond.false66 ], [ 0, %if.end59 ]
  %tobool72 = icmp ne i32 %cond71, 0
  br i1 %tobool72, label %if.then73, label %if.end75

if.then73:                                        ; preds = %cond.end70
  %call74 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.50, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end75:                                         ; preds = %cond.end70
  %tobool76 = icmp ne i32 %call62, 0
  br i1 %tobool76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %if.end75
  %call78 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.51, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end79:                                         ; preds = %if.end75
  %call80 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %getsda81 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %25 = load i32 (i8*)*, i32 (i8*)** %getsda81, align 8, !tbaa !59
  %data82 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %26 = load i8*, i8** %data82, align 8, !tbaa !51
  %call83 = call i32 %25(i8* %26)
  %getscl84 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %27 = load i32 (i8*)*, i32 (i8*)** %getscl84, align 8, !tbaa !48
  %cmp85 = icmp eq i32 (i8*)* %27, null
  br i1 %cmp85, label %cond.end91, label %cond.false87

cond.false87:                                     ; preds = %if.end79
  %getscl88 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %28 = load i32 (i8*)*, i32 (i8*)** %getscl88, align 8, !tbaa !48
  %data89 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %29 = load i8*, i8** %data89, align 8, !tbaa !51
  %call90 = call i32 %28(i8* %29)
  br label %cond.end91

cond.end91:                                       ; preds = %if.end79, %cond.false87
  %cond92 = phi i32 [ %call90, %cond.false87 ], [ 1, %if.end79 ]
  %tobool93 = icmp ne i32 %cond92, 0
  br i1 %tobool93, label %if.end96, label %if.then94

if.then94:                                        ; preds = %cond.end91
  %call95 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.52, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end96:                                         ; preds = %cond.end91
  %tobool97 = icmp ne i32 %call83, 0
  br i1 %tobool97, label %if.end100, label %if.then98

if.then98:                                        ; preds = %if.end96
  %call99 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.53, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end100:                                        ; preds = %if.end96
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %30 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !45
  %tobool101 = icmp ne void (%struct.i2c_adapter*)* %30, null
  br i1 %tobool101, label %if.then102, label %if.end104

if.then102:                                       ; preds = %if.end100
  %post_xfer103 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %31 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer103, align 8, !tbaa !45
  call void %31(%struct.i2c_adapter* %i2c_adap)
  br label %if.end104

if.end104:                                        ; preds = %if.then102, %if.end100
  %call105 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.54, i32 0, i32 0), i8* %arraydecay)
  br label %cleanup

bailout:                                          ; preds = %if.then98, %if.then94, %if.then77, %if.then73, %if.then57, %if.then53, %if.then37, %if.then33, %if.then17
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call106 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %post_xfer107 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %32 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer107, align 8, !tbaa !45
  %tobool108 = icmp ne void (%struct.i2c_adapter*)* %32, null
  br i1 %tobool108, label %if.then109, label %cleanup

if.then109:                                       ; preds = %bailout
  %post_xfer110 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %33 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer110, align 8, !tbaa !45
  call void %33(%struct.i2c_adapter* %i2c_adap)
  br label %cleanup

cleanup:                                          ; preds = %bailout, %if.then109, %if.then, %if.end104
  %retval.0 = phi i32 [ 0, %if.end104 ], [ -19, %if.then ], [ -19, %if.then109 ], [ -19, %bailout ]
  ret i32 %retval.0
}

declare void @dev_warn(%struct.device*, i8*, ...) #1

declare i32 @printk(i8*, ...) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "counting-function"="mcount" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { nounwind readnone }
attributes #4 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"i2c_adapter", !4, i64 0, !7, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !8, i64 40, !8, i64 176, !7, i64 312, !7, i64 316, !15, i64 320, !7, i64 1744, !5, i64 1748, !32, i64 1800, !25, i64 1896, !17, i64 2056, !4, i64 2072, !4, i64 2080, !4, i64 2088}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"int", !5, i64 0}
!8 = !{!"rt_mutex", !9, i64 0, !14, i64 72, !4, i64 80, !4, i64 88, !7, i64 96, !4, i64 104, !4, i64 112, !7, i64 120, !4, i64 128}
!9 = !{!"raw_spinlock", !10, i64 0, !7, i64 4, !7, i64 8, !4, i64 16, !12, i64 24}
!10 = !{!"qspinlock", !11, i64 0}
!11 = !{!"", !7, i64 0}
!12 = !{!"lockdep_map", !4, i64 0, !5, i64 8, !4, i64 24, !7, i64 32, !13, i64 40}
!13 = !{!"long", !5, i64 0}
!14 = !{!"rb_root", !4, i64 0}
!15 = !{!"device", !4, i64 0, !4, i64 8, !16, i64 16, !4, i64 280, !4, i64 288, !25, i64 296, !4, i64 456, !4, i64 464, !4, i64 472, !4, i64 480, !28, i64 488, !29, i64 528, !4, i64 1104, !4, i64 1112, !4, i64 1120, !17, i64 1128, !7, i64 1144, !4, i64 1152, !4, i64 1160, !34, i64 1168, !13, i64 1176, !4, i64 1184, !17, i64 1192, !4, i64 1208, !4, i64 1216, !35, i64 1224, !4, i64 1232, !4, i64 1240, !7, i64 1248, !7, i64 1252, !26, i64 1256, !17, i64 1328, !36, i64 1344, !4, i64 1376, !4, i64 1384, !4, i64 1392, !4, i64 1400, !4, i64 1408, !31, i64 1416, !31, i64 1416}
!16 = !{!"kobject", !4, i64 0, !17, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !18, i64 56, !20, i64 64, !7, i64 256, !7, i64 256, !7, i64 256, !7, i64 256, !7, i64 256}
!17 = !{!"list_head", !4, i64 0, !4, i64 8}
!18 = !{!"kref", !19, i64 0}
!19 = !{!"refcount_struct", !11, i64 0}
!20 = !{!"delayed_work", !21, i64 0, !23, i64 80, !4, i64 176, !7, i64 184}
!21 = !{!"work_struct", !22, i64 0, !17, i64 8, !4, i64 24, !12, i64 32}
!22 = !{!"", !13, i64 0}
!23 = !{!"timer_list", !24, i64 0, !13, i64 16, !4, i64 24, !13, i64 32, !7, i64 40, !12, i64 48}
!24 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!25 = !{!"mutex", !22, i64 0, !26, i64 8, !27, i64 80, !17, i64 88, !4, i64 104, !12, i64 112}
!26 = !{!"spinlock", !5, i64 0}
!27 = !{!"optimistic_spin_queue", !11, i64 0}
!28 = !{!"dev_links_info", !17, i64 0, !17, i64 16, !5, i64 32}
!29 = !{!"dev_pm_info", !30, i64 0, !7, i64 4, !7, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 4, !31, i64 5, !26, i64 8, !17, i64 80, !32, i64 96, !4, i64 192, !31, i64 200, !31, i64 200, !31, i64 200, !23, i64 208, !13, i64 304, !21, i64 312, !33, i64 392, !4, i64 480, !11, i64 488, !11, i64 492, !7, i64 496, !7, i64 496, !7, i64 496, !7, i64 496, !7, i64 496, !7, i64 496, !31, i64 497, !7, i64 497, !7, i64 497, !7, i64 497, !7, i64 497, !7, i64 497, !7, i64 500, !5, i64 504, !5, i64 508, !7, i64 512, !7, i64 516, !13, i64 520, !13, i64 528, !13, i64 536, !13, i64 544, !4, i64 552, !4, i64 560, !4, i64 568}
!30 = !{!"pm_message", !7, i64 0}
!31 = !{!"_Bool", !5, i64 0}
!32 = !{!"completion", !7, i64 0, !33, i64 8}
!33 = !{!"__wait_queue_head", !26, i64 0, !17, i64 72}
!34 = !{!"long long", !5, i64 0}
!35 = !{!"dev_archdata", !4, i64 0}
!36 = !{!"klist_node", !4, i64 0, !17, i64 8, !18, i64 24}
!37 = !{!38, !4, i64 40}
!38 = !{!"i2c_algo_bit_data", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !7, i64 56, !7, i64 60}
!39 = !{!7, !7, i64 0}
!40 = !{!41, !42, i64 2}
!41 = !{!"i2c_msg", !42, i64 0, !42, i64 2, !42, i64 4, !4, i64 8}
!42 = !{!"short", !5, i64 0}
!43 = !{!41, !42, i64 0}
!44 = !{!41, !42, i64 4}
!45 = !{!38, !4, i64 48}
!46 = !{!3, !4, i64 16}
!47 = !{!3, !7, i64 316}
!48 = !{!38, !4, i64 32}
!49 = !{!3, !4, i64 2080}
!50 = !{!38, !4, i64 8}
!51 = !{!38, !4, i64 0}
!52 = !{!38, !7, i64 56}
!53 = !{!41, !4, i64 8}
!54 = !{!5, !5, i64 0}
!55 = !{!38, !4, i64 16}
!56 = !{!13, !13, i64 0}
!57 = !{!38, !7, i64 60}
!58 = !{i32 889894}
!59 = !{!38, !4, i64 24}
