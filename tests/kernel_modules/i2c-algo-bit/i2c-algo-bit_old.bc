; ModuleID = 'drivers/i2c/algos/i2c-algo-bit.bc'
source_filename = "drivers/i2c/algos/i2c-algo-bit.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.31 }
%union.anon.31 = type { i8* }
%struct.i2c_adapter = type { %struct.module*, i32, %struct.i2c_algorithm*, i8*, %struct.rt_mutex, i32, i32, %struct.device, i32, [48 x i8], %struct.completion, %struct.mutex, %struct.list_head, %struct.i2c_bus_recovery_info* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type opaque
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.atomic64_t = type { i64 }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.file = type opaque
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.2, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.3, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.4, %union.anon.5 }
%union.anon.2 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.3 = type { i64 }
%union.anon.4 = type { %struct.list_head }
%union.anon.5 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.6 }
%union.anon.6 = type { %struct.anon.7 }
%struct.anon.7 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.9, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.12 }
%union.anon.9 = type { %struct.anon.10 }
%struct.anon.10 = type { i64, i64 }
%union.anon.12 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type opaque
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.14 }
%union.anon.14 = type { %struct.anon.18, [80 x i8] }
%struct.anon.18 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.page = type { i64, %struct.address_space*, %struct.anon.22, %union.anon.28, %union.anon.30, [8 x i8] }
%struct.address_space = type opaque
%struct.anon.22 = type { %union.anon.23, %union.anon.24 }
%union.anon.23 = type { i64 }
%union.anon.24 = type { i64 }
%union.anon.28 = type { %struct.list_head }
%union.anon.30 = type { i64 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.module_ref = type { i64, i64 }
%struct.i2c_algorithm = type { {}*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }
%struct.rt_mutex = type { %struct.raw_spinlock, %struct.plist_head, %struct.task_struct* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type {}
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.proc_dir_entry*, %struct.kref, i64, i8* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32 }
%struct.proc_dir_entry = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.i2c_bus_recovery_info = type { i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*, i32)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_bus_recovery_info*)*, void (%struct.i2c_bus_recovery_info*)*, i32, i32 }
%struct.i2c_msg = type { i16, i16, i16, i8* }
%union.i2c_smbus_data = type { i16, [32 x i8] }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.i2c_algo_bit_data = type { i8*, void (i8*, i32)*, void (i8*, i32)*, i32 (i8*)*, i32 (i8*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }

@__param_str_bit_test = internal constant [22 x i8] c"i2c_algo_bit.bit_test\00", align 16
@param_ops_int = external global %struct.kernel_param_ops, align 8
@bit_test = internal global i32 0, align 4
@__param_bit_test = internal constant %struct.kernel_param { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__param_str_bit_test, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 292, i16 -1, %union.anon.31 { i8* bitcast (i32* @bit_test to i8*) } }, section "__param", align 8
@i2c_bit_algo = constant { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* } { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)* @bit_xfer, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)* null, i32 (%struct.i2c_adapter*)* @bit_func }, align 8
@__kstrtab_i2c_bit_algo = internal constant [13 x i8] c"i2c_bit_algo\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_algo = internal constant %struct.kernel_symbol { i64 ptrtoint ({ i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }* @i2c_bit_algo to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_i2c_bit_algo, i32 0, i32 0) }, section "___ksymtab+i2c_bit_algo", align 8
@__kstrtab_i2c_bit_add_bus = internal constant [16 x i8] c"i2c_bit_add_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_bus to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_i2c_bit_add_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_bus", align 8
@__kstrtab_i2c_bit_add_numbered_bus = internal constant [25 x i8] c"i2c_bit_add_numbered_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_numbered_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_numbered_bus to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_i2c_bit_add_numbered_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_numbered_bus", align 8
@smp_ops = external global %struct.smp_ops, align 8
@jiffies = external global i64, align 8
@.str = private unnamed_addr constant [31 x i8] c"died at extended address code\0A\00", align 1
@.str.1 = private unnamed_addr constant [26 x i8] c"died at 2nd address code\0A\00", align 1
@.str.2 = private unnamed_addr constant [31 x i8] c"died at repeated address code\0A\00", align 1
@.str.3 = private unnamed_addr constant [38 x i8] c"readbytes: invalid block length (%d)\0A\00", align 1
@.str.4 = private unnamed_addr constant [28 x i8] c"readbytes: ack/nak timeout\0A\00", align 1
@.str.5 = private unnamed_addr constant [25 x i8] c"sendbytes: NAK bailout.\0A\00", align 1
@.str.6 = private unnamed_addr constant [21 x i8] c"sendbytes: error %d\0A\00", align 1
@.str.7 = private unnamed_addr constant [35 x i8] c"Not I2C compliant: can't read SCL\0A\00", align 1
@.str.8 = private unnamed_addr constant [23 x i8] c"Bus may be unreliable\0A\00", align 1
@.str.9 = private unnamed_addr constant [45 x i8] c"\016%s: Testing SDA only, SCL is not readable\0A\00", align 1
@.str.10 = private unnamed_addr constant [45 x i8] c"\014%s: bus seems to be busy (scl=%d, sda=%d)\0A\00", align 1
@.str.11 = private unnamed_addr constant [23 x i8] c"\014%s: SDA stuck high!\0A\00", align 1
@.str.12 = private unnamed_addr constant [49 x i8] c"\014%s: SCL unexpected low while pulling SDA low!\0A\00", align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"\014%s: SDA stuck low!\0A\00", align 1
@.str.14 = private unnamed_addr constant [50 x i8] c"\014%s: SCL unexpected low while pulling SDA high!\0A\00", align 1
@.str.15 = private unnamed_addr constant [23 x i8] c"\014%s: SCL stuck high!\0A\00", align 1
@.str.16 = private unnamed_addr constant [49 x i8] c"\014%s: SDA unexpected low while pulling SCL low!\0A\00", align 1
@.str.17 = private unnamed_addr constant [22 x i8] c"\014%s: SCL stuck low!\0A\00", align 1
@.str.18 = private unnamed_addr constant [50 x i8] c"\014%s: SDA unexpected low while pulling SCL high!\0A\00", align 1
@.str.19 = private unnamed_addr constant [15 x i8] c"\016%s: Test OK\0A\00", align 1
@llvm.used = appending global [4 x i8*] [i8* bitcast (%struct.kernel_param* @__param_bit_test to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_algo to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_bus to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_numbered_bus to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_xfer(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msgs, i32 %num) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !35
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %pre_xfer1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer1, align 8, !tbaa !35
  %call = call i32 %3(%struct.i2c_adapter* %i2c_adap)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %do.end

do.end:                                           ; preds = %entry, %if.then
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %i.0 = phi i32 [ 0, %do.end ], [ %inc, %for.inc ]
  %cmp4 = icmp slt i32 %i.0, %num
  br i1 %cmp4, label %for.body, label %do.end70

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msgs, i64 %idxprom
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %4 = load i16, i16* %flags, align 2, !tbaa !37
  %conv = zext i16 %4 to i32
  %and = and i32 %conv, 4096
  %conv5 = trunc i32 %and to i16
  %flags6 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %5 = load i16, i16* %flags6, align 2, !tbaa !37
  %conv7 = zext i16 %5 to i32
  %and8 = and i32 %conv7, 16384
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end26, label %if.then10

if.then10:                                        ; preds = %for.body
  %tobool11 = icmp ne i32 %i.0, 0
  br i1 %tobool11, label %do.end15, label %if.end16

do.end15:                                         ; preds = %if.then10
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %1)
  br label %if.end16

if.end16:                                         ; preds = %do.end15, %if.then10
  %call17 = call i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp18 = icmp eq i32 %call17, 0
  %tobool20 = icmp ne i16 %conv5, 0
  %or.cond = or i1 %cmp18, %tobool20
  br i1 %or.cond, label %if.end26, label %do.end70

if.end26:                                         ; preds = %if.end16, %for.body
  %flags27 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %6 = load i16, i16* %flags27, align 2, !tbaa !37
  %conv28 = zext i16 %6 to i32
  %and29 = and i32 %conv28, 1
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end26
  %call32 = call i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp33 = icmp sge i32 %call32, 1
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %7 = load i16, i16* %len, align 4, !tbaa !40
  %conv40 = zext i16 %7 to i32
  %cmp41 = icmp slt i32 %call32, %conv40
  br i1 %cmp41, label %if.then43, label %for.inc

if.then43:                                        ; preds = %if.then31
  %cmp44 = icmp sge i32 %call32, 0
  %.call32 = select i1 %cmp44, i32 -5, i32 %call32
  br label %do.end70

if.else:                                          ; preds = %if.end26
  %call49 = call i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp50 = icmp sge i32 %call49, 1
  %len57 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %8 = load i16, i16* %len57, align 4, !tbaa !40
  %conv58 = zext i16 %8 to i32
  %cmp59 = icmp slt i32 %call49, %conv58
  br i1 %cmp59, label %if.then61, label %for.inc

if.then61:                                        ; preds = %if.else
  %cmp62 = icmp sge i32 %call49, 0
  %.call49 = select i1 %cmp62, i32 -5, i32 %call49
  br label %do.end70

for.inc:                                          ; preds = %if.then31, %if.else
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.end70:                                         ; preds = %if.then43, %if.then61, %if.end16, %for.cond
  %ret.2 = phi i32 [ %.call32, %if.then43 ], [ %.call49, %if.then61 ], [ %call17, %if.end16 ], [ %i.0, %for.cond ]
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %9 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !41
  %tobool71 = icmp ne void (%struct.i2c_adapter*)* %9, null
  br i1 %tobool71, label %if.then72, label %cleanup

if.then72:                                        ; preds = %do.end70
  %post_xfer73 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %10 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer73, align 8, !tbaa !41
  call void %10(%struct.i2c_adapter* %i2c_adap)
  br label %cleanup

cleanup:                                          ; preds = %do.end70, %if.then72, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %ret.2, %if.then72 ], [ %ret.2, %do.end70 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_func(%struct.i2c_adapter* %adap) #1 {
entry:
  ret i32 268402719
}

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_bus(%struct.i2c_adapter* %adap) #1 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_adapter)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* %add_adapter) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %2 = load i32, i32* @bit_test, align 4, !tbaa !42
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %call = call i32 @test_bus(%struct.i2c_adapter* %adap)
  %3 = load i32, i32* @bit_test, align 4, !tbaa !42
  %cmp = icmp sge i32 %3, 2
  %cmp1 = icmp slt i32 %call, 0
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.then, %entry
  %algo = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 2
  store %struct.i2c_algorithm* bitcast ({ i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }* @i2c_bit_algo to %struct.i2c_algorithm*), %struct.i2c_algorithm** %algo, align 8, !tbaa !43
  %retries = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 6
  store i32 3, i32* %retries, align 4, !tbaa !44
  %call4 = call i32 %add_adapter(%struct.i2c_adapter* %adap)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %cleanup, label %if.end7

if.end7:                                          ; preds = %if.end3
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !45
  %cmp8 = icmp eq i32 (i8*)* %4, null
  br i1 %cmp8, label %if.then9, label %cleanup

if.then9:                                         ; preds = %if.end7
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 7
  %call10 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.7, i32 0, i32 0))
  %dev11 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 7
  %call12 = call i32 (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev11, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.8, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %if.then9, %if.end3, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ %call4, %if.end3 ], [ 0, %if.then9 ], [ 0, %if.end7 ]
  ret i32 %retval.0
}

declare i32 @i2c_add_adapter(%struct.i2c_adapter*) #2

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_numbered_bus(%struct.i2c_adapter* %adap) #1 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_numbered_adapter)
  ret i32 %call
}

declare i32 @i2c_add_numbered_adapter(%struct.i2c_adapter*) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define internal void @i2c_start(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !46
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !47
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !48
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @i2c_repstart(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  call void @sdahi(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !46
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !47
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !48
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #1 {
entry:
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %0 = load i16, i16* %flags1, align 2, !tbaa !37
  %flags2 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %1 = load i16, i16* %flags2, align 2, !tbaa !37
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 4096
  %conv3 = trunc i32 %and to i16
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %2 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %3 = bitcast i8* %2 to %struct.i2c_algo_bit_data*
  %conv4 = zext i16 %conv3 to i32
  %tobool = icmp ne i32 %conv4, 0
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %retries5 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 6
  %4 = load i32, i32* %retries5, align 4, !tbaa !44
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi i32 [ %4, %cond.false ], [ 0, %entry ]
  %conv6 = zext i16 %0 to i32
  %and7 = and i32 %conv6, 16
  %tobool8 = icmp ne i32 %and7, 0
  %addr9 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %5 = load i16, i16* %addr9, align 8, !tbaa !49
  %conv10 = zext i16 %5 to i32
  br i1 %tobool8, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %shr = ashr i32 %conv10, 7
  %and11 = and i32 %shr, 6
  %or = or i32 240, %and11
  %conv12 = trunc i32 %or to i8
  %call = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv12, i32 %cond)
  %cmp = icmp eq i32 %call, 1
  %tobool14 = icmp ne i16 %conv3, 0
  %or.cond = or i1 %cmp, %tobool14
  br i1 %or.cond, label %if.end, label %if.then15

if.then15:                                        ; preds = %if.then
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call16 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %if.then
  %addr17 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %6 = load i16, i16* %addr17, align 8, !tbaa !49
  %conv18 = zext i16 %6 to i32
  %and19 = and i32 %conv18, 255
  %conv20 = trunc i32 %and19 to i8
  %call21 = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv20)
  %cmp22 = icmp eq i32 %call21, 1
  %tobool25 = icmp ne i16 %conv3, 0
  %or.cond1 = or i1 %cmp22, %tobool25
  br i1 %or.cond1, label %if.end29, label %if.then26

if.then26:                                        ; preds = %if.end
  %dev27 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call28 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev27, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i32 0, i32 0))
  br label %cleanup

if.end29:                                         ; preds = %if.end
  %conv30 = zext i16 %0 to i32
  %and31 = and i32 %conv30, 1
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %do.end36, label %if.end75

do.end36:                                         ; preds = %if.end29
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %3)
  %conv37 = zext i8 %conv12 to i32
  %or38 = or i32 %conv37, 1
  %conv39 = trunc i32 %or38 to i8
  %call40 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv39, i32 %cond)
  %cmp41 = icmp eq i32 %call40, 1
  %tobool44 = icmp ne i16 %conv3, 0
  %or.cond2 = or i1 %cmp41, %tobool44
  br i1 %or.cond2, label %if.end75, label %if.then45

if.then45:                                        ; preds = %do.end36
  %dev46 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call47 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev46, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.2, i32 0, i32 0))
  br label %cleanup

if.else:                                          ; preds = %cond.end
  %shl = shl i32 %conv10, 1
  %conv52 = trunc i32 %shl to i8
  %conv53 = zext i16 %0 to i32
  %and54 = and i32 %conv53, 1
  %tobool55 = icmp ne i32 %and54, 0
  %conv57 = zext i8 %conv52 to i32
  %or58 = or i32 %conv57, 1
  %conv59 = trunc i32 %or58 to i8
  %addr.0 = select i1 %tobool55, i8 %conv59, i8 %conv52
  %conv61 = zext i16 %0 to i32
  %and62 = and i32 %conv61, 8192
  %tobool63 = icmp ne i32 %and62, 0
  %conv65 = zext i8 %addr.0 to i32
  %xor = xor i32 %conv65, 1
  %conv66 = trunc i32 %xor to i8
  %addr.1 = select i1 %tobool63, i8 %conv66, i8 %addr.0
  %call68 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr.1, i32 %cond)
  %cmp69 = icmp eq i32 %call68, 1
  %tobool72 = icmp ne i16 %conv3, 0
  %or.cond3 = or i1 %cmp69, %tobool72
  br i1 %or.cond3, label %if.end75, label %cleanup

if.end75:                                         ; preds = %if.else, %if.end29, %do.end36
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.end75, %if.then45, %if.then26, %if.then15
  %retval.0 = phi i32 [ 0, %if.end75 ], [ -5, %if.then45 ], [ -6, %if.then26 ], [ -6, %if.then15 ], [ -6, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #1 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !50
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !40
  %conv = zext i16 %1 to i32
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags1, align 2, !tbaa !37
  %conv2 = zext i16 %2 to i32
  br label %while.cond

while.cond:                                       ; preds = %if.end35, %entry
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.end35 ]
  %rdcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.end35 ]
  %count.0 = phi i32 [ %conv, %entry ], [ %count.1, %if.end35 ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %call = call i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap)
  %cmp4 = icmp sge i32 %call, 0
  br i1 %cmp4, label %if.then, label %cleanup

if.then:                                          ; preds = %while.body
  %conv6 = trunc i32 %call to i8
  store i8 %conv6, i8* %temp.0, align 1, !tbaa !51
  %inc = add nsw i32 %rdcount.0, 1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %dec = add nsw i32 %count.0, -1
  %cmp7 = icmp eq i32 %inc, 1
  %and = and i32 %conv2, 1024
  %tobool = icmp ne i32 %and, 0
  %or.cond = and i1 %cmp7, %tobool
  br i1 %or.cond, label %if.then9, label %do.end

if.then9:                                         ; preds = %if.then
  %cmp10 = icmp sle i32 %call, 0
  %cmp12 = icmp sgt i32 %call, 32
  %or.cond1 = or i1 %cmp10, %cmp12
  br i1 %or.cond1, label %if.then14, label %if.end21

if.then14:                                        ; preds = %if.then9
  %and15 = and i32 %conv2, 2048
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then14
  %call18 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 0)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.then14
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call20 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.3, i32 0, i32 0), i32 %call)
  br label %cleanup

if.end21:                                         ; preds = %if.then9
  %add = add nsw i32 %dec, %call
  %len22 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %3 = load i16, i16* %len22, align 4, !tbaa !40
  %conv23 = zext i16 %3 to i32
  %add24 = add nsw i32 %conv23, %call
  %conv25 = trunc i32 %add24 to i16
  store i16 %conv25, i16* %len22, align 4, !tbaa !40
  br label %do.end

do.end:                                           ; preds = %if.then, %if.end21
  %count.1 = phi i32 [ %add, %if.end21 ], [ %dec, %if.then ]
  %and27 = and i32 %conv2, 2048
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.end35, label %if.then29

if.then29:                                        ; preds = %do.end
  %call30 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %count.1)
  %cmp31 = icmp slt i32 %call30, 0
  br i1 %cmp31, label %cleanup, label %if.end35

if.end35:                                         ; preds = %if.then29, %do.end
  br label %while.cond

cleanup:                                          ; preds = %while.body, %while.cond, %if.then29, %if.end19
  %retval.0 = phi i32 [ -71, %if.end19 ], [ %call30, %if.then29 ], [ %rdcount.0, %while.cond ], [ %rdcount.0, %while.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #1 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !50
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !40
  %conv = zext i16 %1 to i32
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags, align 2, !tbaa !37
  %conv1 = zext i16 %2 to i32
  %and = and i32 %conv1, 4096
  %conv2 = trunc i32 %and to i16
  br label %while.cond

while.cond:                                       ; preds = %if.then, %entry
  %count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.then ]
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.then ]
  %wrcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.then ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i8, i8* %temp.0, align 1, !tbaa !51
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %3)
  %cmp5 = icmp sgt i32 %call, 0
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %conv7 = zext i16 %conv2 to i32
  %tobool = icmp ne i32 %conv7, 0
  %cmp8 = icmp eq i32 %call, 0
  %or.cond = and i1 %tobool, %cmp8
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.body
  %dec = add nsw i32 %count.0, -1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %inc = add nsw i32 %wrcount.0, 1
  br label %while.cond

if.else:                                          ; preds = %lor.lhs.false
  %cmp10 = icmp eq i32 %call, 0
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  br i1 %cmp10, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.else
  %call13 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.5, i32 0, i32 0))
  br label %cleanup

if.else14:                                        ; preds = %if.else
  %call16 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0), i32 %call)
  br label %cleanup

cleanup:                                          ; preds = %while.cond, %if.else14, %if.then12
  %retval.0 = phi i32 [ -5, %if.then12 ], [ %call, %if.else14 ], [ %wrcount.0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @i2c_stop(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  call void @sdalo(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !46
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !47
  call void %0(i8* %1, i32 1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !48
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

declare void @__udelay(i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @scllo(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !52
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !47
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !48
  %div = sdiv i32 %2, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdahi(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !46
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !47
  call void %0(i8* %1, i32 1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !48
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sclhi(%struct.i2c_algo_bit_data* %adap) #1 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy5 = alloca i64, align 8
  %__dummy26 = alloca i64, align 8
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !52
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !47
  call void %0(i8* %1, i32 1)
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %2 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !45
  %tobool = icmp ne i32 (i8*)* %2, null
  br i1 %tobool, label %if.end, label %done

if.end:                                           ; preds = %entry
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.end
  %getscl1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl1, align 8, !tbaa !45
  %data2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %5 = load i8*, i8** %data2, align 8, !tbaa !47
  %call = call i32 %4(i8* %5)
  %tobool3 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool3, true
  br i1 %lnot, label %while.body, label %done

while.body:                                       ; preds = %while.cond
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #4
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #4
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #4
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #4
  %tobool4 = icmp ne i32 1, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %while.body
  %10 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #4
  %11 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #4
  %cmp7 = icmp eq i64* %__dummy5, %__dummy26
  %conv8 = zext i1 %cmp7 to i32
  %12 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #4
  %13 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #4
  %timeout = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 8
  %14 = load i32, i32* %timeout, align 4, !tbaa !55
  %conv12 = sext i32 %14 to i64
  %add = add i64 %3, %conv12
  %15 = load volatile i64, i64* @jiffies, align 8, !tbaa !53
  %sub = sub nsw i64 %add, %15
  %cmp13 = icmp slt i64 %sub, 0
  br i1 %cmp13, label %if.then15, label %if.end22

if.then15:                                        ; preds = %land.lhs.true
  %getscl16 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %16 = load i32 (i8*)*, i32 (i8*)** %getscl16, align 8, !tbaa !45
  %data17 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %17 = load i8*, i8** %data17, align 8, !tbaa !47
  %call18 = call i32 %16(i8* %17)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %done, label %cleanup

if.end22:                                         ; preds = %land.lhs.true, %while.body
  call void @cpu_relax()
  br label %while.cond

done:                                             ; preds = %if.then15, %while.cond, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %18 = load i32, i32* %udelay, align 8, !tbaa !48
  %conv23 = sext i32 %18 to i64
  call void @__udelay(i64 %conv23)
  br label %cleanup

cleanup:                                          ; preds = %if.then15, %done
  %retval.0 = phi i32 [ 0, %done ], [ -110, %if.then15 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @cpu_relax() #0 {
entry:
  call void @rep_nop()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rep_nop() #0 {
entry:
  call void asm sideeffect "rep; nop", "~{memory},~{dirflag},~{fpsr},~{flags}"() #4, !srcloc !56
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr, i32 %retries) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %do.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %do.end ]
  %ret.0 = phi i32 [ 0, %entry ], [ %call, %do.end ]
  %cmp = icmp sle i32 %i.0, %retries
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr)
  %cmp1 = icmp eq i32 %call, 1
  %cmp2 = icmp eq i32 %i.0, %retries
  %or.cond = or i1 %cmp1, %cmp2
  br i1 %or.cond, label %for.end, label %do.end

do.end:                                           ; preds = %for.body
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !48
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @yield()
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %ret.1 = phi i32 [ %call, %for.body ], [ %ret.0, %for.cond ]
  %tobool = icmp ne i32 %i.0, 0
  %tobool6 = icmp ne i32 %ret.1, 0
  %or.cond1 = and i1 %tobool, %tobool6
  ret i32 %ret.1
}

declare i32 @dev_err(%struct.device*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %c) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %i.0 = phi i32 [ 7, %entry ], [ %dec, %if.end ]
  %cmp = icmp sge i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %conv = zext i8 %c to i32
  %shr = ashr i32 %conv, %i.0
  %and = and i32 %shr, 1
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !46
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !47
  call void %2(i8* %3, i32 %and)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !48
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv1 = sext i32 %div to i64
  call void @__udelay(i64 %conv1)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call4 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %cleanup, label %if.end11

if.end11:                                         ; preds = %for.end
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %5 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !57
  %data12 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %6 = load i8*, i8** %data12, align 8, !tbaa !47
  %call13 = call i32 %5(i8* %6)
  %tobool = icmp ne i32 %call13, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %for.body, %if.end11
  %retval.0 = phi i32 [ %lnot.ext, %if.end11 ], [ -110, %for.body ], [ -110, %for.end ]
  ret i32 %retval.0
}

declare void @yield() #2

; Function Attrs: nounwind uwtable
define internal i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %indata.0 = phi i8 [ 0, %entry ], [ %indata.1, %if.end ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %cmp = icmp slt i32 %i.0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  %conv = zext i8 %indata.0 to i32
  %mul = mul nsw i32 %conv, 2
  %conv2 = trunc i32 %mul to i8
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %2 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !57
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !47
  %call3 = call i32 %2(i8* %3)
  %tobool = icmp ne i32 %call3, 0
  %conv5 = zext i8 %conv2 to i32
  %or = or i32 %conv5, 1
  %conv6 = trunc i32 %or to i8
  %indata.1 = select i1 %tobool, i8 %conv6, i8 %conv2
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 2
  %4 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !52
  %data8 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %5 = load i8*, i8** %data8, align 8, !tbaa !47
  call void %4(i8* %5, i32 0)
  %cmp9 = icmp eq i32 %i.0, 7
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %6 = load i32, i32* %udelay, align 8, !tbaa !48
  %div = sdiv i32 %6, 2
  %cond = select i1 %cmp9, i32 %div, i32 %6
  %conv12 = sext i32 %cond to i64
  call void @__udelay(i64 %conv12)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv13 = zext i8 %indata.0 to i32
  br label %cleanup

cleanup:                                          ; preds = %for.body, %for.end
  %retval.0 = phi i32 [ %conv13, %for.end ], [ -110, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %is_ack) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %tobool = icmp ne i32 %is_ack, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !46
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !47
  call void %2(i8* %3, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !48
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 7
  %call3 = call i32 (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.4, i32 0, i32 0))
  br label %cleanup

if.end4:                                          ; preds = %if.end
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end4, %if.then2
  %retval.0 = phi i32 [ -110, %if.then2 ], [ 0, %if.end4 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdalo(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !46
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !47
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !48
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @test_bus(%struct.i2c_adapter* %i2c_adap) #1 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !12
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %name1 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %name1, i32 0, i32 0
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !35
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %pre_xfer2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer2, align 8, !tbaa !35
  %call = call i32 %3(%struct.i2c_adapter* %i2c_adap)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.then, %entry
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !45
  %cmp5 = icmp eq i32 (i8*)* %4, null
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.9, i32 0, i32 0), i8* %arraydecay)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %5 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !57
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %6 = load i8*, i8** %data, align 8, !tbaa !47
  %call9 = call i32 %5(i8* %6)
  %getscl10 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %7 = load i32 (i8*)*, i32 (i8*)** %getscl10, align 8, !tbaa !45
  %cmp11 = icmp eq i32 (i8*)* %7, null
  br i1 %cmp11, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end8
  %getscl12 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %8 = load i32 (i8*)*, i32 (i8*)** %getscl12, align 8, !tbaa !45
  %data13 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %9 = load i8*, i8** %data13, align 8, !tbaa !47
  %call14 = call i32 %8(i8* %9)
  br label %cond.end

cond.end:                                         ; preds = %if.end8, %cond.false
  %cond = phi i32 [ %call14, %cond.false ], [ 1, %if.end8 ]
  %tobool15 = icmp ne i32 %cond, 0
  %tobool16 = icmp ne i32 %call9, 0
  %or.cond = and i1 %tobool15, %tobool16
  br i1 %or.cond, label %if.end19, label %if.then17

if.then17:                                        ; preds = %cond.end
  %call18 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.10, i32 0, i32 0), i8* %arraydecay, i32 %cond, i32 %call9)
  br label %bailout

if.end19:                                         ; preds = %cond.end
  call void @sdalo(%struct.i2c_algo_bit_data* %1)
  %getsda20 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %10 = load i32 (i8*)*, i32 (i8*)** %getsda20, align 8, !tbaa !57
  %data21 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %11 = load i8*, i8** %data21, align 8, !tbaa !47
  %call22 = call i32 %10(i8* %11)
  %getscl23 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %12 = load i32 (i8*)*, i32 (i8*)** %getscl23, align 8, !tbaa !45
  %cmp24 = icmp eq i32 (i8*)* %12, null
  br i1 %cmp24, label %cond.end30, label %cond.false26

cond.false26:                                     ; preds = %if.end19
  %getscl27 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %13 = load i32 (i8*)*, i32 (i8*)** %getscl27, align 8, !tbaa !45
  %data28 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %14 = load i8*, i8** %data28, align 8, !tbaa !47
  %call29 = call i32 %13(i8* %14)
  br label %cond.end30

cond.end30:                                       ; preds = %if.end19, %cond.false26
  %cond31 = phi i32 [ %call29, %cond.false26 ], [ 1, %if.end19 ]
  %tobool32 = icmp ne i32 %call22, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %cond.end30
  %call34 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end35:                                         ; preds = %cond.end30
  %tobool36 = icmp ne i32 %cond31, 0
  br i1 %tobool36, label %if.end39, label %if.then37

if.then37:                                        ; preds = %if.end35
  %call38 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.12, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end39:                                         ; preds = %if.end35
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %getsda40 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %15 = load i32 (i8*)*, i32 (i8*)** %getsda40, align 8, !tbaa !57
  %data41 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %16 = load i8*, i8** %data41, align 8, !tbaa !47
  %call42 = call i32 %15(i8* %16)
  %getscl43 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %17 = load i32 (i8*)*, i32 (i8*)** %getscl43, align 8, !tbaa !45
  %cmp44 = icmp eq i32 (i8*)* %17, null
  br i1 %cmp44, label %cond.end50, label %cond.false46

cond.false46:                                     ; preds = %if.end39
  %getscl47 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %18 = load i32 (i8*)*, i32 (i8*)** %getscl47, align 8, !tbaa !45
  %data48 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %19 = load i8*, i8** %data48, align 8, !tbaa !47
  %call49 = call i32 %18(i8* %19)
  br label %cond.end50

cond.end50:                                       ; preds = %if.end39, %cond.false46
  %cond51 = phi i32 [ %call49, %cond.false46 ], [ 1, %if.end39 ]
  %tobool52 = icmp ne i32 %call42, 0
  br i1 %tobool52, label %if.end55, label %if.then53

if.then53:                                        ; preds = %cond.end50
  %call54 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end55:                                         ; preds = %cond.end50
  %tobool56 = icmp ne i32 %cond51, 0
  br i1 %tobool56, label %if.end59, label %if.then57

if.then57:                                        ; preds = %if.end55
  %call58 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.14, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end59:                                         ; preds = %if.end55
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %getsda60 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %20 = load i32 (i8*)*, i32 (i8*)** %getsda60, align 8, !tbaa !57
  %data61 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %21 = load i8*, i8** %data61, align 8, !tbaa !47
  %call62 = call i32 %20(i8* %21)
  %getscl63 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %22 = load i32 (i8*)*, i32 (i8*)** %getscl63, align 8, !tbaa !45
  %cmp64 = icmp eq i32 (i8*)* %22, null
  br i1 %cmp64, label %cond.end70, label %cond.false66

cond.false66:                                     ; preds = %if.end59
  %getscl67 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %23 = load i32 (i8*)*, i32 (i8*)** %getscl67, align 8, !tbaa !45
  %data68 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %24 = load i8*, i8** %data68, align 8, !tbaa !47
  %call69 = call i32 %23(i8* %24)
  br label %cond.end70

cond.end70:                                       ; preds = %if.end59, %cond.false66
  %cond71 = phi i32 [ %call69, %cond.false66 ], [ 0, %if.end59 ]
  %tobool72 = icmp ne i32 %cond71, 0
  br i1 %tobool72, label %if.then73, label %if.end75

if.then73:                                        ; preds = %cond.end70
  %call74 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.15, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end75:                                         ; preds = %cond.end70
  %tobool76 = icmp ne i32 %call62, 0
  br i1 %tobool76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %if.end75
  %call78 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.16, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end79:                                         ; preds = %if.end75
  %call80 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %getsda81 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %25 = load i32 (i8*)*, i32 (i8*)** %getsda81, align 8, !tbaa !57
  %data82 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %26 = load i8*, i8** %data82, align 8, !tbaa !47
  %call83 = call i32 %25(i8* %26)
  %getscl84 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %27 = load i32 (i8*)*, i32 (i8*)** %getscl84, align 8, !tbaa !45
  %cmp85 = icmp eq i32 (i8*)* %27, null
  br i1 %cmp85, label %cond.end91, label %cond.false87

cond.false87:                                     ; preds = %if.end79
  %getscl88 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %28 = load i32 (i8*)*, i32 (i8*)** %getscl88, align 8, !tbaa !45
  %data89 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %29 = load i8*, i8** %data89, align 8, !tbaa !47
  %call90 = call i32 %28(i8* %29)
  br label %cond.end91

cond.end91:                                       ; preds = %if.end79, %cond.false87
  %cond92 = phi i32 [ %call90, %cond.false87 ], [ 1, %if.end79 ]
  %tobool93 = icmp ne i32 %cond92, 0
  br i1 %tobool93, label %if.end96, label %if.then94

if.then94:                                        ; preds = %cond.end91
  %call95 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.17, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end96:                                         ; preds = %cond.end91
  %tobool97 = icmp ne i32 %call83, 0
  br i1 %tobool97, label %if.end100, label %if.then98

if.then98:                                        ; preds = %if.end96
  %call99 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.18, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end100:                                        ; preds = %if.end96
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %30 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !41
  %tobool101 = icmp ne void (%struct.i2c_adapter*)* %30, null
  br i1 %tobool101, label %if.then102, label %if.end104

if.then102:                                       ; preds = %if.end100
  %post_xfer103 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %31 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer103, align 8, !tbaa !41
  call void %31(%struct.i2c_adapter* %i2c_adap)
  br label %if.end104

if.end104:                                        ; preds = %if.then102, %if.end100
  %call105 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.19, i32 0, i32 0), i8* %arraydecay)
  br label %cleanup

bailout:                                          ; preds = %if.then98, %if.then94, %if.then77, %if.then73, %if.then57, %if.then53, %if.then37, %if.then33, %if.then17
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call106 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %post_xfer107 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %32 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer107, align 8, !tbaa !41
  %tobool108 = icmp ne void (%struct.i2c_adapter*)* %32, null
  br i1 %tobool108, label %if.then109, label %cleanup

if.then109:                                       ; preds = %bailout
  %post_xfer110 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %33 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer110, align 8, !tbaa !41
  call void %33(%struct.i2c_adapter* %i2c_adap)
  br label %cleanup

cleanup:                                          ; preds = %bailout, %if.then109, %if.then, %if.end104
  %retval.0 = phi i32 [ 0, %if.end104 ], [ -19, %if.then ], [ -19, %if.then109 ], [ -19, %bailout ]
  ret i32 %retval.0
}

declare i32 @dev_warn(%struct.device*, i8*, ...) #2

declare i32 @printk(i8*, ...) #2

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !4, i64 24}
!13 = !{!"i2c_adapter", !4, i64 0, !14, i64 8, !4, i64 16, !4, i64 24, !15, i64 32, !14, i64 64, !14, i64 68, !20, i64 72, !14, i64 512, !5, i64 516, !29, i64 568, !24, i64 600, !19, i64 640, !4, i64 656}
!14 = !{!"int", !5, i64 0}
!15 = !{!"rt_mutex", !16, i64 0, !18, i64 8, !4, i64 24}
!16 = !{!"raw_spinlock", !17, i64 0}
!17 = !{!"arch_spinlock", !5, i64 0}
!18 = !{!"plist_head", !19, i64 0}
!19 = !{!"list_head", !4, i64 0, !4, i64 8}
!20 = !{!"device", !4, i64 0, !4, i64 8, !21, i64 16, !4, i64 80, !4, i64 88, !24, i64 96, !4, i64 136, !4, i64 144, !4, i64 152, !26, i64 160, !4, i64 248, !14, i64 256, !4, i64 264, !31, i64 272, !4, i64 280, !19, i64 288, !4, i64 304, !32, i64 312, !4, i64 328, !33, i64 336, !14, i64 344, !14, i64 348, !25, i64 352, !19, i64 360, !34, i64 376, !4, i64 408, !4, i64 416, !4, i64 424, !4, i64 432}
!21 = !{!"kobject", !4, i64 0, !19, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !22, i64 56, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60, !14, i64 60}
!22 = !{!"kref", !23, i64 0}
!23 = !{!"", !14, i64 0}
!24 = !{!"mutex", !23, i64 0, !25, i64 4, !19, i64 8, !4, i64 24, !4, i64 32}
!25 = !{!"spinlock", !5, i64 0}
!26 = !{!"dev_pm_info", !27, i64 0, !14, i64 4, !14, i64 4, !28, i64 4, !28, i64 4, !28, i64 4, !28, i64 4, !25, i64 6, !19, i64 8, !29, i64 24, !4, i64 56, !28, i64 64, !28, i64 64, !4, i64 72, !4, i64 80}
!27 = !{!"pm_message", !14, i64 0}
!28 = !{!"_Bool", !5, i64 0}
!29 = !{!"completion", !14, i64 0, !30, i64 8}
!30 = !{!"__wait_queue_head", !25, i64 0, !19, i64 8}
!31 = !{!"long long", !5, i64 0}
!32 = !{!"dev_archdata", !4, i64 0, !4, i64 8}
!33 = !{!"acpi_dev_node", !4, i64 0}
!34 = !{!"klist_node", !4, i64 0, !19, i64 8, !22, i64 24}
!35 = !{!36, !4, i64 40}
!36 = !{!"i2c_algo_bit_data", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !14, i64 56, !14, i64 60}
!37 = !{!38, !39, i64 2}
!38 = !{!"i2c_msg", !39, i64 0, !39, i64 2, !39, i64 4, !4, i64 8}
!39 = !{!"short", !5, i64 0}
!40 = !{!38, !39, i64 4}
!41 = !{!36, !4, i64 48}
!42 = !{!14, !14, i64 0}
!43 = !{!13, !4, i64 16}
!44 = !{!13, !14, i64 68}
!45 = !{!36, !4, i64 32}
!46 = !{!36, !4, i64 8}
!47 = !{!36, !4, i64 0}
!48 = !{!36, !14, i64 56}
!49 = !{!38, !39, i64 0}
!50 = !{!38, !4, i64 8}
!51 = !{!5, !5, i64 0}
!52 = !{!36, !4, i64 16}
!53 = !{!54, !54, i64 0}
!54 = !{!"long", !5, i64 0}
!55 = !{!36, !14, i64 60}
!56 = !{i32 444944}
!57 = !{!36, !4, i64 24}
