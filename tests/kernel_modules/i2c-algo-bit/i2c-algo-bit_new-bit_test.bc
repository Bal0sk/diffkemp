; ModuleID = 'drivers/i2c/algos/i2c-algo-bit.bc'
source_filename = "drivers/i2c/algos/i2c-algo-bit.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.33 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.1 }
%union.anon.1 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%union.anon = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.file = type opaque
%struct.seq_file = type opaque
%struct.vm_operations_struct = type opaque
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon.32, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.rb_root = type { %struct.rb_node* }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.2 }
%union.anon.2 = type { %struct.anon }
%struct.anon = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type opaque
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type opaque
%struct.signal_struct = type opaque
%struct.sighand_struct = type opaque
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.kuid_t = type { i32 }
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.5 }
%union.anon.5 = type { %struct.anon.9, [80 x i8] }
%struct.anon.9 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type opaque
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.page = type { i64, %union.anon.15, %union.anon.16, %union.anon.17, %union.anon.21, %union.anon.24, [8 x i8] }
%union.anon.15 = type { %struct.address_space* }
%struct.address_space = type opaque
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.21 = type { %struct.list_head }
%union.anon.24 = type { i64 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.25 }
%union.anon.25 = type { %struct.anon.26 }
%struct.anon.26 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.28, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.31 }
%union.anon.28 = type { %struct.anon.29 }
%struct.anon.29 = type { i64, i64 }
%union.anon.31 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kioctx_table = type opaque
%struct.user_namespace = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.atomic64_t = type { i64 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.pgprot = type { i64 }
%struct.anon.32 = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.mempolicy = type opaque
%struct.vm_userfaultfd_ctx = type {}
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type opaque
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.atomic_t = type { i32 }
%union.anon.33 = type { i8* }
%struct.i2c_adapter = type { %struct.module*, i32, %struct.i2c_algorithm*, i8*, %struct.i2c_lock_operations*, %struct.rt_mutex, %struct.rt_mutex, i32, i32, %struct.device, i32, [48 x i8], %struct.completion, %struct.mutex, %struct.list_head, %struct.i2c_bus_recovery_info*, %struct.i2c_adapter_quirks*, %struct.irq_domain* }
%struct.i2c_algorithm = type { {}*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }
%struct.i2c_lock_operations = type { void (%struct.i2c_adapter*, i32)*, i32 (%struct.i2c_adapter*, i32)*, void (%struct.i2c_adapter*, i32)* }
%struct.rt_mutex = type { %struct.raw_spinlock, %struct.rb_root, %struct.rb_node*, %struct.task_struct* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.kgid_t = type { i32 }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type {}
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.dma_map_ops = type opaque
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.i2c_bus_recovery_info = type { i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*, i32)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }
%struct.i2c_adapter_quirks = type { i64, i32, i16, i16, i16, i16 }
%struct.irq_domain = type { %struct.list_head, i8*, %struct.irq_domain_ops*, i8*, i32, %struct.fwnode_handle*, i32, %struct.irq_domain_chip_generic*, %struct.irq_domain*, i64, i32, i32, %struct.radix_tree_root, [0 x i32] }
%struct.irq_domain_ops = type { i32 (%struct.irq_domain*, %struct.device_node*, i32)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i32)*, i32 (%struct.irq_domain*, i32, i64)*, void (%struct.irq_domain*, i32)*, i32 (%struct.irq_domain*, %struct.device_node*, i32*, i32, i64*, i32*)*, i32 (%struct.irq_domain*, i32, i32, i8*)*, void (%struct.irq_domain*, i32, i32)*, void (%struct.irq_domain*, %struct.irq_data*)*, void (%struct.irq_domain*, %struct.irq_data*)*, i32 (%struct.irq_domain*, %struct.irq_fwspec*, i64*, i32*)* }
%struct.irq_fwspec = type { %struct.fwnode_handle*, i32, [16 x i32] }
%struct.irq_data = type opaque
%struct.irq_domain_chip_generic = type opaque
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.0, [64 x i8*], [3 x [1 x i64]] }
%union.anon.0 = type { %struct.list_head }
%struct.i2c_msg = type { i16, i16, i16, i8* }
%union.i2c_smbus_data = type { i16, [32 x i8] }
%struct.i2c_algo_bit_data = type { i8*, void (i8*, i32)*, void (i8*, i32)*, i32 (i8*)*, i32 (i8*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }

@__param_str_bit_test = internal constant [22 x i8] c"i2c_algo_bit.bit_test\00", align 16
@param_ops_int = external constant %struct.kernel_param_ops, align 8
@bit_test = internal global i32 0, align 4
@__param_bit_test = internal constant %struct.kernel_param { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__param_str_bit_test, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_int, i16 292, i8 -1, i8 0, %union.anon.33 { i8* bitcast (i32* @bit_test to i8*) } }, section "__param", align 8
@i2c_bit_algo = constant { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* } { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)* @bit_xfer, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)* null, i32 (%struct.i2c_adapter*)* @bit_func }, align 8
@__kstrtab_i2c_bit_algo = internal constant [13 x i8] c"i2c_bit_algo\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_algo = internal constant %struct.kernel_symbol { i64 ptrtoint ({ i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }* @i2c_bit_algo to i64), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @__kstrtab_i2c_bit_algo, i32 0, i32 0) }, section "___ksymtab+i2c_bit_algo", align 8
@__kstrtab_i2c_bit_add_bus = internal constant [16 x i8] c"i2c_bit_add_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_bus to i64), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__kstrtab_i2c_bit_add_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_bus", align 8
@__kstrtab_i2c_bit_add_numbered_bus = internal constant [25 x i8] c"i2c_bit_add_numbered_bus\00", section "__ksymtab_strings", align 1
@__ksymtab_i2c_bit_add_numbered_bus = internal constant %struct.kernel_symbol { i64 ptrtoint (i32 (%struct.i2c_adapter*)* @i2c_bit_add_numbered_bus to i64), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__kstrtab_i2c_bit_add_numbered_bus, i32 0, i32 0) }, section "___ksymtab+i2c_bit_add_numbered_bus", align 8
@jiffies = external global i64, align 8
@.str = private unnamed_addr constant [31 x i8] c"died at extended address code\0A\00", align 1
@.str.1 = private unnamed_addr constant [26 x i8] c"died at 2nd address code\0A\00", align 1
@.str.2 = private unnamed_addr constant [31 x i8] c"died at repeated address code\0A\00", align 1
@.str.3 = private unnamed_addr constant [38 x i8] c"readbytes: invalid block length (%d)\0A\00", align 1
@.str.4 = private unnamed_addr constant [28 x i8] c"readbytes: ack/nak timeout\0A\00", align 1
@.str.5 = private unnamed_addr constant [25 x i8] c"sendbytes: NAK bailout.\0A\00", align 1
@.str.6 = private unnamed_addr constant [21 x i8] c"sendbytes: error %d\0A\00", align 1
@i2c_bit_quirk_no_clk_stretch = internal constant %struct.i2c_adapter_quirks { i64 16, i32 0, i16 0, i16 0, i16 0, i16 0 }, align 8
@.str.7 = private unnamed_addr constant [35 x i8] c"Not I2C compliant: can't read SCL\0A\00", align 1
@.str.8 = private unnamed_addr constant [23 x i8] c"Bus may be unreliable\0A\00", align 1
@.str.9 = private unnamed_addr constant [45 x i8] c"\016%s: Testing SDA only, SCL is not readable\0A\00", align 1
@.str.10 = private unnamed_addr constant [45 x i8] c"\014%s: bus seems to be busy (scl=%d, sda=%d)\0A\00", align 1
@.str.11 = private unnamed_addr constant [23 x i8] c"\014%s: SDA stuck high!\0A\00", align 1
@.str.12 = private unnamed_addr constant [49 x i8] c"\014%s: SCL unexpected low while pulling SDA low!\0A\00", align 1
@.str.13 = private unnamed_addr constant [22 x i8] c"\014%s: SDA stuck low!\0A\00", align 1
@.str.14 = private unnamed_addr constant [50 x i8] c"\014%s: SCL unexpected low while pulling SDA high!\0A\00", align 1
@.str.15 = private unnamed_addr constant [23 x i8] c"\014%s: SCL stuck high!\0A\00", align 1
@.str.16 = private unnamed_addr constant [49 x i8] c"\014%s: SDA unexpected low while pulling SCL low!\0A\00", align 1
@.str.17 = private unnamed_addr constant [22 x i8] c"\014%s: SCL stuck low!\0A\00", align 1
@.str.18 = private unnamed_addr constant [50 x i8] c"\014%s: SDA unexpected low while pulling SCL high!\0A\00", align 1
@.str.19 = private unnamed_addr constant [15 x i8] c"\016%s: Test OK\0A\00", align 1
@llvm.used = appending global [4 x i8*] [i8* bitcast (%struct.kernel_param* @__param_bit_test to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_algo to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_bus to i8*), i8* bitcast (%struct.kernel_symbol* @__ksymtab_i2c_bit_add_numbered_bus to i8*)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define internal i32 @bit_xfer(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msgs, i32 %num) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !35
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %do.end

if.then:                                          ; preds = %entry
  %pre_xfer1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer1, align 8, !tbaa !35
  %call = call i32 %3(%struct.i2c_adapter* %i2c_adap)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %do.end

do.end:                                           ; preds = %entry, %if.then
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %i.0 = phi i32 [ 0, %do.end ], [ %inc, %for.inc ]
  %cmp4 = icmp slt i32 %i.0, %num
  br i1 %cmp4, label %for.body, label %do.end70

for.body:                                         ; preds = %for.cond
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msgs, i64 %idxprom
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %4 = load i16, i16* %flags, align 2, !tbaa !37
  %conv = zext i16 %4 to i32
  %and = and i32 %conv, 4096
  %conv5 = trunc i32 %and to i16
  %flags6 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %5 = load i16, i16* %flags6, align 2, !tbaa !37
  %conv7 = zext i16 %5 to i32
  %and8 = and i32 %conv7, 16384
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end26, label %if.then10

if.then10:                                        ; preds = %for.body
  %tobool11 = icmp ne i32 %i.0, 0
  br i1 %tobool11, label %do.end15, label %if.end16

do.end15:                                         ; preds = %if.then10
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %1)
  br label %if.end16

if.end16:                                         ; preds = %do.end15, %if.then10
  %call17 = call i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp18 = icmp eq i32 %call17, 0
  %tobool20 = icmp ne i16 %conv5, 0
  %or.cond = or i1 %cmp18, %tobool20
  br i1 %or.cond, label %if.end26, label %do.end70

if.end26:                                         ; preds = %if.end16, %for.body
  %flags27 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 1
  %6 = load i16, i16* %flags27, align 2, !tbaa !37
  %conv28 = zext i16 %6 to i32
  %and29 = and i32 %conv28, 1
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then31, label %if.else

if.then31:                                        ; preds = %if.end26
  %call32 = call i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp33 = icmp sge i32 %call32, 1
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %7 = load i16, i16* %len, align 4, !tbaa !40
  %conv40 = zext i16 %7 to i32
  %cmp41 = icmp slt i32 %call32, %conv40
  br i1 %cmp41, label %if.then43, label %for.inc

if.then43:                                        ; preds = %if.then31
  %cmp44 = icmp sge i32 %call32, 0
  %.call32 = select i1 %cmp44, i32 -5, i32 %call32
  br label %do.end70

if.else:                                          ; preds = %if.end26
  %call49 = call i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %arrayidx)
  %cmp50 = icmp sge i32 %call49, 1
  %len57 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %arrayidx, i32 0, i32 2
  %8 = load i16, i16* %len57, align 4, !tbaa !40
  %conv58 = zext i16 %8 to i32
  %cmp59 = icmp slt i32 %call49, %conv58
  br i1 %cmp59, label %if.then61, label %for.inc

if.then61:                                        ; preds = %if.else
  %cmp62 = icmp sge i32 %call49, 0
  %.call49 = select i1 %cmp62, i32 -5, i32 %call49
  br label %do.end70

for.inc:                                          ; preds = %if.then31, %if.else
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

do.end70:                                         ; preds = %if.then43, %if.then61, %if.end16, %for.cond
  %ret.2 = phi i32 [ %.call32, %if.then43 ], [ %.call49, %if.then61 ], [ %call17, %if.end16 ], [ %i.0, %for.cond ]
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %9 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !41
  %tobool71 = icmp ne void (%struct.i2c_adapter*)* %9, null
  br i1 %tobool71, label %if.then72, label %cleanup

if.then72:                                        ; preds = %do.end70
  %post_xfer73 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %10 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer73, align 8, !tbaa !41
  call void %10(%struct.i2c_adapter* %i2c_adap)
  br label %cleanup

cleanup:                                          ; preds = %do.end70, %if.then72, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %ret.2, %if.then72 ], [ %ret.2, %do.end70 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_func(%struct.i2c_adapter* %adap) #0 {
entry:
  ret i32 268402719
}

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_bus(%struct.i2c_adapter* %adap) #0 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_adapter)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* %add_adapter) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %2 = load i32, i32* @bit_test, align 4, !tbaa !42
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %call = call i32 @test_bus(%struct.i2c_adapter* %adap)
  %3 = load i32, i32* @bit_test, align 4, !tbaa !42
  %cmp = icmp sge i32 %3, 2
  %cmp1 = icmp slt i32 %call, 0
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.then, %entry
  %algo = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 2
  store %struct.i2c_algorithm* bitcast ({ i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }* @i2c_bit_algo to %struct.i2c_algorithm*), %struct.i2c_algorithm** %algo, align 8, !tbaa !43
  %retries = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 8
  store i32 3, i32* %retries, align 4, !tbaa !44
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !45
  %cmp4 = icmp eq i32 (i8*)* %4, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %quirks = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 16
  store %struct.i2c_adapter_quirks* @i2c_bit_quirk_no_clk_stretch, %struct.i2c_adapter_quirks** %quirks, align 8, !tbaa !46
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %call7 = call i32 %add_adapter(%struct.i2c_adapter* %adap)
  %cmp8 = icmp slt i32 %call7, 0
  br i1 %cmp8, label %cleanup, label %if.end10

if.end10:                                         ; preds = %if.end6
  %getscl11 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %5 = load i32 (i8*)*, i32 (i8*)** %getscl11, align 8, !tbaa !45
  %cmp12 = icmp eq i32 (i8*)* %5, null
  br i1 %cmp12, label %if.then13, label %cleanup

if.then13:                                        ; preds = %if.end10
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.7, i32 0, i32 0))
  %dev14 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_warn(%struct.device* %dev14, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.8, i32 0, i32 0))
  br label %cleanup

cleanup:                                          ; preds = %if.end10, %if.then13, %if.end6, %if.then
  %retval.0 = phi i32 [ -19, %if.then ], [ %call7, %if.end6 ], [ 0, %if.then13 ], [ 0, %if.end10 ]
  ret i32 %retval.0
}

declare i32 @i2c_add_adapter(%struct.i2c_adapter*) #1

; Function Attrs: nounwind uwtable
define i32 @i2c_bit_add_numbered_bus(%struct.i2c_adapter* %adap) #0 {
entry:
  %call = call i32 @__i2c_bit_add_bus(%struct.i2c_adapter* %adap, i32 (%struct.i2c_adapter*)* @i2c_add_numbered_adapter)
  ret i32 %call
}

declare i32 @i2c_add_numbered_adapter(%struct.i2c_adapter*) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define internal void @i2c_start(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !48
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !49
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @i2c_repstart(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  call void @sdahi(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !48
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !49
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @scllo(%struct.i2c_algo_bit_data* %adap)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bit_doAddress(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #0 {
entry:
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %0 = load i16, i16* %flags1, align 2, !tbaa !37
  %flags2 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %1 = load i16, i16* %flags2, align 2, !tbaa !37
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 4096
  %conv3 = trunc i32 %and to i16
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %2 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %3 = bitcast i8* %2 to %struct.i2c_algo_bit_data*
  %conv4 = zext i16 %conv3 to i32
  %tobool = icmp ne i32 %conv4, 0
  br i1 %tobool, label %cond.end, label %cond.false

cond.false:                                       ; preds = %entry
  %retries5 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 8
  %4 = load i32, i32* %retries5, align 4, !tbaa !44
  br label %cond.end

cond.end:                                         ; preds = %entry, %cond.false
  %cond = phi i32 [ %4, %cond.false ], [ 0, %entry ]
  %conv6 = zext i16 %0 to i32
  %and7 = and i32 %conv6, 16
  %tobool8 = icmp ne i32 %and7, 0
  %addr9 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %5 = load i16, i16* %addr9, align 8, !tbaa !50
  %conv10 = zext i16 %5 to i32
  br i1 %tobool8, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %shr = ashr i32 %conv10, 7
  %and11 = and i32 %shr, 6
  %or = or i32 240, %and11
  %conv12 = trunc i32 %or to i8
  %call = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv12, i32 %cond)
  %cmp = icmp eq i32 %call, 1
  %tobool14 = icmp ne i16 %conv3, 0
  %or.cond = or i1 %cmp, %tobool14
  br i1 %or.cond, label %if.end, label %if.then15

if.then15:                                        ; preds = %if.then
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %if.then
  %addr16 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 0
  %6 = load i16, i16* %addr16, align 8, !tbaa !50
  %conv17 = zext i16 %6 to i32
  %and18 = and i32 %conv17, 255
  %conv19 = trunc i32 %and18 to i8
  %call20 = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv19)
  %cmp21 = icmp eq i32 %call20, 1
  %tobool24 = icmp ne i16 %conv3, 0
  %or.cond1 = or i1 %cmp21, %tobool24
  br i1 %or.cond1, label %if.end27, label %if.then25

if.then25:                                        ; preds = %if.end
  %dev26 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev26, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.1, i32 0, i32 0))
  br label %cleanup

if.end27:                                         ; preds = %if.end
  %conv28 = zext i16 %0 to i32
  %and29 = and i32 %conv28, 1
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %do.end34, label %if.end72

do.end34:                                         ; preds = %if.end27
  call void @i2c_repstart(%struct.i2c_algo_bit_data* %3)
  %conv35 = zext i8 %conv12 to i32
  %or36 = or i32 %conv35, 1
  %conv37 = trunc i32 %or36 to i8
  %call38 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %conv37, i32 %cond)
  %cmp39 = icmp eq i32 %call38, 1
  %tobool42 = icmp ne i16 %conv3, 0
  %or.cond2 = or i1 %cmp39, %tobool42
  br i1 %or.cond2, label %if.end72, label %if.then43

if.then43:                                        ; preds = %do.end34
  %dev44 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev44, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.2, i32 0, i32 0))
  br label %cleanup

if.else:                                          ; preds = %cond.end
  %shl = shl i32 %conv10, 1
  %conv49 = trunc i32 %shl to i8
  %conv50 = zext i16 %0 to i32
  %and51 = and i32 %conv50, 1
  %tobool52 = icmp ne i32 %and51, 0
  %conv54 = zext i8 %conv49 to i32
  %or55 = or i32 %conv54, 1
  %conv56 = trunc i32 %or55 to i8
  %addr.0 = select i1 %tobool52, i8 %conv56, i8 %conv49
  %conv58 = zext i16 %0 to i32
  %and59 = and i32 %conv58, 8192
  %tobool60 = icmp ne i32 %and59, 0
  %conv62 = zext i8 %addr.0 to i32
  %xor = xor i32 %conv62, 1
  %conv63 = trunc i32 %xor to i8
  %addr.1 = select i1 %tobool60, i8 %conv63, i8 %addr.0
  %call65 = call i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr.1, i32 %cond)
  %cmp66 = icmp eq i32 %call65, 1
  %tobool69 = icmp ne i16 %conv3, 0
  %or.cond3 = or i1 %cmp66, %tobool69
  br i1 %or.cond3, label %if.end72, label %cleanup

if.end72:                                         ; preds = %if.else, %if.end27, %do.end34
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.end72, %if.then43, %if.then25, %if.then15
  %retval.0 = phi i32 [ 0, %if.end72 ], [ -5, %if.then43 ], [ -6, %if.then25 ], [ -6, %if.then15 ], [ -6, %if.else ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @readbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #0 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !51
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !40
  %conv = zext i16 %1 to i32
  %flags1 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags1, align 2, !tbaa !37
  %conv2 = zext i16 %2 to i32
  br label %while.cond

while.cond:                                       ; preds = %if.end34, %entry
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.end34 ]
  %rdcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.end34 ]
  %count.0 = phi i32 [ %conv, %entry ], [ %count.1, %if.end34 ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %call = call i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap)
  %cmp4 = icmp sge i32 %call, 0
  br i1 %cmp4, label %if.then, label %cleanup

if.then:                                          ; preds = %while.body
  %conv6 = trunc i32 %call to i8
  store i8 %conv6, i8* %temp.0, align 1, !tbaa !52
  %inc = add nsw i32 %rdcount.0, 1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %dec = add nsw i32 %count.0, -1
  %cmp7 = icmp eq i32 %inc, 1
  %and = and i32 %conv2, 1024
  %tobool = icmp ne i32 %and, 0
  %or.cond = and i1 %cmp7, %tobool
  br i1 %or.cond, label %if.then9, label %do.end

if.then9:                                         ; preds = %if.then
  %cmp10 = icmp sle i32 %call, 0
  %cmp12 = icmp sgt i32 %call, 32
  %or.cond1 = or i1 %cmp10, %cmp12
  br i1 %or.cond1, label %if.then14, label %if.end20

if.then14:                                        ; preds = %if.then9
  %and15 = and i32 %conv2, 2048
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end19, label %if.then17

if.then17:                                        ; preds = %if.then14
  %call18 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 0)
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.then14
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.3, i32 0, i32 0), i32 %call)
  br label %cleanup

if.end20:                                         ; preds = %if.then9
  %add = add nsw i32 %dec, %call
  %len21 = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %3 = load i16, i16* %len21, align 4, !tbaa !40
  %conv22 = zext i16 %3 to i32
  %add23 = add nsw i32 %conv22, %call
  %conv24 = trunc i32 %add23 to i16
  store i16 %conv24, i16* %len21, align 4, !tbaa !40
  br label %do.end

do.end:                                           ; preds = %if.then, %if.end20
  %count.1 = phi i32 [ %add, %if.end20 ], [ %dec, %if.then ]
  %and26 = and i32 %conv2, 2048
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.end34, label %if.then28

if.then28:                                        ; preds = %do.end
  %call29 = call i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %count.1)
  %cmp30 = icmp slt i32 %call29, 0
  br i1 %cmp30, label %cleanup, label %if.end34

if.end34:                                         ; preds = %if.then28, %do.end
  br label %while.cond

cleanup:                                          ; preds = %while.body, %while.cond, %if.then28, %if.end19
  %retval.0 = phi i32 [ -71, %if.end19 ], [ %call29, %if.then28 ], [ %rdcount.0, %while.cond ], [ %rdcount.0, %while.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sendbytes(%struct.i2c_adapter* %i2c_adap, %struct.i2c_msg* %msg) #0 {
entry:
  %buf = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 3
  %0 = load i8*, i8** %buf, align 8, !tbaa !51
  %len = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 2
  %1 = load i16, i16* %len, align 4, !tbaa !40
  %conv = zext i16 %1 to i32
  %flags = getelementptr inbounds %struct.i2c_msg, %struct.i2c_msg* %msg, i32 0, i32 1
  %2 = load i16, i16* %flags, align 2, !tbaa !37
  %conv1 = zext i16 %2 to i32
  %and = and i32 %conv1, 4096
  %conv2 = trunc i32 %and to i16
  br label %while.cond

while.cond:                                       ; preds = %if.then, %entry
  %count.0 = phi i32 [ %conv, %entry ], [ %dec, %if.then ]
  %temp.0 = phi i8* [ %0, %entry ], [ %incdec.ptr, %if.then ]
  %wrcount.0 = phi i32 [ 0, %entry ], [ %inc, %if.then ]
  %cmp = icmp sgt i32 %count.0, 0
  br i1 %cmp, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond
  %3 = load i8, i8* %temp.0, align 1, !tbaa !52
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %3)
  %cmp5 = icmp sgt i32 %call, 0
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %conv7 = zext i16 %conv2 to i32
  %tobool = icmp ne i32 %conv7, 0
  %cmp8 = icmp eq i32 %call, 0
  %or.cond = and i1 %tobool, %cmp8
  br i1 %or.cond, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %while.body
  %dec = add nsw i32 %count.0, -1
  %incdec.ptr = getelementptr inbounds i8, i8* %temp.0, i32 1
  %inc = add nsw i32 %wrcount.0, 1
  br label %while.cond

if.else:                                          ; preds = %lor.lhs.false
  %cmp10 = icmp eq i32 %call, 0
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  br i1 %cmp10, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.5, i32 0, i32 0))
  br label %cleanup

if.else13:                                        ; preds = %if.else
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0), i32 %call)
  br label %cleanup

cleanup:                                          ; preds = %while.cond, %if.else13, %if.then12
  %retval.0 = phi i32 [ -5, %if.then12 ], [ %call, %if.else13 ], [ %wrcount.0, %while.cond ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @i2c_stop(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  call void @sdalo(%struct.i2c_algo_bit_data* %adap)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %adap)
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !48
  call void %0(i8* %1, i32 1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !49
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

declare void @__udelay(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @scllo(%struct.i2c_algo_bit_data* %adap) #3 {
entry:
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !53
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !48
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !49
  %div = sdiv i32 %2, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdahi(%struct.i2c_algo_bit_data* %adap) #3 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !48
  call void %0(i8* %1, i32 1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !49
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sclhi(%struct.i2c_algo_bit_data* %adap) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy5 = alloca i64, align 8
  %__dummy26 = alloca i64, align 8
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 2
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !53
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !48
  call void %0(i8* %1, i32 1)
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %2 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !45
  %tobool = icmp ne i32 (i8*)* %2, null
  br i1 %tobool, label %if.end, label %done

if.end:                                           ; preds = %entry
  %3 = load volatile i64, i64* @jiffies, align 8, !tbaa !54
  br label %while.cond

while.cond:                                       ; preds = %if.end22, %if.end
  %getscl1 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl1, align 8, !tbaa !45
  %data2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %5 = load i8*, i8** %data2, align 8, !tbaa !48
  %call = call i32 %4(i8* %5)
  %tobool3 = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool3, true
  br i1 %lnot, label %while.body, label %done

while.body:                                       ; preds = %while.cond
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #5
  %7 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #5
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %8 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %8) #5
  %9 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #5
  %tobool4 = icmp ne i32 1, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %while.body
  %10 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %10) #5
  %11 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #5
  %cmp7 = icmp eq i64* %__dummy5, %__dummy26
  %conv8 = zext i1 %cmp7 to i32
  %12 = bitcast i64* %__dummy26 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %12) #5
  %13 = bitcast i64* %__dummy5 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %13) #5
  %timeout = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 8
  %14 = load i32, i32* %timeout, align 4, !tbaa !55
  %conv12 = sext i32 %14 to i64
  %add = add i64 %3, %conv12
  %15 = load volatile i64, i64* @jiffies, align 8, !tbaa !54
  %sub = sub i64 %add, %15
  %cmp13 = icmp slt i64 %sub, 0
  br i1 %cmp13, label %if.then15, label %if.end22

if.then15:                                        ; preds = %land.lhs.true
  %getscl16 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 4
  %16 = load i32 (i8*)*, i32 (i8*)** %getscl16, align 8, !tbaa !45
  %data17 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %17 = load i8*, i8** %data17, align 8, !tbaa !48
  %call18 = call i32 %16(i8* %17)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %done, label %cleanup

if.end22:                                         ; preds = %land.lhs.true, %while.body
  call void @cpu_relax()
  br label %while.cond

done:                                             ; preds = %if.then15, %while.cond, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %18 = load i32, i32* %udelay, align 8, !tbaa !49
  %conv23 = sext i32 %18 to i64
  call void @__udelay(i64 %conv23)
  br label %cleanup

cleanup:                                          ; preds = %if.then15, %done
  %retval.0 = phi i32 [ 0, %done ], [ -110, %if.then15 ]
  ret i32 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @cpu_relax() #4 {
entry:
  call void @rep_nop()
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @rep_nop() #4 {
entry:
  call void asm sideeffect "rep; nop", "~{memory},~{dirflag},~{fpsr},~{flags}"() #5, !srcloc !56
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @try_address(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr, i32 %retries) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %do.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %do.end ]
  %ret.0 = phi i32 [ 0, %entry ], [ %call, %do.end ]
  %cmp = icmp sle i32 %i.0, %retries
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %addr)
  %cmp1 = icmp eq i32 %call, 1
  %cmp2 = icmp eq i32 %i.0, %retries
  %or.cond = or i1 %cmp1, %cmp2
  br i1 %or.cond, label %for.end, label %do.end

do.end:                                           ; preds = %for.body
  call void @i2c_stop(%struct.i2c_algo_bit_data* %1)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !49
  %conv = sext i32 %2 to i64
  call void @__udelay(i64 %conv)
  call void @yield()
  call void @i2c_start(%struct.i2c_algo_bit_data* %1)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond, %for.body
  %ret.1 = phi i32 [ %call, %for.body ], [ %ret.0, %for.cond ]
  %tobool = icmp ne i32 %i.0, 0
  %tobool6 = icmp ne i32 %ret.1, 0
  %or.cond1 = and i1 %tobool, %tobool6
  ret i32 %ret.1
}

declare void @dev_err(%struct.device*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @i2c_outb(%struct.i2c_adapter* %i2c_adap, i8 zeroext %c) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %i.0 = phi i32 [ 7, %entry ], [ %dec, %if.end ]
  %cmp = icmp sge i32 %i.0, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %conv = zext i8 %c to i32
  %shr = ashr i32 %conv, %i.0
  %and = and i32 %shr, 1
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !48
  call void %2(i8* %3, i32 %and)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !49
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv1 = sext i32 %div to i64
  call void @__udelay(i64 %conv1)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp2 = icmp slt i32 %call, 0
  br i1 %cmp2, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %dec = add nsw i32 %i.0, -1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call4 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp5 = icmp slt i32 %call4, 0
  br i1 %cmp5, label %cleanup, label %if.end11

if.end11:                                         ; preds = %for.end
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %5 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !57
  %data12 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %6 = load i8*, i8** %data12, align 8, !tbaa !48
  %call13 = call i32 %5(i8* %6)
  %tobool = icmp ne i32 %call13, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %for.end, %for.body, %if.end11
  %retval.0 = phi i32 [ %lnot.ext, %if.end11 ], [ -110, %for.body ], [ -110, %for.end ]
  ret i32 %retval.0
}

declare void @yield() #1

; Function Attrs: nounwind uwtable
define internal i32 @i2c_inb(%struct.i2c_adapter* %i2c_adap) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %indata.0 = phi i8 [ 0, %entry ], [ %indata.1, %if.end ]
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %if.end ]
  %cmp = icmp slt i32 %i.0, 8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  %conv = zext i8 %indata.0 to i32
  %mul = mul nsw i32 %conv, 2
  %conv2 = trunc i32 %mul to i8
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %2 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !57
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !48
  %call3 = call i32 %2(i8* %3)
  %tobool = icmp ne i32 %call3, 0
  %conv5 = zext i8 %conv2 to i32
  %or = or i32 %conv5, 1
  %conv6 = trunc i32 %or to i8
  %indata.1 = select i1 %tobool, i8 %conv6, i8 %conv2
  %setscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 2
  %4 = load void (i8*, i32)*, void (i8*, i32)** %setscl, align 8, !tbaa !53
  %data8 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %5 = load i8*, i8** %data8, align 8, !tbaa !48
  call void %4(i8* %5, i32 0)
  %cmp9 = icmp eq i32 %i.0, 7
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %6 = load i32, i32* %udelay, align 8, !tbaa !49
  %div = sdiv i32 %6, 2
  %cond = select i1 %cmp9, i32 %div, i32 %6
  %conv12 = sext i32 %cond to i64
  call void @__udelay(i64 %conv12)
  %inc = add nsw i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %conv13 = zext i8 %indata.0 to i32
  br label %cleanup

cleanup:                                          ; preds = %for.body, %for.end
  %retval.0 = phi i32 [ %conv13, %for.end ], [ -110, %for.body ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @acknak(%struct.i2c_adapter* %i2c_adap, i32 %is_ack) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %tobool = icmp ne i32 %is_ack, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 1
  %2 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %3 = load i8*, i8** %data, align 8, !tbaa !48
  call void %2(i8* %3, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 7
  %4 = load i32, i32* %udelay, align 8, !tbaa !49
  %add = add nsw i32 %4, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  %call = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %dev = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 9
  call void (%struct.device*, i8*, ...) @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.4, i32 0, i32 0))
  br label %cleanup

if.end3:                                          ; preds = %if.end
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.then2
  %retval.0 = phi i32 [ -110, %if.then2 ], [ 0, %if.end3 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sdalo(%struct.i2c_algo_bit_data* %adap) #3 {
entry:
  %setsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 1
  %0 = load void (i8*, i32)*, void (i8*, i32)** %setsda, align 8, !tbaa !47
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 0
  %1 = load i8*, i8** %data, align 8, !tbaa !48
  call void %0(i8* %1, i32 0)
  %udelay = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %adap, i32 0, i32 7
  %2 = load i32, i32* %udelay, align 8, !tbaa !49
  %add = add nsw i32 %2, 1
  %div = sdiv i32 %add, 2
  %conv = sext i32 %div to i64
  call void @__udelay(i64 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @test_bus(%struct.i2c_adapter* %i2c_adap) #0 {
entry:
  %algo_data = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 3
  %0 = load i8*, i8** %algo_data, align 8, !tbaa !2
  %1 = bitcast i8* %0 to %struct.i2c_algo_bit_data*
  %name1 = getelementptr inbounds %struct.i2c_adapter, %struct.i2c_adapter* %i2c_adap, i32 0, i32 11
  %arraydecay = getelementptr inbounds [48 x i8], [48 x i8]* %name1, i32 0, i32 0
  %pre_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %2 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer, align 8, !tbaa !35
  %tobool = icmp ne i32 (%struct.i2c_adapter*)* %2, null
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %pre_xfer2 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 5
  %3 = load i32 (%struct.i2c_adapter*)*, i32 (%struct.i2c_adapter*)** %pre_xfer2, align 8, !tbaa !35
  %call = call i32 %3(%struct.i2c_adapter* %i2c_adap)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %cleanup, label %if.end4

if.end4:                                          ; preds = %if.then, %entry
  %getscl = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %4 = load i32 (i8*)*, i32 (i8*)** %getscl, align 8, !tbaa !45
  %cmp5 = icmp eq i32 (i8*)* %4, null
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end4
  %call7 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.9, i32 0, i32 0), i8* %arraydecay)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end4
  %getsda = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %5 = load i32 (i8*)*, i32 (i8*)** %getsda, align 8, !tbaa !57
  %data = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %6 = load i8*, i8** %data, align 8, !tbaa !48
  %call9 = call i32 %5(i8* %6)
  %getscl10 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %7 = load i32 (i8*)*, i32 (i8*)** %getscl10, align 8, !tbaa !45
  %cmp11 = icmp eq i32 (i8*)* %7, null
  br i1 %cmp11, label %cond.end, label %cond.false

cond.false:                                       ; preds = %if.end8
  %getscl12 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %8 = load i32 (i8*)*, i32 (i8*)** %getscl12, align 8, !tbaa !45
  %data13 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %9 = load i8*, i8** %data13, align 8, !tbaa !48
  %call14 = call i32 %8(i8* %9)
  br label %cond.end

cond.end:                                         ; preds = %if.end8, %cond.false
  %cond = phi i32 [ %call14, %cond.false ], [ 1, %if.end8 ]
  %tobool15 = icmp ne i32 %cond, 0
  %tobool16 = icmp ne i32 %call9, 0
  %or.cond = and i1 %tobool15, %tobool16
  br i1 %or.cond, label %if.end19, label %if.then17

if.then17:                                        ; preds = %cond.end
  %call18 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.10, i32 0, i32 0), i8* %arraydecay, i32 %cond, i32 %call9)
  br label %bailout

if.end19:                                         ; preds = %cond.end
  call void @sdalo(%struct.i2c_algo_bit_data* %1)
  %getsda20 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %10 = load i32 (i8*)*, i32 (i8*)** %getsda20, align 8, !tbaa !57
  %data21 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %11 = load i8*, i8** %data21, align 8, !tbaa !48
  %call22 = call i32 %10(i8* %11)
  %getscl23 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %12 = load i32 (i8*)*, i32 (i8*)** %getscl23, align 8, !tbaa !45
  %cmp24 = icmp eq i32 (i8*)* %12, null
  br i1 %cmp24, label %cond.end30, label %cond.false26

cond.false26:                                     ; preds = %if.end19
  %getscl27 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %13 = load i32 (i8*)*, i32 (i8*)** %getscl27, align 8, !tbaa !45
  %data28 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %14 = load i8*, i8** %data28, align 8, !tbaa !48
  %call29 = call i32 %13(i8* %14)
  br label %cond.end30

cond.end30:                                       ; preds = %if.end19, %cond.false26
  %cond31 = phi i32 [ %call29, %cond.false26 ], [ 1, %if.end19 ]
  %tobool32 = icmp ne i32 %call22, 0
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %cond.end30
  %call34 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.11, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end35:                                         ; preds = %cond.end30
  %tobool36 = icmp ne i32 %cond31, 0
  br i1 %tobool36, label %if.end39, label %if.then37

if.then37:                                        ; preds = %if.end35
  %call38 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.12, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end39:                                         ; preds = %if.end35
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %getsda40 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %15 = load i32 (i8*)*, i32 (i8*)** %getsda40, align 8, !tbaa !57
  %data41 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %16 = load i8*, i8** %data41, align 8, !tbaa !48
  %call42 = call i32 %15(i8* %16)
  %getscl43 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %17 = load i32 (i8*)*, i32 (i8*)** %getscl43, align 8, !tbaa !45
  %cmp44 = icmp eq i32 (i8*)* %17, null
  br i1 %cmp44, label %cond.end50, label %cond.false46

cond.false46:                                     ; preds = %if.end39
  %getscl47 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %18 = load i32 (i8*)*, i32 (i8*)** %getscl47, align 8, !tbaa !45
  %data48 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %19 = load i8*, i8** %data48, align 8, !tbaa !48
  %call49 = call i32 %18(i8* %19)
  br label %cond.end50

cond.end50:                                       ; preds = %if.end39, %cond.false46
  %cond51 = phi i32 [ %call49, %cond.false46 ], [ 1, %if.end39 ]
  %tobool52 = icmp ne i32 %call42, 0
  br i1 %tobool52, label %if.end55, label %if.then53

if.then53:                                        ; preds = %cond.end50
  %call54 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.13, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end55:                                         ; preds = %cond.end50
  %tobool56 = icmp ne i32 %cond51, 0
  br i1 %tobool56, label %if.end59, label %if.then57

if.then57:                                        ; preds = %if.end55
  %call58 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.14, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end59:                                         ; preds = %if.end55
  call void @scllo(%struct.i2c_algo_bit_data* %1)
  %getsda60 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %20 = load i32 (i8*)*, i32 (i8*)** %getsda60, align 8, !tbaa !57
  %data61 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %21 = load i8*, i8** %data61, align 8, !tbaa !48
  %call62 = call i32 %20(i8* %21)
  %getscl63 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %22 = load i32 (i8*)*, i32 (i8*)** %getscl63, align 8, !tbaa !45
  %cmp64 = icmp eq i32 (i8*)* %22, null
  br i1 %cmp64, label %cond.end70, label %cond.false66

cond.false66:                                     ; preds = %if.end59
  %getscl67 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %23 = load i32 (i8*)*, i32 (i8*)** %getscl67, align 8, !tbaa !45
  %data68 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %24 = load i8*, i8** %data68, align 8, !tbaa !48
  %call69 = call i32 %23(i8* %24)
  br label %cond.end70

cond.end70:                                       ; preds = %if.end59, %cond.false66
  %cond71 = phi i32 [ %call69, %cond.false66 ], [ 0, %if.end59 ]
  %tobool72 = icmp ne i32 %cond71, 0
  br i1 %tobool72, label %if.then73, label %if.end75

if.then73:                                        ; preds = %cond.end70
  %call74 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.15, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end75:                                         ; preds = %cond.end70
  %tobool76 = icmp ne i32 %call62, 0
  br i1 %tobool76, label %if.end79, label %if.then77

if.then77:                                        ; preds = %if.end75
  %call78 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.16, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end79:                                         ; preds = %if.end75
  %call80 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %getsda81 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 3
  %25 = load i32 (i8*)*, i32 (i8*)** %getsda81, align 8, !tbaa !57
  %data82 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %26 = load i8*, i8** %data82, align 8, !tbaa !48
  %call83 = call i32 %25(i8* %26)
  %getscl84 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %27 = load i32 (i8*)*, i32 (i8*)** %getscl84, align 8, !tbaa !45
  %cmp85 = icmp eq i32 (i8*)* %27, null
  br i1 %cmp85, label %cond.end91, label %cond.false87

cond.false87:                                     ; preds = %if.end79
  %getscl88 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 4
  %28 = load i32 (i8*)*, i32 (i8*)** %getscl88, align 8, !tbaa !45
  %data89 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 0
  %29 = load i8*, i8** %data89, align 8, !tbaa !48
  %call90 = call i32 %28(i8* %29)
  br label %cond.end91

cond.end91:                                       ; preds = %if.end79, %cond.false87
  %cond92 = phi i32 [ %call90, %cond.false87 ], [ 1, %if.end79 ]
  %tobool93 = icmp ne i32 %cond92, 0
  br i1 %tobool93, label %if.end96, label %if.then94

if.then94:                                        ; preds = %cond.end91
  %call95 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.17, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end96:                                         ; preds = %cond.end91
  %tobool97 = icmp ne i32 %call83, 0
  br i1 %tobool97, label %if.end100, label %if.then98

if.then98:                                        ; preds = %if.end96
  %call99 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.18, i32 0, i32 0), i8* %arraydecay)
  br label %bailout

if.end100:                                        ; preds = %if.end96
  %post_xfer = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %30 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer, align 8, !tbaa !41
  %tobool101 = icmp ne void (%struct.i2c_adapter*)* %30, null
  br i1 %tobool101, label %if.then102, label %if.end104

if.then102:                                       ; preds = %if.end100
  %post_xfer103 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %31 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer103, align 8, !tbaa !41
  call void %31(%struct.i2c_adapter* %i2c_adap)
  br label %if.end104

if.end104:                                        ; preds = %if.then102, %if.end100
  %call105 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.19, i32 0, i32 0), i8* %arraydecay)
  br label %cleanup

bailout:                                          ; preds = %if.then98, %if.then94, %if.then77, %if.then73, %if.then57, %if.then53, %if.then37, %if.then33, %if.then17
  call void @sdahi(%struct.i2c_algo_bit_data* %1)
  %call106 = call i32 @sclhi(%struct.i2c_algo_bit_data* %1)
  %post_xfer107 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %32 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer107, align 8, !tbaa !41
  %tobool108 = icmp ne void (%struct.i2c_adapter*)* %32, null
  br i1 %tobool108, label %if.then109, label %cleanup

if.then109:                                       ; preds = %bailout
  %post_xfer110 = getelementptr inbounds %struct.i2c_algo_bit_data, %struct.i2c_algo_bit_data* %1, i32 0, i32 6
  %33 = load void (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)** %post_xfer110, align 8, !tbaa !41
  call void %33(%struct.i2c_adapter* %i2c_adap)
  br label %cleanup

cleanup:                                          ; preds = %bailout, %if.then109, %if.then, %if.end104
  %retval.0 = phi i32 [ 0, %if.end104 ], [ -19, %if.then ], [ -19, %if.then109 ], [ -19, %bailout ]
  ret i32 %retval.0
}

declare void @dev_warn(%struct.device*, i8*, ...) #1

declare i32 @printk(i8*, ...) #1

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"i2c_adapter", !4, i64 0, !7, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !8, i64 40, !8, i64 72, !7, i64 104, !7, i64 108, !13, i64 112, !7, i64 840, !5, i64 844, !27, i64 896, !18, i64 928, !15, i64 960, !4, i64 976, !4, i64 984, !4, i64 992}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"int", !5, i64 0}
!8 = !{!"rt_mutex", !9, i64 0, !12, i64 8, !4, i64 16, !4, i64 24}
!9 = !{!"raw_spinlock", !10, i64 0}
!10 = !{!"qspinlock", !11, i64 0}
!11 = !{!"", !7, i64 0}
!12 = !{!"rb_root", !4, i64 0}
!13 = !{!"device", !4, i64 0, !4, i64 8, !14, i64 16, !4, i64 80, !4, i64 88, !18, i64 96, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !23, i64 160, !24, i64 200, !4, i64 488, !4, i64 496, !15, i64 504, !7, i64 520, !4, i64 528, !4, i64 536, !32, i64 544, !20, i64 552, !4, i64 560, !15, i64 568, !4, i64 584, !33, i64 592, !4, i64 600, !4, i64 608, !7, i64 616, !7, i64 620, !21, i64 624, !15, i64 632, !34, i64 648, !4, i64 680, !4, i64 688, !4, i64 696, !4, i64 704, !4, i64 712, !26, i64 720, !26, i64 720}
!14 = !{!"kobject", !4, i64 0, !15, i64 8, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !16, i64 56, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60, !7, i64 60}
!15 = !{!"list_head", !4, i64 0, !4, i64 8}
!16 = !{!"kref", !17, i64 0}
!17 = !{!"refcount_struct", !11, i64 0}
!18 = !{!"mutex", !19, i64 0, !21, i64 8, !22, i64 12, !15, i64 16}
!19 = !{!"", !20, i64 0}
!20 = !{!"long", !5, i64 0}
!21 = !{!"spinlock", !5, i64 0}
!22 = !{!"optimistic_spin_queue", !11, i64 0}
!23 = !{!"dev_links_info", !15, i64 0, !15, i64 16, !5, i64 32}
!24 = !{!"dev_pm_info", !25, i64 0, !7, i64 4, !7, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 4, !26, i64 5, !21, i64 8, !15, i64 16, !27, i64 32, !4, i64 64, !26, i64 72, !26, i64 72, !26, i64 72, !29, i64 80, !20, i64 128, !31, i64 136, !28, i64 168, !4, i64 192, !11, i64 200, !11, i64 204, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !7, i64 208, !26, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 209, !7, i64 212, !5, i64 216, !5, i64 220, !7, i64 224, !7, i64 228, !20, i64 232, !20, i64 240, !20, i64 248, !20, i64 256, !4, i64 264, !4, i64 272, !4, i64 280}
!25 = !{!"pm_message", !7, i64 0}
!26 = !{!"_Bool", !5, i64 0}
!27 = !{!"completion", !7, i64 0, !28, i64 8}
!28 = !{!"__wait_queue_head", !21, i64 0, !15, i64 8}
!29 = !{!"timer_list", !30, i64 0, !20, i64 16, !4, i64 24, !20, i64 32, !7, i64 40}
!30 = !{!"hlist_node", !4, i64 0, !4, i64 8}
!31 = !{!"work_struct", !19, i64 0, !15, i64 8, !4, i64 24}
!32 = !{!"long long", !5, i64 0}
!33 = !{!"dev_archdata", !4, i64 0}
!34 = !{!"klist_node", !4, i64 0, !15, i64 8, !16, i64 24}
!35 = !{!36, !4, i64 40}
!36 = !{!"i2c_algo_bit_data", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !7, i64 56, !7, i64 60}
!37 = !{!38, !39, i64 2}
!38 = !{!"i2c_msg", !39, i64 0, !39, i64 2, !39, i64 4, !4, i64 8}
!39 = !{!"short", !5, i64 0}
!40 = !{!38, !39, i64 4}
!41 = !{!36, !4, i64 48}
!42 = !{!7, !7, i64 0}
!43 = !{!3, !4, i64 16}
!44 = !{!3, !7, i64 108}
!45 = !{!36, !4, i64 32}
!46 = !{!3, !4, i64 984}
!47 = !{!36, !4, i64 8}
!48 = !{!36, !4, i64 0}
!49 = !{!36, !7, i64 56}
!50 = !{!38, !39, i64 0}
!51 = !{!38, !4, i64 8}
!52 = !{!5, !5, i64 0}
!53 = !{!36, !4, i64 16}
!54 = !{!20, !20, i64 0}
!55 = !{!36, !7, i64 60}
!56 = !{i32 589877}
!57 = !{!36, !4, i64 24}
