; ModuleID = 'net/sunrpc/xprtsock.bc'
source_filename = "net/sunrpc/xprtsock.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.xprt_class = type { %struct.list_head, i32, %struct.rpc_xprt* (%struct.xprt_create*)*, %struct.module*, [32 x i8] }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.rpc_xprt = type { %struct.atomic_t, %struct.rpc_xprt_ops*, %struct.rpc_timeout*, %struct.__kernel_sockaddr_storage, i64, i32, i64, i64, i64, i32, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.list_head, i32, i32, %struct.atomic_t, i64, i8, i32, i32, i64, i64, i32, %struct.work_struct, %struct.timer_list, i64, i64, %struct.spinlock, %struct.spinlock, i32, %struct.rpc_task*, %struct.svc_xprt*, %struct.list_head, %struct.anon.70, %struct.net*, i8*, [6 x i8*] }
%struct.rpc_xprt_ops = type { void (%struct.rpc_xprt*, i64, i64)*, i32 (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*, i16)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, i8* (%struct.rpc_task*, i64)*, void (i8*)*, i32 (%struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*, %struct.seq_file*)* }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, i8* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, i8, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.mm_struct*, %struct.mm_struct*, %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, %struct.timespec, %struct.timespec, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, i32, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.plist_head, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, %struct.atomic_t }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i64 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, %struct.vm_area_struct*, i64 (%struct.file*, i64, i64, i64, i64)*, void (%struct.mm_struct*, i64)*, i64, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [44 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.hlist_head, %struct.file*, %struct.uprobes_state }
%struct.rb_root = type { %struct.rb_node* }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page* }
%struct.page = type { i64, %struct.address_space*, %struct.anon.15, %union.anon.21, %union.anon.23, [8 x i8] }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.40, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.41, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.42, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.7, %struct.list_head, %struct.hlist_node }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.3, i8* }
%union.anon.3 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type opaque
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%union.anon.7 = type { %struct.list_head }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.6, i32 }
%union.anon.6 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type { i8*, i32, i64 (%struct.dentry*, i8*, i64, i8*, i64, i32)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i32 (%struct.dentry*, i8*, i8*, i64, i32, i32)* }
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%struct.atomic64_t = type { i64 }
%union.anon.40 = type { i32 }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%union.anon.41 = type { %struct.callback_head }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.kiocb = type { %struct.atomic_t, %struct.file*, %struct.kioctx*, i32 (%struct.kiocb*, %struct.io_event*)*, void (%struct.kiocb*)*, %union.anon.53, i64, i64, i8*, i16, i64, i8*, i64, %struct.iovec, %struct.iovec*, i64, i64, %struct.list_head, %struct.eventfd_ctx* }
%struct.kioctx = type opaque
%struct.io_event = type { i64, i64, i64, i64 }
%union.anon.53 = type { i8* }
%struct.iovec = type { i8*, i64 }
%struct.eventfd_ctx = type opaque
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.8 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.8 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%union.anon.42 = type { %struct.pipe_inode_info* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.read_descriptor_t = type { i64, i64, %union.anon.14, i32 }
%union.anon.14 = type { i8* }
%struct.swap_info_struct = type opaque
%struct.anon.15 = type { %union.anon.16, %union.anon.17 }
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.21 = type { %struct.list_head }
%union.anon.23 = type { i64 }
%struct.pgd_t = type { i64 }
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.file = type { %union.anon.2, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.2 = type { %struct.list_head }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.cred = type { %struct.atomic_t, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.10, %struct.key_type*, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.11, i64, i32, i32, i32, i16, i16, i64, i8*, %union.anon.12, %union.anon.13 }
%union.anon.10 = type { %struct.rb_node }
%struct.key_type = type opaque
%struct.key_user = type opaque
%union.anon.11 = type { i64 }
%union.anon.12 = type { %struct.list_head }
%union.anon.13 = type { i64 }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, i32, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x i32], [0 x i32*] }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32 }
%struct.desc_struct = type { %union.anon.24 }
%union.anon.24 = type { %struct.anon.25 }
%struct.anon.25 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.xsave_struct }
%struct.xsave_struct = type { %struct.i387_fxsave_struct, %struct.xsave_hdr_struct, %struct.ymmh_struct }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.27, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.30 }
%union.anon.27 = type { %struct.anon.28 }
%struct.anon.28 = type { i64, i64 }
%union.anon.30 = type { [12 x i32] }
%struct.xsave_hdr_struct = type { i64, [2 x i64], [5 x i64] }
%struct.ymmh_struct = type { [64 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%union.ktime = type { i64 }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.1 }
%union.anon.1 = type { i16 }
%struct.plist_head = type { %struct.list_head }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.backing_dev_info = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.32 }
%union.anon.32 = type { %struct.anon.36, [80 x i8] }
%struct.anon.36 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.seqcount = type { i32 }
%struct.css_set = type { %struct.atomic_t, %struct.hlist_node, %struct.list_head, %struct.list_head, [4 x %struct.cgroup_subsys_state*], %struct.callback_head }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.atomic_t, i64, %struct.css_id*, %struct.work_struct }
%struct.cgroup = type { i64, %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.dentry*, %struct.cgroup_name*, [4 x %struct.cgroup_subsys_state*], %struct.cgroupfs_root*, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.callback_head, %struct.work_struct, %struct.list_head, %struct.spinlock, %struct.simple_xattrs }
%struct.cgroup_name = type { %struct.callback_head, [0 x i8] }
%struct.cgroupfs_root = type { %struct.super_block*, i64, i32, i64, %struct.list_head, %struct.cgroup, i32, %struct.list_head, %struct.list_head, i64, %struct.ida, [4096 x i8], [64 x i8] }
%struct.ida = type { %struct.idr, %struct.ida_bitmap* }
%struct.idr = type { %struct.idr_layer*, %struct.idr_layer*, %struct.idr_layer*, i32, i32, i32, %struct.spinlock }
%struct.idr_layer = type { i32, [4 x i64], [256 x %struct.idr_layer*], i32, i32, %struct.callback_head }
%struct.ida_bitmap = type { i64, [15 x i64] }
%struct.simple_xattrs = type { %struct.list_head, %struct.spinlock }
%struct.css_id = type opaque
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.pipe_inode_info = type opaque
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type { %struct.spinlock, i32, %struct.timespec, %struct.timespec, i64, i64, i32, i32, %struct.timespec, %struct.timespec, i64, i32 }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.rpc_timeout = type { i64, i64, i64, i32, i8 }
%struct.__kernel_sockaddr_storage = type { i16, [126 x i8] }
%struct.rpc_wait_queue = type { %struct.spinlock, [4 x %struct.list_head], i32, i8, i8, i8, i16, %struct.rpc_timer, i8* }
%struct.rpc_timer = type { %struct.timer_list, %struct.list_head, i64 }
%struct.atomic_t = type { i32 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.spinlock = type { %union.anon.0 }
%union.anon.0 = type { %struct.raw_spinlock }
%struct.rpc_task = type { %struct.atomic_t, %struct.list_head, %struct.rpc_clnt*, %struct.rpc_rqst*, %struct.rpc_message, void (%struct.rpc_task*)*, void (%struct.rpc_task*)*, %struct.rpc_call_ops*, i8*, i64, i64, %struct.workqueue_struct*, %struct.rpc_wait_queue*, %union.anon.69, %union.ktime, i32, i32, i16, i16, i8 }
%struct.rpc_clnt = type { %struct.atomic_t, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.rpc_xprt*, %struct.rpc_procinfo*, i32, i32, i32, i8*, %struct.rpc_auth*, %struct.rpc_stat*, %struct.rpc_iostats*, i8, %struct.rpc_rtt*, %struct.rpc_timeout*, i32, [32 x i8], %struct.dentry*, %struct.rpc_clnt*, %struct.rpc_rtt, %struct.rpc_timeout, %struct.rpc_program*, i8* }
%struct.rpc_procinfo = type { i32, void (i8*, %struct.xdr_stream*, i8*)*, i32 (i8*, %struct.xdr_stream*, i8*)*, i32, i32, i32, i32, i32, i8* }
%struct.xdr_stream = type { i32*, %struct.xdr_buf*, i32*, %struct.kvec*, %struct.kvec, %struct.page**, i32 }
%struct.xdr_buf = type { [1 x %struct.kvec], [1 x %struct.kvec], %struct.page**, i32, i32, i32, i32, i32 }
%struct.kvec = type { i8*, i64 }
%struct.rpc_auth = type { i32, i32, i32, i32, %struct.rpc_authops*, i32, %struct.atomic_t, %struct.rpc_cred_cache* }
%struct.rpc_authops = type { %struct.module*, i32, i8*, %struct.rpc_auth* (%struct.rpc_clnt*, i32)*, void (%struct.rpc_auth*)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, i32 (%struct.rpc_auth*)*, void (%struct.rpc_auth*)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)* }
%struct.rpc_cred = type { %struct.hlist_node, %struct.list_head, %struct.callback_head, %struct.rpc_auth*, %struct.rpc_credops*, i64, i64, %struct.atomic_t, i32 }
%struct.rpc_credops = type { i8*, i32 (%struct.rpc_auth*, %struct.rpc_cred*)*, void (%struct.rpc_cred*)*, i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)*, i32* (%struct.rpc_task*, i32*)*, i32 (%struct.rpc_task*)*, i32* (%struct.rpc_task*, i32*)*, i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)* }
%struct.auth_cred = type { i32, i32, %struct.group_info*, i8*, i8 }
%struct.rpcsec_gss_info = type opaque
%struct.rpc_cred_cache = type opaque
%struct.rpc_stat = type { %struct.rpc_program*, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.rpc_iostats = type opaque
%struct.rpc_rtt = type { i64, [5 x i64], [5 x i64], [5 x i32] }
%struct.rpc_program = type { i8*, i32, i32, %struct.rpc_version**, %struct.rpc_stat*, i8* }
%struct.rpc_version = type { i32, i32, %struct.rpc_procinfo* }
%struct.rpc_rqst = type { %struct.rpc_xprt*, %struct.xdr_buf, %struct.xdr_buf, %struct.rpc_task*, %struct.rpc_cred*, i32, i32, i32, i32, %struct.page**, void (%struct.rpc_rqst*)*, %struct.list_head, i32*, i64, i64, i64, i64, %struct.xdr_buf, i64, i64, %union.ktime, i32, i32, i32, %union.ktime, i32 }
%struct.rpc_message = type { %struct.rpc_procinfo*, i8*, i8*, %struct.rpc_cred* }
%struct.rpc_call_ops = type { void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)*, void (i8*)* }
%struct.workqueue_struct = type opaque
%union.anon.69 = type { %struct.rpc_wait }
%struct.rpc_wait = type { %struct.list_head, %struct.list_head, %struct.list_head, i64 }
%struct.svc_xprt = type { %struct.svc_xprt_class*, %struct.svc_xprt_ops*, %struct.kref, %struct.list_head, %struct.list_head, i64, %struct.svc_serv*, %struct.atomic_t, %struct.mutex, %struct.spinlock, i8*, %struct.list_head, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.rpc_wait_queue, %struct.list_head, %struct.net*, %struct.rpc_xprt* }
%struct.svc_xprt_class = type { i8*, %struct.module*, %struct.svc_xprt_ops*, %struct.list_head, i32 }
%struct.svc_xprt_ops = type { %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)*, %struct.svc_xprt* (%struct.svc_xprt*)*, i32 (%struct.svc_xprt*)*, i32 (%struct.svc_rqst*)*, void (%struct.svc_rqst*)*, i32 (%struct.svc_rqst*)*, void (%struct.svc_rqst*)*, void (%struct.svc_xprt*)*, void (%struct.svc_xprt*)* }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.svc_rqst = type { %struct.list_head, %struct.list_head, %struct.svc_xprt*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.svc_serv*, %struct.svc_pool*, %struct.svc_procedure*, %struct.auth_ops*, %struct.svc_cred, i8*, %struct.svc_deferred_req*, i32, i64, %struct.xdr_buf, %struct.xdr_buf, [259 x %struct.page*], %struct.page**, i32, %struct.page**, [259 x %struct.kvec], i32, i32, i32, i32, i32, i8, i8*, i8*, i8*, i32, %struct.cache_req, i8, %struct.auth_domain*, %struct.auth_domain*, i32, %struct.svc_cacherep*, i32, %struct.__wait_queue_head, %struct.task_struct* }
%struct.svc_pool = type { i32, %struct.spinlock, %struct.list_head, %struct.list_head, i32, %struct.list_head, %struct.svc_pool_stats, i32, [28 x i8] }
%struct.svc_pool_stats = type { i64, i64, i64, i64 }
%struct.svc_procedure = type { i32 (%struct.svc_rqst*, i8*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32, i32, i32, i32, i32 }
%struct.auth_ops = type { i8*, %struct.module*, i32, i32 (%struct.svc_rqst*, i32*)*, i32 (%struct.svc_rqst*)*, void (%struct.auth_domain*)*, i32 (%struct.svc_rqst*)* }
%struct.svc_cred = type { i32, i32, %struct.group_info*, i32, i8* }
%struct.svc_deferred_req = type { i32, %struct.svc_xprt*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.cache_deferred_req, i64, i32, [0 x i32] }
%struct.cache_deferred_req = type { %struct.hlist_node, %struct.list_head, %struct.cache_head*, i8*, void (%struct.cache_deferred_req*, i32)* }
%struct.cache_head = type { %struct.cache_head*, i64, i64, %struct.kref, i64 }
%struct.cache_req = type { %struct.cache_deferred_req* (%struct.cache_req*)*, i32 }
%struct.auth_domain = type { %struct.kref, %struct.hlist_node, i8*, %struct.auth_ops* }
%struct.svc_cacherep = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.svc_serv = type { %struct.svc_program*, %struct.svc_stat*, %struct.spinlock, i32, i32, i32, i32, i32, %struct.list_head, %struct.list_head, i32, %struct.timer_list, i8*, i32, %struct.svc_pool*, void (%struct.svc_serv*, %struct.net*)*, %struct.module*, i32 (i8*)* }
%struct.svc_program = type { %struct.svc_program*, i32, i32, i32, i32, %struct.svc_version**, i8*, i8*, %struct.svc_stat*, i32 (%struct.svc_rqst*)* }
%struct.svc_version = type { i32, i32, %struct.svc_procedure*, i32, i8, i32 (%struct.svc_rqst*, i32*)* }
%struct.svc_stat = type { %struct.svc_program*, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.anon.70 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net = type { %struct.atomic_t, %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head, %struct.user_namespace*, i32, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.list_head, %struct.net_device*, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, [56 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_nf, %struct.netns_xt, %struct.netns_ct, [56 x i8], %struct.netns_nf_frag, %struct.sock*, %struct.sock*, %struct.net_generic*, [40 x i8], %struct.netns_xfrm, %struct.netns_ipvs*, %struct.sock*, %struct.atomic_t, [44 x i8] }
%struct.proc_dir_entry = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.43, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node* }
%union.anon.43 = type { %struct.anon.44 }
%struct.anon.44 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*, %struct.nsproxy*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.net_device = type { [16 x i8], %struct.hlist_node, i8*, i64, i64, i64, i32, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, i64, i64, i64, i64, i64, i32, i32, %struct.net_device_stats, %struct.atomic64_t, %struct.net_device_ops*, %struct.ethtool_ops*, %struct.header_ops*, i32, i32, i16, i16, i8, i8, i8, i8, i32, i16, i16, i16, i16, [32 x i8], i8, i8, i8, i16, %struct.spinlock, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i8, i32, i32, i8*, %struct.in_device*, %struct.dn_dev*, %struct.inet6_dev*, i8*, %struct.wireless_dev*, i64, i8*, %struct.netdev_rx_queue*, i32, i32, i32 (%struct.sk_buff**)*, i8*, %struct.netdev_queue*, [32 x i8], [56 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, i64, %struct.spinlock, %struct.xps_dev_maps*, %struct.cpu_rmap*, i64, i32, %struct.timer_list, i32*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8, i8, i16, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.net*, %union.anon.51, %struct.garp_port*, %struct.mrp_port*, %struct.device, [4 x %struct.attribute_group*], %struct.rtnl_link_ops*, i32, i16, i8, [16 x %struct.netdev_tc_txq], [16 x i8], %struct.phy_device*, %struct.lock_class_key*, i32, %struct.pm_qos_request, [56 x i8] }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i16 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*)*, %struct.rtnl_link_stats64* (%struct.net_device*, %struct.rtnl_link_stats64*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i8)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.net_device*, %struct.net_device*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*)*, i32 (%struct.net_device*, i1)* }
%struct.sk_buff = type { %struct.sk_buff*, %struct.sk_buff*, %union.ktime, %struct.sock*, %struct.net_device*, [48 x i8], i64, %struct.sec_path*, i32, i32, i16, i16, %union.anon.45, i32, i16, i16, {}*, %struct.nf_conntrack*, %struct.sk_buff*, i32, i32, i16, i16, i16, i16, i16, i16, i32, %union.anon.47, i32, i32, i32, i32, i32, i32, i32, i32, i8*, i8*, i32, %struct.atomic_t }
%struct.sec_path = type opaque
%union.anon.45 = type { i32 }
%struct.nf_conntrack = type { %struct.atomic_t }
%union.anon.47 = type { i32 }
%struct.ifreq = type { %union.anon.48, %union.anon.49 }
%union.anon.48 = type { [16 x i8] }
%union.anon.49 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.neigh_parms = type { %struct.net*, %struct.net_device*, %struct.neigh_parms*, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, %struct.neigh_table*, i8*, i32, %struct.atomic_t, %struct.callback_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.neigh_table = type { %struct.neigh_table*, i32, i32, i32, i32 (i8*, %struct.net_device*, i32*)*, i32 (%struct.neighbour*)*, i32 (%struct.pneigh_entry*)*, void (%struct.pneigh_entry*)*, void (%struct.sk_buff*)*, i8*, %struct.neigh_parms, i32, i32, i32, i32, i64, %struct.delayed_work, %struct.timer_list, %struct.sk_buff_head, %struct.atomic_t, %struct.rwlock_t, i64, %struct.neigh_statistics*, %struct.neigh_hash_table*, %struct.pneigh_entry** }
%struct.pneigh_entry = type { %struct.pneigh_entry*, %struct.net*, %struct.net_device*, i8, [0 x i8] }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.neigh_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.neigh_hash_table = type { %struct.neighbour**, i32, [4 x i32], %struct.callback_head }
%struct.neighbour = type { %struct.neighbour*, %struct.neigh_table*, %struct.neigh_parms*, i64, i64, %struct.rwlock_t, %struct.atomic_t, %struct.sk_buff_head, i32, %struct.timer_list, i64, %struct.atomic_t, i8, i8, i8, i8, %struct.seqlock_t, [32 x i8], %struct.hh_cache, i32 (%struct.neighbour*, %struct.sk_buff*)*, %struct.neigh_ops*, %struct.callback_head, %struct.net_device*, [0 x i8] }
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.hh_cache = type { i16, i16, %struct.seqlock_t, [12 x i64] }
%struct.neigh_ops = type { i32, void (%struct.neighbour*, %struct.sk_buff*)*, void (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)* }
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32 }
%struct.nlattr = type { i16, i16 }
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, i16, i16, i32, i32, [6 x i64] }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%struct.ethtool_ops = type { i32 (%struct.net_device*, %struct.ethtool_cmd*)*, i32 (%struct.net_device*, %struct.ethtool_cmd*)*, void (%struct.net_device*, %struct.ethtool_drvinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, %struct.ethtool_regs*, i8*)*, void (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, void (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_test*, i64*)*, void (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*, i32*)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*)*, i32 (%struct.net_device*, %struct.ethtool_flash*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*, i32*)*, void (%struct.net_device*, %struct.ethtool_channels*)*, i32 (%struct.net_device*, %struct.ethtool_channels*)*, i32 (%struct.net_device*, %struct.ethtool_dump*)*, i32 (%struct.net_device*, %struct.ethtool_dump*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_dump*)*, i32 (%struct.net_device*, %struct.ethtool_ts_info*)*, i32 (%struct.net_device*, %struct.ethtool_modinfo*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)* }
%struct.ethtool_cmd = type { i32, i32, i32, i16, i8, i8, i8, i8, i8, i8, i32, i32, i16, i8, i8, i32, [2 x i32] }
%struct.ethtool_drvinfo = type { i32, [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [12 x i8], i32, i32, i32, i32, i32 }
%struct.ethtool_regs = type { i32, i32, i32, [0 x i8] }
%struct.ethtool_wolinfo = type { i32, i32, i32, [6 x i8] }
%struct.ethtool_coalesce = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_ringparam = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_pauseparam = type { i32, i32, i32, i32 }
%struct.ethtool_test = type { i32, i32, i32, i32, [0 x i64] }
%struct.ethtool_stats = type { i32, i32, [0 x i64] }
%struct.ethtool_rxnfc = type { i32, i32, i64, %struct.ethtool_rx_flow_spec, i32, [0 x i32] }
%struct.ethtool_rx_flow_spec = type { i32, %union.ethtool_flow_union, %struct.ethtool_flow_ext, %union.ethtool_flow_union, %struct.ethtool_flow_ext, i64, i32 }
%union.ethtool_flow_union = type { %struct.ethtool_tcpip4_spec, [36 x i8] }
%struct.ethtool_tcpip4_spec = type { i32, i32, i16, i16, i8 }
%struct.ethtool_flow_ext = type { [2 x i8], [6 x i8], i16, i16, [2 x i32] }
%struct.ethtool_flash = type { i32, i32, [128 x i8] }
%struct.ethtool_channels = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_dump = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_ts_info = type { i32, i32, i32, i32, [3 x i32], i32, [3 x i32] }
%struct.ethtool_modinfo = type { i32, i32, i32, [8 x i32] }
%struct.ethtool_eeprom = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_eee = type { i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)* }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sysfs_dirent = type opaque
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.in_device = type opaque
%struct.dn_dev = type opaque
%struct.inet6_dev = type { %struct.net_device*, %struct.list_head, %struct.ifmcaddr6*, %struct.ifmcaddr6*, %struct.spinlock, i8, i8, i8, i64, i64, %struct.timer_list, %struct.timer_list, %struct.ifacaddr6*, %struct.rwlock_t, %struct.atomic_t, i32, i32, %struct.in6_addr, %struct.neigh_parms*, %struct.inet6_dev*, %struct.ipv6_devconf, %struct.ipv6_devstat, i64, %struct.callback_head }
%struct.ifmcaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.ifmcaddr6*, %struct.ip6_sf_list*, %struct.ip6_sf_list*, i32, i8, [2 x i64], %struct.timer_list, i32, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.ip6_sf_list = type { %struct.ip6_sf_list*, %struct.in6_addr, [2 x i64], i8, i8, i8 }
%struct.ifacaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.rt6_info*, %struct.ifacaddr6*, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.rt6_info = type opaque
%struct.in6_addr = type { %union.anon.64 }
%union.anon.64 = type { [4 x i32] }
%struct.ipv6_devconf = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8* }
%struct.ipv6_devstat = type { %struct.proc_dir_entry*, [1 x %struct.ipstats_mib*], %struct.icmpv6_mib_device*, %struct.icmpv6msg_mib_device* }
%struct.ipstats_mib = type { [32 x i64], %struct.u64_stats_sync }
%struct.u64_stats_sync = type {}
%struct.icmpv6_mib_device = type { [6 x %struct.atomic64_t] }
%struct.icmpv6msg_mib_device = type { [512 x %struct.atomic64_t] }
%struct.wireless_dev = type opaque
%struct.netdev_rx_queue = type { %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8] }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, [36 x i8], %struct.spinlock, i32, i64, i64, i64, [32 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type opaque
%struct.xps_dev_maps = type { %struct.callback_head, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.cpu_rmap = type opaque
%struct.netpoll_info = type opaque
%union.anon.51 = type { i8* }
%struct.garp_port = type opaque
%struct.mrp_port = type opaque
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type { %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request* }
%struct.pm_qos_constraints = type { %struct.plist_head, i32, i32, i32, %struct.blocking_notifier_head* }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.pm_qos_flags = type { %struct.list_head, i32 }
%struct.dev_pm_qos_request = type { i32, %union.anon.52, %struct.device* }
%union.anon.52 = type { %struct.plist_node }
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.dma_attrs = type { [1 x i64] }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, void (%struct.net_device*)*, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()* }
%struct.nla_policy = type { i16, i16 }
%struct.netdev_tc_txq = type { i16, i16 }
%struct.phy_device = type opaque
%struct.pm_qos_request = type { %struct.plist_node, i32, %struct.delayed_work }
%struct.netns_core = type { %struct.ctl_table_header*, i32, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { [1 x %struct.tcp_mib*], [1 x %struct.ipstats_mib*], [1 x %struct.linux_mib*], [1 x %struct.udp_mib*], [1 x %struct.udp_mib*], [1 x %struct.icmp_mib*], %struct.icmpmsg_mib*, %struct.proc_dir_entry*, [1 x %struct.udp_mib*], [1 x %struct.udp_mib*], [1 x %struct.ipstats_mib*], [1 x %struct.icmpv6_mib*], %struct.icmpv6msg_mib* }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [95 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.icmpmsg_mib = type { [512 x %struct.atomic64_t] }
%struct.udp_mib = type { [8 x i64] }
%struct.icmpv6_mib = type { [6 x i64] }
%struct.icmpv6msg_mib = type { [512 x %struct.atomic64_t] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_ipv4 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.fib_rules_ops*, i8, %struct.fib_table*, %struct.fib_table*, %struct.fib_table*, %struct.hlist_head*, %struct.sock*, %struct.sock**, %struct.inet_peer_base*, %struct.tcpm_hash_bucket*, i32, [52 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, i32, i32, i32, i32, i32, i32, i32, [2 x i32], [3 x i64], %struct.atomic_t, %struct.mr_table* }
%struct.ipv4_devconf = type opaque
%struct.fib_rules_ops = type opaque
%struct.fib_table = type opaque
%struct.inet_peer_base = type { %struct.inet_peer*, %struct.seqlock_t, i32, i32 }
%struct.inet_peer = type { %struct.inet_peer*, %struct.inet_peer*, %struct.inetpeer_addr, i32, [14 x i32], i32, i64, %union.anon.66, %union.anon.67, i32, %struct.atomic_t }
%struct.inetpeer_addr = type { %struct.inetpeer_addr_base, i16 }
%struct.inetpeer_addr_base = type { %union.anon.65 }
%union.anon.65 = type { [4 x i32] }
%union.anon.66 = type { %struct.list_head }
%union.anon.67 = type { %struct.callback_head }
%struct.tcpm_hash_bucket = type opaque
%struct.netns_frags = type { i32, %struct.list_head, %struct.spinlock, [38 x i8], %struct.percpu_counter, i32, i32, i32, [12 x i8] }
%struct.xt_table = type opaque
%struct.mr_table = type opaque
%struct.netns_ipv6 = type { %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, [24 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, [40 x i8], %struct.dst_ops, i32, i64, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.atomic_t, [12 x i8] }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.rt6_statistics = type opaque
%struct.fib6_table = type opaque
%struct.dst_ops = type { i16, i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, %struct.kmem_cache*, [8 x i8], %struct.percpu_counter, [24 x i8] }
%struct.dst_entry = type { %struct.callback_head, %struct.dst_entry*, %struct.net_device*, %struct.dst_ops*, i64, i64, %struct.dst_entry*, %struct.dst_entry*, %struct.xfrm_state*, i32 (%struct.sk_buff*)*, i32 (%struct.sk_buff*)*, i16, i16, i16, i16, i16, i16, i32, [2 x i64], %struct.atomic_t, i32, i64, %union.anon.54 }
%struct.xfrm_state = type opaque
%union.anon.54 = type { %struct.dst_entry* }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, i32, [64 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page* }
%struct.kmem_cache_order_objects = type { i64 }
%struct.kmem_cache_node = type opaque
%struct.netns_nf = type { %struct.proc_dir_entry*, [13 x %struct.nf_logger*], %struct.ctl_table_header* }
%struct.nf_logger = type opaque
%struct.netns_xt = type { [13 x %struct.list_head], i8 }
%struct.netns_ct = type { %struct.atomic_t, i32, i32, %struct.kmem_cache*, %struct.hlist_nulls_head*, %struct.hlist_head*, %struct.hlist_nulls_head, %struct.hlist_nulls_head, %struct.hlist_nulls_head, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_exp_event_notifier*, i32, i32, i32, i32, i32, i32, i32, i8, %struct.nf_ip_net, %struct.hlist_head*, i32, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i8* }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.ip_conntrack_stat = type opaque
%struct.nf_ct_event_notifier = type opaque
%struct.nf_exp_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.nf_generic_net, %struct.nf_tcp_net, %struct.nf_udp_net, %struct.nf_icmp_net, %struct.nf_icmp_net, %struct.ctl_table_header*, %struct.ctl_table* }
%struct.nf_generic_net = type { %struct.nf_proto_net, i32 }
%struct.nf_proto_net = type { %struct.ctl_table_header*, %struct.ctl_table*, %struct.ctl_table_header*, %struct.ctl_table*, i32 }
%struct.nf_tcp_net = type { %struct.nf_proto_net, [14 x i32], i32, i32, i32 }
%struct.nf_udp_net = type { %struct.nf_proto_net, [2 x i32] }
%struct.nf_icmp_net = type { %struct.nf_proto_net, i32 }
%struct.netns_nf_frag = type { %struct.netns_sysctl_ipv6, [48 x i8], %struct.netns_frags }
%struct.net_generic = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.hlist_head, %struct.work_struct, %struct.__wait_queue_head, %struct.list_head, %struct.hlist_head*, i32, [6 x %struct.hlist_head], [6 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.sock*, %struct.sock*, i32, i32, i32, i32, %struct.ctl_table_header*, [32 x i8], %struct.dst_ops, %struct.dst_ops }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32 }
%struct.netns_ipvs = type opaque
%struct.sock = type { %struct.sock_common, %struct.socket_lock_t, %struct.sk_buff_head, %struct.anon.62, i32, i32, %struct.atomic_t, i32, %struct.sk_filter*, %struct.socket_wq*, [2 x %struct.xfrm_policy*], i64, %struct.dst_entry*, %struct.dst_entry*, %struct.spinlock, %struct.atomic_t, %struct.atomic_t, i32, %struct.sk_buff_head, i32, i32, i32, i64, i64, i32, i32, i16, i32, i64, %struct.sk_buff_head, %struct.proto*, %struct.rwlock_t, i32, i32, i16, i16, i32, %struct.pid*, %struct.cred*, i64, i64, i8*, %struct.timer_list, %union.ktime, %struct.socket*, i8*, %struct.page_frag, %struct.sk_buff*, i32, i32, i8*, i32, i32, %struct.cg_proto*, void (%struct.sock*)*, void (%struct.sock*, i32)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)* }
%struct.sock_common = type { %union.anon.55, %union.anon.57, %union.anon.58, i16, i8, i8, i32, %union.anon.60, %struct.proto*, %struct.net*, [0 x i32], %union.anon.61, i32, %struct.atomic_t, [0 x i32] }
%union.anon.55 = type { i64 }
%union.anon.57 = type { i32 }
%union.anon.58 = type { i32 }
%union.anon.60 = type { %struct.hlist_node }
%union.anon.61 = type { %struct.hlist_node }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.__wait_queue_head }
%struct.anon.62 = type { %struct.atomic_t, i32, %struct.sk_buff*, %struct.sk_buff* }
%struct.sk_filter = type { %struct.atomic_t, i32, i32 (%struct.sk_buff*, %struct.sock_filter*)*, %struct.callback_head, [0 x %struct.sock_filter] }
%struct.sock_filter = type { i16, i8, i8, i32 }
%struct.socket_wq = type { %struct.__wait_queue_head, %struct.fasync_struct*, %struct.callback_head, [16 x i8] }
%struct.xfrm_policy = type opaque
%struct.proto = type { void (%struct.sock*, i64)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, i32)*, %struct.sock* (%struct.sock*, i32, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.kiocb*, %struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.kiocb*, %struct.sock*, %struct.msghdr*, i64, i32, i32, i32*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, i16)*, void (%struct.sock*, i32)*, i32, void (%struct.sock*)*, %struct.atomic64_t*, %struct.percpu_counter*, i32*, i64*, i32*, i32*, i32, i8, %struct.kmem_cache*, i32, i32, %struct.percpu_counter*, %struct.request_sock_ops*, %struct.timewait_sock_ops*, %union.anon.63, %struct.module*, [32 x i8], %struct.list_head }
%struct.msghdr = type { i8*, i32, %struct.iovec*, i64, i8*, i64, i32 }
%struct.request_sock_ops = type { i32, i32, %struct.kmem_cache*, i8*, i32 (%struct.sock*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*)*, void (%struct.request_sock*)*, void (%struct.sock*, %struct.request_sock*)* }
%struct.request_sock = type { %struct.request_sock*, i16, i8, i8, i32, i32, i32, i64, %struct.request_sock_ops*, %struct.sock*, i32, i32 }
%struct.timewait_sock_ops = type { %struct.kmem_cache*, i8*, i32, i32 (%struct.sock*, %struct.sock*, i8*)*, void (%struct.sock*)* }
%union.anon.63 = type { %struct.inet_hashinfo* }
%struct.inet_hashinfo = type { %struct.inet_ehash_bucket*, %struct.spinlock*, i32, i32, %struct.inet_bind_hashbucket*, i32, %struct.kmem_cache*, [16 x i8], [32 x %struct.inet_listen_hashbucket], %struct.atomic_t, [60 x i8] }
%struct.inet_ehash_bucket = type { %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.inet_bind_hashbucket = type { %struct.spinlock, %struct.hlist_head }
%struct.inet_listen_hashbucket = type { %struct.spinlock, %struct.hlist_nulls_head }
%struct.socket = type { i32, i16, i64, %struct.socket_wq*, %struct.file*, %struct.sock*, %struct.proto_ops* }
%struct.proto_ops = type { i32, %struct.module*, i32 (%struct.socket*)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32, i32)*, i32 (%struct.socket*, %struct.socket*)*, i32 (%struct.socket*, %struct.socket*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32*, i32)*, i32 (%struct.file*, %struct.socket*, %struct.poll_table_struct*)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.kiocb*, %struct.socket*, %struct.msghdr*, i64)*, i32 (%struct.kiocb*, %struct.socket*, %struct.msghdr*, i64, i32)*, i32 (%struct.file*, %struct.socket*, %struct.vm_area_struct*)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, i64*, %struct.pipe_inode_info*, i64, i32)*, void (%struct.sock*, i32)* }
%struct.cg_proto = type { void (%struct.sock*)*, %struct.res_counter*, %struct.percpu_counter*, i32*, i64*, i64, %struct.mem_cgroup* }
%struct.res_counter = type { i64, i64, i64, i64, i64, %struct.spinlock, %struct.res_counter* }
%struct.mem_cgroup = type opaque
%struct.xprt_create = type { i32, %struct.net*, %struct.sockaddr*, %struct.sockaddr*, i64, i8*, %struct.svc_xprt*, i32 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.5 }
%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.5 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.sockaddr_in = type { i16, i16, %struct.in_addr, [8 x i8] }
%struct.in_addr = type { i32 }
%struct.sockaddr_un = type { i16, [108 x i8] }
%struct.sock_xprt = type { %struct.rpc_xprt, %struct.socket*, %struct.sock*, i32, i32, i32, i32, i32, i64, i64, %struct.delayed_work, %struct.__kernel_sockaddr_storage, i16, i64, i64, void (%struct.sock*, i32)*, void (%struct.sock*)*, void (%struct.sock*)* }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.xdr_skb_reader = type { %struct.sk_buff*, i32, i64, i32 }
%struct.__raw_tickets = type { i8, i8 }
%struct.tcp_sock = type { %struct.inet_connection_sock, i16, i16, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.list_head, i64, %struct.anon.82, i32, i32, i32, i32, i32, i32, i16, i8, i8, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i16, i8, i8, i32, i8, %struct.tcp_options_received, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.sk_buff*, %struct.sk_buff*, %struct.sk_buff*, %struct.sk_buff_head, [1 x %struct.tcp_sack_block], [4 x %struct.tcp_sack_block], [4 x %struct.tcp_sack_block], %struct.sk_buff*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.anon.83, %struct.anon.84, %struct.anon.85, i32, %struct.tcp_sock_af_ops*, %struct.tcp_md5sig_info*, %struct.tcp_fastopen_request*, %struct.request_sock* }
%struct.inet_connection_sock = type { %struct.inet_sock, %struct.request_sock_queue, %struct.inet_bind_bucket*, i64, %struct.timer_list, %struct.timer_list, i32, i32, %struct.tcp_congestion_ops*, %struct.inet_connection_sock_af_ops*, i32 (%struct.sock*, i32)*, i8, i8, i8, i8, i8, i8, i16, %struct.anon.80, %struct.anon.81, [16 x i32], i32 }
%struct.inet_sock = type { %struct.sock, %struct.ipv6_pinfo*, i32, i16, i16, i16, i16, %struct.ip_options_rcu*, i32, i8, i8, i8, i8, i8, i8, i32, i32, i32, %struct.ip_mc_socklist*, %struct.inet_cork_full }
%struct.ipv6_pinfo = type { %struct.in6_addr, %struct.in6_addr, %struct.in6_addr, %struct.in6_pktinfo, %struct.in6_addr*, i32, i32, i32, i32, i32, %union.anon.71, i16, i8, i8, i8, i32, i32, %struct.ipv6_mc_socklist*, %struct.ipv6_ac_socklist*, %struct.ipv6_fl_socklist*, %struct.ipv6_txoptions*, %struct.sk_buff*, %struct.sk_buff*, %struct.anon.74 }
%struct.in6_pktinfo = type { %struct.in6_addr, i32 }
%union.anon.71 = type { %struct.anon.72 }
%struct.anon.72 = type { i16 }
%struct.ipv6_mc_socklist = type { %struct.in6_addr, i32, %struct.ipv6_mc_socklist*, %struct.rwlock_t, i32, %struct.ip6_sf_socklist*, %struct.callback_head }
%struct.ip6_sf_socklist = type { i32, i32, [0 x %struct.in6_addr] }
%struct.ipv6_ac_socklist = type { %struct.in6_addr, i32, %struct.ipv6_ac_socklist* }
%struct.ipv6_fl_socklist = type { %struct.ipv6_fl_socklist*, %struct.ip6_flowlabel*, %struct.callback_head }
%struct.ip6_flowlabel = type { %struct.ip6_flowlabel*, i32, %struct.atomic_t, %struct.in6_addr, %struct.ipv6_txoptions*, i64, %struct.callback_head, i8, %union.anon.73, i64, i64, %struct.net* }
%union.anon.73 = type { %struct.pid* }
%struct.ipv6_txoptions = type { i32, i16, i16, %struct.ipv6_opt_hdr*, %struct.ipv6_opt_hdr*, %struct.ipv6_rt_hdr*, %struct.ipv6_opt_hdr* }
%struct.ipv6_rt_hdr = type { i8, i8, i8, i8 }
%struct.ipv6_opt_hdr = type { i8, i8 }
%struct.anon.74 = type { %struct.ipv6_txoptions*, i8, i8 }
%struct.ip_options_rcu = type { %struct.callback_head, %struct.ip_options }
%struct.ip_options = type { i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, [0 x i8] }
%struct.ip_mc_socklist = type opaque
%struct.inet_cork_full = type { %struct.inet_cork, %struct.flowi }
%struct.inet_cork = type { i32, i32, %struct.ip_options*, i32, i32, %struct.dst_entry*, i8 }
%struct.flowi = type { %union.anon.75 }
%union.anon.75 = type { %struct.flowi6 }
%struct.flowi6 = type { %struct.flowi_common, %struct.in6_addr, %struct.in6_addr, i32, %union.flowi_uli, [4 x i8] }
%struct.flowi_common = type { i32, i32, i32, i8, i8, i8, i8, i32 }
%union.flowi_uli = type { i32 }
%struct.request_sock_queue = type { %struct.request_sock*, %struct.request_sock*, %struct.rwlock_t, i8, %struct.listen_sock*, %struct.fastopen_queue* }
%struct.listen_sock = type { i8, i8, i32, i32, i32, i32, i32, [0 x %struct.request_sock*] }
%struct.fastopen_queue = type { %struct.request_sock*, %struct.request_sock*, %struct.spinlock, i32, i32 }
%struct.inet_bind_bucket = type { %struct.net*, i16, i8, i8, i32, i32, %struct.hlist_node, %struct.hlist_head }
%struct.tcp_congestion_ops = type { %struct.list_head, i64, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*, i32, i32)*, void (%struct.sock*, i8)*, void (%struct.sock*, i32)*, i32 (%struct.sock*)*, void (%struct.sock*, i32, i32)*, void (%struct.sock*, i32, %struct.sk_buff*)*, [16 x i8], %struct.module* }
%struct.inet_connection_sock_af_ops = type { i32 (%struct.sk_buff*, %struct.flowi*)*, void (%struct.sock*, %struct.sk_buff*)*, i32 (%struct.sock*)*, void (%struct.sock*, %struct.sk_buff*)*, i32 (%struct.sock*, %struct.sk_buff*)*, %struct.sock* (%struct.sock*, %struct.sk_buff*, %struct.request_sock*, %struct.dst_entry*)*, i16, i16, i16, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, void (%struct.sock*, %struct.sockaddr*)*, i32 (%struct.sock*, %struct.inet_bind_bucket*, i1)* }
%struct.anon.80 = type { i8, i8, i8, i8, i32, i64, i32, i16, i16 }
%struct.anon.81 = type { i32, i32, i32, i32 }
%struct.anon.82 = type { %struct.sk_buff_head, %struct.task_struct*, %struct.iovec*, i32, i32 }
%struct.tcp_options_received = type { i64, i32, i32, i32, i16, i8, i16, i16 }
%struct.tcp_sack_block = type { i32, i32 }
%struct.anon.83 = type { i32, i32, i32 }
%struct.anon.84 = type { i32, i32, i32 }
%struct.anon.85 = type { i32, i32 }
%struct.tcp_sock_af_ops = type { %struct.tcp_md5sig_key* (%struct.sock*, %struct.sock*)*, i32 (i8*, %struct.tcp_md5sig_key*, %struct.sock*, %struct.request_sock*, %struct.sk_buff*)*, i32 (%struct.sock*, i8*, i32)* }
%struct.tcp_md5sig_key = type { %struct.hlist_node, i8, i8, %union.tcp_md5_addr, [80 x i8], %struct.callback_head }
%union.tcp_md5_addr = type { %struct.in6_addr }
%struct.tcp_md5sig_info = type { %struct.hlist_head, %struct.callback_head }
%struct.tcp_fastopen_request = type { %struct.tcp_fastopen_cookie, %struct.msghdr*, i16 }
%struct.tcp_fastopen_cookie = type { i8, [16 x i8] }
%struct.svc_sock = type { %struct.svc_xprt, %struct.socket*, %struct.sock*, void (%struct.sock*)*, void (%struct.sock*, i32)*, void (%struct.sock*)*, i32, i32, i32, [259 x %struct.page*] }
%struct.rpc_buffer = type { i64, [0 x i8] }

@xs_local_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_local_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_local_transport, i32 0, i32 0) }, i32 257, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_local, %struct.module* null, [32 x i8] c"named UNIX socket\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_udp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_udp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_udp_transport, i32 0, i32 0) }, i32 17, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_udp, %struct.module* null, [32 x i8] c"udp\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_tcp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_tcp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_tcp_transport, i32 0, i32 0) }, i32 6, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_tcp, %struct.module* null, [32 x i8] c"tcp\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_bc_tcp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_bc_tcp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_bc_tcp_transport, i32 0, i32 0) }, i32 -2147483642, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_bc_tcp, %struct.module* null, [32 x i8] c"tcp NFSv4.1 backchannel\00\00\00\00\00\00\00\00\00" }, align 8
@__param_str_min_resvport = internal constant [20 x i8] c"sunrpc.min_resvport\00", align 16
@param_ops_portnr = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_portnr, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_min_resvport = internal global i32 665, align 4
@__param_min_resvport = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_min_resvport, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_portnr, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @xprt_min_resvport to i8*) } }, section "__param", align 8
@__param_str_max_resvport = internal constant [20 x i8] c"sunrpc.max_resvport\00", align 16
@xprt_max_resvport = internal global i32 1023, align 4
@__param_max_resvport = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_max_resvport, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_portnr, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @xprt_max_resvport to i8*) } }, section "__param", align 8
@__param_str_tcp_slot_table_entries = internal constant [30 x i8] c"sunrpc.tcp_slot_table_entries\00", align 16
@param_ops_slot_table_size = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_slot_table_size, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_tcp_slot_table_entries = internal global i32 2, align 4
@__param_tcp_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__param_str_tcp_slot_table_entries, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_slot_table_size, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @xprt_tcp_slot_table_entries to i8*) } }, section "__param", align 8
@__param_str_tcp_max_slot_table_entries = internal constant [34 x i8] c"sunrpc.tcp_max_slot_table_entries\00", align 16
@param_ops_max_slot_table_size = internal global %struct.kernel_param_ops { i32 (i8*, %struct.kernel_param*)* @param_set_max_slot_table_size, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_max_tcp_slot_table_entries = internal global i32 65536, align 4
@__param_tcp_max_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__param_str_tcp_max_slot_table_entries, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_max_slot_table_size, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @xprt_max_tcp_slot_table_entries to i8*) } }, section "__param", align 8
@__param_str_udp_slot_table_entries = internal constant [30 x i8] c"sunrpc.udp_slot_table_entries\00", align 16
@xprt_udp_slot_table_entries = internal global i32 16, align 4
@__param_udp_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__param_str_udp_slot_table_entries, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_slot_table_size, i16 420, i16 -1, %union.anon.5 { i8* bitcast (i32* @xprt_udp_slot_table_entries to i8*) } }, section "__param", align 8
@smp_ops = external global %struct.smp_ops, align 8
@xs_local_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_tcp_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @xs_local_rpcbind, void (%struct.rpc_xprt*, i16)* @xs_local_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_local_connect, i8* (%struct.rpc_task*, i64)* @rpc_malloc, void (i8*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_local_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @xs_close, void (%struct.rpc_xprt*)* @xs_local_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_local_print_stats }, align 8
@xs_local_default_timeout = internal constant %struct.rpc_timeout { i64 10000, i64 10000, i64 0, i32 2, i8 0 }, align 8
@.str = private unnamed_addr constant [6 x i8] c"local\00", align 1
@xs_init_anyaddr.sin = internal constant %struct.sockaddr_in { i16 2, i16 0, %struct.in_addr zeroinitializer, [8 x i8] zeroinitializer }, align 4
@xs_init_anyaddr.sin6 = internal constant { i16, i16, i32, { { [16 x i8] } }, i32 } { i16 10, i16 0, i32 0, { { [16 x i8] } } zeroinitializer, i32 0 }, align 4
@.str.1 = private unnamed_addr constant [13 x i8] c"packet data:\00", align 1
@jiffies = external global i64, align 8
@.str.2 = private unnamed_addr constant [66 x i8] c"\09xprt:\09local %lu %lu %lu %ld %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@.str.3 = private unnamed_addr constant [5 x i8] c"%08x\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"%pi6\00", align 1
@.str.5 = private unnamed_addr constant [22 x i8] c"net/sunrpc/xprtsock.c\00", align 1
@.str.6 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str.7 = private unnamed_addr constant [5 x i8] c"%4hx\00", align 1
@.str.8 = private unnamed_addr constant [45 x i8] c"\013%s: unhandled error (%d) connecting to %s\0A\00", align 1
@__func__.xs_local_setup_socket = private unnamed_addr constant [22 x i8] c"xs_local_setup_socket\00", align 1
@current_task = external global %struct.task_struct*, align 8
@xs_udp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* @xs_udp_set_buffer_size, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt_cong, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt_cong, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @rpcb_getport_async, void (%struct.rpc_xprt*, i16)* @xs_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_connect, i8* (%struct.rpc_task*, i64)* @rpc_malloc, void (i8*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_udp_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_rtt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_udp_timer, void (%struct.rpc_task*)* @xprt_release_rqst_cong, void (%struct.rpc_xprt*)* @xs_close, void (%struct.rpc_xprt*)* @xs_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_udp_print_stats }, align 8
@xs_udp_default_timeout = internal constant %struct.rpc_timeout { i64 5000, i64 30000, i64 5000, i32 5, i8 0 }, align 8
@.str.9 = private unnamed_addr constant [4 x i8] c"udp\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"udp6\00", align 1
@rpciod_workqueue = external global %struct.workqueue_struct*, align 8
@.str.11 = private unnamed_addr constant [55 x i8] c"\09xprt:\09udp %u %lu %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@xs_tcp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_tcp_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_lock_and_alloc_slot, void (%struct.rpc_task*)* @rpcb_getport_async, void (%struct.rpc_xprt*, i16)* @xs_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_connect, i8* (%struct.rpc_task*, i64)* @rpc_malloc, void (i8*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_tcp_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @xs_tcp_close, void (%struct.rpc_xprt*)* @xs_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_tcp_print_stats }, align 8
@xs_tcp_default_timeout = internal constant %struct.rpc_timeout { i64 60000, i64 60000, i64 0, i32 2, i8 0 }, align 8
@.str.12 = private unnamed_addr constant [4 x i8] c"tcp\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c"tcp6\00", align 1
@.str.14 = private unnamed_addr constant [67 x i8] c"\09xprt:\09tcp %u %lu %lu %lu %ld %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@.str.15 = private unnamed_addr constant [41 x i8] c"%s: connect returned unhandled error %d\0A\00", align 1
@__func__.xs_tcp_setup_socket = private unnamed_addr constant [20 x i8] c"xs_tcp_setup_socket\00", align 1
@xs_tcp_fin_timeout = internal global i32 15000, section ".data..read_mostly", align 4
@bc_tcp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @xs_local_rpcbind, void (%struct.rpc_xprt*, i16)* null, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, i8* (%struct.rpc_task*, i64)* @bc_malloc, void (i8*)* @bc_free, i32 (%struct.rpc_task*)* @bc_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @bc_close, void (%struct.rpc_xprt*)* @bc_destroy, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_tcp_print_stats }, align 8
@bc_malloc.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.16 = private unnamed_addr constant [34 x i8] c"\015Error sending entire callback!\0A\00", align 1
@phys_base = external global i64, align 8
@llvm.used = appending global [5 x i8*] [i8* bitcast (%struct.kernel_param* @__param_min_resvport to i8*), i8* bitcast (%struct.kernel_param* @__param_max_resvport to i8*), i8* bitcast (%struct.kernel_param* @__param_tcp_slot_table_entries to i8*), i8* bitcast (%struct.kernel_param* @__param_tcp_max_slot_table_entries to i8*), i8* bitcast (%struct.kernel_param* @__param_udp_slot_table_entries to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @init_socket_xprt() #1 {
entry:
  %call = call i32 @xprt_register_transport(%struct.xprt_class* @xs_local_transport)
  %call1 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_udp_transport)
  %call2 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_tcp_transport)
  %call3 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_bc_tcp_transport)
  ret i32 0
}

declare i32 @xprt_register_transport(%struct.xprt_class*) #2

; Function Attrs: nounwind uwtable
define void @cleanup_socket_xprt() #1 {
entry:
  %call = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_local_transport)
  %call1 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_udp_transport)
  %call2 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_tcp_transport)
  %call3 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_bc_tcp_transport)
  ret void
}

declare i32 @xprt_unregister_transport(%struct.xprt_class*) #2

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_local(%struct.xprt_create* %args) #1 {
entry:
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !12
  %1 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_un*
  %2 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !16
  %3 = load i32, i32* @xprt_max_tcp_slot_table_entries, align 4, !tbaa !16
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %2, i32 %3)
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call i64 @IS_ERR(i8* %4)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %5 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 0, i32* %prot, align 8, !tbaa !17
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !31
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !32
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 60000, i64* %bind_timeout, align 8, !tbaa !33
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 3000, i64* %reestablish_timeout, align 8, !tbaa !34
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 300000, i64* %idle_timeout, align 8, !tbaa !35
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_local_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !36
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_local_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !37
  %sun_family = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %1, i32 0, i32 0
  %7 = load i16, i16* %sun_family, align 2, !tbaa !38
  %conv = zext i16 %7 to i32
  %cond = icmp eq i32 %conv, 1
  br i1 %cond, label %sw.bb, label %out_err.sink.split

sw.bb:                                            ; preds = %if.end
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %1, i32 0, i32 1
  %arrayidx = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i64 0, i64 0
  %8 = load i8, i8* %arrayidx, align 2, !tbaa !40
  %conv2 = sext i8 %8 to i32
  %cmp = icmp ne i32 %conv2, 47
  br i1 %cmp, label %out_err.sink.split, label %if.end6

if.end6:                                          ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  %call7 = call i32 @xs_local_setup_socket(%struct.sock_xprt* %6)
  %conv8 = sext i32 %call7 to i64
  %call9 = call i8* @ERR_PTR(i64 %conv8)
  %9 = bitcast i8* %call9 to %struct.rpc_xprt*
  %tobool10 = icmp ne %struct.rpc_xprt* %9, null
  br i1 %tobool10, label %out_err, label %do.end16

do.end16:                                         ; preds = %if.end6
  %call17 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call17, label %cleanup, label %out_err.sink.split

out_err.sink.split:                               ; preds = %if.end, %sw.bb, %do.end16
  %.sink = phi i64 [ -22, %do.end16 ], [ -22, %sw.bb ], [ -97, %if.end ]
  %call20 = call i8* @ERR_PTR(i64 %.sink)
  %10 = bitcast i8* %call20 to %struct.rpc_xprt*
  br label %out_err

out_err:                                          ; preds = %out_err.sink.split, %if.end6
  %ret.0 = phi %struct.rpc_xprt* [ %9, %if.end6 ], [ %10, %out_err.sink.split ]
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %do.end16, %entry, %out_err
  %retval.0 = phi %struct.rpc_xprt* [ %ret.0, %out_err ], [ %call, %entry ], [ %call, %do.end16 ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %slot_table_size, i32 %max_slot_table_size) #1 {
entry:
  %addrlen = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %0 = load i64, i64* %addrlen, align 8, !tbaa !41
  %cmp = icmp ugt i64 %0, 128
  br i1 %cmp, label %do.end, label %if.end

do.end:                                           ; preds = %entry
  %call = call i8* @ERR_PTR(i64 -9)
  %1 = bitcast i8* %call to %struct.rpc_xprt*
  br label %cleanup30

if.end:                                           ; preds = %entry
  %net = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 1
  %2 = load %struct.net*, %struct.net** %net, align 8, !tbaa !42
  %call1 = call %struct.rpc_xprt* @xprt_alloc(%struct.net* %2, i64 1768, i32 %slot_table_size, i32 %max_slot_table_size)
  %cmp2 = icmp eq %struct.rpc_xprt* %call1, null
  br i1 %cmp2, label %do.end6, label %if.end8

do.end6:                                          ; preds = %if.end
  %call7 = call i8* @ERR_PTR(i64 -12)
  %3 = bitcast i8* %call7 to %struct.rpc_xprt*
  br label %cleanup30

if.end8:                                          ; preds = %if.end
  %4 = bitcast %struct.rpc_xprt* %call1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %addrlen9 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %6 = load i64, i64* %addrlen9, align 8, !tbaa !41
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call1, i32 0, i32 3
  %7 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %8 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !12
  %9 = bitcast %struct.sockaddr* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %9, i64 %6, i32 2, i1 false)
  %addrlen11 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %10 = load i64, i64* %addrlen11, align 8, !tbaa !41
  %addrlen12 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call1, i32 0, i32 4
  store i64 %10, i64* %addrlen12, align 8, !tbaa !43
  %srcaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 2
  %11 = load %struct.sockaddr*, %struct.sockaddr** %srcaddr, align 8, !tbaa !44
  %tobool = icmp ne %struct.sockaddr* %11, null
  br i1 %tobool, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end8
  %addrlen15 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %12 = load i64, i64* %addrlen15, align 8, !tbaa !41
  %srcaddr17 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %13 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr17 to i8*
  %srcaddr18 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 2
  %14 = load %struct.sockaddr*, %struct.sockaddr** %srcaddr18, align 8, !tbaa !44
  %15 = bitcast %struct.sockaddr* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %15, i64 %12, i32 2, i1 false)
  br label %if.end29

if.else:                                          ; preds = %if.end8
  %dstaddr20 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %16 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr20, align 8, !tbaa !12
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %16, i32 0, i32 0
  %17 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %17 to i32
  %srcaddr21 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %18 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr21 to %struct.sockaddr*
  %call22 = call i32 @xs_init_anyaddr(i32 %conv, %struct.sockaddr* %18)
  %cmp23 = icmp ne i32 %call22, 0
  br i1 %cmp23, label %if.then25, label %cleanup

if.then25:                                        ; preds = %if.else
  call void @xprt_free(%struct.rpc_xprt* %call1)
  %conv26 = sext i32 %call22 to i64
  %call27 = call i8* @ERR_PTR(i64 %conv26)
  %19 = bitcast i8* %call27 to %struct.rpc_xprt*
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then25
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then25 ], [ 0, %if.else ]
  %retval.0 = phi %struct.rpc_xprt* [ %19, %if.then25 ], [ undef, %if.else ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %if.end29, label %cleanup30

if.end29:                                         ; preds = %cleanup, %if.then13
  br label %cleanup30

cleanup30:                                        ; preds = %cleanup, %if.end29, %do.end6, %do.end
  %retval.1 = phi %struct.rpc_xprt* [ %1, %do.end ], [ %3, %do.end6 ], [ %call1, %if.end29 ], [ %retval.0, %cleanup ]
  ret %struct.rpc_xprt* %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @IS_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %cmp = icmp uge i64 %0, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  ret i64 %expval
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR(i64 %error) #0 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_set_bound(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 4, i64* %state)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_peer_addresses(%struct.rpc_xprt* %xprt, i8* %protocol, i8* %netid) #1 {
entry:
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 2
  store i8* %protocol, i8** %arrayidx, align 8, !tbaa !47
  %address_strings1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings1, i64 0, i64 5
  store i8* %netid, i8** %arrayidx2, align 8, !tbaa !47
  call void @xs_format_common_peer_addresses(%struct.rpc_xprt* %xprt)
  call void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_setup_socket(%struct.sock_xprt* %transport) #1 {
entry:
  %sock = alloca %struct.socket*, align 8
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %0 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %call = call %struct.task_struct* @get_current()
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call, i32 0, i32 3
  %1 = load i32, i32* %flags, align 4, !tbaa !48
  %or = or i32 %1, 131072
  store i32 %or, i32* %flags, align 4, !tbaa !48
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 18
  call void @clear_bit(i32 7, i64* %state)
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 36
  %2 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !78
  %call2 = call i32 @__sock_create(%struct.net* %2, i32 1, i32 1, i32 0, %struct.socket** %sock, i32 1)
  %cmp = icmp slt i32 %call2, 0
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %3 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !47
  call void @xs_reclassify_socketu(%struct.socket* %3)
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !47
  %call6 = call i32 @xs_local_finish_connecting(%struct.rpc_xprt* %xprt1, %struct.socket* %4)
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end
  %Pivot6 = icmp slt i32 %call6, -2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %call6, 0
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %call6, 0
  br i1 %SwitchLeaf4, label %do.end9, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call6, -2
  br i1 %SwitchLeaf2, label %out, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %call6, -111
  br i1 %SwitchLeaf, label %out, label %NewDefault

do.end9:                                          ; preds = %LeafBlock3
  call void @xprt_set_connected(%struct.rpc_xprt* %xprt1)
  br label %out

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %sub = sub nsw i32 0, %call6
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 38
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 0
  %5 = load i8*, i8** %arrayidx, align 8, !tbaa !47
  %call18 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.xs_local_setup_socket, i32 0, i32 0), i32 %sub, i8* %5)
  br label %out

out:                                              ; preds = %LeafBlock1, %LeafBlock, %do.end9, %sw.default, %entry
  %status.0 = phi i32 [ %call2, %entry ], [ %call6, %LeafBlock ], [ %call6, %LeafBlock1 ], [ %call6, %sw.default ], [ %call6, %do.end9 ]
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt1)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt1, i32 %status.0)
  %call19 = call %struct.task_struct* @get_current()
  %flags20 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call19, i32 0, i32 3
  %6 = load i32, i32* %flags20, align 4, !tbaa !48
  %and = and i32 %6, -131073
  store i32 %and, i32* %flags20, align 4, !tbaa !48
  %7 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  ret i32 %status.0
}

declare zeroext i1 @try_module_get(%struct.module*) #2

declare void @xprt_free(%struct.rpc_xprt*) #2

declare %struct.rpc_xprt* @xprt_alloc(%struct.net*, i64, i32, i32) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #3

; Function Attrs: nounwind uwtable
define internal i32 @xs_init_anyaddr(i32 %family, %struct.sockaddr* %sap) #1 {
entry:
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %entry
  %Pivot6 = icmp slt i32 %family, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %family, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %family, 10
  br i1 %SwitchLeaf4, label %sw.bb1, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %family, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %family, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %cmp = icmp uge i64 16, 64
  %0 = bitcast %struct.sockaddr* %sap to i8*
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %call = call i8* @__memcpy(i8* %0, i8* bitcast (%struct.sockaddr_in* @xs_init_anyaddr.sin to i8*), i64 16)
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.sockaddr_in* @xs_init_anyaddr.sin to i8*), i64 16, i32 2, i1 false)
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock3
  %cmp4 = icmp uge i64 28, 64
  %1 = bitcast %struct.sockaddr* %sap to i8*
  br i1 %cmp4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %sw.bb1
  %call6 = call i8* @__memcpy(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @xs_init_anyaddr.sin6 to i8*), i64 28)
  br label %sw.epilog

if.else7:                                         ; preds = %sw.bb1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @xs_init_anyaddr.sin6 to i8*), i64 28, i32 2, i1 false)
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock, %if.then5, %if.else7, %if.then, %if.else
  br label %return

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %return

return:                                           ; preds = %NewDefault, %sw.epilog
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -97, %NewDefault ]
  ret i32 %retval.0
}

declare i8* @__memcpy(i8*, i8*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

declare i32 @xprt_reserve_xprt(%struct.rpc_xprt*, %struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_release_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #1 {
entry:
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  %0 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !79
  %cmp = icmp ne %struct.rpc_task* %task, %0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq %struct.rpc_task* %task, null
  br i1 %cmp1, label %out_release, label %if.end3

if.end3:                                          ; preds = %if.end
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !80
  %cmp4 = icmp eq %struct.rpc_rqst* %1, null
  br i1 %cmp4, label %out_release, label %if.end6

if.end6:                                          ; preds = %if.end3
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  %2 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !83
  %cmp7 = icmp eq i32 %2, 0
  br i1 %cmp7, label %out_release, label %if.end9

if.end9:                                          ; preds = %if.end6
  %rq_bytes_sent10 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 23
  %3 = load i32, i32* %rq_bytes_sent10, align 8, !tbaa !83
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  %4 = load i32, i32* %len, align 8, !tbaa !86
  %cmp11 = icmp eq i32 %3, %4
  br i1 %cmp11, label %out_release, label %if.end13

if.end13:                                         ; preds = %if.end9
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @set_bit(i32 3, i64* %state)
  br label %out_release

out_release:                                      ; preds = %if.end9, %if.end6, %if.end3, %if.end, %if.end13
  call void @xprt_release_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %out_release, %entry
  ret void
}

declare void @xprt_alloc_slot(%struct.rpc_xprt*, %struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_local_rpcbind(%struct.rpc_task* %task) #1 {
entry:
  call void @rcu_read_lock()
  %tk_client = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 2
  %0 = load %struct.rpc_clnt*, %struct.rpc_clnt** %tk_client, align 8, !tbaa !87
  %cl_xprt = getelementptr inbounds %struct.rpc_clnt, %struct.rpc_clnt* %0, i32 0, i32 4
  %1 = load volatile %struct.rpc_xprt*, %struct.rpc_xprt** %cl_xprt, align 8, !tbaa !47
  call void @xprt_set_bound(%struct.rpc_xprt* %1)
  call void @rcu_read_unlock()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_set_port(%struct.rpc_xprt* %xprt, i16 zeroext %port) #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_connect(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %2 = load i16, i16* %tk_flags, align 8, !tbaa !88
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpc_exit(%struct.rpc_task* %task, i32 -107)
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %call = call i32 @xs_local_setup_socket(%struct.sock_xprt* %1)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %land.lhs.true, label %cleanup.cont

land.lhs.true:                                    ; preds = %if.end
  %tk_flags2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %3 = load i16, i16* %tk_flags2, align 8, !tbaa !88
  %conv3 = zext i16 %3 to i32
  %and4 = and i32 %conv3, 1024
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %cleanup.cont, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %call7 = call i64 @msleep_interruptible(i32 15000)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then, %if.then6, %land.lhs.true, %if.end
  ret void
}

declare i8* @rpc_malloc(%struct.rpc_task*, i64) #2

declare void @rpc_free(i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_send_request(%struct.rpc_task* %task) #1 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !80
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !89
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf1)
  %rq_snd_buf2 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !90
  %5 = bitcast i8* %4 to i32*
  %rq_snd_buf3 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head4 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf3, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head4, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay5, i32 0, i32 1
  %6 = load i64, i64* %iov_len, align 8, !tbaa !92
  %conv = trunc i64 %6 to i32
  call void @xs_pktdump(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1, i32 0, i32 0), i32* %5, i32 %conv)
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %7 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %8 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !83
  %call = call i32 @xs_sendpages(%struct.socket* %7, %struct.sockaddr* null, i32 0, %struct.xdr_buf* %rq_snd_buf, i32 %8)
  %cmp = icmp sge i32 %call, 0
  %lnot = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end25

if.then:                                          ; preds = %entry
  %rq_bytes_sent9 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %9 = load i32, i32* %rq_bytes_sent9, align 8, !tbaa !83
  %add = add i32 %9, %call
  store i32 %add, i32* %rq_bytes_sent9, align 8, !tbaa !83
  %conv10 = sext i32 %call to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  %10 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !96
  %add11 = add i64 %10, %conv10
  store i64 %add11, i64* %rq_xmit_bytes_sent, align 8, !tbaa !96
  %rq_bytes_sent12 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %11 = load i32, i32* %rq_bytes_sent12, align 8, !tbaa !83
  %rq_snd_buf13 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf13, i32 0, i32 7
  %12 = load i32, i32* %len, align 8, !tbaa !86
  %cmp14 = icmp uge i32 %11, %12
  %lnot16 = xor i1 %cmp14, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 1)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.then
  %rq_bytes_sent24 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent24, align 8, !tbaa !83
  br label %cleanup

if.end25:                                         ; preds = %if.then, %entry
  %status.0 = phi i32 [ %call, %entry ], [ -11, %if.then ]
  %cond = icmp eq i32 %status.0, -11
  br i1 %cond, label %sw.bb, label %sw.bb30

sw.bb:                                            ; preds = %if.end25
  %call26 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

sw.bb30:                                          ; preds = %if.end25
  call void @xs_close(%struct.rpc_xprt* %1)
  br label %cleanup

cleanup:                                          ; preds = %sw.bb, %sw.bb30, %if.then23
  %retval.0 = phi i32 [ 0, %if.then23 ], [ -107, %sw.bb30 ], [ %call26, %sw.bb ]
  ret i32 %retval.0
}

declare void @xprt_set_retrans_timeout_def(%struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_close(%struct.rpc_xprt* %xprt) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  call void @xs_reset_transport(%struct.sock_xprt* %1)
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !34
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !97
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 7, i64* %state)
  %state1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 3, i64* %state1)
  %state2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 6, i64* %state2)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !98
  call void @xprt_disconnect_done(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_destroy(%struct.rpc_xprt* %xprt) #1 {
entry:
  call void @xs_close(%struct.rpc_xprt* %xprt)
  call void @xs_free_peer_addresses(%struct.rpc_xprt* %xprt)
  call void @xprt_free(%struct.rpc_xprt* %xprt)
  call void @module_put(%struct.module* null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #1 {
entry:
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !99
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 27
  %1 = load i64, i64* %last_used, align 8, !tbaa !100
  %sub = sub i64 %0, %1
  %div = sdiv i64 %sub, 1000
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %idle_time.0 = phi i64 [ %div, %if.then ], [ 0, %entry ]
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bind_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 0
  %2 = load i64, i64* %bind_count, align 8, !tbaa !101
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat1, i32 0, i32 1
  %3 = load i64, i64* %connect_count, align 8, !tbaa !102
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_time = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat2, i32 0, i32 3
  %4 = load i64, i64* %connect_time, align 8, !tbaa !103
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %sends = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat3, i32 0, i32 4
  %5 = load i64, i64* %sends, align 8, !tbaa !104
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat4, i32 0, i32 5
  %6 = load i64, i64* %recvs, align 8, !tbaa !105
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bad_xids = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 6
  %7 = load i64, i64* %bad_xids, align 8, !tbaa !106
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %req_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat6, i32 0, i32 8
  %8 = load i64, i64* %req_u, align 8, !tbaa !107
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bklog_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat7, i32 0, i32 9
  %9 = load i64, i64* %bklog_u, align 8, !tbaa !108
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %max_slots = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat8, i32 0, i32 7
  %10 = load i64, i64* %max_slots, align 8, !tbaa !109
  %stat9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %sending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat9, i32 0, i32 10
  %11 = load i64, i64* %sending_u, align 8, !tbaa !110
  %stat10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %pending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat10, i32 0, i32 11
  %12 = load i64, i64* %pending_u, align 8, !tbaa !111
  %call11 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.2, i32 0, i32 0), i64 %2, i64 %3, i64 %4, i64 %idle_time.0, i64 %5, i64 %6, i64 %7, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @set_bit(i32 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !112
  ret void
}

declare void @xprt_release_xprt(%struct.rpc_xprt*, %struct.rpc_task*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock() #0 {
entry:
  call void @__rcu_read_lock()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock() #0 {
entry:
  call void @__rcu_read_unlock()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock() #0 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !113
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock() #0 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !114
  ret void
}

declare void @rpc_exit(%struct.rpc_task*, i32) #2

declare i64 @msleep_interruptible(i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_encode_stream_record_marker(%struct.xdr_buf* %buf) #0 {
entry:
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !115
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 4
  %conv1 = trunc i64 %sub to i32
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !90
  %2 = bitcast i8* %1 to i32*
  %or = or i32 -2147483648, %conv1
  %call = call i32 @__fswab32(i32 %or) #4
  store i32 %call, i32* %2, align 4, !tbaa !16
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_pktdump(i8* %msg, i32* %packet, i32 %count) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_sendpages(%struct.socket* %sock, %struct.sockaddr* %addr, i32 %addrlen, %struct.xdr_buf* %xdr, i32 %base) #1 {
entry:
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !115
  %sub = sub i32 %0, %base
  %tobool = icmp ne %struct.socket* %sock, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %cleanup83, label %if.end

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 2
  call void @clear_bit(i32 0, i64* %flags)
  %cmp = icmp ne i32 %base, 0
  %.addrlen = select i1 %cmp, i32 0, i32 %addrlen
  %.addr = select i1 %cmp, %struct.sockaddr* null, %struct.sockaddr* %addr
  %conv7 = zext i32 %base to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 1
  %1 = load i64, i64* %iov_len, align 8, !tbaa !92
  %cmp8 = icmp ult i64 %conv7, %1
  %cmp10 = icmp ne %struct.sockaddr* %.addr, null
  %or.cond = or i1 %cmp8, %cmp10
  %head14 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head14, i64 0, i64 0
  %iov_len16 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx15, i32 0, i32 1
  %2 = load i64, i64* %iov_len16, align 8, !tbaa !92
  %conv17 = zext i32 %base to i64
  br i1 %or.cond, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %sub18 = sub i64 %2, %conv17
  %conv19 = trunc i64 %sub18 to i32
  %sub20 = sub i32 %sub, %conv19
  %head21 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx22 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head21, i64 0, i64 0
  %cmp23 = icmp ne i32 %sub20, 0
  %conv24 = zext i1 %cmp23 to i32
  %call = call i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* %.addr, i32 %.addrlen, %struct.kvec* %arrayidx22, i32 %base, i32 %conv24)
  %cmp25 = icmp eq i32 %sub20, 0
  %cmp28 = icmp ne i32 %call, %conv19
  %or.cond1 = or i1 %cmp25, %cmp28
  %add = add nsw i32 0, %call
  %base.addr.0 = select i1 %or.cond1, i32 %base, i32 0
  %sent.0 = select i1 %or.cond1, i32 0, i32 %add
  br i1 %or.cond1, label %out, label %if.end38

if.else:                                          ; preds = %if.end
  %sub36 = sub i64 %conv17, %2
  %conv37 = trunc i64 %sub36 to i32
  br label %if.end38

if.end38:                                         ; preds = %if.then12, %if.else
  %remainder.0 = phi i32 [ %sub, %if.else ], [ %sub20, %if.then12 ]
  %base.addr.1 = phi i32 [ %conv37, %if.else ], [ %base.addr.0, %if.then12 ]
  %sent.1 = phi i32 [ 0, %if.else ], [ %sent.0, %if.then12 ]
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %3 = load i32, i32* %page_len, align 4, !tbaa !116
  %cmp39 = icmp ult i32 %base.addr.1, %3
  %page_len43 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %4 = load i32, i32* %page_len43, align 4, !tbaa !116
  br i1 %cmp39, label %if.then41, label %if.else60

if.then41:                                        ; preds = %if.end38
  %sub44 = sub i32 %4, %base.addr.1
  %sub45 = sub i32 %remainder.0, %sub44
  %cmp46 = icmp ne i32 %sub45, 0
  %conv47 = zext i1 %cmp46 to i32
  %call48 = call i32 @xs_send_pagedata(%struct.socket* %sock, %struct.xdr_buf* %xdr, i32 %base.addr.1, i32 %conv47)
  %cmp49 = icmp eq i32 %sub45, 0
  %cmp52 = icmp ne i32 %call48, %sub44
  %or.cond2 = or i1 %cmp49, %cmp52
  %add56 = add nsw i32 %sent.1, %call48
  %base.addr.2 = select i1 %or.cond2, i32 %base.addr.1, i32 0
  %sent.2 = select i1 %or.cond2, i32 %sent.1, i32 %add56
  br i1 %or.cond2, label %out, label %if.end63

if.else60:                                        ; preds = %if.end38
  %sub62 = sub i32 %base.addr.1, %4
  br label %if.end63

if.end63:                                         ; preds = %if.then41, %if.else60
  %base.addr.3 = phi i32 [ %sub62, %if.else60 ], [ %base.addr.2, %if.then41 ]
  %sent.3 = phi i32 [ %sent.1, %if.else60 ], [ %sent.2, %if.then41 ]
  %conv64 = zext i32 %base.addr.3 to i64
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx65 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail, i64 0, i64 0
  %iov_len66 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx65, i32 0, i32 1
  %5 = load i64, i64* %iov_len66, align 8, !tbaa !92
  %cmp67 = icmp uge i64 %conv64, %5
  br i1 %cmp67, label %cleanup83, label %if.end70

if.end70:                                         ; preds = %if.end63
  %tail71 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx72 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail71, i64 0, i64 0
  %call73 = call i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* null, i32 0, %struct.kvec* %arrayidx72, i32 %base.addr.3, i32 0)
  br label %out

out:                                              ; preds = %if.then41, %if.then12, %if.end70
  %err.0 = phi i32 [ %call, %if.then12 ], [ %call48, %if.then41 ], [ %call73, %if.end70 ]
  %sent.4 = phi i32 [ %sent.0, %if.then12 ], [ %sent.2, %if.then41 ], [ %sent.3, %if.end70 ]
  %cmp74 = icmp eq i32 %sent.4, 0
  br i1 %cmp74, label %cleanup83, label %if.end77

if.end77:                                         ; preds = %out
  %cmp78 = icmp sgt i32 %err.0, 0
  %add81 = add nsw i32 %sent.4, %err.0
  %add81.sent.4 = select i1 %cmp78, i32 %add81, i32 %sent.4
  br label %cleanup83

cleanup83:                                        ; preds = %out, %if.end63, %entry, %if.end77
  %retval.0 = phi i32 [ %add81.sent.4, %if.end77 ], [ -88, %entry ], [ %sent.3, %if.end63 ], [ %err.0, %out ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_nospace(%struct.rpc_task* %task) #1 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !80
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !89
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %1)
  %tobool = icmp ne i32 %call, 0
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %4, i32 0, i32 2
  br i1 %tobool, label %cond.true, label %if.else

cond.true:                                        ; preds = %entry
  %call1 = call i32 @constant_test_bit(i32 0, i64* %flags)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then7, label %if.end12

if.then7:                                         ; preds = %cond.true
  %sock8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %5 = load %struct.socket*, %struct.socket** %sock8, align 8, !tbaa !93
  %flags9 = getelementptr inbounds %struct.socket, %struct.socket* %5, i32 0, i32 2
  call void @set_bit(i32 2, i64* %flags9)
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %6 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %sk_write_pending = getelementptr inbounds %struct.sock, %struct.sock* %6, i32 0, i32 49
  %7 = load i32, i32* %sk_write_pending, align 4, !tbaa !118
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* %sk_write_pending, align 4, !tbaa !118
  call void @xprt_wait_for_buffer_space(%struct.rpc_task* %task, void (%struct.rpc_task*)* @xs_nospace_callback)
  br label %if.end12

if.else:                                          ; preds = %entry
  call void @clear_bit(i32 0, i64* %flags)
  br label %if.end12

if.end12:                                         ; preds = %cond.true, %if.then7, %if.else
  %ret.0 = phi i32 [ -107, %if.else ], [ -11, %if.then7 ], [ -11, %cond.true ]
  %transport_lock13 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 29
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock13)
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32(i32 %val) #6 {
entry:
  %call = call i32 @__arch_swab32(i32 %val) #4
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32(i32 %val) #6 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #4, !srcloc !125
  ret i32 %0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @clear_bit(i32 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !126
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* %addr, i32 %addrlen, %struct.kvec* %vec, i32 %base, i32 %more) #1 {
entry:
  %msg = alloca %struct.msghdr, align 8
  %iov = alloca %struct.kvec, align 8
  %0 = bitcast %struct.msghdr* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* %0) #7
  %msg_name = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 0
  %1 = bitcast %struct.sockaddr* %addr to i8*
  store i8* %1, i8** %msg_name, align 8, !tbaa !127
  %msg_namelen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 1
  store i32 %addrlen, i32* %msg_namelen, align 8, !tbaa !129
  %msg_iov = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 2
  store %struct.iovec* null, %struct.iovec** %msg_iov, align 8, !tbaa !130
  %msg_iovlen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 3
  store i64 0, i64* %msg_iovlen, align 8, !tbaa !131
  %msg_control = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 4
  store i8* null, i8** %msg_control, align 8, !tbaa !132
  %msg_controllen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 5
  store i64 0, i64* %msg_controllen, align 8, !tbaa !133
  %msg_flags = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 6
  %tobool = icmp ne i32 %more, 0
  %2 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32768, i32 0
  %or = or i32 16448, %cond
  store i32 %or, i32* %msg_flags, align 8, !tbaa !134
  %3 = bitcast %struct.kvec* %iov to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %3) #7
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 0
  %iov_base1 = getelementptr inbounds %struct.kvec, %struct.kvec* %vec, i32 0, i32 0
  %4 = load i8*, i8** %iov_base1, align 8, !tbaa !90
  %idx.ext = zext i32 %base to i64
  %add.ptr = getelementptr i8, i8* %4, i64 %idx.ext
  store i8* %add.ptr, i8** %iov_base, align 8, !tbaa !90
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 1
  %iov_len2 = getelementptr inbounds %struct.kvec, %struct.kvec* %vec, i32 0, i32 1
  %5 = load i64, i64* %iov_len2, align 8, !tbaa !92
  %conv = zext i32 %base to i64
  %sub = sub i64 %5, %conv
  store i64 %sub, i64* %iov_len, align 8, !tbaa !92
  %iov_len3 = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 1
  %6 = load i64, i64* %iov_len3, align 8, !tbaa !92
  %cmp = icmp ne i64 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %iov_len5 = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 1
  %7 = load i64, i64* %iov_len5, align 8, !tbaa !92
  %call = call i32 @kernel_sendmsg(%struct.socket* %sock, %struct.msghdr* %msg, %struct.kvec* %iov, i64 1, i64 %7)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call6 = call i32 @kernel_sendmsg(%struct.socket* %sock, %struct.msghdr* %msg, %struct.kvec* null, i64 0, i64 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call6, %if.end ]
  %8 = bitcast %struct.kvec* %iov to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %8) #7
  %9 = bitcast %struct.msghdr* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 56, i8* %9) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_send_pagedata(%struct.socket* %sock, %struct.xdr_buf* %xdr, i32 %base, i32 %more) #1 {
entry:
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %0 = load i32, i32* %page_len, align 4, !tbaa !116
  %sub = sub i32 %0, %base
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 3
  %1 = load i32, i32* %page_base, align 8, !tbaa !135
  %add = add i32 %base, %1
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 2
  %2 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !136
  %shr = lshr i32 %add, 12
  %idx.ext = zext i32 %shr to i64
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %2, i64 %idx.ext
  %conv = zext i32 %add to i64
  %and = and i64 %conv, 4095
  %conv1 = trunc i64 %and to i32
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %entry
  %remainder.0 = phi i32 [ %sub, %entry ], [ %sub6, %cleanup.cont ]
  %ppage.0 = phi %struct.page** [ %add.ptr, %entry ], [ %ppage.1, %cleanup.cont ]
  %sent.0 = phi i32 [ 0, %entry ], [ %sent.1, %cleanup.cont ]
  %base.addr.0 = phi i32 [ %conv1, %entry ], [ %base.addr.1, %cleanup.cont ]
  %conv2 = zext i32 %base.addr.0 to i64
  %sub3 = sub i64 4096, %conv2
  %conv4 = trunc i64 %sub3 to i32
  %cmp = icmp ult i32 %conv4, %remainder.0
  %conv4.remainder.0 = select i1 %cmp, i32 %conv4, i32 %remainder.0
  %sub6 = sub i32 %remainder.0, %conv4.remainder.0
  %cmp7 = icmp ne i32 %sub6, 0
  %tobool = icmp ne i32 %more, 0
  %or.cond = or i1 %cmp7, %tobool
  %or = or i32 16448, 32768
  %flags.0 = select i1 %or.cond, i32 %or, i32 16448
  %ops = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 6
  %3 = load %struct.proto_ops*, %struct.proto_ops** %ops, align 8, !tbaa !137
  %sendpage = getelementptr inbounds %struct.proto_ops, %struct.proto_ops* %3, i32 0, i32 20
  %4 = load i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)** %sendpage, align 8, !tbaa !139
  %5 = load %struct.page*, %struct.page** %ppage.0, align 8, !tbaa !47
  %conv9 = zext i32 %conv4.remainder.0 to i64
  %call = call i64 %4(%struct.socket* %sock, %struct.page* %5, i32 %base.addr.0, i64 %conv9, i32 %flags.0)
  %conv10 = trunc i64 %call to i32
  %cmp11 = icmp eq i32 %sub6, 0
  %cmp14 = icmp ne i32 %conv10, %conv4.remainder.0
  %or.cond1 = or i1 %cmp11, %cmp14
  br i1 %or.cond1, label %cleanup, label %if.end17

if.end17:                                         ; preds = %for.cond
  %add18 = add nsw i32 %sent.0, %conv10
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %ppage.0, i32 1
  br label %cleanup

cleanup:                                          ; preds = %for.cond, %if.end17
  %ppage.1 = phi %struct.page** [ %incdec.ptr, %if.end17 ], [ %ppage.0, %for.cond ]
  %sent.1 = phi i32 [ %add18, %if.end17 ], [ %sent.0, %for.cond ]
  %base.addr.1 = phi i32 [ 0, %if.end17 ], [ %base.addr.0, %for.cond ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end17 ], [ 2, %for.cond ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %cleanup.cont, label %for.end

cleanup.cont:                                     ; preds = %cleanup
  br label %for.cond

for.end:                                          ; preds = %cleanup
  %cmp20 = icmp eq i32 %sent.1, 0
  br i1 %cmp20, label %cleanup29, label %if.end23

if.end23:                                         ; preds = %for.end
  %cmp24 = icmp sgt i32 %conv10, 0
  %add27 = add nsw i32 %sent.1, %conv10
  %add27.sent.1 = select i1 %cmp24, i32 %add27, i32 %sent.1
  br label %cleanup29

cleanup29:                                        ; preds = %for.end, %if.end23
  %retval.0 = phi i32 [ %add27.sent.1, %if.end23 ], [ %conv10, %for.end ]
  ret i32 %retval.0
}

declare i32 @kernel_sendmsg(%struct.socket*, %struct.msghdr*, %struct.kvec*, i64, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock_bh(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_connected(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @constant_test_bit(i32 1, i64* %state)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @constant_test_bit(i32 %nr, i64* %addr) #5 {
entry:
  %rem = urem i32 %nr, 64
  %sh_prom = zext i32 %rem to i64
  %shl = shl i64 1, %sh_prom
  %div = udiv i32 %nr, 64
  %idxprom = zext i32 %div to i64
  %arrayidx = getelementptr inbounds i64, i64* %addr, i64 %idxprom
  %0 = load volatile i64, i64* %arrayidx, align 8, !tbaa !99
  %and = and i64 %shl, %0
  %cmp = icmp ne i64 %and, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @variable_test_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr) #7, !srcloc !141
  ret i32 %0
}

declare void @xprt_wait_for_buffer_space(%struct.rpc_task*, void (%struct.rpc_task*)*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_nospace_callback(%struct.rpc_task* %task) #1 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !80
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !89
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %4 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %sk_write_pending = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 49
  %5 = load i32, i32* %sk_write_pending, align 4, !tbaa !118
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %sk_write_pending, align 4, !tbaa !118
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %6 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %6, i32 0, i32 2
  call void @clear_bit(i32 0, i64* %flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock_bh(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @_raw_spin_lock_bh(%struct.raw_spinlock*) #2 section ".spinlock.text"

declare void @_raw_spin_unlock_bh(%struct.raw_spinlock*) #2 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @xs_reset_transport(%struct.sock_xprt* %transport) #1 {
entry:
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  %0 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !93
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %1 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %cmp = icmp eq %struct.sock* %1, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  store i16 0, i16* %srcport, align 8, !tbaa !142
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 31
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %inet2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  store %struct.sock* null, %struct.sock** %inet2, align 8, !tbaa !117
  %sock3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  store %struct.socket* null, %struct.socket** %sock3, align 8, !tbaa !93
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 45
  store i8* null, i8** %sk_user_data, align 8, !tbaa !143
  call void @xs_restore_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %1)
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 31
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  %sk_no_check = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 19
  %bf.load = load i32, i32* %sk_no_check, align 8
  %bf.clear = and i32 %bf.load, -13
  store i32 %bf.clear, i32* %sk_no_check, align 8
  call void @sock_release(%struct.socket* %0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

declare void @xprt_disconnect_done(%struct.rpc_xprt*) #2

declare void @_raw_write_lock_bh(%struct.rwlock_t*) #2 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @xs_restore_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %sk) #1 {
entry:
  %old_data_ready = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  %0 = load void (%struct.sock*, i32)*, void (%struct.sock*, i32)** %old_data_ready, align 8, !tbaa !144
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 55
  store void (%struct.sock*, i32)* %0, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !145
  %old_state_change = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 16
  %1 = load void (%struct.sock*)*, void (%struct.sock*)** %old_state_change, align 8, !tbaa !146
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 54
  store void (%struct.sock*)* %1, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !147
  %old_write_space = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 17
  %2 = load void (%struct.sock*)*, void (%struct.sock*)** %old_write_space, align 8, !tbaa !148
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 56
  store void (%struct.sock*)* %2, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !149
  ret void
}

declare void @_raw_write_unlock_bh(%struct.rwlock_t*) #2 section ".spinlock.text"

declare void @sock_release(%struct.socket*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_free_peer_addresses(%struct.rpc_xprt* %xprt) #1 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %NodeBlock

NodeBlock:                                        ; preds = %for.body
  %Pivot = icmp slt i32 %i.0, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %i.0, 5
  br i1 %SwitchLeaf2, label %for.inc, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %i.0, 2
  br i1 %SwitchLeaf, label %for.inc, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !47
  call void @kfree(i8* %0)
  br label %for.inc

for.inc:                                          ; preds = %LeafBlock1, %LeafBlock, %sw.default
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @module_put(%struct.module*) #2

declare void @kfree(i8*) #2

declare i32 @seq_printf(%struct.seq_file*, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !150
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_common_peer_addresses(%struct.rpc_xprt* %xprt) #1 {
entry:
  %buf = alloca [128 x i8], align 16
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %0 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call, i32 0, i32 0
  %1 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %1 to i32
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %entry
  %Pivot6 = icmp slt i32 %conv, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf4, label %sw.bb17, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf2, label %sw.bb6, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call1 = call %struct.sockaddr_un* @xs_addr_un(%struct.rpc_xprt* %xprt)
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %call1, i32 0, i32 1
  %arraydecay2 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i32 0, i32 0
  %call3 = call i64 @strlcpy(i8* %arraydecay, i8* %arraydecay2, i64 128)
  %arraydecay4 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call5 = call i8* @kstrdup(i8* %arraydecay4, i32 208)
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 0
  store i8* %call5, i8** %arrayidx, align 8, !tbaa !47
  br label %sw.epilog

sw.bb6:                                           ; preds = %LeafBlock1
  %arraydecay7 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call8 = call i64 @rpc_ntop(%struct.sockaddr* %call, i8* %arraydecay7, i64 128)
  %arraydecay9 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call10 = call i8* @kstrdup(i8* %arraydecay9, i32 208)
  %address_strings11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx12 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings11, i64 0, i64 0
  store i8* %call10, i8** %arrayidx12, align 8, !tbaa !47
  %call13 = call %struct.sockaddr_in* @xs_addr_in(%struct.rpc_xprt* %xprt)
  %arraydecay14 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %call13, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.in_addr, %struct.in_addr* %sin_addr, i32 0, i32 0
  %2 = load i32, i32* %s_addr, align 4, !tbaa !151
  %call15 = call i32 @__fswab32(i32 %2) #4
  %call16 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay14, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0), i32 %call15)
  br label %sw.epilog

sw.bb17:                                          ; preds = %LeafBlock3
  %arraydecay18 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call19 = call i64 @rpc_ntop(%struct.sockaddr* %call, i8* %arraydecay18, i64 128)
  %arraydecay20 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call21 = call i8* @kstrdup(i8* %arraydecay20, i32 208)
  %address_strings22 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx23 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings22, i64 0, i64 0
  store i8* %call21, i8** %arrayidx23, align 8, !tbaa !47
  %call24 = call %struct.sockaddr_in6* @xs_addr_in6(%struct.rpc_xprt* %xprt)
  %arraydecay25 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call24, i32 0, i32 3
  %call26 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay25, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), %struct.in6_addr* %sin6_addr)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %do.body

do.body:                                          ; preds = %NewDefault
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i32 325, i64 12) #7, !srcloc !154
  br label %do.body27

do.body27:                                        ; preds = %do.body27, %do.body
  br label %do.body27

sw.epilog:                                        ; preds = %sw.bb17, %sw.bb6, %sw.bb
  %arraydecay30 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call31 = call i8* @kstrdup(i8* %arraydecay30, i32 208)
  %address_strings32 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx33 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings32, i64 0, i64 3
  store i8* %call31, i8** %arrayidx33, align 8, !tbaa !47
  %3 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt) #1 {
entry:
  %buf = alloca [128 x i8], align 16
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %0 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call1 = call zeroext i16 @rpc_get_port(%struct.sockaddr* %call)
  %conv = zext i16 %call1 to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 128, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.6, i32 0, i32 0), i32 %conv)
  %arraydecay3 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call4 = call i8* @kstrdup(i8* %arraydecay3, i32 208)
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 1
  store i8* %call4, i8** %arrayidx, align 8, !tbaa !47
  %arraydecay5 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call6 = call zeroext i16 @rpc_get_port(%struct.sockaddr* %call)
  %conv7 = zext i16 %call6 to i32
  %call8 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay5, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i32 0, i32 0), i32 %conv7)
  %arraydecay9 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call10 = call i8* @kstrdup(i8* %arraydecay9, i32 208)
  %address_strings11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx12 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings11, i64 0, i64 4
  store i8* %call10, i8** %arrayidx12, align 8, !tbaa !47
  %1 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %1) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt) #0 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr*
  ret %struct.sockaddr* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_un* @xs_addr_un(%struct.rpc_xprt* %xprt) #0 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_un*
  ret %struct.sockaddr_un* %0
}

declare i64 @strlcpy(i8*, i8*, i64) #2

declare i8* @kstrdup(i8*, i32) #2

declare i64 @rpc_ntop(%struct.sockaddr*, i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in* @xs_addr_in(%struct.rpc_xprt* %xprt) #0 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_in*
  ret %struct.sockaddr_in* %0
}

declare i32 @snprintf(i8*, i64, i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in6* @xs_addr_in6(%struct.rpc_xprt* %xprt) #0 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_in6*
  ret %struct.sockaddr_in6* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @rpc_get_port(%struct.sockaddr* %sap) #0 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %0 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  br label %return.sink.split

sw.bb3:                                           ; preds = %LeafBlock1
  %2 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  br label %return.sink.split

return.sink.split:                                ; preds = %sw.bb, %sw.bb3
  %sin6_port.sink = phi i16* [ %sin6_port, %sw.bb3 ], [ %sin_port, %sw.bb ]
  %3 = load i16, i16* %sin6_port.sink, align 2, !tbaa !155
  %call4 = call zeroext i16 @__fswab16(i16 zeroext %3) #4
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  br label %return

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %return

return:                                           ; preds = %NewDefault, %return.sink.split
  %retval.0 = phi i16 [ 0, %NewDefault ], [ %conv6, %return.sink.split ]
  ret i16 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16(i16 zeroext %val) #6 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

; Function Attrs: alwaysinline nounwind uwtable
define internal %struct.task_struct* @get_current() #5 {
entry:
  %0 = call %struct.task_struct* asm "movq %gs:${1:P},$0", "=r,im,~{dirflag},~{fpsr},~{flags}"(%struct.task_struct** @current_task) #4, !srcloc !156
  ret %struct.task_struct* %0
}

declare i32 @__sock_create(%struct.net*, i32, i32, i32, %struct.socket**, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_reclassify_socketu(%struct.socket* %sock) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !157
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 31
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 45
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !143
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 55
  store void (%struct.sock*, i32)* @xs_local_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !145
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 56
  store void (%struct.sock*)* @xs_udp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !149
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 21
  store i32 32, i32* %sk_allocation, align 8, !tbaa !158
  call void @xprt_clear_connected(%struct.rpc_xprt* %xprt)
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock2, align 8, !tbaa !93
  %inet3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet3, align 8, !tbaa !117
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 31
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 1
  %5 = load i64, i64* %connect_count, align 8, !tbaa !102
  %inc = add i64 %5, 1
  store i64 %inc, i64* %connect_count, align 8, !tbaa !102
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !99
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_start = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 2
  store i64 %6, i64* %connect_start, align 8, !tbaa !159
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %7 = load i64, i64* %addrlen, align 8, !tbaa !43
  %conv = trunc i64 %7 to i32
  %call6 = call i32 @kernel_connect(%struct.socket* %sock, %struct.sockaddr* %call, i32 %conv, i32 0)
  ret i32 %call6
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_set_connected(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @set_bit(i32 1, i64* %state)
  ret void
}

declare i32 @printk(i8*, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_connecting(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !160
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 2, i64* %state)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !161
  ret void
}

declare void @xprt_wake_pending_tasks(%struct.rpc_xprt*, i32) #2

; Function Attrs: nounwind uwtable
define internal void @xs_save_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %sk) #1 {
entry:
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 55
  %0 = load void (%struct.sock*, i32)*, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !145
  %old_data_ready = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  store void (%struct.sock*, i32)* %0, void (%struct.sock*, i32)** %old_data_ready, align 8, !tbaa !144
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 54
  %1 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !147
  %old_state_change = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 16
  store void (%struct.sock*)* %1, void (%struct.sock*)** %old_state_change, align 8, !tbaa !146
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 56
  %2 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !149
  %old_write_space = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 17
  store void (%struct.sock*)* %2, void (%struct.sock*)** %old_write_space, align 8, !tbaa !148
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_data_ready(%struct.sock* %sk, i32 %len) #1 {
entry:
  %err = alloca i32, align 4
  %_xid = alloca i32, align 4
  %0 = bitcast i32* %err to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %cmp = icmp eq %struct.rpc_xprt* %call, null
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %call1 = call %struct.sk_buff* @skb_recv_datagram(%struct.sock* %sk, i32 0, i32 1, i32* %err)
  %cmp2 = icmp eq %struct.sk_buff* %call1, null
  br i1 %cmp2, label %out, label %if.end4

if.end4:                                          ; preds = %if.end
  %len5 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %call1, i32 0, i32 8
  %2 = load i32, i32* %len5, align 8, !tbaa !162
  %conv = zext i32 %2 to i64
  %sub = sub i64 %conv, 4
  %conv6 = trunc i64 %sub to i32
  %cmp7 = icmp slt i32 %conv6, 4
  br i1 %cmp7, label %dropit, label %if.end13

if.end13:                                         ; preds = %if.end4
  %3 = bitcast i32* %_xid to i8*
  %call14 = call i8* @skb_header_pointer(%struct.sk_buff* %call1, i32 4, i32 4, i8* %3)
  %4 = bitcast i8* %call14 to i32*
  %cmp15 = icmp eq i32* %4, null
  br i1 %cmp15, label %dropit, label %if.end18

if.end18:                                         ; preds = %if.end13
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_lock(%struct.spinlock* %transport_lock)
  %5 = load i32, i32* %4, align 4, !tbaa !16
  %call19 = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %call, i32 %5)
  %tobool = icmp ne %struct.rpc_rqst* %call19, null
  br i1 %tobool, label %if.end21, label %out_unlock

if.end21:                                         ; preds = %if.end18
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call19, i32 0, i32 3
  %6 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !164
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call19, i32 0, i32 17
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 6
  %7 = load i32, i32* %buflen, align 4, !tbaa !165
  %cmp22 = icmp sgt i32 %7, %conv6
  %conv6. = select i1 %cmp22, i32 %conv6, i32 %7
  %rq_private_buf26 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call19, i32 0, i32 17
  %call27 = call i32 @xs_local_copy_to_xdr(%struct.xdr_buf* %rq_private_buf26, %struct.sk_buff* %call1)
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %out_unlock, label %if.end33

if.end33:                                         ; preds = %if.end21
  call void @xprt_complete_rqst(%struct.rpc_task* %6, i32 %conv6.)
  br label %out_unlock

out_unlock:                                       ; preds = %if.end21, %if.end18, %if.end33
  %transport_lock34 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_unlock(%struct.spinlock* %transport_lock34)
  br label %dropit

dropit:                                           ; preds = %if.end13, %if.end4, %out_unlock
  call void @skb_free_datagram(%struct.sock* %sk, %struct.sk_buff* %call1)
  br label %out

out:                                              ; preds = %if.end, %entry, %dropit
  %sk_callback_lock35 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock35)
  %8 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #7
  %9 = bitcast i32* %err to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %9) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_write_space(%struct.sock* %sk) #1 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call zeroext i1 @sock_writeable(%struct.sock* %sk)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xs_write_space(%struct.sock* %sk)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sk_callback_lock1 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_connected(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 1, i64* %state)
  ret void
}

declare i32 @kernel_connect(%struct.socket*, %struct.sockaddr*, i32, i32) #2

declare void @_raw_read_lock_bh(%struct.rwlock_t*) #2 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk) #0 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 45
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !143
  %1 = bitcast i8* %0 to %struct.rpc_xprt*
  ret %struct.rpc_xprt* %1
}

declare %struct.sk_buff* @skb_recv_datagram(%struct.sock*, i32, i32, i32*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %buffer) #0 {
entry:
  %call = call i32 @skb_headlen(%struct.sk_buff* %skb)
  %sub = sub nsw i32 %call, %offset
  %cmp = icmp sge i32 %sub, %len
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %data = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 38
  %0 = load i8*, i8** %data, align 8, !tbaa !166
  %idx.ext = sext i32 %offset to i64
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 %idx.ext
  br label %cleanup

if.end:                                           ; preds = %entry
  %call1 = call i32 @skb_copy_bits(%struct.sk_buff* %skb, i32 %offset, i8* %buffer, i32 %len)
  %cmp2 = icmp slt i32 %call1, 0
  %.buffer = select i1 %cmp2, i8* null, i8* %buffer
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %add.ptr, %if.then ], [ %.buffer, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

declare %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_copy_to_xdr(%struct.xdr_buf* %xdr, %struct.sk_buff* %skb) #1 {
entry:
  %desc = alloca %struct.xdr_skb_reader, align 8
  %0 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %skb1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb1, align 8, !tbaa !167
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  store i32 4, i32* %offset, align 8, !tbaa !169
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %1 = load i32, i32* %len, align 8, !tbaa !162
  %conv = zext i32 %1 to i64
  %sub = sub i64 %conv, 4
  store i64 %sub, i64* %count, align 8, !tbaa !170
  %csum = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 0, i32* %csum, align 8, !tbaa !171
  %call = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %xdr, i32 0, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  %cmp = icmp slt i64 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %count3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %2 = load i64, i64* %count3, align 8, !tbaa !170
  %tobool = icmp ne i64 %2, 0
  %. = select i1 %tobool, i32 -1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ %., %if.end ]
  %3 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %3) #7
  ret i32 %retval.0
}

declare void @xprt_complete_rqst(%struct.rpc_task*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #0 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon.0* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @skb_free_datagram(%struct.sock*, %struct.sk_buff*) #2

declare void @_raw_read_unlock_bh(%struct.rwlock_t*) #2 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @skb_headlen(%struct.sk_buff* %skb) #0 {
entry:
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %0 = load i32, i32* %len, align 8, !tbaa !162
  %data_len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 9
  %1 = load i32, i32* %data_len, align 4, !tbaa !172
  %sub = sub i32 %0, %1
  ret i32 %sub
}

declare i32 @skb_copy_bits(%struct.sk_buff*, i32, i8*, i32) #2

declare void @_raw_spin_lock(%struct.raw_spinlock*) #2 section ".spinlock.text"

declare i64 @xdr_partial_copy_from_skb(%struct.xdr_buf*, i32, %struct.xdr_skb_reader*, i64 (%struct.xdr_skb_reader*, i8*, i64)*) #2

declare i64 @xdr_skb_read_bits(%struct.xdr_skb_reader*, i8*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !173
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #0 {
entry:
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i32 0, i32 0
  call void @arch_spin_unlock(%struct.arch_spinlock* %raw_lock)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @arch_spin_unlock(%struct.arch_spinlock* %lock) #5 {
entry:
  call void @__ticket_spin_unlock(%struct.arch_spinlock* %lock)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__ticket_spin_unlock(%struct.arch_spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.arch_spinlock, %struct.arch_spinlock* %lock, i32 0, i32 0
  %tickets = bitcast %union.anon.1* %0 to %struct.__raw_tickets*
  %head = getelementptr inbounds %struct.__raw_tickets, %struct.__raw_tickets* %tickets, i32 0, i32 0
  call void asm sideeffect "addb ${1:b}, $0\0A", "=*m,qi,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i8* %head, i32 1, i8* %head) #7, !srcloc !174
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @sock_writeable(%struct.sock* %sk) #0 {
entry:
  %sk_wmem_alloc = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 15
  %call = call i32 @atomic_read(%struct.atomic_t* %sk_wmem_alloc)
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 17
  %0 = load i32, i32* %sk_sndbuf, align 4, !tbaa !175
  %shr = ashr i32 %0, 1
  %cmp = icmp slt i32 %call, %shr
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal void @xs_write_space(%struct.sock* %sk) #1 {
entry:
  %sk_socket = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  %0 = load %struct.socket*, %struct.socket** %sk_socket, align 8, !tbaa !176
  %tobool = icmp ne %struct.socket* %0, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %0, i32 0, i32 2
  call void @clear_bit(i32 2, i64* %flags)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool4 = icmp ne %struct.rpc_xprt* %call, null
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %cleanup.cont, label %if.end15

if.end15:                                         ; preds = %if.end
  %flags16 = getelementptr inbounds %struct.socket, %struct.socket* %0, i32 0, i32 2
  %call17 = call i32 @test_and_clear_bit(i32 0, i64* %flags16)
  %cmp = icmp eq i32 %call17, 0
  br i1 %cmp, label %cleanup.cont, label %if.end20

if.end20:                                         ; preds = %if.end15
  call void @xprt_write_space(%struct.rpc_xprt* %call)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end20, %entry, %if.end, %if.end15
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #0 {
entry:
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %0 = load volatile i32, i32* %counter, align 4, !tbaa !16
  ret i32 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_clear_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !177
  ret i32 %0
}

declare void @xprt_write_space(%struct.rpc_xprt*) #2

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_udp(%struct.xprt_create* %args) #1 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %.compoundliteral46 = alloca %struct.atomic64_t, align 8
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !12
  %1 = load i32, i32* @xprt_udp_slot_table_entries, align 4, !tbaa !16
  %2 = load i32, i32* @xprt_udp_slot_table_entries, align 4, !tbaa !16
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %1, i32 %2)
  %3 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call i64 @IS_ERR(i8* %3)
  %tobool = icmp ne i64 %call1, 0
  br i1 %tobool, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 17, i32* %prot, align 8, !tbaa !17
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 0, i32* %tsh_size, align 8, !tbaa !31
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 64384, i64* %max_payload, align 8, !tbaa !32
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 60000, i64* %bind_timeout, align 8, !tbaa !33
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 2000, i64* %reestablish_timeout, align 8, !tbaa !34
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 300000, i64* %idle_timeout, align 8, !tbaa !35
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_udp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !36
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_udp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !37
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %6 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %6 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb32, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %7 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %7, i32 0, i32 1
  %8 = load i16, i16* %sin_port, align 2, !tbaa !178
  %conv2 = zext i16 %8 to i32
  %cmp = icmp ne i32 %conv2, 0
  br i1 %cmp, label %if.then4, label %do.body7

if.then4:                                         ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body7

do.body7:                                         ; preds = %sw.bb, %if.then4
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %connect_worker8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work9 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker8, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work9, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !179
  %9 = bitcast %struct.atomic64_t* %data to i8*
  %10 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false), !tbaa.struct !180
  %connect_worker10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work11 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker10, i32 0, i32 0
  %entry12 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work11, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry12)
  %connect_worker14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work15 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker14, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work15, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_udp_setup_socket, void (%struct.work_struct*)** %func, align 8, !tbaa !181
  %connect_worker21 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker21, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* null, %struct.lock_class_key* null)
  %connect_worker22 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer23 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker22, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer23, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !182
  %connect_worker24 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %11 = ptrtoint %struct.delayed_work* %connect_worker24 to i64
  %connect_worker25 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer26 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker25, i32 0, i32 1
  %data27 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer26, i32 0, i32 4
  store i64 %11, i64* %data27, align 8, !tbaa !183
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0))
  br label %sw.epilog

sw.bb32:                                          ; preds = %LeafBlock1
  %12 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %12, i32 0, i32 1
  %13 = load i16, i16* %sin6_port, align 2, !tbaa !184
  %conv33 = zext i16 %13 to i32
  %cmp34 = icmp ne i32 %conv33, 0
  br i1 %cmp34, label %if.then36, label %do.body40

if.then36:                                        ; preds = %sw.bb32
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body40

do.body40:                                        ; preds = %sw.bb32, %if.then36
  %connect_worker41 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work42 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker41, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work42, i32 0)
  %connect_worker43 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work44 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker43, i32 0, i32 0
  %data45 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work44, i32 0, i32 0
  %counter47 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral46, i32 0, i32 0
  store i64 68719476704, i64* %counter47, align 8, !tbaa !179
  %14 = bitcast %struct.atomic64_t* %data45 to i8*
  %15 = bitcast %struct.atomic64_t* %.compoundliteral46 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 8, i32 8, i1 false), !tbaa.struct !180
  %connect_worker48 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work49 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker48, i32 0, i32 0
  %entry50 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work49, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry50)
  %connect_worker52 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %work53 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker52, i32 0, i32 0
  %func54 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work53, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_udp_setup_socket, void (%struct.work_struct*)** %func54, align 8, !tbaa !181
  %connect_worker62 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer63 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker62, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer63, i32 2, i8* null, %struct.lock_class_key* null)
  %connect_worker64 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer65 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker64, i32 0, i32 1
  %function66 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer65, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function66, align 8, !tbaa !182
  %connect_worker67 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %16 = ptrtoint %struct.delayed_work* %connect_worker67 to i64
  %connect_worker68 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 10
  %timer69 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker68, i32 0, i32 1
  %data70 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer69, i32 0, i32 4
  store i64 %16, i64* %data70, align 8, !tbaa !183
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.10, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.body40, %do.body7
  %call76 = call i32 @xprt_bound(%struct.rpc_xprt* %call)
  %tobool77 = icmp ne i32 %call76, 0
  %call86 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call86, label %cleanup, label %out_err

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out_err

out_err:                                          ; preds = %NewDefault, %sw.epilog
  %.sink = phi i64 [ -22, %sw.epilog ], [ -97, %NewDefault ]
  %call89 = call i8* @ERR_PTR(i64 %.sink)
  %17 = bitcast i8* %call89 to %struct.rpc_xprt*
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry, %out_err
  %retval.0 = phi %struct.rpc_xprt* [ %17, %out_err ], [ %call, %entry ], [ %call, %sw.epilog ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__init_work(%struct.work_struct* %work, i32 %onstack) #0 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #0 {
entry:
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  store %struct.list_head* %list, %struct.list_head** %next, align 8, !tbaa !187
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !188
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_setup_socket(%struct.work_struct* %work) #1 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1464
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 0
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock2, align 8, !tbaa !93
  %call = call %struct.task_struct* @get_current()
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call, i32 0, i32 3
  %3 = load i32, i32* %flags, align 4, !tbaa !48
  %or = or i32 %3, 131072
  store i32 %or, i32* %flags, align 4, !tbaa !48
  call void @xs_reset_transport(%struct.sock_xprt* %1)
  %call3 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt1)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call3, i32 0, i32 0
  %4 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %4 to i32
  %call4 = call %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt1, %struct.sock_xprt* %1, i32 %conv, i32 2, i32 17)
  %5 = bitcast %struct.socket* %call4 to i8*
  %call5 = call i64 @IS_ERR(i8* %5)
  %tobool = icmp ne i64 %call5, 0
  br i1 %tobool, label %out, label %do.end

do.end:                                           ; preds = %entry
  call void @xs_udp_finish_connecting(%struct.rpc_xprt* %xprt1, %struct.socket* %call4)
  br label %out

out:                                              ; preds = %entry, %do.end
  %status.0 = phi i32 [ 0, %do.end ], [ -5, %entry ]
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt1)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt1, i32 %status.0)
  %call6 = call %struct.task_struct* @get_current()
  %flags7 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call6, i32 0, i32 3
  %6 = load i32, i32* %flags7, align 4, !tbaa !48
  %and = and i32 %6, -131073
  store i32 %and, i32* %flags7, align 4, !tbaa !48
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #2

declare void @delayed_work_timer_fn(i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_bound(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @constant_test_bit(i32 4, i64* %state)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_set_buffer_size(%struct.rpc_xprt* %xprt, i64 %sndsize, i64 %rcvsize) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sndsize1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  store i64 0, i64* %sndsize1, align 8, !tbaa !189
  %tobool = icmp ne i64 %sndsize, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %add = add i64 %sndsize, 1024
  %sndsize2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  store i64 %add, i64* %sndsize2, align 8, !tbaa !189
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rcvsize3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  store i64 0, i64* %rcvsize3, align 8, !tbaa !190
  %tobool4 = icmp ne i64 %rcvsize, 0
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %add6 = add i64 %rcvsize, 1024
  %rcvsize7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  store i64 %add6, i64* %rcvsize7, align 8, !tbaa !190
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  call void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt)
  ret void
}

declare i32 @xprt_reserve_xprt_cong(%struct.rpc_xprt*, %struct.rpc_task*) #2

declare void @xprt_release_xprt_cong(%struct.rpc_xprt*, %struct.rpc_task*) #2

declare void @rpcb_getport_async(%struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_set_port(%struct.rpc_xprt* %xprt, i16 zeroext %port) #1 {
entry:
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  call void @rpc_set_port(%struct.sockaddr* %call, i16 zeroext %port)
  call void @xs_update_peer_port(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_connect(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %cmp = icmp ne %struct.socket* %2, null
  br i1 %cmp, label %land.lhs.true, label %do.end15

land.lhs.true:                                    ; preds = %entry
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 17
  %3 = load i16, i16* %tk_flags, align 8, !tbaa !88
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %do.end15, label %do.end

do.end:                                           ; preds = %land.lhs.true
  %4 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !47
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %5 = load i64, i64* %reestablish_timeout, align 8, !tbaa !34
  %call = call zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %4, %struct.delayed_work* %connect_worker, i64 %5)
  %reestablish_timeout1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %6 = load i64, i64* %reestablish_timeout1, align 8, !tbaa !34
  %shl = shl i64 %6, 1
  store i64 %shl, i64* %reestablish_timeout1, align 8, !tbaa !34
  %reestablish_timeout2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %7 = load i64, i64* %reestablish_timeout2, align 8, !tbaa !34
  %cmp3 = icmp ult i64 %7, 3000
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %do.end
  %reestablish_timeout6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 3000, i64* %reestablish_timeout6, align 8, !tbaa !34
  br label %if.end

if.end:                                           ; preds = %if.then5, %do.end
  %reestablish_timeout7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %8 = load i64, i64* %reestablish_timeout7, align 8, !tbaa !34
  %cmp8 = icmp ugt i64 %8, 300000
  br i1 %cmp8, label %if.then10, label %if.end18

if.then10:                                        ; preds = %if.end
  %reestablish_timeout11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 300000, i64* %reestablish_timeout11, align 8, !tbaa !34
  br label %if.end18

do.end15:                                         ; preds = %entry, %land.lhs.true
  %9 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !47
  %connect_worker16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call17 = call zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %9, %struct.delayed_work* %connect_worker16, i64 0)
  br label %if.end18

if.end18:                                         ; preds = %if.end, %if.then10, %do.end15
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_udp_send_request(%struct.rpc_task* %task) #1 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !80
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !89
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !90
  %5 = bitcast i8* %4 to i32*
  %rq_snd_buf2 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head3 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf2, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head3, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay4, i32 0, i32 1
  %6 = load i64, i64* %iov_len, align 8, !tbaa !92
  %conv = trunc i64 %6 to i32
  call void @xs_pktdump(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1, i32 0, i32 0), i32* %5, i32 %conv)
  %call = call i32 @xprt_bound(%struct.rpc_xprt* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %7 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %call5 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %1)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 4
  %8 = load i64, i64* %addrlen, align 8, !tbaa !43
  %conv6 = trunc i64 %8 to i32
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %9 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !83
  %call7 = call i32 @xs_sendpages(%struct.socket* %7, %struct.sockaddr* %call5, i32 %conv6, %struct.xdr_buf* %rq_snd_buf, i32 %9)
  %cmp = icmp sge i32 %call7, 0
  br i1 %cmp, label %if.then9, label %if.end16

if.then9:                                         ; preds = %if.end
  %conv10 = sext i32 %call7 to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  %10 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !96
  %add = add i64 %10, %conv10
  store i64 %add, i64* %rq_xmit_bytes_sent, align 8, !tbaa !96
  %rq_snd_buf11 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf11, i32 0, i32 7
  %11 = load i32, i32* %len, align 8, !tbaa !86
  %cmp12 = icmp uge i32 %call7, %11
  br i1 %cmp12, label %cleanup, label %if.end16

if.end16:                                         ; preds = %if.then9, %if.end
  %status.0 = phi i32 [ %call7, %if.end ], [ -11, %if.then9 ]
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end16
  %Pivot = icmp slt i32 %status.0, -11
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %status.0, -11
  br i1 %SwitchLeaf2, label %sw.bb17, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %status.0, -88
  br i1 %SwitchLeaf, label %cleanup, label %NewDefault

sw.bb17:                                          ; preds = %LeafBlock1
  %call18 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.bb22

sw.bb22:                                          ; preds = %NewDefault
  %sock23 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %12 = load %struct.socket*, %struct.socket** %sock23, align 8, !tbaa !93
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %12, i32 0, i32 2
  call void @clear_bit(i32 0, i64* %flags)
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock, %sw.bb17, %sw.bb22, %if.then9, %entry
  %retval.0 = phi i32 [ -107, %entry ], [ 0, %if.then9 ], [ %status.0, %sw.bb22 ], [ %call18, %sw.bb17 ], [ -107, %LeafBlock ]
  ret i32 %retval.0
}

declare void @xprt_set_retrans_timeout_rtt(%struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_udp_timer(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #1 {
entry:
  call void @xprt_adjust_cwnd(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task, i32 -110)
  ret void
}

declare void @xprt_release_rqst_cong(%struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal void @xs_destroy(%struct.rpc_xprt* %xprt) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %connect_worker)
  call void @xs_local_destroy(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 12
  %2 = load i16, i16* %srcport, align 8, !tbaa !142
  %conv = zext i16 %2 to i32
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bind_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 0
  %3 = load i64, i64* %bind_count, align 8, !tbaa !101
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %sends = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat1, i32 0, i32 4
  %4 = load i64, i64* %sends, align 8, !tbaa !104
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat2, i32 0, i32 5
  %5 = load i64, i64* %recvs, align 8, !tbaa !105
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bad_xids = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat3, i32 0, i32 6
  %6 = load i64, i64* %bad_xids, align 8, !tbaa !106
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %req_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat4, i32 0, i32 8
  %7 = load i64, i64* %req_u, align 8, !tbaa !107
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bklog_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 9
  %8 = load i64, i64* %bklog_u, align 8, !tbaa !108
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %max_slots = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat6, i32 0, i32 7
  %9 = load i64, i64* %max_slots, align 8, !tbaa !109
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %sending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat7, i32 0, i32 10
  %10 = load i64, i64* %sending_u, align 8, !tbaa !110
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %pending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat8, i32 0, i32 11
  %11 = load i64, i64* %pending_u, align 8, !tbaa !111
  %call = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.11, i32 0, i32 0), i32 %conv, i64 %3, i64 %4, i64 %5, i64 %6, i64 %7, i64 %8, i64 %9, i64 %10, i64 %11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %rcvsize = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  %3 = load i64, i64* %rcvsize, align 8, !tbaa !190
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sk_userlocks = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 19
  %bf.load = load i32, i32* %sk_userlocks, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %or = or i32 %bf.clear, 2
  %bf.load1 = load i32, i32* %sk_userlocks, align 8
  %bf.value = and i32 %or, 15
  %bf.shl = shl i32 %bf.value, 4
  %bf.clear2 = and i32 %bf.load1, -241
  %bf.set = or i32 %bf.clear2, %bf.shl
  store i32 %bf.set, i32* %sk_userlocks, align 8
  %rcvsize3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 13
  %4 = load i64, i64* %rcvsize3, align 8, !tbaa !190
  %max_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %5 = load i32, i32* %max_reqs, align 8, !tbaa !191
  %conv = zext i32 %5 to i64
  %mul = mul i64 %4, %conv
  %mul4 = mul i64 %mul, 2
  %conv5 = trunc i64 %mul4 to i32
  %sk_rcvbuf = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 7
  store i32 %conv5, i32* %sk_rcvbuf, align 4, !tbaa !192
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sndsize = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  %6 = load i64, i64* %sndsize, align 8, !tbaa !189
  %tobool6 = icmp ne i64 %6, 0
  br i1 %tobool6, label %if.then7, label %if.end24

if.then7:                                         ; preds = %if.end
  %sk_userlocks8 = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 19
  %bf.load9 = load i32, i32* %sk_userlocks8, align 8
  %bf.lshr10 = lshr i32 %bf.load9, 4
  %bf.clear11 = and i32 %bf.lshr10, 15
  %or12 = or i32 %bf.clear11, 1
  %bf.load13 = load i32, i32* %sk_userlocks8, align 8
  %bf.value14 = and i32 %or12, 15
  %bf.shl15 = shl i32 %bf.value14, 4
  %bf.clear16 = and i32 %bf.load13, -241
  %bf.set17 = or i32 %bf.clear16, %bf.shl15
  store i32 %bf.set17, i32* %sk_userlocks8, align 8
  %sndsize18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 14
  %7 = load i64, i64* %sndsize18, align 8, !tbaa !189
  %max_reqs19 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %8 = load i32, i32* %max_reqs19, align 8, !tbaa !191
  %conv20 = zext i32 %8 to i64
  %mul21 = mul i64 %7, %conv20
  %mul22 = mul i64 %mul21, 2
  %conv23 = trunc i64 %mul22 to i32
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 17
  store i32 %conv23, i32* %sk_sndbuf, align 4, !tbaa !175
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 56
  %9 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !149
  call void %9(%struct.sock* %2)
  br label %if.end24

if.end24:                                         ; preds = %if.then7, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_set_port(%struct.sockaddr* %sap, i16 zeroext %port) #0 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %0 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call = call zeroext i16 @__fswab16(i16 zeroext %port) #4
  %conv1 = zext i16 %call to i32
  %conv2 = trunc i32 %conv1 to i16
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  store i16 %conv2, i16* %sin_port, align 2, !tbaa !178
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %call4 = call zeroext i16 @__fswab16(i16 zeroext %port) #4
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %2 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  store i16 %conv6, i16* %sin6_port, align 2, !tbaa !184
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.bb3, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_update_peer_port(%struct.rpc_xprt* %xprt) #1 {
entry:
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 4
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !47
  call void @kfree(i8* %0)
  %address_strings1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings1, i64 0, i64 1
  %1 = load i8*, i8** %arrayidx2, align 8, !tbaa !47
  call void @kfree(i8* %1)
  call void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #0 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 64, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #2

declare void @xprt_adjust_cwnd(%struct.rpc_xprt*, %struct.rpc_task*, i32) #2

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #2

; Function Attrs: nounwind uwtable
define internal %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt, %struct.sock_xprt* %transport, i32 %family, i32 %type, i32 %protocol) #1 {
entry:
  %sock = alloca %struct.socket*, align 8
  %0 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 36
  %1 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !78
  %call = call i32 @__sock_create(%struct.net* %1, i32 %family, i32 %type, i32 %protocol, %struct.socket** %sock, i32 1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !47
  call void @xs_reclassify_socket(i32 %family, %struct.socket* %2)
  %3 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !47
  %call1 = call i32 @xs_bind(%struct.sock_xprt* %transport, %struct.socket* %3)
  %tobool = icmp ne i32 %call1, 0
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !47
  br i1 %tobool, label %if.then2, label %cleanup

if.then2:                                         ; preds = %if.end
  call void @sock_release(%struct.socket* %4)
  br label %out

out:                                              ; preds = %entry, %if.then2
  %err.0 = phi i32 [ %call1, %if.then2 ], [ %call, %entry ]
  %conv = sext i32 %err.0 to i64
  %call4 = call i8* @ERR_PTR(i64 %conv)
  %5 = bitcast i8* %call4 to %struct.socket*
  br label %cleanup

cleanup:                                          ; preds = %if.end, %out
  %retval.0 = phi %struct.socket* [ %5, %out ], [ %4, %if.end ]
  %6 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  ret %struct.socket* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !157
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 31
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 45
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !143
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 55
  store void (%struct.sock*, i32)* @xs_udp_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !145
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 56
  store void (%struct.sock*)* @xs_udp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !149
  %sk_no_check = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 19
  %bf.load = load i32, i32* %sk_no_check, align 8
  %bf.clear = and i32 %bf.load, -13
  %bf.set = or i32 %bf.clear, 8
  store i32 %bf.set, i32* %sk_no_check, align 8
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 21
  store i32 32, i32* %sk_allocation, align 8, !tbaa !158
  call void @xprt_set_connected(%struct.rpc_xprt* %xprt)
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock2, align 8, !tbaa !93
  %inet3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet3, align 8, !tbaa !117
  call void @xs_set_memalloc(%struct.rpc_xprt* %xprt)
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 31
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_reclassify_socket(i32 %family, %struct.socket* %sock) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_bind(%struct.sock_xprt* %transport, %struct.socket* %sock) #1 {
entry:
  %myaddr = alloca %struct.__kernel_sockaddr_storage, align 8
  %0 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  %call = call zeroext i16 @xs_get_srcport(%struct.sock_xprt* %transport)
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %1 = load i64, i64* %addrlen, align 8, !tbaa !193
  %2 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to i8*
  %srcaddr = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 11
  %3 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 %1, i32 8, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.end9, %entry
  %nloop.0 = phi i32 [ 0, %entry ], [ %inc.nloop.0, %if.end9 ]
  %port.0 = phi i16 [ %call, %entry ], [ %call10, %if.end9 ]
  %4 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to %struct.sockaddr*
  call void @rpc_set_port(%struct.sockaddr* %4, i16 zeroext %port.0)
  %5 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to %struct.sockaddr*
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %addrlen2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 4
  %6 = load i64, i64* %addrlen2, align 8, !tbaa !193
  %conv = trunc i64 %6 to i32
  %call3 = call i32 @kernel_bind(%struct.socket* %sock, %struct.sockaddr* %5, i32 %conv)
  %conv4 = zext i16 %port.0 to i32
  %cmp = icmp eq i32 %conv4, 0
  br i1 %cmp, label %do.end, label %if.end

if.end:                                           ; preds = %do.body
  %cmp6 = icmp eq i32 %call3, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  store i16 %port.0, i16* %srcport, align 8, !tbaa !142
  br label %do.end

if.end9:                                          ; preds = %if.end
  %call10 = call zeroext i16 @xs_next_srcport(%struct.sock_xprt* %transport, i16 zeroext %port.0)
  %conv11 = zext i16 %call10 to i32
  %conv12 = zext i16 %port.0 to i32
  %cmp13 = icmp sgt i32 %conv11, %conv12
  %inc = add nsw i32 %nloop.0, 1
  %inc.nloop.0 = select i1 %cmp13, i32 %inc, i32 %nloop.0
  %cmp17 = icmp eq i32 %call3, -98
  %cmp19 = icmp ne i32 %inc.nloop.0, 2
  %7 = select i1 %cmp17, i1 %cmp19, i1 false
  br i1 %7, label %do.body, label %do.end

do.end:                                           ; preds = %if.end9, %do.body, %if.then8
  %ss_family = getelementptr inbounds %struct.__kernel_sockaddr_storage, %struct.__kernel_sockaddr_storage* %myaddr, i32 0, i32 0
  %8 = load i16, i16* %ss_family, align 8, !tbaa !194
  %conv21 = zext i16 %8 to i32
  %cmp22 = icmp eq i32 %conv21, 2
  %9 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %9) #7
  ret i32 %call3
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_get_srcport(%struct.sock_xprt* %transport) #1 {
entry:
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  %0 = load i16, i16* %srcport, align 8, !tbaa !142
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %resvport = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 19
  %bf.load = load i8, i8* %resvport, align 8
  %bf.clear = and i8 %bf.load, 1
  %conv2 = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %conv2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call = call zeroext i16 @xs_get_random_port()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %port.0 = phi i16 [ %call, %if.then ], [ %0, %land.lhs.true ], [ %0, %entry ]
  ret i16 %port.0
}

declare i32 @kernel_bind(%struct.socket*, %struct.sockaddr*, i32) #2

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_next_srcport(%struct.sock_xprt* %transport, i16 zeroext %port) #1 {
entry:
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  %0 = load i16, i16* %srcport, align 8, !tbaa !142
  %conv = zext i16 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %srcport2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 12
  store i16 0, i16* %srcport2, align 8, !tbaa !142
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %resvport = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 19
  %bf.load = load i8, i8* %resvport, align 8
  %bf.clear = and i8 %bf.load, 1
  %tobool = icmp ne i8 %bf.clear, 0
  br i1 %tobool, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %conv5 = zext i16 %port to i32
  %1 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !16
  %cmp6 = icmp ule i32 %conv5, %1
  br i1 %cmp6, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %conv8 = zext i16 %port to i32
  %2 = load i32, i32* @xprt_max_resvport, align 4, !tbaa !16
  %cmp9 = icmp ugt i32 %conv8, %2
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %lor.lhs.false, %if.end4
  %3 = load i32, i32* @xprt_max_resvport, align 4, !tbaa !16
  %conv12 = trunc i32 %3 to i16
  br label %return

if.end13:                                         ; preds = %lor.lhs.false
  %dec = add i16 %port, -1
  br label %return

return:                                           ; preds = %if.end, %if.end13, %if.then11
  %retval.0 = phi i16 [ %conv12, %if.then11 ], [ %dec, %if.end13 ], [ 0, %if.end ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_get_random_port() #1 {
entry:
  %0 = load i32, i32* @xprt_max_resvport, align 4, !tbaa !16
  %1 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !16
  %sub = sub i32 %0, %1
  %conv = trunc i32 %sub to i16
  %call = call i32 @prandom_u32()
  %conv1 = trunc i32 %call to i16
  %conv2 = zext i16 %conv1 to i32
  %conv3 = zext i16 %conv to i32
  %rem = srem i32 %conv2, %conv3
  %conv4 = trunc i32 %rem to i16
  %conv5 = zext i16 %conv4 to i32
  %2 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !16
  %add = add i32 %conv5, %2
  %conv6 = trunc i32 %add to i16
  ret i16 %conv6
}

declare i32 @prandom_u32() #2

; Function Attrs: nounwind uwtable
define internal void @xs_udp_data_ready(%struct.sock* %sk, i32 %len) #1 {
entry:
  %err = alloca i32, align 4
  %_xid = alloca i32, align 4
  %0 = bitcast i32* %err to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool = icmp ne %struct.rpc_xprt* %call, null
  br i1 %tobool, label %if.end, label %out

if.end:                                           ; preds = %entry
  %call1 = call %struct.sk_buff* @skb_recv_datagram(%struct.sock* %sk, i32 0, i32 1, i32* %err)
  %cmp = icmp eq %struct.sk_buff* %call1, null
  br i1 %cmp, label %out, label %if.end3

if.end3:                                          ; preds = %if.end
  %len4 = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %call1, i32 0, i32 8
  %2 = load i32, i32* %len4, align 8, !tbaa !162
  %conv = zext i32 %2 to i64
  %sub = sub i64 %conv, 8
  %conv5 = trunc i64 %sub to i32
  %cmp6 = icmp slt i32 %conv5, 4
  br i1 %cmp6, label %dropit, label %if.end12

if.end12:                                         ; preds = %if.end3
  %3 = bitcast i32* %_xid to i8*
  %call13 = call i8* @skb_header_pointer(%struct.sk_buff* %call1, i32 8, i32 4, i8* %3)
  %4 = bitcast i8* %call13 to i32*
  %cmp14 = icmp eq i32* %4, null
  br i1 %cmp14, label %dropit, label %if.end17

if.end17:                                         ; preds = %if.end12
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_lock(%struct.spinlock* %transport_lock)
  %5 = load i32, i32* %4, align 4, !tbaa !16
  %call18 = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %call, i32 %5)
  %tobool19 = icmp ne %struct.rpc_rqst* %call18, null
  br i1 %tobool19, label %if.end21, label %out_unlock

if.end21:                                         ; preds = %if.end17
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call18, i32 0, i32 3
  %6 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !164
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call18, i32 0, i32 17
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 6
  %7 = load i32, i32* %buflen, align 4, !tbaa !165
  %cmp22 = icmp sgt i32 %7, %conv5
  %conv5. = select i1 %cmp22, i32 %conv5, i32 %7
  %rq_private_buf26 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call18, i32 0, i32 17
  %call27 = call i32 @csum_partial_copy_to_xdr(%struct.xdr_buf* %rq_private_buf26, %struct.sk_buff* %call1)
  %tobool28 = icmp ne i32 %call27, 0
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %8 = load i16, i16* %skc_family, align 8, !tbaa !195
  %conv31 = zext i16 %8 to i32
  %cmp32 = icmp eq i32 %conv31, 2
  %call41 = call %struct.net* @sock_net(%struct.sock* %sk)
  %mib = getelementptr inbounds %struct.net, %struct.net* %call41, i32 0, i32 21
  br i1 %tobool28, label %do.body30, label %do.body72

do.body30:                                        ; preds = %if.end21
  br i1 %cmp32, label %do.body40, label %do.body55

do.body40:                                        ; preds = %do.body30
  %udp_statistics = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 3
  %arrayidx = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_statistics, i64 0, i64 0
  %9 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx, align 8, !tbaa !47
  %mibs = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %9, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs, i64 0, i64 3
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx42, i64* %arrayidx42) #7, !srcloc !196
  br label %out_unlock

do.body55:                                        ; preds = %do.body30
  %udp_stats_in6 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 8
  %arrayidx59 = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_stats_in6, i64 0, i64 0
  %10 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx59, align 32, !tbaa !47
  %mibs60 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %10, i32 0, i32 0
  %arrayidx61 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs60, i64 0, i64 3
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx61, i64* %arrayidx61) #7, !srcloc !197
  br label %out_unlock

do.body72:                                        ; preds = %if.end21
  br i1 %cmp32, label %do.body85, label %do.body106

do.body85:                                        ; preds = %do.body72
  %udp_statistics89 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 3
  %arrayidx90 = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_statistics89, i64 0, i64 0
  %11 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx90, align 8, !tbaa !47
  %mibs91 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %11, i32 0, i32 0
  %arrayidx92 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs91, i64 0, i64 1
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx92, i64* %arrayidx92) #7, !srcloc !198
  br label %do.end122

do.body106:                                       ; preds = %do.body72
  %udp_stats_in6110 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 8
  %arrayidx111 = getelementptr inbounds [1 x %struct.udp_mib*], [1 x %struct.udp_mib*]* %udp_stats_in6110, i64 0, i64 0
  %12 = load %struct.udp_mib*, %struct.udp_mib** %arrayidx111, align 32, !tbaa !47
  %mibs112 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %12, i32 0, i32 0
  %arrayidx113 = getelementptr inbounds [8 x i64], [8 x i64]* %mibs112, i64 0, i64 1
  call void asm "incq %gs:${0:P}", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx113, i64* %arrayidx113) #7, !srcloc !199
  br label %do.end122

do.end122:                                        ; preds = %do.body106, %do.body85
  call void @xprt_adjust_cwnd(%struct.rpc_xprt* %call, %struct.rpc_task* %6, i32 %conv5.)
  call void @xprt_complete_rqst(%struct.rpc_task* %6, i32 %conv5.)
  br label %out_unlock

out_unlock:                                       ; preds = %do.body40, %do.body55, %if.end17, %do.end122
  %transport_lock123 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_unlock(%struct.spinlock* %transport_lock123)
  br label %dropit

dropit:                                           ; preds = %if.end12, %if.end3, %out_unlock
  call void @skb_free_datagram(%struct.sock* %sk, %struct.sk_buff* %call1)
  br label %out

out:                                              ; preds = %if.end, %entry, %dropit
  %sk_callback_lock124 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock124)
  %13 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %13) #7
  %14 = bitcast i32* %err to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %14) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_set_memalloc(%struct.rpc_xprt* %xprt) #1 {
entry:
  ret void
}

declare i32 @csum_partial_copy_to_xdr(%struct.xdr_buf*, %struct.sk_buff*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @sock_net(%struct.sock* %sk) #0 {
entry:
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_net = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 9
  %call = call %struct.net* @read_pnet(%struct.net** %skc_net)
  ret %struct.net* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @read_pnet(%struct.net** %pnet) #0 {
entry:
  %0 = load %struct.net*, %struct.net** %pnet, align 8, !tbaa !47
  ret %struct.net* %0
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_tcp(%struct.xprt_create* %args) #1 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %.compoundliteral49 = alloca %struct.atomic64_t, align 8
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !12
  %1 = load i32, i32* @xprt_max_tcp_slot_table_entries, align 4, !tbaa !16
  %flags = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 7
  %2 = load i32, i32* %flags, align 8, !tbaa !200
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %. = select i1 %tobool, i32 65536, i32 %1
  %3 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !16
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %3, i32 %.)
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call i64 @IS_ERR(i8* %4)
  %tobool2 = icmp ne i64 %call1, 0
  br i1 %tobool2, label %cleanup, label %if.end4

if.end4:                                          ; preds = %entry
  %5 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 6, i32* %prot, align 8, !tbaa !17
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !31
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !32
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 60000, i64* %bind_timeout, align 8, !tbaa !33
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 3000, i64* %reestablish_timeout, align 8, !tbaa !34
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 300000, i64* %idle_timeout, align 8, !tbaa !35
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_tcp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !36
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_tcp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !37
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %7 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %7 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end4
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb35, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %8 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %8, i32 0, i32 1
  %9 = load i16, i16* %sin_port, align 2, !tbaa !178
  %conv5 = zext i16 %9 to i32
  %cmp = icmp ne i32 %conv5, 0
  br i1 %cmp, label %if.then7, label %do.body10

if.then7:                                         ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body10

do.body10:                                        ; preds = %sw.bb, %if.then7
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %connect_worker11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work12 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker11, i32 0, i32 0
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work12, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !179
  %10 = bitcast %struct.atomic64_t* %data to i8*
  %11 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 8, i32 8, i1 false), !tbaa.struct !180
  %connect_worker13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work14 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker13, i32 0, i32 0
  %entry15 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work14, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry15)
  %connect_worker17 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work18 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker17, i32 0, i32 0
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work18, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_tcp_setup_socket, void (%struct.work_struct*)** %func, align 8, !tbaa !181
  %connect_worker24 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker24, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2, i8* null, %struct.lock_class_key* null)
  %connect_worker25 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer26 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker25, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer26, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !182
  %connect_worker27 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %12 = ptrtoint %struct.delayed_work* %connect_worker27 to i64
  %connect_worker28 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer29 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker28, i32 0, i32 1
  %data30 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer29, i32 0, i32 4
  store i64 %12, i64* %data30, align 8, !tbaa !183
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0))
  br label %sw.epilog

sw.bb35:                                          ; preds = %LeafBlock1
  %13 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %13, i32 0, i32 1
  %14 = load i16, i16* %sin6_port, align 2, !tbaa !184
  %conv36 = zext i16 %14 to i32
  %cmp37 = icmp ne i32 %conv36, 0
  br i1 %cmp37, label %if.then39, label %do.body43

if.then39:                                        ; preds = %sw.bb35
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %do.body43

do.body43:                                        ; preds = %sw.bb35, %if.then39
  %connect_worker44 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work45 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker44, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work45, i32 0)
  %connect_worker46 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work47 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker46, i32 0, i32 0
  %data48 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work47, i32 0, i32 0
  %counter50 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral49, i32 0, i32 0
  store i64 68719476704, i64* %counter50, align 8, !tbaa !179
  %15 = bitcast %struct.atomic64_t* %data48 to i8*
  %16 = bitcast %struct.atomic64_t* %.compoundliteral49 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false), !tbaa.struct !180
  %connect_worker51 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work52 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker51, i32 0, i32 0
  %entry53 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work52, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry53)
  %connect_worker55 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %work56 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker55, i32 0, i32 0
  %func57 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work56, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_tcp_setup_socket, void (%struct.work_struct*)** %func57, align 8, !tbaa !181
  %connect_worker65 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer66 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker65, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer66, i32 2, i8* null, %struct.lock_class_key* null)
  %connect_worker67 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer68 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker67, i32 0, i32 1
  %function69 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer68, i32 0, i32 3
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function69, align 8, !tbaa !182
  %connect_worker70 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %17 = ptrtoint %struct.delayed_work* %connect_worker70 to i64
  %connect_worker71 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 10
  %timer72 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker71, i32 0, i32 1
  %data73 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer72, i32 0, i32 4
  store i64 %17, i64* %data73, align 8, !tbaa !183
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.body43, %do.body10
  %call79 = call i32 @xprt_bound(%struct.rpc_xprt* %call)
  %tobool80 = icmp ne i32 %call79, 0
  %call89 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call89, label %cleanup, label %out_err

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out_err

out_err:                                          ; preds = %NewDefault, %sw.epilog
  %.sink = phi i64 [ -22, %sw.epilog ], [ -97, %NewDefault ]
  %call92 = call i8* @ERR_PTR(i64 %.sink)
  %18 = bitcast i8* %call92 to %struct.rpc_xprt*
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry, %out_err
  %retval.0 = phi %struct.rpc_xprt* [ %18, %out_err ], [ %call, %entry ], [ %call, %sw.epilog ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_setup_socket(%struct.work_struct* %work) #1 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1464
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !93
  %xprt2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 0
  %call = call %struct.task_struct* @get_current()
  %flags = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call, i32 0, i32 3
  %3 = load i32, i32* %flags, align 4, !tbaa !48
  %or = or i32 %3, 131072
  store i32 %or, i32* %flags, align 4, !tbaa !48
  %tobool = icmp ne %struct.socket* %2, null
  %state10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt2, i32 0, i32 18
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  call void @clear_bit(i32 7, i64* %state10)
  %call3 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt2)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call3, i32 0, i32 0
  %4 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %4 to i32
  %call4 = call %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt2, %struct.sock_xprt* %1, i32 %conv, i32 1, i32 6)
  %5 = bitcast %struct.socket* %call4 to i8*
  %call5 = call i64 @IS_ERR(i8* %5)
  %tobool6 = icmp ne i64 %call5, 0
  br i1 %tobool6, label %if.then7, label %do.end

if.then7:                                         ; preds = %if.then
  %6 = bitcast %struct.socket* %call4 to i8*
  %call8 = call i64 @PTR_ERR(i8* %6)
  %conv9 = trunc i64 %call8 to i32
  br label %out

if.else:                                          ; preds = %entry
  %call11 = call i32 @test_and_clear_bit(i32 7, i64* %state10)
  call void @xs_tcp_reuse_connection(%struct.sock_xprt* %1)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %out, label %do.end

do.end:                                           ; preds = %if.else, %if.then
  %sock.0 = phi %struct.socket* [ %call4, %if.then ], [ %2, %if.else ]
  %call16 = call i32 @xs_tcp_finish_connecting(%struct.rpc_xprt* %xprt2, %struct.socket* %sock.0)
  br label %NodeBlock22

NodeBlock22:                                      ; preds = %do.end
  %Pivot23 = icmp slt i32 %call16, -101
  br i1 %Pivot23, label %NodeBlock6, label %NodeBlock20

NodeBlock20:                                      ; preds = %NodeBlock22
  %Pivot21 = icmp slt i32 %call16, -22
  br i1 %Pivot21, label %NodeBlock12, label %NodeBlock18

NodeBlock18:                                      ; preds = %NodeBlock20
  %Pivot19 = icmp slt i32 %call16, 0
  br i1 %Pivot19, label %LeafBlock14, label %LeafBlock16

LeafBlock16:                                      ; preds = %NodeBlock18
  %SwitchLeaf17 = icmp eq i32 %call16, 0
  br i1 %SwitchLeaf17, label %sw.bb21, label %NewDefault

LeafBlock14:                                      ; preds = %NodeBlock18
  %SwitchLeaf15 = icmp eq i32 %call16, -22
  br i1 %SwitchLeaf15, label %out, label %NewDefault

NodeBlock12:                                      ; preds = %NodeBlock20
  %Pivot13 = icmp slt i32 %call16, -99
  br i1 %Pivot13, label %LeafBlock8, label %LeafBlock10

LeafBlock10:                                      ; preds = %NodeBlock12
  %SwitchLeaf11 = icmp eq i32 %call16, -99
  br i1 %SwitchLeaf11, label %sw.bb, label %NewDefault

LeafBlock8:                                       ; preds = %NodeBlock12
  %SwitchLeaf9 = icmp eq i32 %call16, -101
  br i1 %SwitchLeaf9, label %out, label %NewDefault

NodeBlock6:                                       ; preds = %NodeBlock22
  %Pivot7 = icmp slt i32 %call16, -111
  br i1 %Pivot7, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock6
  %Pivot = icmp slt i32 %call16, -104
  br i1 %Pivot, label %LeafBlock2, label %LeafBlock4

LeafBlock4:                                       ; preds = %NodeBlock
  %SwitchLeaf5 = icmp eq i32 %call16, -104
  br i1 %SwitchLeaf5, label %out, label %NewDefault

LeafBlock2:                                       ; preds = %NodeBlock
  %SwitchLeaf3 = icmp eq i32 %call16, -111
  br i1 %SwitchLeaf3, label %out, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock6
  %call16.off = add i32 %call16, 115
  %SwitchLeaf = icmp ule i32 %call16.off, 1
  br i1 %SwitchLeaf, label %sw.bb21, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock16, %LeafBlock14, %LeafBlock10, %LeafBlock8, %LeafBlock4, %LeafBlock2, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %call20 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.xs_tcp_setup_socket, i32 0, i32 0), i32 %call16)
  br label %sw.bb

sw.bb:                                            ; preds = %LeafBlock10, %sw.default
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt2)
  br label %out

sw.bb21:                                          ; preds = %LeafBlock16, %LeafBlock
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt2)
  br label %cleanup28.sink.split

out:                                              ; preds = %LeafBlock14, %LeafBlock8, %LeafBlock4, %LeafBlock2, %if.else, %sw.bb, %if.then7
  %status.0 = phi i32 [ %conv9, %if.then7 ], [ %call16, %LeafBlock2 ], [ %call16, %LeafBlock4 ], [ %call16, %LeafBlock8 ], [ %call16, %LeafBlock14 ], [ -11, %sw.bb ], [ -11, %if.else ]
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt2)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt2, i32 %status.0)
  br label %cleanup28.sink.split

cleanup28.sink.split:                             ; preds = %sw.bb21, %out
  %call22 = call %struct.task_struct* @get_current()
  %flags23 = getelementptr inbounds %struct.task_struct, %struct.task_struct* %call22, i32 0, i32 3
  %7 = load i32, i32* %flags23, align 4, !tbaa !48
  %and27 = and i32 %7, -131073
  store i32 %and27, i32* %flags23, align 4, !tbaa !48
  ret void
}

declare void @xprt_lock_and_alloc_slot(%struct.rpc_xprt*, %struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_send_request(%struct.rpc_task* %task) #1 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !80
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !89
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf1)
  %rq_snd_buf2 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !90
  %5 = bitcast i8* %4 to i32*
  %rq_snd_buf3 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head4 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf3, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head4, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay5, i32 0, i32 1
  %6 = load i64, i64* %iov_len, align 8, !tbaa !92
  %conv = trunc i64 %6 to i32
  call void @xs_pktdump(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.1, i32 0, i32 0), i32* %5, i32 %conv)
  br label %while.cond

while.cond:                                       ; preds = %if.then28, %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %7 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %8 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !83
  %call = call i32 @xs_sendpages(%struct.socket* %7, %struct.sockaddr* null, i32 0, %struct.xdr_buf* %rq_snd_buf, i32 %8)
  %cmp = icmp slt i32 %call, 0
  %lnot = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %while.end, label %if.end

if.end:                                           ; preds = %while.cond
  %rq_bytes_sent9 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %9 = load i32, i32* %rq_bytes_sent9, align 8, !tbaa !83
  %add = add i32 %9, %call
  store i32 %add, i32* %rq_bytes_sent9, align 8, !tbaa !83
  %conv10 = sext i32 %call to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  %10 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !96
  %add11 = add i64 %10, %conv10
  store i64 %add11, i64* %rq_xmit_bytes_sent, align 8, !tbaa !96
  %rq_bytes_sent12 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  %11 = load i32, i32* %rq_bytes_sent12, align 8, !tbaa !83
  %rq_snd_buf13 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf13, i32 0, i32 7
  %12 = load i32, i32* %len, align 8, !tbaa !86
  %cmp14 = icmp uge i32 %11, %12
  %lnot16 = xor i1 %cmp14, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 1)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end
  %rq_bytes_sent24 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 23
  store i32 0, i32* %rq_bytes_sent24, align 8, !tbaa !83
  br label %cleanup

if.end25:                                         ; preds = %if.end
  %cmp26 = icmp ne i32 %call, 0
  br i1 %cmp26, label %if.then28, label %while.end

if.then28:                                        ; preds = %if.end25
  br label %while.cond

while.end:                                        ; preds = %if.end25, %while.cond
  %status.0 = phi i32 [ %call, %while.cond ], [ -11, %if.end25 ]
  br label %NodeBlock13

NodeBlock13:                                      ; preds = %while.end
  %Pivot14 = icmp slt i32 %status.0, -88
  br i1 %Pivot14, label %NodeBlock, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %status.0, -32
  br i1 %Pivot12, label %LeafBlock3, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %status.0, -11
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %status.0, -11
  br i1 %SwitchLeaf8, label %sw.bb30, label %NewDefault

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %status.0, -32
  br i1 %SwitchLeaf6, label %sw.bb36, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock11
  %SwitchLeaf4 = icmp eq i32 %status.0, -88
  br i1 %SwitchLeaf4, label %cleanup, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock13
  %Pivot = icmp slt i32 %status.0, -107
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %status.0, -107
  br i1 %SwitchLeaf2, label %sw.bb36, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %status.0, -111
  br i1 %SwitchLeaf, label %sw.bb36, label %NewDefault

sw.bb30:                                          ; preds = %LeafBlock7
  %call31 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock7, %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.bb35

sw.bb35:                                          ; preds = %NewDefault
  call void @xs_tcp_shutdown(%struct.rpc_xprt* %1)
  br label %sw.bb36

sw.bb36:                                          ; preds = %LeafBlock5, %LeafBlock1, %LeafBlock, %sw.bb35
  %sock37 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %13 = load %struct.socket*, %struct.socket** %sock37, align 8, !tbaa !93
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %13, i32 0, i32 2
  call void @clear_bit(i32 0, i64* %flags)
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock3, %sw.bb30, %sw.bb36, %if.then23
  %retval.0 = phi i32 [ 0, %if.then23 ], [ %status.0, %sw.bb36 ], [ %call31, %sw.bb30 ], [ -107, %LeafBlock3 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_close(%struct.rpc_xprt* %xprt) #1 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_clear_bit(i32 8, i64* %state)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @xs_close(%struct.rpc_xprt* %xprt)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @xs_tcp_shutdown(%struct.rpc_xprt* %xprt)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !99
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 27
  %3 = load i64, i64* %last_used, align 8, !tbaa !100
  %sub = sub i64 %2, %3
  %div = sdiv i64 %sub, 1000
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %idle_time.0 = phi i64 [ %div, %if.then ], [ 0, %entry ]
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 12
  %4 = load i16, i16* %srcport, align 8, !tbaa !142
  %conv = zext i16 %4 to i32
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bind_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 0
  %5 = load i64, i64* %bind_count, align 8, !tbaa !101
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat1, i32 0, i32 1
  %6 = load i64, i64* %connect_count, align 8, !tbaa !102
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_time = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat2, i32 0, i32 3
  %7 = load i64, i64* %connect_time, align 8, !tbaa !103
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %sends = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat3, i32 0, i32 4
  %8 = load i64, i64* %sends, align 8, !tbaa !104
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %recvs = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat4, i32 0, i32 5
  %9 = load i64, i64* %recvs, align 8, !tbaa !105
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bad_xids = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat5, i32 0, i32 6
  %10 = load i64, i64* %bad_xids, align 8, !tbaa !106
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %req_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat6, i32 0, i32 8
  %11 = load i64, i64* %req_u, align 8, !tbaa !107
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %bklog_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat7, i32 0, i32 9
  %12 = load i64, i64* %bklog_u, align 8, !tbaa !108
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %max_slots = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat8, i32 0, i32 7
  %13 = load i64, i64* %max_slots, align 8, !tbaa !109
  %stat9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %sending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat9, i32 0, i32 10
  %14 = load i64, i64* %sending_u, align 8, !tbaa !110
  %stat10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %pending_u = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat10, i32 0, i32 11
  %15 = load i64, i64* %pending_u, align 8, !tbaa !111
  %call11 = call i32 (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.14, i32 0, i32 0), i32 %conv, i64 %5, i64 %6, i64 %7, i64 %idle_time.0, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12, i64 %13, i64 %14, i64 %15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_shutdown(%struct.rpc_xprt* %xprt) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !93
  %cmp = icmp ne %struct.socket* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @kernel_sock_shutdown(%struct.socket* %2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @kernel_sock_shutdown(%struct.socket*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #0 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_reuse_connection(%struct.sock_xprt* %transport) #1 {
entry:
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %0 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %0, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %1 = load volatile i8, i8* %skc_state, align 2, !tbaa !201
  %conv = zext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 7
  br i1 %cmp, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %state2 = getelementptr inbounds %struct.socket, %struct.socket* %2, i32 0, i32 0
  %3 = load i32, i32* %state2, align 8, !tbaa !202
  %cmp3 = icmp eq i32 %3, 1
  br i1 %cmp3, label %if.then, label %if.end9

if.then:                                          ; preds = %land.lhs.true
  %inet5 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %4 = load %struct.sock*, %struct.sock** %inet5, align 8, !tbaa !117
  %sk_shutdown = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 19
  %bf.load = load i32, i32* %sk_shutdown, align 8
  %bf.clear = and i32 %bf.load, 3
  %cmp6 = icmp eq i32 %bf.clear, 0
  br i1 %cmp6, label %cleanup.cont, label %if.end9

if.end9:                                          ; preds = %if.then, %land.lhs.true, %entry
  %shl = shl i32 1, %conv
  %and = and i32 %shl, 6
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then10, label %if.end22

if.then10:                                        ; preds = %if.end9
  %inet11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %5 = load %struct.sock*, %struct.sock** %inet11, align 8, !tbaa !117
  %sk_shutdown12 = getelementptr inbounds %struct.sock, %struct.sock* %5, i32 0, i32 19
  %bf.load13 = load i32, i32* %sk_shutdown12, align 8
  %bf.clear14 = and i32 %bf.load13, 3
  %cmp15 = icmp eq i32 %bf.clear14, 0
  br i1 %cmp15, label %cleanup.cont, label %if.end22

if.end22:                                         ; preds = %if.then10, %if.end9
  call void @xs_abort_connection(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end22, %if.then, %if.then10
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !117
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !157
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 31
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 45
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !143
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 55
  store void (%struct.sock*, i32)* @xs_tcp_data_ready, void (%struct.sock*, i32)** %sk_data_ready, align 8, !tbaa !145
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 54
  store void (%struct.sock*)* @xs_tcp_state_change, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !147
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 56
  store void (%struct.sock*)* @xs_tcp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !149
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 21
  store i32 32, i32* %sk_allocation, align 8, !tbaa !158
  %sk_userlocks = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 19
  %bf.load = load i32, i32* %sk_userlocks, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %or = or i32 %bf.clear, 8
  %bf.load2 = load i32, i32* %sk_userlocks, align 8
  %bf.value = and i32 %or, 15
  %bf.shl = shl i32 %bf.value, 4
  %bf.clear3 = and i32 %bf.load2, -241
  %bf.set = or i32 %bf.clear3, %bf.shl
  store i32 %bf.set, i32* %sk_userlocks, align 8
  call void @sock_reset_flag(%struct.sock* %3, i32 4)
  %call = call %struct.tcp_sock* @tcp_sk(%struct.sock* %3)
  %linger2 = getelementptr inbounds %struct.tcp_sock, %struct.tcp_sock* %call, i32 0, i32 77
  store i32 0, i32* %linger2, align 8, !tbaa !203
  %call4 = call %struct.tcp_sock* @tcp_sk(%struct.sock* %3)
  %nonagle = getelementptr inbounds %struct.tcp_sock, %struct.tcp_sock* %call4, i32 0, i32 24
  %bf.load5 = load i8, i8* %nonagle, align 1
  %bf.clear6 = and i8 %bf.load5, 15
  %conv = zext i8 %bf.clear6 to i32
  %or7 = or i32 %conv, 1
  %conv8 = trunc i32 %or7 to i8
  %bf.load9 = load i8, i8* %nonagle, align 1
  %bf.value10 = and i8 %conv8, 15
  %bf.clear11 = and i8 %bf.load9, -16
  %bf.set12 = or i8 %bf.clear11, %bf.value10
  store i8 %bf.set12, i8* %nonagle, align 1
  call void @xprt_clear_connected(%struct.rpc_xprt* %xprt)
  %sock13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock13, align 8, !tbaa !93
  %inet14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet14, align 8, !tbaa !117
  %sk_callback_lock15 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 31
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock15)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call16 = call i32 @xprt_bound(%struct.rpc_xprt* %xprt)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.end19, label %out

if.end19:                                         ; preds = %if.end
  call void @xs_set_memalloc(%struct.rpc_xprt* %xprt)
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_count = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat, i32 0, i32 1
  %5 = load i64, i64* %connect_count, align 8, !tbaa !102
  %inc = add i64 %5, 1
  store i64 %inc, i64* %connect_count, align 8, !tbaa !102
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !99
  %stat20 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %connect_start = getelementptr inbounds %struct.anon.70, %struct.anon.70* %stat20, i32 0, i32 2
  store i64 %6, i64* %connect_start, align 8, !tbaa !159
  %call21 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %7 = load i64, i64* %addrlen, align 8, !tbaa !43
  %conv22 = trunc i64 %7 to i32
  %call23 = call i32 @kernel_connect(%struct.socket* %sock, %struct.sockaddr* %call21, i32 %conv22, i32 2048)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end19
  %Pivot = icmp slt i32 %call23, 0
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call23, 0
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call23, -115
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1, %LeafBlock
  %connect_cookie = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %8 = load i32, i32* %connect_cookie, align 8, !tbaa !217
  %inc24 = add i32 %8, 1
  store i32 %inc24, i32* %connect_cookie, align 8, !tbaa !217
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  %9 = load i64, i64* %reestablish_timeout, align 8, !tbaa !34
  %cmp = icmp ult i64 %9, 3000
  br i1 %cmp, label %if.then26, label %out

if.then26:                                        ; preds = %sw.bb
  %reestablish_timeout27 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 23
  store i64 3000, i64* %reestablish_timeout27, align 8, !tbaa !34
  br label %out

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out

out:                                              ; preds = %NewDefault, %if.then26, %sw.bb, %if.end
  %ret.0 = phi i32 [ -107, %if.end ], [ %call23, %sw.bb ], [ %call23, %if.then26 ], [ %call23, %NewDefault ]
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_force_close(%struct.rpc_xprt* %xprt) #1 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @set_bit(i32 8, i64* %state)
  call void @xprt_force_disconnect(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_abort_connection(%struct.sock_xprt* %transport) #1 {
entry:
  %any = alloca %struct.sockaddr, align 2
  %0 = bitcast %struct.sockaddr* %any to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0) #7
  %1 = bitcast %struct.sockaddr* %any to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 16, i32 2, i1 false)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %any, i32 0, i32 0
  store i16 0, i16* %sa_family, align 2, !tbaa !45
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !93
  %call = call i32 @kernel_connect(%struct.socket* %2, %struct.sockaddr* %any, i32 16, i32 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %do.end3, label %if.then

if.then:                                          ; preds = %entry
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  call void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt)
  br label %do.end3

do.end3:                                          ; preds = %entry, %if.then
  %3 = bitcast %struct.sockaddr* %any to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %3) #7
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #3

; Function Attrs: nounwind uwtable
define internal void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt) #1 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !218
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 7, i64* %state)
  %state1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 8, i64* %state1)
  %state2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 3, i64* %state2)
  %state3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 6, i64* %state3)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !219
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_data_ready(%struct.sock* %sk, i32 %bytes) #1 {
entry:
  %rd_desc = alloca %struct.read_descriptor_t, align 8
  %0 = bitcast %struct.read_descriptor_t* %rd_desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool = icmp ne %struct.rpc_xprt* %call, null
  br i1 %tobool, label %if.end, label %out

if.end:                                           ; preds = %entry
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  %1 = load i64, i64* %reestablish_timeout, align 8, !tbaa !34
  %tobool1 = icmp ne i64 %1, 0
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %if.end
  %reestablish_timeout3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout3, align 8, !tbaa !34
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %if.end
  %2 = bitcast %struct.rpc_xprt* %call to i8*
  %arg = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 2
  %data = bitcast %union.anon.14* %arg to i8**
  store i8* %2, i8** %data, align 8, !tbaa !40
  br label %do.body5

do.body5:                                         ; preds = %do.body5, %if.end4
  %count = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 1
  store i64 65536, i64* %count, align 8, !tbaa !220
  %call6 = call i32 @tcp_read_sock(%struct.sock* %sk, %struct.read_descriptor_t* %rd_desc, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)* @xs_tcp_data_recv)
  %cmp = icmp sgt i32 %call6, 0
  br i1 %cmp, label %do.body5, label %out

out:                                              ; preds = %do.body5, %entry
  %sk_callback_lock9 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock9)
  %3 = bitcast %struct.read_descriptor_t* %rd_desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_state_change(%struct.sock* %sk) #1 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool = icmp ne %struct.rpc_xprt* %call, null
  br i1 %tobool, label %do.end3, label %out

do.end3:                                          ; preds = %entry
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %0 = load volatile i8, i8* %skc_state, align 2, !tbaa !201
  %conv = zext i8 %0 to i32
  br label %NodeBlock13

NodeBlock13:                                      ; preds = %do.end3
  %Pivot14 = icmp slt i32 %conv, 8
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv, 9
  br i1 %Pivot12, label %sw.bb13, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv, 11
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv, 11
  br i1 %SwitchLeaf8, label %sw.bb17, label %NewDefault

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv, 9
  br i1 %SwitchLeaf6, label %sw.bb23, label %NewDefault

NodeBlock3:                                       ; preds = %NodeBlock13
  %Pivot4 = icmp slt i32 %conv, 4
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %conv, 7
  br i1 %Pivot, label %LeafBlock1, label %sw.bb27

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 4
  br i1 %SwitchLeaf2, label %sw.bb9, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_lock(%struct.spinlock* %transport_lock)
  %call4 = call i32 @xprt_test_and_set_connected(%struct.rpc_xprt* %call)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %sw.bb
  %1 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %2, i32 0, i32 6
  store i32 0, i32* %tcp_offset, align 4, !tbaa !222
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %2, i32 0, i32 7
  store i32 0, i32* %tcp_reclen, align 8, !tbaa !223
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %2, i32 0, i32 8
  store i64 0, i64* %tcp_copied, align 8, !tbaa !224
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %2, i32 0, i32 9
  store i64 6, i64* %tcp_flags, align 8, !tbaa !225
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %call, i32 -11)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %sw.bb
  %transport_lock8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  call void @spin_unlock(%struct.spinlock* %transport_lock8)
  br label %out

sw.bb9:                                           ; preds = %LeafBlock1
  %connect_cookie = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  %3 = load i32, i32* %connect_cookie, align 8, !tbaa !217
  %inc = add i32 %3, 1
  store i32 %inc, i32* %connect_cookie, align 8, !tbaa !217
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !34
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @set_bit(i32 6, i64* %state)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !226
  %state10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i32 1, i64* %state10)
  %state11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i32 3, i64* %state11)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !227
  %4 = load i32, i32* @xs_tcp_fin_timeout, align 4, !tbaa !16
  %conv12 = zext i32 %4 to i64
  call void @xs_tcp_schedule_linger_timeout(%struct.rpc_xprt* %call, i64 %conv12)
  br label %out

sw.bb13:                                          ; preds = %NodeBlock11
  %connect_cookie14 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  %5 = load i32, i32* %connect_cookie14, align 8, !tbaa !217
  %inc15 = add i32 %5, 1
  store i32 %inc15, i32* %connect_cookie14, align 8, !tbaa !217
  %state16 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i32 1, i64* %state16)
  call void @xs_tcp_force_close(%struct.rpc_xprt* %call)
  br label %sw.bb17

sw.bb17:                                          ; preds = %LeafBlock7, %sw.bb13
  %reestablish_timeout18 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  %6 = load i64, i64* %reestablish_timeout18, align 8, !tbaa !34
  %cmp = icmp ult i64 %6, 3000
  br i1 %cmp, label %if.then20, label %out

if.then20:                                        ; preds = %sw.bb17
  %reestablish_timeout21 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 3000, i64* %reestablish_timeout21, align 8, !tbaa !34
  br label %out

sw.bb23:                                          ; preds = %LeafBlock5
  %state24 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @set_bit(i32 6, i64* %state24)
  %7 = load i32, i32* @xs_tcp_fin_timeout, align 4, !tbaa !16
  %conv25 = zext i32 %7 to i64
  call void @xs_tcp_schedule_linger_timeout(%struct.rpc_xprt* %call, i64 %conv25)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !228
  %state26 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i32 1, i64* %state26)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !229
  br label %out

sw.bb27:                                          ; preds = %NodeBlock
  call void @xs_tcp_cancel_linger_timeout(%struct.rpc_xprt* %call)
  call void @xs_sock_mark_closed(%struct.rpc_xprt* %call)
  br label %out

NewDefault:                                       ; preds = %LeafBlock7, %LeafBlock5, %LeafBlock1, %LeafBlock
  br label %out

out:                                              ; preds = %NewDefault, %if.end7, %sw.bb9, %sw.bb23, %sw.bb27, %if.then20, %sw.bb17, %entry
  %sk_callback_lock28 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock28)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_write_space(%struct.sock* %sk) #1 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call i32 @sk_stream_wspace(%struct.sock* %sk)
  %call1 = call i32 @sk_stream_min_wspace(%struct.sock* %sk)
  %cmp = icmp sge i32 %call, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xs_write_space(%struct.sock* %sk)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sk_callback_lock2 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 31
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock2)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sock_reset_flag(%struct.sock* %sk, i32 %flag) #0 {
entry:
  %sk_flags = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 11
  call void @__clear_bit(i32 %flag, i64* %sk_flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.tcp_sock* @tcp_sk(%struct.sock* %sk) #0 {
entry:
  %0 = bitcast %struct.sock* %sk to %struct.tcp_sock*
  ret %struct.tcp_sock* %0
}

declare i32 @tcp_read_sock(%struct.sock*, %struct.read_descriptor_t*, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)*) #2

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_data_recv(%struct.read_descriptor_t* %rd_desc, %struct.sk_buff* %skb, i32 %offset, i64 %len) #1 {
entry:
  %desc = alloca %struct.xdr_skb_reader, align 8
  %arg = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 2
  %data = bitcast %union.anon.14* %arg to i8**
  %0 = load i8*, i8** %data, align 8, !tbaa !40
  %1 = bitcast i8* %0 to %struct.rpc_xprt*
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %4 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %4) #7
  %skb1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb1, align 8, !tbaa !167
  %offset2 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  store i32 %offset, i32* %offset2, align 8, !tbaa !169
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  store i64 %len, i64* %count, align 8, !tbaa !170
  %csum = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 0, i32* %csum, align 8, !tbaa !171
  br label %do.body3

do.body3:                                         ; preds = %do.cond19, %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %and = and i64 %5, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body3
  call void @xs_tcp_read_fraghdr(%struct.rpc_xprt* %1, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end:                                           ; preds = %do.body3
  %tcp_flags4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %6 = load i64, i64* %tcp_flags4, align 8, !tbaa !225
  %and5 = and i64 %6, 4
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  call void @xs_tcp_read_xid(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end8:                                          ; preds = %if.end
  %tcp_flags9 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags9, align 8, !tbaa !225
  %and10 = and i64 %7, 16
  %tobool11 = icmp ne i64 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  call void @xs_tcp_read_calldir(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end13:                                         ; preds = %if.end8
  %tcp_flags14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags14, align 8, !tbaa !225
  %and15 = and i64 %8, 8
  %tobool16 = icmp ne i64 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end13
  call void @xs_tcp_read_data(%struct.rpc_xprt* %1, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end18:                                         ; preds = %if.end13
  call void @xs_tcp_read_discard(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

do.cond19:                                        ; preds = %if.end18, %if.then17, %if.then12, %if.then7, %if.then
  %count20 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %9 = load i64, i64* %count20, align 8, !tbaa !170
  %tobool21 = icmp ne i64 %9, 0
  br i1 %tobool21, label %do.body3, label %do.end25

do.end25:                                         ; preds = %do.cond19
  %count26 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %10 = load i64, i64* %count26, align 8, !tbaa !170
  %sub = sub i64 %len, %10
  %conv = trunc i64 %sub to i32
  %11 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %11) #7
  ret i32 %conv
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_fraghdr(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tcp_fraghdr = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 3
  %2 = bitcast i32* %tcp_fraghdr to i8*
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %3 = load i32, i32* %tcp_offset, align 4, !tbaa !222
  %idx.ext = zext i32 %3 to i64
  %add.ptr1 = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  %tcp_offset2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %4 = load i32, i32* %tcp_offset2, align 4, !tbaa !222
  %conv = zext i32 %4 to i64
  %sub = sub i64 4, %conv
  %call = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr1, i64 %sub)
  %tcp_offset3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %5 = load i32, i32* %tcp_offset3, align 4, !tbaa !222
  %conv4 = zext i32 %5 to i64
  %add = add i64 %conv4, %call
  %conv5 = trunc i64 %add to i32
  store i32 %conv5, i32* %tcp_offset3, align 4, !tbaa !222
  %cmp = icmp ne i64 %call, %sub
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tcp_fraghdr7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 3
  %6 = load i32, i32* %tcp_fraghdr7, align 8, !tbaa !230
  %call8 = call i32 @__fswab32(i32 %6) #4
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  store i32 %call8, i32* %tcp_reclen, align 8, !tbaa !223
  %tcp_reclen9 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %7 = load i32, i32* %tcp_reclen9, align 8, !tbaa !223
  %and = and i32 %7, -2147483648
  %tobool = icmp ne i32 %and, 0
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %and12 = and i64 %8, -2
  %or = or i64 %8, 1
  %and12.sink = select i1 %tobool, i64 %or, i64 %and12
  store i64 %and12.sink, i64* %tcp_flags, align 8, !tbaa !225
  %tcp_reclen14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %9 = load i32, i32* %tcp_reclen14, align 8, !tbaa !223
  %and15 = and i32 %9, 2147483647
  store i32 %and15, i32* %tcp_reclen14, align 8, !tbaa !223
  %tcp_flags16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %10 = load i64, i64* %tcp_flags16, align 8, !tbaa !225
  %and17 = and i64 %10, -3
  store i64 %and17, i64* %tcp_flags16, align 8, !tbaa !225
  %tcp_offset18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  store i32 0, i32* %tcp_offset18, align 4, !tbaa !222
  %tcp_reclen19 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %11 = load i32, i32* %tcp_reclen19, align 8, !tbaa !223
  %cmp20 = icmp ult i32 %11, 8
  %lnot = xor i1 %cmp20, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  %conv23 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %do.end, label %cleanup.cont

do.end:                                           ; preds = %if.end
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end, %entry, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_xid(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !222
  %conv = zext i32 %0 to i64
  %sub = sub i64 4, %conv
  %tcp_xid = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 4
  %1 = bitcast i32* %tcp_xid to i8*
  %tcp_offset1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %2 = load i32, i32* %tcp_offset1, align 4, !tbaa !222
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %call = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr, i64 %sub)
  %tcp_offset2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %3 = load i32, i32* %tcp_offset2, align 4, !tbaa !222
  %conv3 = zext i32 %3 to i64
  %add = add i64 %conv3, %call
  %conv4 = trunc i64 %add to i32
  store i32 %conv4, i32* %tcp_offset2, align 4, !tbaa !222
  %cmp = icmp ne i64 %call, %sub
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %4 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %and = and i64 %4, -5
  store i64 %and, i64* %tcp_flags, align 8, !tbaa !225
  %tcp_flags6 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags6, align 8, !tbaa !225
  %or = or i64 %5, 16
  store i64 %or, i64* %tcp_flags6, align 8, !tbaa !225
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 8
  store i64 4, i64* %tcp_copied, align 8, !tbaa !224
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_calldir(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !222
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 4
  %conv1 = trunc i64 %sub to i32
  %conv2 = zext i32 %conv1 to i64
  %sub3 = sub i64 4, %conv2
  %tcp_calldir = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 5
  %1 = bitcast i32* %tcp_calldir to i8*
  %idx.ext = zext i32 %conv1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %call = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr, i64 %sub3)
  %tcp_offset4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %2 = load i32, i32* %tcp_offset4, align 4, !tbaa !222
  %conv5 = zext i32 %2 to i64
  %add = add i64 %conv5, %call
  %conv6 = trunc i64 %add to i32
  store i32 %conv6, i32* %tcp_offset4, align 4, !tbaa !222
  %cmp = icmp ne i64 %call, %sub3
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %3 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %and = and i64 %3, -17
  store i64 %and, i64* %tcp_flags, align 8, !tbaa !225
  %tcp_calldir8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 5
  %4 = load i32, i32* %tcp_calldir8, align 8, !tbaa !231
  %call9 = call i32 @__fswab32(i32 %4) #4
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %call9, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call9, 1
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call9, 0
  br i1 %SwitchLeaf, label %sw.bb15, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %tcp_flags10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags10, align 8, !tbaa !225
  %or = or i64 %5, 32
  store i64 %or, i64* %tcp_flags10, align 8, !tbaa !225
  %tcp_flags11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %6 = load i64, i64* %tcp_flags11, align 8, !tbaa !225
  %or12 = or i64 %6, 8
  store i64 %or12, i64* %tcp_flags11, align 8, !tbaa !225
  %tcp_flags13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags13, align 8, !tbaa !225
  %or14 = or i64 %7, 64
  store i64 %or14, i64* %tcp_flags13, align 8, !tbaa !225
  br label %sw.epilog

sw.bb15:                                          ; preds = %LeafBlock
  %tcp_flags16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags16, align 8, !tbaa !225
  %or17 = or i64 %8, 32
  store i64 %or17, i64* %tcp_flags16, align 8, !tbaa !225
  %tcp_flags18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %9 = load i64, i64* %tcp_flags18, align 8, !tbaa !225
  %or19 = or i64 %9, 8
  store i64 %or19, i64* %tcp_flags18, align 8, !tbaa !225
  %tcp_flags20 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %10 = load i64, i64* %tcp_flags20, align 8, !tbaa !225
  %and21 = and i64 %10, -65
  store i64 %and21, i64* %tcp_flags20, align 8, !tbaa !225
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %do.end24

do.end24:                                         ; preds = %NewDefault
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt)
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end24, %sw.bb15, %sw.bb
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %call = call i32 @_xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %and = and i64 %2, -9
  store i64 %and, i64* %tcp_flags, align 8, !tbaa !225
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_discard(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 7
  %0 = load i32, i32* %tcp_reclen, align 8, !tbaa !223
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %1 = load i32, i32* %tcp_offset, align 4, !tbaa !222
  %sub = sub i32 %0, %1
  %conv = zext i32 %sub to i64
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %2 = load i64, i64* %count, align 8, !tbaa !170
  %cmp = icmp ugt i64 %conv, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count2 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %3 = load i64, i64* %count2, align 8, !tbaa !170
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.0 = phi i64 [ %3, %if.then ], [ %conv, %entry ]
  %count3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %4 = load i64, i64* %count3, align 8, !tbaa !170
  %sub4 = sub i64 %4, %len.0
  store i64 %sub4, i64* %count3, align 8, !tbaa !170
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %5 = load i32, i32* %offset, align 8, !tbaa !169
  %conv5 = zext i32 %5 to i64
  %add = add i64 %conv5, %len.0
  %conv6 = trunc i64 %add to i32
  store i32 %conv6, i32* %offset, align 8, !tbaa !169
  %tcp_offset7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %6 = load i32, i32* %tcp_offset7, align 4, !tbaa !222
  %conv8 = zext i32 %6 to i64
  %add9 = add i64 %conv8, %len.0
  %conv10 = trunc i64 %add9 to i32
  store i32 %conv10, i32* %tcp_offset7, align 4, !tbaa !222
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport) #1 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !222
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 7
  %1 = load i32, i32* %tcp_reclen, align 8, !tbaa !223
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %or = or i64 %2, 2
  store i64 %or, i64* %tcp_flags, align 8, !tbaa !225
  %tcp_offset1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  store i32 0, i32* %tcp_offset1, align 4, !tbaa !222
  %tcp_flags2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %3 = load i64, i64* %tcp_flags2, align 8, !tbaa !225
  %and = and i64 %3, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.then
  %tcp_flags4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %4 = load i64, i64* %tcp_flags4, align 8, !tbaa !225
  %and5 = and i64 %4, -9
  store i64 %and5, i64* %tcp_flags4, align 8, !tbaa !225
  %tcp_flags6 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags6, align 8, !tbaa !225
  %or7 = or i64 %5, 4
  store i64 %or7, i64* %tcp_flags6, align 8, !tbaa !225
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 8
  store i64 0, i64* %tcp_copied, align 8, !tbaa !224
  br label %if.end8

if.end8:                                          ; preds = %if.then, %if.then3, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @_xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %call = call i32 @xs_tcp_read_reply(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xs_tcp_read_reply(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_lock(%struct.spinlock* %transport_lock)
  %tcp_xid = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 4
  %2 = load i32, i32* %tcp_xid, align 4, !tbaa !232
  %call = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %xprt, i32 %2)
  %tobool = icmp ne %struct.rpc_rqst* %call, null
  br i1 %tobool, label %if.end, label %do.end3

do.end3:                                          ; preds = %entry
  %transport_lock4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock(%struct.spinlock* %transport_lock4)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @xs_tcp_read_common(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc, %struct.rpc_rqst* %call)
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %3 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %and = and i64 %3, 8
  %tobool5 = icmp ne i64 %and, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call, i32 0, i32 3
  %4 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !164
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %5 = load i64, i64* %tcp_copied, align 8, !tbaa !224
  %conv = trunc i64 %5 to i32
  call void @xprt_complete_rqst(%struct.rpc_task* %4, i32 %conv)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %transport_lock8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 29
  call void @spin_unlock(%struct.spinlock* %transport_lock8)
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %do.end3
  %retval.0 = phi i32 [ 0, %if.end7 ], [ -1, %do.end3 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_common(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc, %struct.rpc_rqst* %req) #0 {
entry:
  %my_desc = alloca %struct.xdr_skb_reader, align 8
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 17
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !225
  %and = and i64 %2, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %cmp = icmp uge i64 4, 64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 0
  %3 = load i8*, i8** %iov_base, align 8, !tbaa !90
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %4 = load i64, i64* %tcp_copied, align 8, !tbaa !224
  %add.ptr2 = getelementptr i8, i8* %3, i64 %4
  %tcp_calldir = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 5
  %5 = bitcast i32* %tcp_calldir to i8*
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %call = call i8* @__memcpy(i8* %add.ptr2, i8* %5, i64 4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr2, i8* %5, i64 4, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then1
  %__ret.0 = phi i8* [ %call, %if.then1 ], [ %add.ptr2, %if.else ]
  %tcp_copied10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %6 = load i64, i64* %tcp_copied10, align 8, !tbaa !224
  %add = add i64 %6, 4
  store i64 %add, i64* %tcp_copied10, align 8, !tbaa !224
  %tcp_flags11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags11, align 8, !tbaa !225
  %and12 = and i64 %7, -33
  store i64 %and12, i64* %tcp_flags11, align 8, !tbaa !225
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %8 = load i64, i64* %count, align 8, !tbaa !170
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %9 = load i32, i32* %tcp_reclen, align 8, !tbaa !223
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %10 = load i32, i32* %tcp_offset, align 4, !tbaa !222
  %sub = sub i32 %9, %10
  %conv = zext i32 %sub to i64
  %cmp14 = icmp ugt i64 %8, %conv
  br i1 %cmp14, label %if.then16, label %if.else39

if.then16:                                        ; preds = %if.end13
  %11 = bitcast %struct.xdr_skb_reader* %my_desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %11) #7
  %tcp_reclen17 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %12 = load i32, i32* %tcp_reclen17, align 8, !tbaa !223
  %tcp_offset18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %13 = load i32, i32* %tcp_offset18, align 4, !tbaa !222
  %sub19 = sub i32 %12, %13
  %conv20 = zext i32 %sub19 to i64
  %cmp23 = icmp uge i64 32, 64
  %14 = bitcast %struct.xdr_skb_reader* %my_desc to i8*
  %15 = bitcast %struct.xdr_skb_reader* %desc to i8*
  br i1 %cmp23, label %if.then25, label %if.else27

if.then25:                                        ; preds = %if.then16
  %call26 = call i8* @__memcpy(i8* %14, i8* %15, i64 32)
  br label %if.end28

if.else27:                                        ; preds = %if.then16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 32, i32 8, i1 false)
  br label %if.end28

if.end28:                                         ; preds = %if.else27, %if.then25
  %__ret22.0 = phi i8* [ %call26, %if.then25 ], [ %14, %if.else27 ]
  %count30 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %my_desc, i32 0, i32 2
  store i64 %conv20, i64* %count30, align 8, !tbaa !170
  %tcp_copied31 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %16 = load i64, i64* %tcp_copied31, align 8, !tbaa !224
  %conv32 = trunc i64 %16 to i32
  %call33 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %rq_private_buf, i32 %conv32, %struct.xdr_skb_reader* %my_desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  %count34 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %17 = load i64, i64* %count34, align 8, !tbaa !170
  %sub35 = sub i64 %17, %call33
  store i64 %sub35, i64* %count34, align 8, !tbaa !170
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %18 = load i32, i32* %offset, align 8, !tbaa !169
  %conv36 = zext i32 %18 to i64
  %add37 = add nsw i64 %conv36, %call33
  %conv38 = trunc i64 %add37 to i32
  store i32 %conv38, i32* %offset, align 8, !tbaa !169
  %19 = bitcast %struct.xdr_skb_reader* %my_desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %19) #7
  br label %if.end43

if.else39:                                        ; preds = %if.end13
  %tcp_copied40 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %20 = load i64, i64* %tcp_copied40, align 8, !tbaa !224
  %conv41 = trunc i64 %20 to i32
  %call42 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %rq_private_buf, i32 %conv41, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  br label %if.end43

if.end43:                                         ; preds = %if.else39, %if.end28
  %len.0 = phi i64 [ %conv20, %if.end28 ], [ %8, %if.else39 ]
  %r.0 = phi i64 [ %call33, %if.end28 ], [ %call42, %if.else39 ]
  %cmp44 = icmp sgt i64 %r.0, 0
  br i1 %cmp44, label %if.then46, label %if.end53

if.then46:                                        ; preds = %if.end43
  %tcp_copied47 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %21 = load i64, i64* %tcp_copied47, align 8, !tbaa !224
  %add48 = add i64 %21, %r.0
  store i64 %add48, i64* %tcp_copied47, align 8, !tbaa !224
  %tcp_offset49 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %22 = load i32, i32* %tcp_offset49, align 4, !tbaa !222
  %conv50 = zext i32 %22 to i64
  %add51 = add nsw i64 %conv50, %r.0
  %conv52 = trunc i64 %add51 to i32
  store i32 %conv52, i32* %tcp_offset49, align 4, !tbaa !222
  br label %if.end53

if.end53:                                         ; preds = %if.then46, %if.end43
  %cmp54 = icmp ne i64 %r.0, %len.0
  br i1 %cmp54, label %if.then56, label %do.end68

if.then56:                                        ; preds = %if.end53
  %tcp_flags57 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %23 = load i64, i64* %tcp_flags57, align 8, !tbaa !225
  %and58 = and i64 %23, -9
  store i64 %and58, i64* %tcp_flags57, align 8, !tbaa !225
  br label %cleanup.cont

do.end68:                                         ; preds = %if.end53
  %tcp_copied69 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %24 = load i64, i64* %tcp_copied69, align 8, !tbaa !224
  %rq_private_buf70 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 17
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf70, i32 0, i32 6
  %25 = load i32, i32* %buflen, align 4, !tbaa !165
  %conv71 = zext i32 %25 to i64
  %cmp72 = icmp eq i64 %24, %conv71
  br i1 %cmp72, label %if.then74, label %if.else77

if.then74:                                        ; preds = %do.end68
  %tcp_flags75 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %26 = load i64, i64* %tcp_flags75, align 8, !tbaa !225
  %and76 = and i64 %26, -9
  store i64 %and76, i64* %tcp_flags75, align 8, !tbaa !225
  br label %cleanup.cont

if.else77:                                        ; preds = %do.end68
  %tcp_offset78 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %27 = load i32, i32* %tcp_offset78, align 4, !tbaa !222
  %tcp_reclen79 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %28 = load i32, i32* %tcp_reclen79, align 8, !tbaa !223
  %cmp80 = icmp eq i32 %27, %28
  br i1 %cmp80, label %if.then82, label %cleanup.cont

if.then82:                                        ; preds = %if.else77
  %tcp_flags83 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %29 = load i64, i64* %tcp_flags83, align 8, !tbaa !225
  %and84 = and i64 %29, 1
  %tobool85 = icmp ne i64 %and84, 0
  br i1 %tobool85, label %if.then86, label %cleanup.cont

if.then86:                                        ; preds = %if.then82
  %tcp_flags87 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %30 = load i64, i64* %tcp_flags87, align 8, !tbaa !225
  %and88 = and i64 %30, -9
  store i64 %and88, i64* %tcp_flags87, align 8, !tbaa !225
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then56, %if.else77, %if.then86, %if.then82, %if.then74
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_test_and_set_connected(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 1, i64* %state)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_schedule_linger_timeout(%struct.rpc_xprt* %xprt, i64 %timeout) #1 {
entry:
  %call = call i32 @xprt_test_and_set_connecting(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @set_bit(i32 7, i64* %state)
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = load %struct.workqueue_struct*, %struct.workqueue_struct** @rpciod_workqueue, align 8, !tbaa !47
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call1 = call zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %2, %struct.delayed_work* %connect_worker, i64 %timeout)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_cancel_linger_timeout(%struct.rpc_xprt* %xprt) #1 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @constant_test_bit(i32 7, i64* %state)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false, label %cleanup.cont

lor.lhs.false:                                    ; preds = %entry
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call4 = call zeroext i1 @cancel_delayed_work(%struct.delayed_work* %connect_worker)
  br i1 %call4, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %lor.lhs.false
  %state5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i32 7, i64* %state5)
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %lor.lhs.false, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_sock_mark_closed(%struct.rpc_xprt* %xprt) #1 {
entry:
  call void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt)
  call void @xprt_disconnect_done(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_test_and_set_connecting(%struct.rpc_xprt* %xprt) #0 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call i32 @test_and_set_bit(i32 2, i64* %state)
  ret i32 %call
}

declare zeroext i1 @cancel_delayed_work(%struct.delayed_work*) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_wspace(%struct.sock* %sk) #0 {
entry:
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 17
  %0 = load i32, i32* %sk_sndbuf, align 4, !tbaa !175
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 20
  %1 = load i32, i32* %sk_wmem_queued, align 4, !tbaa !233
  %sub = sub nsw i32 %0, %1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_min_wspace(%struct.sock* %sk) #0 {
entry:
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 20
  %0 = load i32, i32* %sk_wmem_queued, align 4, !tbaa !233
  %shr = ashr i32 %0, 1
  ret i32 %shr
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__clear_bit(i32 %nr, i64* %addr) #0 {
entry:
  call void asm sideeffect "btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #7, !srcloc !234
  ret void
}

declare void @xprt_force_disconnect(%struct.rpc_xprt*) #2

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_bc_tcp(%struct.xprt_create* %args) #1 {
entry:
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !12
  %bc_xprt = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %1 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !235
  %xpt_bc_xprt = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %1, i32 0, i32 19
  %2 = load %struct.rpc_xprt*, %struct.rpc_xprt** %xpt_bc_xprt, align 8, !tbaa !236
  %tobool = icmp ne %struct.rpc_xprt* %2, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %bc_xprt1 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %3 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt1, align 8, !tbaa !235
  %xpt_bc_xprt2 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %3, i32 0, i32 19
  %4 = load %struct.rpc_xprt*, %struct.rpc_xprt** %xpt_bc_xprt2, align 8, !tbaa !236
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !16
  %6 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !16
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %5, i32 %6)
  %7 = bitcast %struct.rpc_xprt* %call to i8*
  %call3 = call i64 @IS_ERR(i8* %7)
  %tobool4 = icmp ne i64 %call3, 0
  br i1 %tobool4, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %8 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 0
  %9 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 6, i32* %prot, align 8, !tbaa !17
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !31
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !32
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_tcp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !37
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 22
  store i64 0, i64* %bind_timeout, align 8, !tbaa !33
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !34
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 28
  store i64 0, i64* %idle_timeout, align 8, !tbaa !35
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @bc_tcp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !36
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %10 = load i16, i16* %sa_family, align 2, !tbaa !45
  %conv = zext i16 %10 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end6
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb7, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0))
  br label %do.end

sw.bb7:                                           ; preds = %LeafBlock1
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %sw.bb, %sw.bb7
  %call9 = call %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt* %call)
  %bc_xprt10 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %11 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt10, align 8, !tbaa !235
  %xpt_bc_xprt11 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %11, i32 0, i32 19
  store %struct.rpc_xprt* %call, %struct.rpc_xprt** %xpt_bc_xprt11, align 8, !tbaa !236
  %bc_xprt12 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %12 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt12, align 8, !tbaa !235
  %bc_xprt13 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 33
  store %struct.svc_xprt* %12, %struct.svc_xprt** %bc_xprt13, align 8, !tbaa !239
  %bc_xprt15 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %13 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt15, align 8, !tbaa !235
  %14 = bitcast %struct.svc_xprt* %13 to i8*
  %add.ptr17 = getelementptr inbounds i8, i8* %14, i64 0
  %15 = bitcast i8* %add.ptr17 to %struct.svc_sock*
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %15, i32 0, i32 1
  %16 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !240
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %9, i32 0, i32 1
  store %struct.socket* %16, %struct.socket** %sock, align 8, !tbaa !93
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %15, i32 0, i32 2
  %17 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !242
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %9, i32 0, i32 2
  store %struct.sock* %17, %struct.sock** %inet, align 8, !tbaa !117
  call void @xprt_set_connected(%struct.rpc_xprt* %call)
  %call18 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call18, label %cleanup, label %if.end20

if.end20:                                         ; preds = %do.end
  call void @xprt_put(%struct.rpc_xprt* %call)
  br label %out_err

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out_err

out_err:                                          ; preds = %NewDefault, %if.end20
  %.sink = phi i64 [ -22, %if.end20 ], [ -97, %NewDefault ]
  %call21 = call i8* @ERR_PTR(i64 %.sink)
  %18 = bitcast i8* %call21 to %struct.rpc_xprt*
  call void @xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end, %out_err, %if.then
  %retval.0 = phi %struct.rpc_xprt* [ %4, %if.then ], [ %18, %out_err ], [ %call, %if.end ], [ %call, %do.end ]
  ret %struct.rpc_xprt* %retval.0
}

declare %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt*) #2

declare void @xprt_put(%struct.rpc_xprt*) #2

; Function Attrs: nounwind uwtable
define internal i8* @bc_malloc(%struct.rpc_task* %task, i64 %size) #1 {
entry:
  %cmp = icmp ugt i64 %size, 4088
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  %lnot2 = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot2, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext5 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end33

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @bc_malloc.__warned, align 1, !tbaa !243, !range !245
  %tobool7 = trunc i8 %0 to i1
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %tobool14 = icmp ne i32 %lnot.ext13, 0
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.then22, label %if.end

if.then22:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.5, i32 0, i32 0), i32 2365)
  br label %if.end

if.end:                                           ; preds = %if.then22, %if.then
  %tobool23 = icmp ne i32 %lnot.ext13, 0
  %lnot24 = xor i1 %tobool23, true
  %lnot26 = xor i1 %lnot24, true
  %lnot.ext27 = zext i1 %lnot26 to i32
  %conv28 = sext i32 %lnot.ext27 to i64
  %expval29 = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool30 = icmp ne i64 %expval29, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end
  store i8 1, i8* @bc_malloc.__warned, align 1, !tbaa !243
  br label %if.end33

if.end33:                                         ; preds = %if.end, %if.then31, %entry
  %tobool35 = icmp ne i32 %lnot.ext, 0
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot.ext39 = zext i1 %lnot38 to i32
  %conv40 = sext i32 %lnot.ext39 to i64
  %expval41 = call i64 @llvm.expect.i64(i64 %conv40, i64 0)
  %cmp42 = icmp ugt i64 %size, 4088
  br i1 %cmp42, label %cleanup, label %if.end45

if.end45:                                         ; preds = %if.end33
  %call = call %struct.page* @alloc_pages(i32 208, i32 0)
  %tobool46 = icmp ne %struct.page* %call, null
  br i1 %tobool46, label %if.end48, label %cleanup

if.end48:                                         ; preds = %if.end45
  %call49 = call i8* @lowmem_page_address(%struct.page* %call)
  %1 = bitcast i8* %call49 to %struct.rpc_buffer*
  %len = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %1, i32 0, i32 0
  store i64 4096, i64* %len, align 8, !tbaa !99
  %data = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end45, %if.end33, %if.end48
  %retval.0 = phi i8* [ %arraydecay, %if.end48 ], [ null, %if.end33 ], [ null, %if.end45 ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bc_free(i8* %buffer) #1 {
entry:
  %tobool = icmp ne i8* %buffer, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %0 = bitcast i8* %buffer to [0 x i8]*
  %1 = bitcast [0 x i8]* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 -8
  %2 = bitcast i8* %add.ptr to %struct.rpc_buffer*
  %3 = ptrtoint %struct.rpc_buffer* %2 to i64
  call void @free_pages(i64 %3, i32 0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bc_send_request(%struct.rpc_task* %task) #1 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 3
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !80
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !89
  %bc_xprt = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 33
  %2 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !239
  %xpt_mutex = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 8
  %call = call i32 @mutex_trylock(%struct.mutex* %xpt_mutex)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.true, label %if.then

if.then:                                          ; preds = %entry
  %xpt_bc_pending = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 16
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %xpt_bc_pending, %struct.rpc_task* %task, void (%struct.rpc_task*)* null)
  %xpt_mutex1 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 8
  %call2 = call i32 @mutex_trylock(%struct.mutex* %xpt_mutex1)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end, label %cleanup

if.end:                                           ; preds = %if.then
  %xpt_bc_pending5 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 16
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %xpt_bc_pending5, %struct.rpc_task* %task)
  br label %cond.true

cond.true:                                        ; preds = %entry, %if.end
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 5
  %call7 = call i32 @constant_test_bit(i32 6, i64* %xpt_flags)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end14, label %if.else

if.else:                                          ; preds = %cond.true
  %call13 = call i32 @bc_sendto(%struct.rpc_rqst* %0)
  br label %if.end14

if.end14:                                         ; preds = %cond.true, %if.else
  %len.0 = phi i32 [ %call13, %if.else ], [ -107, %cond.true ]
  %xpt_mutex15 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 8
  call void @mutex_unlock(%struct.mutex* %xpt_mutex15)
  %cmp = icmp ugt i32 %len.0, 0
  %.len.0 = select i1 %cmp, i32 0, i32 %len.0
  br label %cleanup

cleanup:                                          ; preds = %if.then, %if.end14
  %retval.0 = phi i32 [ %.len.0, %if.end14 ], [ -11, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bc_close(%struct.rpc_xprt* %xprt) #1 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @bc_destroy(%struct.rpc_xprt* %xprt) #1 {
entry:
  ret void
}

declare void @warn_slowpath_null(i8*, i32) #2

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @alloc_pages(i32 %gfp_mask, i32 %order) #0 {
entry:
  %call = call %struct.page* @alloc_pages_current(i32 %gfp_mask, i32 %order)
  ret %struct.page* %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @lowmem_page_address(%struct.page* %page) #5 {
entry:
  %sub.ptr.lhs.cast = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, -24189255811072
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 64
  %shl = shl i64 %sub.ptr.div, 12
  %add = add i64 %shl, -131941395333120
  %0 = inttoptr i64 %add to i8*
  ret i8* %0
}

declare %struct.page* @alloc_pages_current(i32, i32) #2

declare void @free_pages(i64, i32) #2

declare i32 @mutex_trylock(%struct.mutex*) #2

declare void @rpc_sleep_on(%struct.rpc_wait_queue*, %struct.rpc_task*, void (%struct.rpc_task*)*) #2

declare void @rpc_wake_up_queued_task(%struct.rpc_wait_queue*, %struct.rpc_task*) #2

; Function Attrs: nounwind uwtable
define internal i32 @bc_sendto(%struct.rpc_rqst* %req) #1 {
entry:
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 1
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %0 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !89
  %1 = bitcast %struct.rpc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %2, i32 0, i32 1
  %3 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !93
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf)
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !90
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, 4095
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_base3 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx2, i32 0, i32 0
  %6 = load i8*, i8** %iov_base3, align 8, !tbaa !90
  %7 = ptrtoint i8* %6 to i64
  %and4 = and i64 %7, 4095
  %head5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head5, i64 0, i64 0
  %iov_base7 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx6, i32 0, i32 0
  %8 = load i8*, i8** %iov_base7, align 8, !tbaa !90
  %9 = ptrtoint i8* %8 to i64
  %call = call i64 @__phys_addr_nodebug(i64 %9)
  %shr = lshr i64 %call, 12
  %add.ptr8 = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %tail9 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx10 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail9, i64 0, i64 0
  %iov_base11 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx10, i32 0, i32 0
  %10 = load i8*, i8** %iov_base11, align 8, !tbaa !90
  %11 = bitcast i8* %10 to %struct.page*
  %call12 = call i32 @svc_send_common(%struct.socket* %3, %struct.xdr_buf* %rq_snd_buf, %struct.page* %add.ptr8, i64 %and4, %struct.page* %11, i64 %and)
  %len13 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  %12 = load i32, i32* %len13, align 8, !tbaa !115
  %cmp = icmp ne i32 %call12, %12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call14 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.16, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.0 = phi i32 [ -11, %if.then ], [ %call12, %entry ]
  ret i32 %len.0
}

declare void @mutex_unlock(%struct.mutex*) #2

declare i32 @svc_send_common(%struct.socket*, %struct.xdr_buf*, %struct.page*, i64, %struct.page*, i64) #2

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @__phys_addr_nodebug(i64 %x) #0 {
entry:
  %sub = sub i64 %x, -2147483648
  %cmp = icmp ugt i64 %x, %sub
  %0 = load i64, i64* @phys_base, align 8
  %cond = select i1 %cmp, i64 %0, i64 131939247849472
  %add = add i64 %sub, %cond
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define internal i32 @param_set_portnr(i8* %val, %struct.kernel_param* %kp) #1 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 1, i32 65535)
  ret i32 %call
}

declare i32 @param_get_uint(i8*, %struct.kernel_param*) #2

; Function Attrs: nounwind uwtable
define internal i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 %min, i32 %max) #1 {
entry:
  %num = alloca i64, align 8
  %0 = bitcast i64* %num to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %tobool = icmp ne i8* %val, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtoul(i8* %val, i32 0, i64* %num)
  %cmp = icmp eq i32 %call, -22
  br i1 %cmp, label %cleanup, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %1 = load i64, i64* %num, align 8, !tbaa !99
  %conv = zext i32 %min to i64
  %cmp1 = icmp ult i64 %1, %conv
  br i1 %cmp1, label %cleanup, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %2 = load i64, i64* %num, align 8, !tbaa !99
  %conv4 = zext i32 %max to i64
  %cmp5 = icmp ugt i64 %2, %conv4
  br i1 %cmp5, label %cleanup, label %if.end8

if.end8:                                          ; preds = %lor.lhs.false3
  %3 = load i64, i64* %num, align 8, !tbaa !99
  %conv9 = trunc i64 %3 to i32
  %4 = getelementptr inbounds %struct.kernel_param, %struct.kernel_param* %kp, i32 0, i32 4
  %arg = bitcast %union.anon.5* %4 to i8**
  %5 = load i8*, i8** %arg, align 8, !tbaa !40
  %6 = bitcast i8* %5 to i32*
  store i32 %conv9, i32* %6, align 4, !tbaa !16
  br label %cleanup

cleanup:                                          ; preds = %if.end, %lor.lhs.false, %lor.lhs.false3, %entry, %if.end8
  %retval.0 = phi i32 [ 0, %if.end8 ], [ -22, %entry ], [ -22, %lor.lhs.false3 ], [ -22, %lor.lhs.false ], [ -22, %if.end ]
  %7 = bitcast i64* %num to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @kstrtoul(i8* %s, i32 %base, i64* %res) #0 {
entry:
  %call = call i32 @kstrtoull(i8* %s, i32 %base, i64* %res)
  ret i32 %call
}

declare i32 @kstrtoull(i8*, i32, i64*) #2

; Function Attrs: nounwind uwtable
define internal i32 @param_set_slot_table_size(i8* %val, %struct.kernel_param* %kp) #1 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 2, i32 65536)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @param_set_max_slot_table_size(i8* %val, %struct.kernel_param* %kp) #1 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 2, i32 65536)
  ret i32 %call
}

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind readnone }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !4, i64 24}
!13 = !{!"xprt_create", !14, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !15, i64 32, !4, i64 40, !4, i64 48, !14, i64 56}
!14 = !{!"int", !5, i64 0}
!15 = !{!"long", !5, i64 0}
!16 = !{!14, !14, i64 0}
!17 = !{!18, !14, i64 160}
!18 = !{!"rpc_xprt", !19, i64 0, !4, i64 8, !4, i64 16, !20, i64 24, !15, i64 152, !14, i64 160, !15, i64 168, !15, i64 176, !15, i64 184, !14, i64 192, !22, i64 200, !22, i64 400, !22, i64 600, !22, i64 800, !26, i64 1000, !14, i64 1016, !14, i64 1020, !19, i64 1024, !15, i64 1032, !5, i64 1040, !14, i64 1044, !14, i64 1048, !15, i64 1056, !15, i64 1064, !14, i64 1072, !27, i64 1080, !25, i64 1112, !15, i64 1192, !15, i64 1200, !23, i64 1208, !23, i64 1210, !14, i64 1212, !4, i64 1216, !4, i64 1224, !26, i64 1232, !29, i64 1248, !4, i64 1344, !4, i64 1352, !5, i64 1360}
!19 = !{!"", !14, i64 0}
!20 = !{!"__kernel_sockaddr_storage", !21, i64 0, !5, i64 2}
!21 = !{!"short", !5, i64 0}
!22 = !{!"rpc_wait_queue", !23, i64 0, !5, i64 8, !14, i64 72, !5, i64 76, !5, i64 77, !5, i64 78, !21, i64 80, !24, i64 88, !4, i64 192}
!23 = !{!"spinlock", !5, i64 0}
!24 = !{!"rpc_timer", !25, i64 0, !26, i64 80, !15, i64 96}
!25 = !{!"timer_list", !26, i64 0, !15, i64 16, !4, i64 24, !4, i64 32, !15, i64 40, !14, i64 48, !14, i64 52, !4, i64 56, !5, i64 64}
!26 = !{!"list_head", !4, i64 0, !4, i64 8}
!27 = !{!"work_struct", !28, i64 0, !26, i64 8, !4, i64 24}
!28 = !{!"", !15, i64 0}
!29 = !{!"", !15, i64 0, !15, i64 8, !15, i64 16, !15, i64 24, !15, i64 32, !15, i64 40, !15, i64 48, !15, i64 56, !30, i64 64, !30, i64 72, !30, i64 80, !30, i64 88}
!30 = !{!"long long", !5, i64 0}
!31 = !{!18, !14, i64 192}
!32 = !{!18, !15, i64 184}
!33 = !{!18, !15, i64 1056}
!34 = !{!18, !15, i64 1064}
!35 = !{!18, !15, i64 1200}
!36 = !{!18, !4, i64 8}
!37 = !{!18, !4, i64 16}
!38 = !{!39, !21, i64 0}
!39 = !{!"sockaddr_un", !21, i64 0, !5, i64 2}
!40 = !{!5, !5, i64 0}
!41 = !{!13, !15, i64 32}
!42 = !{!13, !4, i64 8}
!43 = !{!18, !15, i64 152}
!44 = !{!13, !4, i64 16}
!45 = !{!46, !21, i64 0}
!46 = !{!"sockaddr", !21, i64 0, !5, i64 2}
!47 = !{!4, !4, i64 0}
!48 = !{!49, !14, i64 20}
!49 = !{!"task_struct", !15, i64 0, !4, i64 8, !19, i64 16, !14, i64 20, !14, i64 24, !50, i64 32, !14, i64 40, !14, i64 44, !14, i64 48, !14, i64 52, !14, i64 56, !14, i64 60, !4, i64 64, !51, i64 72, !56, i64 448, !4, i64 496, !5, i64 504, !14, i64 508, !14, i64 512, !14, i64 516, !57, i64 520, !58, i64 528, !26, i64 560, !59, i64 576, !4, i64 616, !4, i64 624, !60, i64 632, !14, i64 648, !14, i64 652, !14, i64 656, !14, i64 660, !14, i64 664, !14, i64 668, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 672, !14, i64 676, !14, i64 680, !4, i64 688, !4, i64 696, !26, i64 704, !26, i64 720, !4, i64 736, !26, i64 744, !26, i64 760, !5, i64 776, !26, i64 848, !4, i64 864, !4, i64 872, !4, i64 880, !15, i64 888, !15, i64 896, !15, i64 904, !15, i64 912, !15, i64 920, !61, i64 928, !15, i64 944, !15, i64 952, !62, i64 960, !62, i64 976, !15, i64 992, !15, i64 1000, !63, i64 1008, !5, i64 1032, !4, i64 1080, !4, i64 1088, !5, i64 1096, !14, i64 1112, !14, i64 1116, !64, i64 1120, !65, i64 1128, !4, i64 1312, !4, i64 1320, !4, i64 1328, !4, i64 1336, !4, i64 1344, !67, i64 1352, !67, i64 1360, !67, i64 1368, !68, i64 1376, !15, i64 1400, !15, i64 1408, !4, i64 1416, !4, i64 1424, !4, i64 1432, !4, i64 1440, !4, i64 1448, !14, i64 1456, !14, i64 1460, !69, i64 1464, !14, i64 1480, !14, i64 1484, !23, i64 1488, !70, i64 1490, !72, i64 1496, !4, i64 1512, !4, i64 1520, !4, i64 1528, !4, i64 1536, !4, i64 1544, !4, i64 1552, !4, i64 1560, !15, i64 1568, !4, i64 1576, !73, i64 1584, !30, i64 1640, !30, i64 1648, !15, i64 1656, !67, i64 1664, !74, i64 1672, !14, i64 1676, !14, i64 1680, !4, i64 1688, !26, i64 1696, !4, i64 1712, !4, i64 1720, !26, i64 1728, !4, i64 1744, !5, i64 1752, !75, i64 1768, !26, i64 1808, !4, i64 1824, !21, i64 1832, !21, i64 1834, !76, i64 1840, !4, i64 1856, !77, i64 1864, !4, i64 1880, !14, i64 1888, !14, i64 1892, !15, i64 1896, !15, i64 1904, !15, i64 1912, !15, i64 1920, !15, i64 1928, !19, i64 1936}
!50 = !{!"llist_node", !4, i64 0}
!51 = !{!"sched_entity", !52, i64 0, !53, i64 16, !26, i64 40, !14, i64 56, !30, i64 64, !30, i64 72, !30, i64 80, !30, i64 88, !30, i64 96, !54, i64 104, !4, i64 320, !4, i64 328, !4, i64 336, !55, i64 344}
!52 = !{!"load_weight", !15, i64 0, !15, i64 8}
!53 = !{!"rb_node", !15, i64 0, !4, i64 8, !4, i64 16}
!54 = !{!"sched_statistics", !30, i64 0, !30, i64 8, !30, i64 16, !30, i64 24, !30, i64 32, !30, i64 40, !30, i64 48, !30, i64 56, !30, i64 64, !30, i64 72, !30, i64 80, !30, i64 88, !30, i64 96, !30, i64 104, !30, i64 112, !30, i64 120, !30, i64 128, !30, i64 136, !30, i64 144, !30, i64 152, !30, i64 160, !30, i64 168, !30, i64 176, !30, i64 184, !30, i64 192, !30, i64 200, !30, i64 208}
!55 = !{!"sched_avg", !14, i64 0, !14, i64 4, !30, i64 8, !30, i64 16, !15, i64 24}
!56 = !{!"sched_rt_entity", !26, i64 0, !15, i64 16, !15, i64 24, !14, i64 32, !4, i64 40}
!57 = !{!"cpumask", !5, i64 0}
!58 = !{!"sched_info", !15, i64 0, !30, i64 8, !30, i64 16, !30, i64 24}
!59 = !{!"plist_node", !14, i64 0, !26, i64 8, !26, i64 24}
!60 = !{!"task_rss_stat", !14, i64 0, !5, i64 4}
!61 = !{!"cputime", !15, i64 0, !15, i64 8}
!62 = !{!"timespec", !15, i64 0, !15, i64 8}
!63 = !{!"task_cputime", !15, i64 0, !15, i64 8, !30, i64 16}
!64 = !{!"sysv_sem", !4, i64 0}
!65 = !{!"thread_struct", !5, i64 0, !15, i64 24, !15, i64 32, !15, i64 40, !21, i64 48, !21, i64 50, !21, i64 52, !21, i64 54, !15, i64 56, !15, i64 64, !5, i64 72, !15, i64 104, !15, i64 112, !15, i64 120, !15, i64 128, !15, i64 136, !66, i64 144, !4, i64 160, !15, i64 168, !14, i64 176}
!66 = !{!"fpu", !14, i64 0, !14, i64 4, !4, i64 8}
!67 = !{!"", !5, i64 0}
!68 = !{!"sigpending", !26, i64 0, !67, i64 16}
!69 = !{!"seccomp", !14, i64 0, !4, i64 8}
!70 = !{!"raw_spinlock", !71, i64 0}
!71 = !{!"arch_spinlock", !5, i64 0}
!72 = !{!"plist_head", !26, i64 0}
!73 = !{!"task_io_accounting", !30, i64 0, !30, i64 8, !30, i64 16, !30, i64 24, !30, i64 32, !30, i64 40, !30, i64 48}
!74 = !{!"seqcount", !14, i64 0}
!75 = !{!"mutex", !19, i64 0, !23, i64 4, !26, i64 8, !4, i64 24, !4, i64 32}
!76 = !{!"callback_head", !4, i64 0, !4, i64 8}
!77 = !{!"page_frag", !4, i64 0, !14, i64 8, !14, i64 12}
!78 = !{!18, !4, i64 1344}
!79 = !{!18, !4, i64 1216}
!80 = !{!81, !4, i64 32}
!81 = !{!"rpc_task", !19, i64 0, !26, i64 8, !4, i64 24, !4, i64 32, !82, i64 40, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !15, i64 104, !15, i64 112, !4, i64 120, !4, i64 128, !5, i64 136, !5, i64 192, !14, i64 200, !14, i64 204, !21, i64 208, !21, i64 210, !5, i64 212, !5, i64 212, !5, i64 212, !5, i64 212}
!82 = !{!"rpc_message", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24}
!83 = !{!84, !14, i64 336}
!84 = !{!"rpc_rqst", !4, i64 0, !85, i64 8, !85, i64 72, !4, i64 136, !4, i64 144, !14, i64 152, !14, i64 156, !14, i64 160, !14, i64 164, !4, i64 168, !4, i64 176, !26, i64 184, !4, i64 200, !15, i64 208, !15, i64 216, !15, i64 224, !15, i64 232, !85, i64 240, !15, i64 304, !15, i64 312, !5, i64 320, !14, i64 328, !14, i64 332, !14, i64 336, !5, i64 344, !14, i64 352}
!85 = !{!"xdr_buf", !5, i64 0, !5, i64 16, !4, i64 32, !14, i64 40, !14, i64 44, !14, i64 48, !14, i64 52, !14, i64 56}
!86 = !{!84, !14, i64 64}
!87 = !{!81, !4, i64 24}
!88 = !{!81, !21, i64 208}
!89 = !{!84, !4, i64 0}
!90 = !{!91, !4, i64 0}
!91 = !{!"kvec", !4, i64 0, !15, i64 8}
!92 = !{!91, !15, i64 8}
!93 = !{!94, !4, i64 1408}
!94 = !{!"sock_xprt", !18, i64 0, !4, i64 1408, !4, i64 1416, !14, i64 1424, !14, i64 1428, !14, i64 1432, !14, i64 1436, !14, i64 1440, !15, i64 1448, !15, i64 1456, !95, i64 1464, !20, i64 1592, !21, i64 1720, !15, i64 1728, !15, i64 1736, !4, i64 1744, !4, i64 1752, !4, i64 1760}
!95 = !{!"delayed_work", !27, i64 0, !25, i64 32, !4, i64 112, !14, i64 120}
!96 = !{!84, !15, i64 224}
!97 = !{i32 -2142633899}
!98 = !{i32 -2142633839}
!99 = !{!15, !15, i64 0}
!100 = !{!18, !15, i64 1192}
!101 = !{!18, !15, i64 1248}
!102 = !{!18, !15, i64 1256}
!103 = !{!18, !15, i64 1272}
!104 = !{!18, !15, i64 1280}
!105 = !{!18, !15, i64 1288}
!106 = !{!18, !15, i64 1296}
!107 = !{!18, !30, i64 1312}
!108 = !{!18, !30, i64 1320}
!109 = !{!18, !15, i64 1304}
!110 = !{!18, !30, i64 1328}
!111 = !{!18, !30, i64 1336}
!112 = !{i32 -2147115246, i32 -2147115207, i32 -2147115186, i32 -2147115149, i32 -2147115126, i32 -2147115256}
!113 = !{i32 -2146367362}
!114 = !{i32 -2146367258}
!115 = !{!85, !14, i64 56}
!116 = !{!85, !14, i64 44}
!117 = !{!94, !4, i64 1416}
!118 = !{!119, !14, i64 556}
!119 = !{!"sock", !120, i64 0, !121, i64 80, !123, i64 112, !124, i64 136, !14, i64 160, !14, i64 164, !19, i64 168, !14, i64 172, !4, i64 176, !4, i64 184, !5, i64 192, !15, i64 208, !4, i64 216, !4, i64 224, !23, i64 232, !19, i64 236, !19, i64 240, !14, i64 244, !123, i64 248, !14, i64 272, !14, i64 272, !14, i64 272, !14, i64 273, !14, i64 274, !14, i64 276, !14, i64 280, !30, i64 288, !30, i64 296, !14, i64 304, !14, i64 308, !21, i64 312, !14, i64 316, !15, i64 320, !123, i64 328, !4, i64 352, !67, i64 360, !14, i64 364, !14, i64 368, !21, i64 372, !21, i64 374, !14, i64 376, !4, i64 384, !4, i64 392, !15, i64 400, !15, i64 408, !4, i64 416, !25, i64 424, !5, i64 504, !4, i64 512, !4, i64 520, !77, i64 528, !4, i64 544, !14, i64 552, !14, i64 556, !4, i64 560, !14, i64 568, !14, i64 572, !4, i64 576, !4, i64 584, !4, i64 592, !4, i64 600, !4, i64 608, !4, i64 616, !4, i64 624}
!120 = !{!"sock_common", !5, i64 0, !5, i64 8, !5, i64 12, !21, i64 16, !5, i64 18, !5, i64 19, !5, i64 19, !14, i64 20, !5, i64 24, !4, i64 40, !4, i64 48, !5, i64 56, !5, i64 56, !14, i64 72, !19, i64 76, !5, i64 80}
!121 = !{!"", !23, i64 0, !14, i64 4, !122, i64 8}
!122 = !{!"__wait_queue_head", !23, i64 0, !26, i64 8}
!123 = !{!"sk_buff_head", !4, i64 0, !4, i64 8, !14, i64 16, !23, i64 20}
!124 = !{!"", !19, i64 0, !14, i64 4, !4, i64 8, !4, i64 16}
!125 = !{i32 393823}
!126 = !{i32 -2147114538, i32 -2147114499, i32 -2147114478, i32 -2147114441, i32 -2147114418, i32 -2147114548}
!127 = !{!128, !4, i64 0}
!128 = !{!"msghdr", !4, i64 0, !14, i64 8, !4, i64 16, !15, i64 24, !4, i64 32, !15, i64 40, !14, i64 48}
!129 = !{!128, !14, i64 8}
!130 = !{!128, !4, i64 16}
!131 = !{!128, !15, i64 24}
!132 = !{!128, !4, i64 32}
!133 = !{!128, !15, i64 40}
!134 = !{!128, !14, i64 48}
!135 = !{!85, !14, i64 40}
!136 = !{!85, !4, i64 32}
!137 = !{!138, !4, i64 40}
!138 = !{!"socket", !5, i64 0, !21, i64 4, !15, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40}
!139 = !{!140, !4, i64 160}
!140 = !{!"proto_ops", !14, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !4, i64 112, !4, i64 120, !4, i64 128, !4, i64 136, !4, i64 144, !4, i64 152, !4, i64 160, !4, i64 168, !4, i64 176}
!141 = !{i32 324586, i32 324597}
!142 = !{!94, !21, i64 1720}
!143 = !{!119, !4, i64 520}
!144 = !{!94, !4, i64 1744}
!145 = !{!119, !4, i64 592}
!146 = !{!94, !4, i64 1752}
!147 = !{!119, !4, i64 584}
!148 = !{!94, !4, i64 1760}
!149 = !{!119, !4, i64 600}
!150 = !{i32 -2147113325, i32 -2147113286, i32 -2147113265, i32 -2147113228, i32 -2147113205, i32 -2147113335, i32 321335}
!151 = !{!152, !14, i64 4}
!152 = !{!"sockaddr_in", !21, i64 0, !21, i64 2, !153, i64 4, !5, i64 8}
!153 = !{!"in_addr", !14, i64 0}
!154 = !{i32 -2142639563, i32 -2142639538, i32 -2142639268, i32 -2142639471, i32 -2142639440, i32 -2142639410}
!155 = !{!21, !21, i64 0}
!156 = !{i32 -2146889747}
!157 = !{!138, !4, i64 32}
!158 = !{!119, !14, i64 280}
!159 = !{!18, !15, i64 1264}
!160 = !{i32 -2143093347}
!161 = !{i32 -2143093295}
!162 = !{!163, !14, i64 104}
!163 = !{!"sk_buff", !4, i64 0, !4, i64 8, !5, i64 16, !4, i64 24, !4, i64 32, !5, i64 40, !15, i64 88, !4, i64 96, !14, i64 104, !14, i64 108, !21, i64 112, !21, i64 114, !5, i64 116, !14, i64 120, !5, i64 124, !5, i64 124, !5, i64 124, !5, i64 124, !5, i64 124, !5, i64 125, !5, i64 125, !5, i64 125, !5, i64 125, !5, i64 125, !21, i64 126, !4, i64 128, !4, i64 136, !4, i64 144, !14, i64 152, !14, i64 156, !21, i64 160, !21, i64 162, !21, i64 164, !21, i64 166, !21, i64 168, !5, i64 170, !5, i64 170, !5, i64 170, !5, i64 170, !5, i64 170, !5, i64 170, !5, i64 170, !5, i64 171, !5, i64 171, !14, i64 172, !5, i64 176, !14, i64 180, !14, i64 184, !14, i64 188, !14, i64 192, !14, i64 196, !14, i64 200, !14, i64 204, !14, i64 208, !4, i64 216, !4, i64 224, !14, i64 232, !19, i64 236}
!164 = !{!84, !4, i64 136}
!165 = !{!84, !14, i64 292}
!166 = !{!163, !4, i64 224}
!167 = !{!168, !4, i64 0}
!168 = !{!"xdr_skb_reader", !4, i64 0, !14, i64 8, !15, i64 16, !14, i64 24}
!169 = !{!168, !14, i64 8}
!170 = !{!168, !15, i64 16}
!171 = !{!168, !14, i64 24}
!172 = !{!163, !14, i64 108}
!173 = !{i32 -2146588912}
!174 = !{i32 -2146604087}
!175 = !{!119, !14, i64 244}
!176 = !{!119, !4, i64 512}
!177 = !{i32 -2147112859, i32 -2147112820, i32 -2147112799, i32 -2147112762, i32 -2147112739, i32 -2147112869, i32 322587}
!178 = !{!152, !21, i64 2}
!179 = !{!28, !15, i64 0}
!180 = !{i64 0, i64 8, !99}
!181 = !{!27, !4, i64 24}
!182 = !{!25, !4, i64 32}
!183 = !{!25, !15, i64 40}
!184 = !{!185, !21, i64 2}
!185 = !{!"sockaddr_in6", !21, i64 0, !21, i64 2, !14, i64 4, !186, i64 8, !14, i64 24}
!186 = !{!"in6_addr", !5, i64 0}
!187 = !{!26, !4, i64 0}
!188 = !{!26, !4, i64 8}
!189 = !{!94, !15, i64 1736}
!190 = !{!94, !15, i64 1728}
!191 = !{!18, !14, i64 1016}
!192 = !{!119, !14, i64 172}
!193 = !{!94, !15, i64 152}
!194 = !{!20, !21, i64 0}
!195 = !{!119, !21, i64 16}
!196 = !{i32 -2142599788}
!197 = !{i32 -2142564596}
!198 = !{i32 -2142524600}
!199 = !{i32 -2142488982}
!200 = !{!13, !14, i64 56}
!201 = !{!119, !5, i64 18}
!202 = !{!138, !5, i64 0}
!203 = !{!204, !14, i64 1640}
!204 = !{!"tcp_sock", !205, i64 0, !21, i64 1168, !21, i64 1170, !14, i64 1172, !14, i64 1176, !14, i64 1180, !14, i64 1184, !14, i64 1188, !14, i64 1192, !14, i64 1196, !14, i64 1200, !14, i64 1204, !14, i64 1208, !26, i64 1216, !15, i64 1232, !213, i64 1240, !14, i64 1288, !14, i64 1292, !14, i64 1296, !14, i64 1300, !14, i64 1304, !14, i64 1308, !21, i64 1312, !5, i64 1314, !5, i64 1315, !5, i64 1315, !5, i64 1315, !5, i64 1315, !5, i64 1315, !5, i64 1316, !5, i64 1317, !5, i64 1317, !5, i64 1317, !5, i64 1317, !14, i64 1320, !14, i64 1324, !14, i64 1328, !14, i64 1332, !14, i64 1336, !14, i64 1340, !14, i64 1344, !14, i64 1348, !21, i64 1352, !5, i64 1354, !5, i64 1355, !14, i64 1356, !5, i64 1360, !214, i64 1368, !14, i64 1400, !14, i64 1404, !14, i64 1408, !14, i64 1412, !14, i64 1416, !14, i64 1420, !14, i64 1424, !14, i64 1428, !14, i64 1432, !14, i64 1436, !14, i64 1440, !14, i64 1444, !14, i64 1448, !14, i64 1452, !14, i64 1456, !14, i64 1460, !4, i64 1464, !4, i64 1472, !4, i64 1480, !123, i64 1488, !5, i64 1512, !5, i64 1520, !5, i64 1552, !4, i64 1584, !14, i64 1592, !14, i64 1596, !14, i64 1600, !14, i64 1604, !14, i64 1608, !14, i64 1612, !14, i64 1616, !14, i64 1620, !14, i64 1624, !14, i64 1628, !14, i64 1632, !14, i64 1636, !14, i64 1640, !215, i64 1644, !215, i64 1656, !216, i64 1668, !14, i64 1676, !4, i64 1680, !4, i64 1688, !4, i64 1696, !4, i64 1704}
!205 = !{!"inet_connection_sock", !206, i64 0, !210, i64 800, !4, i64 840, !15, i64 848, !25, i64 856, !25, i64 936, !14, i64 1016, !14, i64 1020, !4, i64 1024, !4, i64 1032, !4, i64 1040, !5, i64 1048, !5, i64 1049, !5, i64 1050, !5, i64 1051, !5, i64 1052, !5, i64 1053, !21, i64 1054, !211, i64 1056, !212, i64 1080, !5, i64 1096, !14, i64 1160}
!206 = !{!"inet_sock", !119, i64 0, !4, i64 632, !14, i64 640, !21, i64 644, !21, i64 646, !21, i64 648, !21, i64 650, !4, i64 656, !14, i64 664, !5, i64 668, !5, i64 669, !5, i64 670, !5, i64 671, !5, i64 672, !5, i64 672, !5, i64 672, !5, i64 672, !5, i64 672, !5, i64 672, !5, i64 672, !5, i64 672, !5, i64 673, !14, i64 676, !14, i64 680, !14, i64 684, !4, i64 688, !207, i64 696}
!207 = !{!"inet_cork_full", !208, i64 0, !209, i64 40}
!208 = !{!"inet_cork", !14, i64 0, !14, i64 4, !4, i64 8, !14, i64 16, !14, i64 20, !4, i64 24, !5, i64 32}
!209 = !{!"flowi", !5, i64 0}
!210 = !{!"request_sock_queue", !4, i64 0, !4, i64 8, !67, i64 16, !5, i64 20, !4, i64 24, !4, i64 32}
!211 = !{!"", !5, i64 0, !5, i64 1, !5, i64 2, !5, i64 3, !14, i64 4, !15, i64 8, !14, i64 16, !21, i64 20, !21, i64 22}
!212 = !{!"", !14, i64 0, !14, i64 4, !14, i64 8, !14, i64 12}
!213 = !{!"", !123, i64 0, !4, i64 24, !4, i64 32, !14, i64 40, !14, i64 44}
!214 = !{!"tcp_options_received", !15, i64 0, !14, i64 8, !14, i64 12, !14, i64 16, !21, i64 20, !21, i64 20, !21, i64 20, !21, i64 20, !21, i64 20, !21, i64 21, !21, i64 21, !5, i64 22, !21, i64 24, !21, i64 26}
!215 = !{!"", !14, i64 0, !14, i64 4, !14, i64 8}
!216 = !{!"", !14, i64 0, !14, i64 4}
!217 = !{!18, !14, i64 1072}
!218 = !{i32 -2142479025}
!219 = !{i32 -2142478961}
!220 = !{!221, !15, i64 8}
!221 = !{!"", !15, i64 0, !15, i64 8, !5, i64 16, !14, i64 24}
!222 = !{!94, !14, i64 1436}
!223 = !{!94, !14, i64 1440}
!224 = !{!94, !15, i64 1448}
!225 = !{!94, !15, i64 1456}
!226 = !{i32 -2142478204}
!227 = !{i32 -2142478148}
!228 = !{i32 -2142478042}
!229 = !{i32 -2142477990}
!230 = !{!94, !14, i64 1424}
!231 = !{!94, !14, i64 1432}
!232 = !{!94, !14, i64 1428}
!233 = !{!119, !14, i64 276}
!234 = !{i32 319297}
!235 = !{!13, !4, i64 48}
!236 = !{!237, !4, i64 648}
!237 = !{!"svc_xprt", !4, i64 0, !4, i64 8, !238, i64 16, !26, i64 24, !26, i64 40, !15, i64 56, !4, i64 64, !19, i64 72, !75, i64 80, !23, i64 120, !4, i64 128, !26, i64 136, !20, i64 152, !15, i64 280, !20, i64 288, !15, i64 416, !22, i64 424, !26, i64 624, !4, i64 640, !4, i64 648}
!238 = !{!"kref", !19, i64 0}
!239 = !{!18, !4, i64 1224}
!240 = !{!241, !4, i64 656}
!241 = !{!"svc_sock", !237, i64 0, !4, i64 656, !4, i64 664, !4, i64 672, !4, i64 680, !4, i64 688, !14, i64 696, !14, i64 700, !14, i64 704, !5, i64 712}
!242 = !{!241, !4, i64 664}
!243 = !{!244, !244, i64 0}
!244 = !{!"_Bool", !5, i64 0}
!245 = !{i8 0, i8 2}
