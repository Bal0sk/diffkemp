; ModuleID = 'net/sunrpc/xprtsock.bc'
source_filename = "net/sunrpc/xprtsock.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.xprt_class = type { %struct.list_head, i32, %struct.rpc_xprt* (%struct.xprt_create*)*, %struct.module*, [32 x i8] }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.rpc_xprt = type { %struct.kref, %struct.rpc_xprt_ops*, %struct.rpc_timeout*, %struct.__kernel_sockaddr_storage, i64, i32, i64, i64, i64, i32, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.rpc_wait_queue, %struct.list_head, i32, i32, %struct.atomic_t, i64, i8, %struct.atomic_t, i32, %struct.list_head, i64, i64, i32, %struct.work_struct, %struct.timer_list, i64, i64, i64, i64, %struct.spinlock, %struct.spinlock, i32, %struct.rpc_task*, %struct.svc_xprt*, %struct.list_head, %struct.anon.86, %struct.net*, i8*, [6 x i8*], %struct.callback_head }
%struct.kref = type { %struct.refcount_struct }
%struct.refcount_struct = type { %struct.atomic_t }
%struct.rpc_xprt_ops = type { void (%struct.rpc_xprt*, i64, i64)*, i32 (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*, i16)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, i32 (%struct.rpc_task*)*, void (%struct.rpc_task*)*, i32 (%struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*, %struct.rpc_task*)*, void (%struct.rpc_task*)*, void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*, i64, i64)*, void (%struct.rpc_xprt*, %struct.seq_file*)*, i32 (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)*, void (%struct.rpc_xprt*)*, i32 (%struct.rpc_xprt*, i32)*, i32 (%struct.svc_serv*, %struct.net*)*, i64 (%struct.rpc_xprt*)*, void (%struct.rpc_rqst*)*, void (%struct.rpc_xprt*, i32)* }
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, %struct.file*, i8* }
%struct.mutex = type { %struct.atomic64_t, %struct.spinlock, %struct.optimistic_spin_queue, %struct.list_head }
%struct.atomic64_t = type { i64 }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.file = type { %union.anon.3, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.3 = type { %struct.callback_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %union.anon.8, %struct.list_head, %struct.list_head, %union.anon.9 }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.4, i8* }
%union.anon.4 = type { i64 }
%struct.lockref = type { %union.anon.6 }
%union.anon.6 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.path*, i1)*, %struct.dentry* (%struct.dentry*, %struct.inode*, i32)*, [24 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.fscrypt_operations*, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, i32, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, %struct.user_namespace*, %struct.list_lru, [56 x i8], %struct.list_lru, %struct.callback_head, %struct.work_struct, %struct.mutex, i32, [36 x i8], %struct.spinlock, %struct.list_head, %struct.spinlock, %struct.list_head, [16 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, %struct.dquot** (%struct.inode*)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, %struct.shrink_control*)*, i64 (%struct.super_block*, %struct.shrink_control*)* }
%struct.writeback_control = type { i64, i64, i64, i64, i32, i8 }
%struct.kstatfs = type opaque
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.101, i32 }
%union.anon.101 = type { %struct.kuid_t }
%struct.kuid_t = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.page = type { i64, %union.anon.1, %union.anon.77, %union.anon.78, %union.anon.82, %union.anon.85, [8 x i8] }
%union.anon.1 = type { %struct.address_space* }
%union.anon.77 = type { i64 }
%union.anon.78 = type { i64 }
%union.anon.82 = type { %struct.list_head }
%union.anon.85 = type { i64 }
%struct.shrink_control = type { i32, i64, i32, %struct.mem_cgroup* }
%struct.mem_cgroup = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)*, i32 (%struct.inode*, %struct.kprojid_t*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.kprojid_t = type { i32 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.qc_info*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.kqid*, %struct.qc_dqblk*)*, i32 (%struct.super_block*, i64, %struct.qc_dqblk*)*, i32 (%struct.super_block*, %struct.qc_state*)*, i32 (%struct.super_block*, i32)* }
%struct.qc_info = type { i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.qc_dqblk = type { i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i64, i64, i64, i64, i32 }
%struct.qc_state = type { i32, [3 x %struct.qc_type_state] }
%struct.qc_type_state = type { i32, i32, i32, i32, i32, i32, i32, i64, i64, i64 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { %struct.atomic64_t, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.raw_spinlock = type { %struct.qspinlock }
%struct.qspinlock = type { %struct.atomic_t }
%struct.task_struct = type { %struct.thread_info, i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, i32, i32, i64, %struct.task_struct*, i32, i32, i32, i32, i32, i32, %struct.sched_class*, [16 x i8], %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, %struct.vmacache, %struct.task_rss_stat, i32, i32, i32, i32, i64, i32, i8, [3 x i8], i8, i64, %struct.restart_block, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, %struct.cred*, [16 x i8], %struct.nameidata*, %struct.sysv_sem, %struct.sysv_shm, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.wake_q_node, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.tlbflush_unmap_batch, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i64, i64, i64, i64, i32, %struct.task_struct*, %struct.vm_struct*, %struct.atomic_t, [28 x i8], %struct.thread_struct }
%struct.thread_info = type { i64 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, [32 x i8], %struct.sched_avg, [24 x i8] }
%struct.load_weight = type { i64, i32 }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i64, i64, i32, i32, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, i16, i16, %struct.sched_rt_entity* }
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, i64, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i8, i8 }
%struct.timerqueue_node = type { %struct.rb_node, i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, i64 ()*, i64, [16 x i8] }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, %struct.seqcount, %struct.hrtimer*, i32, i32, i32, i8, i8, i8, i64, %struct.hrtimer*, i32, i32, i32, i32, [4 x %struct.hrtimer_clock_base] }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.cpumask = type { [1 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.user_namespace*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state, %struct.atomic64_t, %struct.work_struct }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %struct.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy*, %struct.vm_userfaultfd_ctx }
%struct.pgprot = type { i64 }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*, i32)*, void (%struct.vm_fault*, i64, i64)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, %struct.page* (%struct.vm_area_struct*, i64)* }
%struct.vm_fault = type { %struct.vm_area_struct*, i32, i32, i64, i64, %struct.pmd_t*, %struct.pud_t*, %struct.pte_t, %struct.page*, %struct.mem_cgroup*, %struct.page*, %struct.pte_t*, %struct.spinlock*, %struct.page* }
%struct.pmd_t = type { i64 }
%struct.pud_t = type { i64 }
%struct.pte_t = type { i64 }
%struct.vm_userfaultfd_ctx = type {}
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [4 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { %struct.ldt_struct*, i16, %struct.mutex, i8*, %struct.vdso_image*, %struct.atomic_t, i16, i16 }
%struct.ldt_struct = type opaque
%struct.vdso_image = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.vmacache = type { i32, [4 x %struct.vm_area_struct*] }
%struct.task_rss_stat = type { i32, [4 x i32] }
%struct.restart_block = type { i64 (%struct.restart_block*)*, %union.anon.56 }
%union.anon.56 = type { %struct.anon.57 }
%struct.anon.57 = type { i32*, i32, i32, i32, i64, i32* }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.prev_cputime = type { i64, i64, %struct.raw_spinlock }
%struct.task_cputime = type { i64, i64, i64 }
%struct.nameidata = type opaque
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net*, %struct.cgroup_namespace* }
%struct.uts_namespace = type { %struct.kref, %struct.new_utsname, %struct.user_namespace*, %struct.ucounts*, %struct.ns_common }
%struct.new_utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.ucounts = type { %struct.hlist_node, %struct.user_namespace*, %struct.kuid_t, i32, [9 x %struct.atomic_t] }
%struct.ns_common = type { %struct.atomic64_t, %struct.proc_ns_operations*, i32 }
%struct.proc_ns_operations = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.cgroup_namespace = type { %struct.atomic_t, %struct.ns_common, %struct.user_namespace*, %struct.ucounts*, %struct.css_set* }
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, i64, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, %struct.pid*, i32, %struct.tty_struct*, %struct.seqlock_t, i64, i64, i64, i64, i64, i64, %struct.prev_cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, %struct.tty_audit_buf*, i8, i16, i16, %struct.mm_struct*, %struct.mutex }
%struct.cpu_itimer = type { i64, i64 }
%struct.thread_group_cputimer = type { %struct.task_cputime_atomic, i8, i8 }
%struct.task_cputime_atomic = type { %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t }
%struct.tty_struct = type opaque
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.wake_q_node = type { %struct.wake_q_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.60 }
%union.anon.60 = type { %struct.anon.64, [80 x i8] }
%struct.anon.64 = type { i32, i32, i32, i64, i64 }
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.nodemask_t = type { [1 x i64] }
%struct.css_set = type { [4 x %struct.cgroup_subsys_state*], %struct.atomic_t, %struct.cgroup*, %struct.list_head, %struct.list_head, %struct.list_head, [4 x %struct.list_head], %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.cgroup*, %struct.css_set*, i8, %struct.callback_head }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.cgroup_subsys*, %struct.percpu_ref, %struct.cgroup_subsys_state*, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.atomic_t, %struct.callback_head, %struct.work_struct }
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void (%struct.cgroup_taskset*)*, void ()*, i32 (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.task_struct*)*, void (%struct.cgroup_subsys_state*)*, i8, i32, i8*, i8*, %struct.cgroup_root*, %struct.idr, %struct.list_head, %struct.cftype*, %struct.cftype*, i32 }
%struct.cgroup_taskset = type opaque
%struct.cgroup_root = type { %struct.kernfs_root*, i32, i32, %struct.cgroup, i32, %struct.atomic_t, %struct.list_head, i32, %struct.idr, [4096 x i8], [64 x i8] }
%struct.kernfs_root = type { %struct.kernfs_node*, i32, %struct.ida, %struct.kernfs_syscall_ops*, %struct.list_head, %struct.__wait_queue_head }
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.52, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%union.anon.52 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i8, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, %struct.seq_file*, i8*, %struct.mutex, %struct.mutex, i32, %struct.list_head, i8*, i64, i8, %struct.vm_operations_struct* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.ida = type { %struct.radix_tree_root }
%struct.radix_tree_root = type { i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i8, i8, i8, i8, %struct.radix_tree_node*, %struct.radix_tree_root*, %union.anon.2, [64 x i8*], [3 x [1 x i64]] }
%union.anon.2 = type { %struct.list_head }
%struct.kernfs_syscall_ops = type { i32 (%struct.kernfs_root*, i32*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_root*)*, i32 (%struct.kernfs_node*, i8*, i16)*, i32 (%struct.kernfs_node*)*, i32 (%struct.kernfs_node*, %struct.kernfs_node*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_node*, %struct.kernfs_root*)* }
%struct.cgroup = type { %struct.cgroup_subsys_state, i64, i32, i32, i32, %struct.kernfs_node*, %struct.cgroup_file, %struct.cgroup_file, i16, i16, i16, i16, [4 x %struct.cgroup_subsys_state*], %struct.cgroup_root*, %struct.list_head, [4 x %struct.list_head], %struct.list_head, %struct.mutex, %struct.__wait_queue_head, %struct.work_struct, %struct.cgroup_bpf, [0 x i32] }
%struct.cgroup_file = type { %struct.kernfs_node* }
%struct.cgroup_bpf = type {}
%struct.idr = type { %struct.radix_tree_root, i32 }
%struct.cftype = type { [64 x i8], i64, i64, i32, i32, %struct.cgroup_subsys*, %struct.list_head, %struct.kernfs_ops*, i32 (%struct.kernfs_open_file*)*, void (%struct.kernfs_open_file*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)* }
%struct.percpu_ref = type { %struct.atomic64_t, i64, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, i8, %struct.callback_head }
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.mempolicy = type opaque
%struct.tlbflush_unmap_batch = type { %struct.cpumask, i8, i8 }
%struct.pipe_inode_info = type { %struct.mutex, %struct.__wait_queue_head, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.page*, %struct.fasync_struct*, %struct.fasync_struct*, %struct.pipe_buffer*, %struct.user_struct* }
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.pipe_buffer = type { %struct.page*, i32, i32, %struct.pipe_buf_operations*, i32, i64 }
%struct.pipe_buf_operations = type { i32, i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, i32 (%struct.pipe_inode_info*, %struct.pipe_buffer*)*, void (%struct.pipe_inode_info*, %struct.pipe_buffer*)* }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, i64, %struct.atomic64_t, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.key = type { %struct.atomic_t, i32, %union.anon.95, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.96, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.97, %union.anon.99, i32 (%struct.key*, %struct.key_type*, %union.key_payload*)* }
%union.anon.95 = type { %struct.rb_node }
%struct.key_user = type opaque
%union.anon.96 = type { i64 }
%struct.kgid_t = type { i32 }
%union.anon.97 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.99 = type { %union.key_payload }
%union.key_payload = type { [4 x i8*] }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.task_delay_info = type opaque
%struct.vm_struct = type opaque
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i16, i16, i16, i16, i32, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, i64*, i64, i32, %struct.mm_segment_t, i8, [15 x i8], %struct.fpu }
%struct.desc_struct = type { %union.anon.70 }
%union.anon.70 = type { %struct.anon.71 }
%struct.anon.71 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.mm_segment_t = type { i64 }
%struct.fpu = type { i32, i8, i8, [58 x i8], %union.fpregs_state }
%union.fpregs_state = type { %struct.xregs_state, [3520 x i8] }
%struct.xregs_state = type { %struct.fxregs_state, %struct.xstate_header, [0 x i8] }
%struct.fxregs_state = type { i16, i16, i16, i16, %union.anon.73, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.76 }
%union.anon.73 = type { %struct.anon.74 }
%struct.anon.74 = type { i64, i64 }
%union.anon.76 = type { [12 x i32] }
%struct.xstate_header = type { i64, i64, [6 x i64] }
%struct.xattr_handler = type opaque
%struct.fscrypt_operations = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.backing_dev_info*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type { %struct.list_head, i64, i64, i32 (i8*, i32)*, i8*, i8*, %struct.kref, i32, i32, i32, i32, %struct.atomic64_t, %struct.bdi_writeback, %struct.list_head, %struct.bdi_writeback_congested*, %struct.__wait_queue_head, %struct.device*, %struct.device*, %struct.timer_list, %struct.dentry*, %struct.dentry* }
%struct.bdi_writeback = type { %struct.backing_dev_info*, i64, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.spinlock, [4 x %struct.percpu_counter], %struct.bdi_writeback_congested*, i64, i64, i64, i64, i64, i64, i64, %struct.fprop_local_percpu, i32, %struct.spinlock, %struct.list_head, %struct.delayed_work, i64, %struct.list_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.fprop_local_percpu = type { %struct.percpu_counter, i32, %struct.raw_spinlock }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.bdi_writeback_congested = type { i64, %struct.atomic_t }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_links_info, %struct.dev_pm_info, %struct.dev_pm_domain*, %struct.irq_domain*, %struct.list_head, i32, %struct.dma_map_ops*, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.fwnode_handle*, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, %struct.iommu_fwspec*, i8 }
%struct.device_private = type opaque
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type { %struct.sock_common, %struct.socket_lock_t, %struct.atomic_t, i32, %struct.sk_buff_head, %struct.sk_buff_head, %struct.anon.48, i32, i32, i32, i32, %struct.sk_filter*, %union.anon.50, [2 x %struct.xfrm_policy*], %struct.dst_entry*, %struct.dst_entry*, %struct.atomic_t, i32, i32, %struct.atomic_t, i64, %struct.sk_buff*, %struct.sk_buff_head, i32, i32, i32, i64, %struct.timer_list, i32, i32, i32, i32, %struct.page_frag, i64, i64, i32, i32, i32, i32, [0 x i32], i32, i16, i64, %struct.proto*, %struct.rwlock_t, i32, i32, i32, i32, %struct.kuid_t, %struct.pid*, %struct.cred*, i64, i64, i16, i8, i32, %struct.socket*, i8*, i8*, %struct.sock_cgroup_data, %struct.mem_cgroup*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, %struct.sock_reuseport*, %struct.callback_head }
%struct.sock_common = type { %union.anon.10, %union.anon.12, %union.anon.13, i16, i8, i8, i32, %union.anon.15, %struct.proto*, %struct.possible_net_t, %struct.in6_addr, %struct.in6_addr, %struct.atomic64_t, %union.anon.44, [0 x i32], %union.anon.45, i32, %union.anon.46, %struct.atomic_t, [0 x i32], %union.anon.47 }
%union.anon.10 = type { i64 }
%union.anon.12 = type { i32 }
%union.anon.13 = type { i32 }
%union.anon.15 = type { %struct.hlist_node }
%struct.possible_net_t = type { %struct.net* }
%struct.in6_addr = type { %union.anon.38 }
%union.anon.38 = type { [4 x i32] }
%union.anon.44 = type { i64 }
%union.anon.45 = type { %struct.hlist_node }
%union.anon.46 = type { i32 }
%union.anon.47 = type { i32 }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.__wait_queue_head }
%struct.anon.48 = type { %struct.atomic_t, i32, %struct.sk_buff*, %struct.sk_buff* }
%struct.sk_filter = type { %struct.atomic_t, %struct.callback_head, %struct.bpf_prog* }
%struct.bpf_prog = type { i16, i8, i32, i32, [8 x i8], %struct.bpf_prog_aux*, %struct.sock_fprog_kern*, i32 (i8*, %struct.bpf_insn*)*, %union.anon.49 }
%struct.bpf_prog_aux = type opaque
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%struct.bpf_insn = type { i8, i8, i16, i32 }
%union.anon.49 = type { [0 x %struct.sock_filter] }
%union.anon.50 = type { %struct.socket_wq* }
%struct.socket_wq = type { %struct.__wait_queue_head, %struct.fasync_struct*, i64, %struct.callback_head, [8 x i8] }
%struct.xfrm_policy = type opaque
%struct.dst_entry = type { %struct.callback_head, %struct.dst_entry*, %struct.net_device*, %struct.dst_ops*, i64, i64, %struct.dst_entry*, %struct.dst_entry*, %struct.xfrm_state*, i32 (%struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, i16, i16, i16, i16, i16, i16, i32, [2 x i64], %struct.atomic_t, i32, i64, %struct.lwtunnel_state*, %union.anon.43 }
%struct.net_device = type { [16 x i8], %struct.hlist_node, i8*, i64, i64, i64, i32, %struct.atomic_t, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.87, i64, i64, i64, i64, i64, i64, i64, i32, i32, %struct.net_device_stats, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic64_t, %struct.net_device_ops*, %struct.ethtool_ops*, %struct.ndisc_ops*, %struct.header_ops*, i32, i32, i16, i16, i8, i8, i8, i8, i32, i32, i32, i16, i16, i16, i16, i16, [32 x i8], i8, i8, i16, i16, i16, %struct.spinlock, i8, i8, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i32, i32, i8*, %struct.in_device*, %struct.dn_dev*, %struct.inet6_dev*, i8*, %struct.wireless_dev*, %struct.wpan_dev*, i8*, %struct.netdev_rx_queue*, i32, i32, i64, i32 (%struct.sk_buff**)*, i8*, %struct.tcf_proto*, %struct.netdev_queue*, %struct.nf_hook_entry*, [32 x i8], %struct.cpu_rmap*, %struct.hlist_node, [24 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, [16 x %struct.hlist_head], i64, %struct.spinlock, i32, %struct.xps_dev_maps*, %struct.tcf_proto*, %struct.timer_list, i32*, %struct.list_head, %struct.list_head, i8, i8, i16, void (%struct.net_device*)*, %struct.netpoll_info*, %struct.possible_net_t, %union.anon.94, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i16, i8, [16 x %struct.netdev_tc_txq], [16 x i8], %struct.phy_device*, %struct.lock_class_key*, %struct.lock_class_key*, i8, [15 x i8] }
%struct.anon.87 = type { %struct.list_head, %struct.list_head }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.sk_buff*, %struct.net_device*, i64)*, i16 (%struct.net_device*, %struct.sk_buff*, i8*, i16 (%struct.net_device*, %struct.sk_buff*)*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*)*, void (%struct.net_device*, %struct.rtnl_link_stats64*)*, i1 (%struct.net_device*, i32)*, i32 (i32, %struct.net_device*, i8*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8, i16)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_stats*)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i32, i64, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, i16, %struct.tc_to_netdev*)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.net_device*, %struct.net_device*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.net_device*, %struct.neighbour*)*, void (%struct.net_device*, %struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16, i16)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32*)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*, i16)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_item_id*)*, i32 (%struct.net_device*, i8*, i64)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, void (%struct.net_device*, %struct.udp_tunnel_info*)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.sk_buff*, %struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.sk_buff*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.netdev_xdp*)* }
%struct.ifreq = type { %union.anon.88, %union.anon.89 }
%union.anon.88 = type { [16 x i8] }
%union.anon.89 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.neigh_parms = type { %struct.possible_net_t, %struct.net_device*, %struct.list_head, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, %struct.neigh_table*, i8*, i32, %struct.atomic_t, %struct.callback_head, i32, [13 x i32], [1 x i64] }
%struct.neighbour = type { %struct.neighbour*, %struct.neigh_table*, %struct.neigh_parms*, i64, i64, %struct.rwlock_t, %struct.atomic_t, %struct.sk_buff_head, i32, %struct.timer_list, i64, %struct.atomic_t, i8, i8, i8, i8, %struct.seqlock_t, [32 x i8], %struct.hh_cache, i32 (%struct.neighbour*, %struct.sk_buff*)*, %struct.neigh_ops*, %struct.callback_head, %struct.net_device*, [0 x i8] }
%struct.hh_cache = type { i16, i16, %struct.seqlock_t, [12 x i64] }
%struct.neigh_ops = type { i32, void (%struct.neighbour*, %struct.sk_buff*)*, void (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)* }
%struct.neigh_table = type { i32, i32, i32, i16, i32 (i8*, %struct.net_device*, i32*)*, i1 (%struct.neighbour*, i8*)*, i32 (%struct.neighbour*)*, i32 (%struct.pneigh_entry*)*, void (%struct.pneigh_entry*)*, void (%struct.sk_buff*)*, i8*, %struct.neigh_parms, %struct.list_head, i32, i32, i32, i32, i64, %struct.delayed_work, %struct.timer_list, %struct.sk_buff_head, %struct.atomic_t, %struct.rwlock_t, i64, %struct.neigh_statistics*, %struct.neigh_hash_table*, %struct.pneigh_entry** }
%struct.pneigh_entry = type { %struct.pneigh_entry*, %struct.possible_net_t, %struct.net_device*, i8, [0 x i8] }
%struct.neigh_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.neigh_hash_table = type { %struct.neighbour**, i32, [4 x i32], %struct.callback_head }
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32, i32, i32, i16 }
%struct.ifla_vf_stats = type { i64, i64, i64, i64, i64, i64 }
%struct.nlattr = type { i16, i16 }
%struct.tc_to_netdev = type { i32, %union.anon.91, i8 }
%union.anon.91 = type { %struct.tc_cls_u32_offload* }
%struct.tc_cls_u32_offload = type opaque
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.netlink_callback*)*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, i16, i16, i32, i32, [6 x i64] }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%struct.netdev_phys_item_id = type { [32 x i8], i8 }
%struct.udp_tunnel_info = type opaque
%struct.netdev_xdp = type { i32, %union.anon.92 }
%union.anon.92 = type { %struct.bpf_prog* }
%struct.ethtool_ops = type { i32 (%struct.net_device*, %struct.ethtool_cmd*)*, i32 (%struct.net_device*, %struct.ethtool_cmd*)*, void (%struct.net_device*, %struct.ethtool_drvinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, %struct.ethtool_regs*, i8*)*, void (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, void (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_test*, i64*)*, void (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*, i32*)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*)*, i32 (%struct.net_device*, %struct.ethtool_flash*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32*, i8*, i8*)*, i32 (%struct.net_device*, i32*, i8*, i8)*, void (%struct.net_device*, %struct.ethtool_channels*)*, i32 (%struct.net_device*, %struct.ethtool_channels*)*, i32 (%struct.net_device*, %struct.ethtool_dump*)*, i32 (%struct.net_device*, %struct.ethtool_dump*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_dump*)*, i32 (%struct.net_device*, %struct.ethtool_ts_info*)*, i32 (%struct.net_device*, %struct.ethtool_modinfo*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_tunable*, i8*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, i32, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)*, i32 (%struct.net_device*, %struct.ethtool_link_ksettings*)* }
%struct.ethtool_cmd = type { i32, i32, i32, i16, i8, i8, i8, i8, i8, i8, i32, i32, i16, i8, i8, i32, [2 x i32] }
%struct.ethtool_drvinfo = type { i32, [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [12 x i8], i32, i32, i32, i32, i32 }
%struct.ethtool_regs = type { i32, i32, i32, [0 x i8] }
%struct.ethtool_wolinfo = type { i32, i32, i32, [6 x i8] }
%struct.ethtool_coalesce = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_ringparam = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_pauseparam = type { i32, i32, i32, i32 }
%struct.ethtool_test = type { i32, i32, i32, i32, [0 x i64] }
%struct.ethtool_stats = type { i32, i32, [0 x i64] }
%struct.ethtool_rxnfc = type { i32, i32, i64, %struct.ethtool_rx_flow_spec, i32, [0 x i32] }
%struct.ethtool_rx_flow_spec = type { i32, %union.ethtool_flow_union, %struct.ethtool_flow_ext, %union.ethtool_flow_union, %struct.ethtool_flow_ext, i64, i32 }
%union.ethtool_flow_union = type { %struct.ethtool_tcpip6_spec, [12 x i8] }
%struct.ethtool_tcpip6_spec = type { [4 x i32], [4 x i32], i16, i16, i8 }
%struct.ethtool_flow_ext = type { [2 x i8], [6 x i8], i16, i16, [2 x i32] }
%struct.ethtool_flash = type { i32, i32, [128 x i8] }
%struct.ethtool_channels = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_dump = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_ts_info = type { i32, i32, i32, i32, [3 x i32], i32, [3 x i32] }
%struct.ethtool_modinfo = type { i32, i32, i32, [8 x i32] }
%struct.ethtool_eeprom = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_eee = type { i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%struct.ethtool_tunable = type { i32, i32, i32, i32, [0 x i8*] }
%struct.ethtool_link_ksettings = type { %struct.ethtool_link_settings, %struct.anon.93 }
%struct.ethtool_link_settings = type { i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, [8 x i32], [0 x i32] }
%struct.anon.93 = type { [1 x i64], [1 x i64], [1 x i64] }
%struct.ndisc_ops = type { i32 (i8)*, i32 (%struct.net_device*, %struct.nd_opt_hdr*, %struct.ndisc_options*)*, void (%struct.net_device*, %struct.neighbour*, i32, i8, %struct.ndisc_options*)*, i32 (%struct.net_device*, i8, %struct.neighbour*, i8*, i8**)*, void (%struct.net_device*, %struct.sk_buff*, i8, i8*)*, void (%struct.net*, %struct.net_device*, %struct.prefix_info*, %struct.inet6_dev*, %struct.in6_addr*, i32, i32, i1, i1, i32, i32, i1)* }
%struct.nd_opt_hdr = type { i8, i8 }
%struct.ndisc_options = type { [15 x %struct.nd_opt_hdr*], %struct.nd_opt_hdr*, %struct.nd_opt_hdr* }
%struct.prefix_info = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)*, i1 (i8*, i32)* }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32 }
%struct.in_device = type opaque
%struct.dn_dev = type opaque
%struct.inet6_dev = type { %struct.net_device*, %struct.list_head, %struct.ifmcaddr6*, %struct.ifmcaddr6*, %struct.spinlock, i8, i8, i8, i8, i64, i64, i64, i64, %struct.timer_list, %struct.timer_list, %struct.timer_list, %struct.ifacaddr6*, %struct.rwlock_t, %struct.atomic_t, i32, i32, i32, [8 x i8], %struct.list_head, %struct.in6_addr, %struct.neigh_parms*, %struct.ipv6_devconf, %struct.ipv6_devstat, %struct.timer_list, i32, i8, i64, %struct.callback_head }
%struct.ifmcaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.ifmcaddr6*, %struct.ip6_sf_list*, %struct.ip6_sf_list*, i32, i8, [2 x i64], %struct.timer_list, i32, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.ip6_sf_list = type { %struct.ip6_sf_list*, %struct.in6_addr, [2 x i64], i8, i8, i8 }
%struct.ifacaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.rt6_info*, %struct.ifacaddr6*, i32, %struct.atomic_t, i64, i64 }
%struct.rt6_info = type opaque
%struct.ipv6_devconf = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.ipv6_stable_secret, i32, i32, i32, i32, i32, %struct.ctl_table_header* }
%struct.ipv6_stable_secret = type { i8, %struct.in6_addr }
%struct.ctl_table_header = type { %union.anon.31, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node*, %struct.list_head }
%union.anon.31 = type { %struct.anon.32 }
%struct.anon.32 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*)*, void (%struct.ctl_table_header*, %struct.ctl_table*, %struct.kuid_t*, %struct.kgid_t*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.ipv6_devstat = type { %struct.proc_dir_entry*, %struct.ipstats_mib*, %struct.icmpv6_mib_device*, %struct.icmpv6msg_mib_device* }
%struct.proc_dir_entry = type opaque
%struct.ipstats_mib = type { [36 x i64], %struct.u64_stats_sync }
%struct.u64_stats_sync = type {}
%struct.icmpv6_mib_device = type { [6 x %struct.atomic64_t] }
%struct.icmpv6msg_mib_device = type { [512 x %struct.atomic64_t] }
%struct.wireless_dev = type opaque
%struct.wpan_dev = type opaque
%struct.netdev_rx_queue = type { %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8] }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.nf_hook_entry = type opaque
%struct.cpu_rmap = type opaque
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, i64, i64, [16 x i8], %struct.spinlock, i32, i64, i64, [40 x i8], %struct.dql }
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.Qdisc = type { i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, i32, i32, %struct.Qdisc_ops*, %struct.qdisc_size_table*, %struct.hlist_node, i32, i32, i8*, %struct.netdev_queue*, %struct.net_rate_estimator*, %struct.gnet_stats_basic_cpu*, %struct.gnet_stats_queue*, [24 x i8], %struct.sk_buff*, %struct.qdisc_skb_head, %struct.gnet_stats_basic_packed, %struct.seqcount, %struct.gnet_stats_queue, i64, %struct.Qdisc*, %struct.sk_buff*, %struct.callback_head, i32, %struct.atomic_t, [8 x i8], %struct.spinlock, [60 x i8] }
%struct.Qdisc_ops = type { %struct.Qdisc_ops*, %struct.Qdisc_class_ops*, [16 x i8], i32, i32 (%struct.sk_buff*, %struct.Qdisc*, %struct.sk_buff**)*, %struct.sk_buff* (%struct.Qdisc*)*, %struct.sk_buff* (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*)*, void (%struct.Qdisc*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.nlattr*)*, void (%struct.Qdisc*)*, i32 (%struct.Qdisc*, %struct.sk_buff*)*, i32 (%struct.Qdisc*, %struct.gnet_dump*)*, %struct.module* }
%struct.Qdisc_class_ops = type { %struct.netdev_queue* (%struct.Qdisc*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.Qdisc*, %struct.Qdisc**)*, %struct.Qdisc* (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, i64)*, i64 (%struct.Qdisc*, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i32, i32, %struct.nlattr**, i64*)*, i32 (%struct.Qdisc*, i64)*, void (%struct.Qdisc*, %struct.qdisc_walker*)*, %struct.tcf_proto** (%struct.Qdisc*, i64)*, i1 (i32)*, i64 (%struct.Qdisc*, i64, i32)*, void (%struct.Qdisc*, i64)*, i32 (%struct.Qdisc*, i64, %struct.sk_buff*, %struct.tcmsg*)*, i32 (%struct.Qdisc*, i64, %struct.gnet_dump*)* }
%struct.tcmsg = type { i8, i8, i16, i32, i32, i32, i32 }
%struct.qdisc_walker = type opaque
%struct.gnet_dump = type { %struct.spinlock*, %struct.sk_buff*, %struct.nlattr*, i32, i32, i32, i8*, i32, %struct.tc_stats }
%struct.tc_stats = type { i64, i32, i32, i32, i32, i32, i32, i32 }
%struct.qdisc_size_table = type { %struct.callback_head, %struct.list_head, %struct.tc_sizespec, i32, [0 x i16] }
%struct.tc_sizespec = type { i8, i8, i16, i32, i32, i32, i32, i32 }
%struct.net_rate_estimator = type opaque
%struct.gnet_stats_basic_cpu = type { %struct.gnet_stats_basic_packed, %struct.u64_stats_sync }
%struct.qdisc_skb_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.gnet_stats_basic_packed = type <{ i64, i32 }>
%struct.gnet_stats_queue = type { i32, i32, i32, i32, i32 }
%struct.xps_dev_maps = type { %struct.callback_head, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.tcf_proto = type { %struct.tcf_proto*, i8*, i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i16, i32, i32, %struct.Qdisc*, i8*, %struct.tcf_proto_ops*, %struct.callback_head }
%struct.tcf_result = type { i64, i32 }
%struct.tcf_proto_ops = type { %struct.list_head, [16 x i8], i32 (%struct.sk_buff*, %struct.tcf_proto*, %struct.tcf_result*)*, i32 (%struct.tcf_proto*)*, i1 (%struct.tcf_proto*, i1)*, i64 (%struct.tcf_proto*, i32)*, i32 (%struct.net*, %struct.sk_buff*, %struct.tcf_proto*, i64, i32, %struct.nlattr**, i64*, i1)*, i32 (%struct.tcf_proto*, i64)*, void (%struct.tcf_proto*, %struct.tcf_walker*)*, i32 (%struct.net*, %struct.tcf_proto*, i64, %struct.sk_buff*, %struct.tcmsg*)*, %struct.module* }
%struct.tcf_walker = type opaque
%struct.netpoll_info = type opaque
%union.anon.94 = type { i8* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, i16 (%struct.kobject*, %struct.bin_attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, void (%struct.net_device*)*, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)*, %struct.net* (%struct.net_device*)*, i64 (%struct.net_device*, i32)*, i32 (%struct.sk_buff*, %struct.net_device*, i32*, i32)* }
%struct.nla_policy = type { i16, i16 }
%struct.netdev_tc_txq = type { i16, i16 }
%struct.phy_device = type opaque
%struct.dst_ops = type { i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.net*, %struct.sock*, %struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, void (%struct.dst_entry*, i8*)*, %struct.kmem_cache*, %struct.percpu_counter, [24 x i8] }
%struct.kmem_cache = type opaque
%struct.xfrm_state = type opaque
%struct.lwtunnel_state = type opaque
%union.anon.43 = type { %struct.dst_entry* }
%struct.sk_buff = type { %union.anon.19, %struct.sock*, %union.anon.24, [48 x i8], i64, void (%struct.sk_buff*)*, %struct.sec_path*, i64, i32, i32, i16, i16, i16, [0 x i8], i8, [0 x i32], [0 x i8], i32, i16, %union.anon.25, i32, i32, i32, i16, i16, %union.anon.27, i32, %union.anon.28, %union.anon.29, i16, i16, i16, i16, i16, i16, i16, [0 x i32], i32, i32, i8*, i8*, i32, %struct.atomic_t }
%union.anon.19 = type { %struct.anon.20 }
%struct.anon.20 = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon.21 }
%union.anon.21 = type { i64 }
%union.anon.24 = type { %struct.net_device* }
%struct.sec_path = type opaque
%union.anon.25 = type { i32 }
%union.anon.27 = type { i32 }
%union.anon.28 = type { i32 }
%union.anon.29 = type { i16 }
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.proto = type { void (%struct.sock*, i64)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, i32)*, %struct.sock* (%struct.sock*, i32, i32*, i1)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.sock*, %struct.msghdr*, i64, i32, i32, i32*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, i16)*, i32, i1 (%struct.sock*)*, void (%struct.sock*)*, %struct.atomic64_t*, %struct.percpu_counter*, i32*, i64*, i32*, i32*, i32, i8, %struct.kmem_cache*, i32, i32, %struct.percpu_counter*, %struct.request_sock_ops*, %struct.timewait_sock_ops*, %union.anon.30, %struct.module*, [32 x i8], %struct.list_head, i32 (%struct.sock*, i32)* }
%struct.msghdr = type { i8*, i32, %struct.iov_iter, i8*, i64, i32, %struct.kiocb* }
%struct.iov_iter = type { i32, i64, i64, %union.anon.16, %union.anon.17 }
%union.anon.16 = type { %struct.iovec* }
%struct.iovec = type { i8*, i64 }
%union.anon.17 = type { i64 }
%struct.kiocb = type { %struct.file*, i64, void (%struct.kiocb*, i64, i64)*, i8*, i32 }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.request_sock_ops = type { i32, i32, %struct.kmem_cache*, i8*, i32 (%struct.sock*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*)*, void (%struct.request_sock*)*, void (%struct.request_sock*)* }
%struct.request_sock = type { %struct.sock_common, %struct.request_sock*, i16, i8, i8, i32, %struct.timer_list, %struct.request_sock_ops*, %struct.sock*, i32*, i32, i32 }
%struct.timewait_sock_ops = type { %struct.kmem_cache*, i8*, i32, i32 (%struct.sock*, %struct.sock*, i8*)*, void (%struct.sock*)* }
%union.anon.30 = type { %struct.inet_hashinfo* }
%struct.inet_hashinfo = type { %struct.inet_ehash_bucket*, %struct.spinlock*, i32, i32, %struct.inet_bind_hashbucket*, i32, %struct.kmem_cache*, [16 x i8], [32 x %struct.inet_listen_hashbucket] }
%struct.inet_ehash_bucket = type { %struct.hlist_nulls_head }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.inet_bind_hashbucket = type { %struct.spinlock, %struct.hlist_head }
%struct.inet_listen_hashbucket = type { %struct.spinlock, %struct.hlist_head }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.qspinlock }
%struct.socket = type { i32, i16, i64, %struct.socket_wq*, %struct.file*, %struct.sock*, %struct.proto_ops* }
%struct.proto_ops = type { i32, %struct.module*, i32 (%struct.socket*)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32, i32)*, i32 (%struct.socket*, %struct.socket*)*, i32 (%struct.socket*, %struct.socket*, i32, i1)*, i32 (%struct.socket*, %struct.sockaddr*, i32*, i32)*, i32 (%struct.file*, %struct.socket*, %struct.poll_table_struct*)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.socket*, %struct.msghdr*, i64)*, i32 (%struct.socket*, %struct.msghdr*, i64, i32)*, i32 (%struct.file*, %struct.socket*, %struct.vm_area_struct*)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.sock*, i32)*, i32 (%struct.socket*)*, i32 (%struct.sock*, %struct.read_descriptor_t*, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)*)* }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.read_descriptor_t = type { i64, i64, %union.anon.51, i32 }
%union.anon.51 = type { i8* }
%struct.sock_cgroup_data = type {}
%struct.sock_reuseport = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, i32, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64, i32, i32 }
%struct.driver_private = type opaque
%struct.dev_links_info = type { %struct.list_head, %struct.list_head, i32 }
%struct.dev_pm_info = type { %struct.pm_message, i16, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.wake_irq*, %struct.atomic_t, %struct.atomic_t, i16, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.wake_irq*, %struct.timer_list, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8 }
%struct.wake_irq = type opaque
%struct.pm_subsys_data = type { %struct.spinlock, i32, %struct.list_head }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops, void (%struct.device*, i1)*, i32 (%struct.device*)*, void (%struct.device*)*, void (%struct.device*)* }
%struct.irq_domain = type opaque
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, i64)*, void (%struct.device*, i64, i8*, i64, i64)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, i64)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, i64)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, void (%struct.device*, %struct.scatterlist*, i32, i32, i64)*, i64 (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32, i64)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { i8* }
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.fwnode_handle, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.fwnode_handle = type { i32, %struct.fwnode_handle* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.iommu_fwspec = type opaque
%struct.mtd_info = type opaque
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.quota_info = type { i32, %struct.mutex, [3 x %struct.inode*], [3 x %struct.mem_dqinfo], [3 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, %struct.kqid*)* }
%struct.sb_writers = type { i32, %struct.__wait_queue_head, [3 x %struct.percpu_rw_semaphore] }
%struct.percpu_rw_semaphore = type { %struct.rcu_sync, i32*, %struct.rw_semaphore, %struct.rcuwait, i32 }
%struct.rcu_sync = type { i32, i32, %struct.__wait_queue_head, i32, %struct.callback_head, i32 }
%struct.rcuwait = type { %struct.task_struct* }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.workqueue_struct = type opaque
%struct.hlist_head = type { %struct.hlist_node* }
%struct.user_namespace = type { %struct.uid_gid_map, %struct.uid_gid_map, %struct.uid_gid_map, %struct.atomic_t, %struct.user_namespace*, i32, %struct.kuid_t, %struct.kgid_t, %struct.ns_common, i64, %struct.work_struct, %struct.ctl_table_set, %struct.ctl_table_header*, %struct.ucounts*, [9 x i32] }
%struct.uid_gid_map = type { i32, [5 x %struct.uid_gid_extent] }
%struct.uid_gid_extent = type { i32, i32, i32 }
%struct.list_lru = type { %struct.list_lru_node* }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_lru_one, [32 x i8] }
%struct.list_lru_one = type { %struct.list_head, i64 }
%union.anon.8 = type { %struct.list_head }
%union.anon.9 = type { %struct.hlist_node }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.102, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.rw_semaphore, i64, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.103, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock_context*, %struct.address_space, %struct.list_head, %union.anon.104, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.inode*, %struct.delayed_call*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.path*, %struct.kstat*, i32, i32)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [24 x i8] }
%struct.delayed_call = type { void (i8*)*, i8* }
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i32, i16, i32, i32, i64, i64, i64, i32, i32, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.timespec, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.102 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.103 = type { %struct.callback_head }
%struct.file_lock_context = type { %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.rw_semaphore, i64, i64, i64, %struct.address_space_operations*, i64, %struct.spinlock, i32, %struct.list_head, i8* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i1 (%struct.page*, i32)*, void (%struct.page*)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.swap_info_struct = type opaque
%union.anon.104 = type { %struct.pipe_inode_info* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**, i8**)*, i64 (%struct.file*, i32, i64, i64)*, void (%struct.seq_file*, %struct.file*)*, i64 (%struct.file*, i64, %struct.file*, i64, i64, i32)*, i32 (%struct.file*, i64, %struct.file*, i64, i64)*, i64 (%struct.file*, i64, i64, %struct.file*, i64)* }
%struct.dir_context = type { i32 (%struct.dir_context*, i8*, i32, i64, i64, i32)*, i64 }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.54 }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, i8* (i8*)*, void (i8*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, i32)*, i1 (%struct.file_lock*)*, i32 (%struct.file_lock*, i32, %struct.list_head*)*, void (%struct.file_lock*, i8**)* }
%union.anon.54 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.cred = type { %struct.atomic_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.group_info = type { %struct.atomic_t, i32, [0 x %struct.kgid_t] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.svc_serv = type { %struct.svc_program*, %struct.svc_stat*, %struct.spinlock, i32, i32, i32, i32, i32, %struct.list_head, %struct.list_head, i32, %struct.timer_list, i8*, i32, %struct.svc_pool*, %struct.svc_serv_ops* }
%struct.svc_program = type { %struct.svc_program*, i32, i32, i32, i32, %struct.svc_version**, i8*, i8*, %struct.svc_stat*, i32 (%struct.svc_rqst*)* }
%struct.svc_version = type { i32, i32, %struct.svc_procedure*, i32, i8, i8, i8, i32 (%struct.svc_rqst*, i32*)* }
%struct.svc_procedure = type { i32 (%struct.svc_rqst*, i8*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32 (i8*, i32*, i8*)*, i32, i32, i32, i32, i32 }
%struct.svc_rqst = type { %struct.list_head, %struct.callback_head, %struct.svc_xprt*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.svc_serv*, %struct.svc_pool*, %struct.svc_procedure*, %struct.auth_ops*, %struct.svc_cred, i8*, %struct.svc_deferred_req*, i64, %struct.xdr_buf, %struct.xdr_buf, [259 x %struct.page*], %struct.page**, %struct.page**, %struct.page**, [259 x %struct.kvec], i32, i32, i32, i32, i32, i32, i64, i8*, i8*, i8*, i32, i32, %struct.cache_req, %struct.auth_domain*, %struct.auth_domain*, %struct.svc_cacherep*, %struct.task_struct*, %struct.spinlock }
%struct.auth_ops = type { i8*, %struct.module*, i32, i32 (%struct.svc_rqst*, i32*)*, i32 (%struct.svc_rqst*)*, void (%struct.auth_domain*)*, i32 (%struct.svc_rqst*)* }
%struct.svc_cred = type { %struct.kuid_t, %struct.kgid_t, %struct.group_info*, i32, i8*, i8*, %struct.gss_api_mech* }
%struct.gss_api_mech = type { %struct.list_head, %struct.module*, %struct.rpcsec_gss_oid, i8*, %struct.gss_api_ops*, i32, %struct.pf_desc*, i8* }
%struct.rpcsec_gss_oid = type { i32, [32 x i8] }
%struct.gss_api_ops = type { i32 (i8*, i64, %struct.gss_ctx*, i64*, i32)*, i32 (%struct.gss_ctx*, %struct.xdr_buf*, %struct.xdr_netobj*)*, i32 (%struct.gss_ctx*, %struct.xdr_buf*, %struct.xdr_netobj*)*, i32 (%struct.gss_ctx*, i32, %struct.xdr_buf*, %struct.page**)*, i32 (%struct.gss_ctx*, i32, %struct.xdr_buf*)*, void (i8*)* }
%struct.gss_ctx = type { %struct.gss_api_mech*, i8* }
%struct.xdr_netobj = type { i32, i8* }
%struct.pf_desc = type { i32, i32, i32, i8*, i8*, i8 }
%struct.svc_deferred_req = type { i32, %struct.svc_xprt*, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.cache_deferred_req, i64, i32, [0 x i32] }
%struct.cache_deferred_req = type { %struct.hlist_node, %struct.list_head, %struct.cache_head*, i8*, void (%struct.cache_deferred_req*, i32)* }
%struct.cache_head = type { %struct.hlist_node, i64, i64, %struct.kref, i64 }
%struct.xdr_buf = type { [1 x %struct.kvec], [1 x %struct.kvec], %struct.page**, i32, i32, i32, i32, i32 }
%struct.kvec = type { i8*, i64 }
%struct.cache_req = type { %struct.cache_deferred_req* (%struct.cache_req*)*, i32 }
%struct.auth_domain = type { %struct.kref, %struct.hlist_node, i8*, %struct.auth_ops* }
%struct.svc_cacherep = type opaque
%struct.svc_stat = type { %struct.svc_program*, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.svc_pool = type { i32, %struct.spinlock, %struct.list_head, i32, %struct.list_head, %struct.svc_pool_stats, i64, [40 x i8] }
%struct.svc_pool_stats = type { %struct.atomic64_t, i64, %struct.atomic64_t, %struct.atomic64_t }
%struct.svc_serv_ops = type { void (%struct.svc_serv*, %struct.net*)*, i32 (i8*)*, void (%struct.svc_xprt*)*, i32 (%struct.svc_serv*, %struct.svc_pool*, i32)*, %struct.module* }
%struct.rpc_rqst = type { %struct.rpc_xprt*, %struct.xdr_buf, %struct.xdr_buf, %struct.rpc_task*, %struct.rpc_cred*, i32, i32, i32, i32, %struct.page**, void (%struct.rpc_rqst*)*, %struct.list_head, i8*, i8*, i64, i8*, i64, i64, i64, %struct.xdr_buf, i64, i64, i64, i32, i32, i32, i64, i32 }
%struct.rpc_cred = type { %struct.hlist_node, %struct.list_head, %struct.callback_head, %struct.rpc_auth*, %struct.rpc_credops*, i64, i64, %struct.atomic_t, %struct.kuid_t }
%struct.rpc_auth = type { i32, i32, i32, i32, %struct.rpc_authops*, i32, %struct.atomic_t, %struct.rpc_cred_cache* }
%struct.rpc_authops = type { %struct.module*, i32, i8*, %struct.rpc_auth* (%struct.rpc_auth_create_args*, %struct.rpc_clnt*)*, void (%struct.rpc_auth*)*, i32 (%struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_auth*, %struct.auth_cred*, i32, i32)*, i32 (i32*, i32)*, i32 (%struct.rpcsec_gss_info*)*, i32 (i32, %struct.rpcsec_gss_info*)*, i32 (%struct.rpc_auth*, %struct.rpc_cred*)* }
%struct.rpc_auth_create_args = type { i32, i8* }
%struct.rpc_clnt = type { %struct.atomic_t, i32, %struct.list_head, %struct.list_head, %struct.spinlock, %struct.rpc_xprt*, %struct.rpc_procinfo*, i32, i32, i32, %struct.rpc_auth*, %struct.rpc_stat*, %struct.rpc_iostats*, i8, %struct.rpc_rtt*, %struct.rpc_timeout*, %struct.atomic_t, i32, [65 x i8], %struct.rpc_pipe_dir_head, %struct.rpc_clnt*, %struct.rpc_rtt, %struct.rpc_timeout, %struct.rpc_program*, %struct.rpc_xprt_iter }
%struct.rpc_procinfo = type { i32, void (i8*, %struct.xdr_stream*, i8*)*, i32 (i8*, %struct.xdr_stream*, i8*)*, i32, i32, i32, i32, i32, i8* }
%struct.xdr_stream = type { i32*, %struct.xdr_buf*, i32*, %struct.kvec*, %struct.kvec, %struct.page**, i32 }
%struct.rpc_stat = type { %struct.rpc_program*, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.rpc_iostats = type opaque
%struct.rpc_pipe_dir_head = type { %struct.list_head, %struct.dentry* }
%struct.rpc_rtt = type { i64, [5 x i64], [5 x i64], [5 x i32] }
%struct.rpc_timeout = type { i64, i64, i64, i32, i8 }
%struct.rpc_program = type { i8*, i32, i32, %struct.rpc_version**, %struct.rpc_stat*, i8* }
%struct.rpc_version = type { i32, i32, %struct.rpc_procinfo* }
%struct.rpc_xprt_iter = type { %struct.rpc_xprt_switch*, %struct.rpc_xprt*, %struct.rpc_xprt_iter_ops* }
%struct.rpc_xprt_switch = type { %struct.spinlock, %struct.kref, i32, %struct.list_head, %struct.net*, %struct.rpc_xprt_iter_ops*, %struct.callback_head }
%struct.rpc_xprt_iter_ops = type { void (%struct.rpc_xprt_iter*)*, %struct.rpc_xprt* (%struct.rpc_xprt_iter*)*, %struct.rpc_xprt* (%struct.rpc_xprt_iter*)* }
%struct.auth_cred = type { %struct.kuid_t, %struct.kgid_t, %struct.group_info*, i8*, i64, i8 }
%struct.rpcsec_gss_info = type { %struct.rpcsec_gss_oid, i32, i32 }
%struct.rpc_cred_cache = type opaque
%struct.rpc_credops = type { i8*, i32 (%struct.rpc_auth*, %struct.rpc_cred*)*, void (%struct.rpc_cred*)*, i32 (%struct.auth_cred*, %struct.rpc_cred*, i32)*, %struct.rpc_cred* (%struct.rpc_task*, %struct.rpc_cred*, i32)*, i32* (%struct.rpc_task*, i32*)*, i32 (%struct.rpc_task*)*, i32* (%struct.rpc_task*, i32*)*, i32 (%struct.rpc_task*, void (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_task*, i32 (i8*, %struct.xdr_stream*, i8*)*, i8*, i32*, i8*)*, i32 (%struct.rpc_cred*)*, i1 (%struct.rpc_cred*)*, i8* (%struct.rpc_cred*)* }
%struct.__kernel_sockaddr_storage = type { i16, [126 x i8] }
%struct.rpc_wait_queue = type { %struct.spinlock, [4 x %struct.list_head], i32, i8, i8, i8, i16, %struct.rpc_timer, i8* }
%struct.rpc_timer = type { %struct.timer_list, %struct.list_head, i64 }
%struct.atomic_t = type { i32 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.timer_list = type { %struct.hlist_node, i64, void (i64)*, i64, i32 }
%struct.spinlock = type { %union.anon }
%union.anon = type { %struct.raw_spinlock }
%struct.rpc_task = type { %struct.atomic_t, i32, %struct.list_head, void (%struct.rpc_task*)*, void (%struct.rpc_task*)*, i64, i64, %struct.rpc_wait_queue*, %union.anon.0, %struct.rpc_message, i8*, %struct.rpc_call_ops*, %struct.rpc_clnt*, %struct.rpc_xprt*, %struct.rpc_rqst*, %struct.workqueue_struct*, i64, i32, i16, i16, i16, i8 }
%union.anon.0 = type { %struct.rpc_wait }
%struct.rpc_wait = type { %struct.list_head, %struct.list_head, %struct.list_head, i64 }
%struct.rpc_message = type { %struct.rpc_procinfo*, i8*, i8*, %struct.rpc_cred* }
%struct.rpc_call_ops = type { void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)*, void (%struct.rpc_task*, i8*)*, void (i8*)* }
%struct.svc_xprt = type { %struct.svc_xprt_class*, %struct.svc_xprt_ops*, %struct.kref, %struct.list_head, %struct.list_head, i64, %struct.svc_serv*, %struct.atomic_t, %struct.atomic_t, %struct.mutex, %struct.spinlock, i8*, %struct.list_head, %struct.__kernel_sockaddr_storage, i64, %struct.__kernel_sockaddr_storage, i64, %struct.rpc_wait_queue, %struct.list_head, %struct.net*, %struct.rpc_xprt*, %struct.rpc_xprt_switch* }
%struct.svc_xprt_class = type { i8*, %struct.module*, %struct.svc_xprt_ops*, %struct.list_head, i32, i32 }
%struct.svc_xprt_ops = type { %struct.svc_xprt* (%struct.svc_serv*, %struct.net*, %struct.sockaddr*, i32, i32)*, %struct.svc_xprt* (%struct.svc_xprt*)*, i32 (%struct.svc_xprt*)*, i32 (%struct.svc_rqst*)*, void (%struct.svc_rqst*)*, i32 (%struct.svc_rqst*)*, void (%struct.svc_rqst*)*, void (%struct.svc_xprt*)*, void (%struct.svc_xprt*)*, i32 (%struct.svc_rqst*)*, void (%struct.svc_xprt*)* }
%struct.anon.86 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.net = type { %struct.atomic_t, %struct.atomic_t, %struct.spinlock, %struct.atomic64_t, %struct.list_head, %struct.list_head, %struct.list_head, %struct.user_namespace*, %struct.ucounts*, %struct.spinlock, %struct.idr, %struct.ns_common, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, i32, i32, i32, %struct.list_head, %struct.net_device*, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, [40 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_nf, %struct.netns_xt, %struct.netns_ct, [16 x i8], %struct.netns_nf_frag, %struct.sock*, %struct.sock*, %struct.net_generic*, [40 x i8], %struct.netns_xfrm, %struct.sock*, %struct.atomic_t, [52 x i8] }
%struct.netns_core = type { %struct.ctl_table_header*, i32, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { %struct.tcp_mib*, %struct.ipstats_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib*, %struct.proc_dir_entry*, %struct.udp_mib*, %struct.udp_mib*, %struct.ipstats_mib*, %struct.icmpv6_mib*, %struct.icmpv6msg_mib* }
%struct.tcp_mib = type { [16 x i64] }
%struct.linux_mib = type { [119 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.icmpmsg_mib = type { [512 x %struct.atomic64_t] }
%struct.udp_mib = type { [9 x i64] }
%struct.icmpv6_mib = type { [6 x i64] }
%struct.icmpv6msg_mib = type { [512 x %struct.atomic64_t] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_ipv4 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.fib_rules_ops*, i8, %struct.fib_table*, %struct.fib_table*, %struct.hlist_head*, i8, %struct.sock*, %struct.sock**, %struct.sock*, %struct.inet_peer_base*, %struct.sock**, [48 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, i32, i32, i32, i32, i32, i32, %struct.local_ports, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [56 x i8], %struct.inet_timewait_death_row, i32, i32, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, i32, %struct.mr_table*, i32, i32, %struct.atomic_t, [52 x i8] }
%struct.ipv4_devconf = type opaque
%struct.fib_rules_ops = type { i32, %struct.list_head, i32, i32, i32, i32, i32 (%struct.fib_rule*, %struct.flowi*, i32, %struct.fib_lookup_arg*)*, i1 (%struct.fib_rule*, %struct.fib_lookup_arg*)*, i32 (%struct.fib_rule*, %struct.flowi*, i32)*, i32 (%struct.fib_rule*, %struct.sk_buff*, %struct.fib_rule_hdr*, %struct.nlattr**)*, i32 (%struct.fib_rule*)*, i32 (%struct.fib_rule*, %struct.fib_rule_hdr*, %struct.nlattr**)*, i32 (%struct.fib_rule*, %struct.sk_buff*, %struct.fib_rule_hdr*)*, i64 (%struct.fib_rule*)*, void (%struct.fib_rules_ops*)*, i32, %struct.nla_policy*, %struct.list_head, %struct.module*, %struct.net*, %struct.callback_head }
%struct.fib_rule = type { %struct.list_head, i32, i32, i32, i32, i32, i32, i8, i8, i32, i64, %struct.fib_rule*, %struct.net*, %struct.atomic_t, i32, i32, i32, [16 x i8], [16 x i8], %struct.fib_kuid_range, %struct.callback_head }
%struct.fib_kuid_range = type { %struct.kuid_t, %struct.kuid_t }
%struct.flowi = type { %union.anon.33 }
%union.anon.33 = type { %struct.flowi6 }
%struct.flowi6 = type { %struct.flowi_common, %struct.in6_addr, %struct.in6_addr, i32, %union.flowi_uli }
%struct.flowi_common = type { i32, i32, i32, i8, i8, i8, i8, i32, %struct.flowi_tunnel, %struct.kuid_t }
%struct.flowi_tunnel = type { i64 }
%union.flowi_uli = type { i32 }
%struct.fib_lookup_arg = type { i8*, i8*, %struct.fib_rule*, i32, i32 }
%struct.fib_rule_hdr = type { i8, i8, i8, i8, i8, i8, i8, i8, i32 }
%struct.fib_table = type { %struct.hlist_node, i32, i32, %struct.callback_head, i64*, [0 x i64] }
%struct.inet_peer_base = type { %struct.inet_peer*, %struct.seqlock_t, i32 }
%struct.inet_peer = type { %struct.inet_peer*, %struct.inet_peer*, %struct.inetpeer_addr, i32, [16 x i32], i32, i64, %union.anon.40, %union.anon.41, i32, %struct.atomic_t }
%struct.inetpeer_addr = type { %union.anon.39, i16 }
%union.anon.39 = type { %struct.in6_addr }
%union.anon.40 = type { %struct.list_head }
%union.anon.41 = type { %struct.callback_head }
%struct.netns_frags = type { %struct.percpu_counter, i32, i32, i32, i32, [8 x i8] }
%struct.xt_table = type opaque
%struct.local_ports = type { %struct.seqlock_t, [2 x i32], i8 }
%struct.inet_timewait_death_row = type { %struct.atomic_t, [60 x i8], %struct.inet_hashinfo*, i32, i32, [48 x i8] }
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.kgid_t] }
%struct.mr_table = type opaque
%struct.netns_ipv6 = type { %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, [56 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, %struct.list_head, [56 x i8], %struct.dst_ops, %struct.rwlock_t, %struct.spinlock, i32, i64, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.sock*, %struct.atomic_t, %struct.atomic_t, %struct.seg6_pernet_data*, [48 x i8] }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.rt6_statistics = type opaque
%struct.fib6_table = type opaque
%struct.seg6_pernet_data = type opaque
%struct.netns_nf = type { %struct.proc_dir_entry*, %struct.nf_queue_handler*, [13 x %struct.nf_logger*], %struct.ctl_table_header*, [13 x [8 x %struct.nf_hook_entry*]], i8, i8 }
%struct.nf_queue_handler = type opaque
%struct.nf_logger = type opaque
%struct.netns_xt = type { [13 x %struct.list_head], i8, i8 }
%struct.netns_ct = type { %struct.atomic_t, i32, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i8, i32, i32, %struct.ct_pcpu*, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_exp_event_notifier*, %struct.nf_ip_net }
%struct.ct_pcpu = type { %struct.spinlock, %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.ip_conntrack_stat = type opaque
%struct.nf_ct_event_notifier = type opaque
%struct.nf_exp_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.nf_generic_net, %struct.nf_tcp_net, %struct.nf_udp_net, %struct.nf_icmp_net, %struct.nf_icmp_net }
%struct.nf_generic_net = type { %struct.nf_proto_net, i32 }
%struct.nf_proto_net = type { %struct.ctl_table_header*, %struct.ctl_table*, i32 }
%struct.nf_tcp_net = type { %struct.nf_proto_net, [14 x i32], i32, i32, i32 }
%struct.nf_udp_net = type { %struct.nf_proto_net, [2 x i32] }
%struct.nf_icmp_net = type { %struct.nf_proto_net, i32 }
%struct.netns_nf_frag = type { %struct.netns_sysctl_ipv6, [16 x i8], %struct.netns_frags }
%struct.net_generic = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.list_head, %struct.hlist_head*, i32, [3 x %struct.hlist_head], [3 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.xfrm_policy_hthresh, %struct.sock*, %struct.sock*, i32, i32, i32, i32, %struct.ctl_table_header*, [56 x i8], %struct.dst_ops, %struct.dst_ops, %struct.spinlock, %struct.spinlock, %struct.mutex, %struct.flow_cache, %struct.atomic_t, %struct.list_head, %struct.atomic_t, %struct.spinlock, %struct.work_struct, %struct.work_struct, %struct.mutex }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32, i8, i8, i8, i8 }
%struct.xfrm_policy_hthresh = type { %struct.work_struct, %struct.seqlock_t, i8, i8, i8, i8 }
%struct.flow_cache = type { i32, %struct.flow_cache_percpu*, %struct.hlist_node, i32, i32, %struct.timer_list }
%struct.flow_cache_percpu = type { %struct.hlist_head*, i32, i32, i32, %struct.tasklet_struct }
%struct.tasklet_struct = type { %struct.tasklet_struct*, i64, %struct.atomic_t, void (i64)*, i64 }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.xprt_create = type { i32, %struct.net*, %struct.sockaddr*, %struct.sockaddr*, i64, i8*, %struct.svc_xprt*, %struct.rpc_xprt_switch*, i32 }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i32*, i32, %struct.mutex, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i32*, i8, %struct.kernel_symbol*, i32*, i32, i32, %struct.exception_table_entry*, i32 ()*, [40 x i8], %struct.module_layout, %struct.module_layout, %struct.mod_arch_specific, i64, i32, %struct.list_head, %struct.bug_entry*, %struct.mod_kallsyms*, %struct.mod_kallsyms, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.trace_event_call**, i32, %struct.trace_enum_map**, i32, %struct.list_head, %struct.list_head, void ()*, %struct.atomic_t, [12 x i8] }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_param = type { i8*, %struct.module*, %struct.kernel_param_ops*, i16, i8, i8, %union.anon.53 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.53 = type { i8* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32, i32 }
%struct.module_layout = type { i8*, i32, i32, i32, i32, %struct.mod_tree_node }
%struct.mod_tree_node = type { %struct.module*, %struct.latch_tree_node }
%struct.latch_tree_node = type { [2 x %struct.rb_node] }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.mod_kallsyms = type { %struct.elf64_sym*, i32, i8* }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, i32 ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8*, i32 }
%struct.trace_event_call = type opaque
%struct.trace_enum_map = type { i8*, i8*, i64 }
%struct.sockaddr_in = type { i16, i16, %struct.in_addr, [8 x i8] }
%struct.in_addr = type { i32 }
%struct.sockaddr_un = type { i16, [108 x i8] }
%struct.sock_xprt = type { %struct.rpc_xprt, %struct.socket*, %struct.sock*, i32, i32, i32, i32, i32, i64, i64, i64, %struct.delayed_work, %struct.work_struct, %struct.mutex, %struct.__kernel_sockaddr_storage, i16, i64, i64, %struct.rpc_timeout, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)* }
%union.anon.108 = type { %struct.list_head* }
%union.anon.106 = type { %struct.socket_wq* }
%union.anon.105 = type { i32 }
%union.anon.107 = type { %struct.tracepoint_func* }
%struct.xdr_skb_reader = type { %struct.sk_buff*, i32, i64, i32 }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%union.anon.111 = type { %struct.tracepoint_func* }
%union.anon.109 = type { %struct.socket_wq* }
%union.anon.110 = type { %struct.tracepoint_func* }
%union.anon.112 = type { %struct.tracepoint_func* }
%union.anon.114 = type { %struct.tracepoint_func* }
%union.anon.113 = type { %struct.tracepoint_func* }
%struct.tcp_sock = type { %struct.inet_connection_sock, i16, i16, i32, i64, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, i32, i32, i32, %struct.list_head, %struct.anon.120, i32, i32, i32, i32, i32, i32, %struct.tcp_rack, i16, i32, [3 x i32], i16, i8, i8, i32, i32, i32, i32, i32, i32, %struct.minmax, i32, i32, i32, i32, i16, i8, i8, i32, i32, %struct.tcp_options_received, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.skb_mstamp, %struct.skb_mstamp, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.sk_buff*, %struct.sk_buff*, %struct.rb_root, %struct.sk_buff*, [1 x %struct.tcp_sack_block], [4 x %struct.tcp_sack_block], [4 x %struct.tcp_sack_block], %struct.sk_buff*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.anon.121, %struct.anon.122, %struct.anon.123, i32, %struct.tcp_sock_af_ops*, %struct.tcp_md5sig_info*, %struct.tcp_fastopen_request*, %struct.request_sock*, i32* }
%struct.inet_connection_sock = type { %struct.inet_sock, %struct.request_sock_queue, %struct.inet_bind_bucket*, i64, %struct.timer_list, %struct.timer_list, i32, i32, %struct.tcp_congestion_ops*, %struct.inet_connection_sock_af_ops*, i32 (%struct.sock*, i32)*, i8, i8, i8, i8, i8, i8, i16, %struct.anon.118, %struct.anon.119, i32, [11 x i64] }
%struct.inet_sock = type { %struct.sock, %struct.ipv6_pinfo*, i32, i16, i16, i16, i16, %struct.ip_options_rcu*, i32, i8, i8, i8, i8, i16, i8, i8, i32, i32, i32, %struct.ip_mc_socklist*, %struct.inet_cork_full }
%struct.ipv6_pinfo = type { %struct.in6_addr, %struct.in6_pktinfo, %struct.in6_addr*, i32, i32, i32, i32, i32, %union.anon.115, i16, i8, i8, i32, i32, i32, %struct.ipv6_mc_socklist*, %struct.ipv6_ac_socklist*, %struct.ipv6_fl_socklist*, %struct.ipv6_txoptions*, %struct.sk_buff*, %struct.sk_buff*, %struct.inet6_cork }
%struct.in6_pktinfo = type { %struct.in6_addr, i32 }
%union.anon.115 = type { %struct.anon.116 }
%struct.anon.116 = type { i16 }
%struct.ipv6_mc_socklist = type { %struct.in6_addr, i32, %struct.ipv6_mc_socklist*, %struct.rwlock_t, i32, %struct.ip6_sf_socklist*, %struct.callback_head }
%struct.ip6_sf_socklist = type { i32, i32, [0 x %struct.in6_addr] }
%struct.ipv6_ac_socklist = type { %struct.in6_addr, i32, %struct.ipv6_ac_socklist* }
%struct.ipv6_fl_socklist = type { %struct.ipv6_fl_socklist*, %struct.ip6_flowlabel*, %struct.callback_head }
%struct.ip6_flowlabel = type { %struct.ip6_flowlabel*, i32, %struct.atomic_t, %struct.in6_addr, %struct.ipv6_txoptions*, i64, %struct.callback_head, i8, %union.anon.117, i64, i64, %struct.net* }
%union.anon.117 = type { %struct.pid* }
%struct.ipv6_txoptions = type { %struct.atomic_t, i32, i16, i16, %struct.ipv6_opt_hdr*, %struct.ipv6_opt_hdr*, %struct.ipv6_rt_hdr*, %struct.ipv6_opt_hdr*, %struct.callback_head }
%struct.ipv6_rt_hdr = type { i8, i8, i8, i8 }
%struct.ipv6_opt_hdr = type { i8, i8 }
%struct.inet6_cork = type { %struct.ipv6_txoptions*, i8, i8 }
%struct.ip_options_rcu = type { %struct.callback_head, %struct.ip_options }
%struct.ip_options = type { i32, i32, i8, i8, i8, i8, i8, i8, i8, i8, [0 x i8] }
%struct.ip_mc_socklist = type opaque
%struct.inet_cork_full = type { %struct.inet_cork, %struct.flowi }
%struct.inet_cork = type { i32, i32, %struct.ip_options*, i32, i32, %struct.dst_entry*, i8, i8, i16, i8 }
%struct.request_sock_queue = type { %struct.spinlock, i8, i32, %struct.atomic_t, %struct.atomic_t, %struct.request_sock*, %struct.request_sock*, %struct.fastopen_queue }
%struct.fastopen_queue = type { %struct.request_sock*, %struct.request_sock*, %struct.spinlock, i32, i32 }
%struct.inet_bind_bucket = type { %struct.possible_net_t, i16, i8, i8, %struct.kuid_t, %struct.in6_addr, i32, i16, i8, %struct.hlist_node, %struct.hlist_head }
%struct.tcp_congestion_ops = type { %struct.list_head, i32, i32, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*, i32, i32)*, void (%struct.sock*, i8)*, void (%struct.sock*, i32)*, void (%struct.sock*, i32)*, i32 (%struct.sock*)*, void (%struct.sock*, %struct.ack_sample*)*, i32 (%struct.sock*)*, i32 (%struct.sock*)*, void (%struct.sock*, %struct.rate_sample*)*, i64 (%struct.sock*, i32, i32*, %union.tcp_cc_info*)*, [16 x i8], %struct.module* }
%struct.ack_sample = type { i32, i32, i32 }
%struct.rate_sample = type { %struct.skb_mstamp, i32, i32, i64, i64, i32, i32, i32, i8, i8 }
%union.tcp_cc_info = type opaque
%struct.inet_connection_sock_af_ops = type { i32 (%struct.sock*, %struct.sk_buff*, %struct.flowi*)*, void (%struct.sock*, %struct.sk_buff*)*, i32 (%struct.sock*)*, void (%struct.sock*, %struct.sk_buff*)*, i32 (%struct.sock*, %struct.sk_buff*)*, %struct.sock* (%struct.sock*, %struct.sk_buff*, %struct.request_sock*, %struct.dst_entry*, %struct.request_sock*, i8*)*, i16, i16, i16, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, void (%struct.sock*, %struct.sockaddr*)*, void (%struct.sock*)* }
%struct.anon.118 = type { i8, i8, i8, i8, i32, i64, i32, i16, i16 }
%struct.anon.119 = type { i32, i32, i32, i32, i32 }
%struct.anon.120 = type { %struct.sk_buff_head, %struct.task_struct*, %struct.msghdr*, i32, i32 }
%struct.tcp_rack = type { %struct.skb_mstamp, i32, i32, i8, i8 }
%struct.minmax = type { [3 x %struct.minmax_sample] }
%struct.minmax_sample = type { i32, i32 }
%struct.tcp_options_received = type { i64, i32, i32, i32, i16, i8, i16, i16 }
%struct.skb_mstamp = type { %union.anon.22 }
%union.anon.22 = type { i64 }
%struct.tcp_sack_block = type { i32, i32 }
%struct.anon.121 = type { i32, i32, i32 }
%struct.anon.122 = type { i32, i32, i32 }
%struct.anon.123 = type { i32, i32 }
%struct.tcp_sock_af_ops = type { %struct.tcp_md5sig_key* (%struct.sock*, %struct.sock*)*, i32 (i8*, %struct.tcp_md5sig_key*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.sock*, i8*, i32)* }
%struct.tcp_md5sig_key = type { %struct.hlist_node, i8, i8, %union.tcp_md5_addr, [80 x i8], %struct.callback_head }
%union.tcp_md5_addr = type { %struct.in6_addr }
%struct.tcp_md5sig_info = type { %struct.hlist_head, %struct.callback_head }
%struct.tcp_fastopen_request = type { %struct.tcp_fastopen_cookie, %struct.msghdr*, i64, i32 }
%struct.tcp_fastopen_cookie = type { %union.anon.124, i8, i8 }
%union.anon.124 = type { %struct.in6_addr }
%union.anon.125 = type { %struct.tracepoint_func* }
%union.anon.126 = type { i8 }
%struct.svc_sock = type { %struct.svc_xprt, %struct.socket*, %struct.sock*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32, i32, i32, [259 x %struct.page*] }
%struct.rpc_buffer = type { i64, [0 x i8] }

@xs_local_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_local_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_local_transport, i32 0, i32 0) }, i32 257, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_local, %struct.module* null, [32 x i8] c"named UNIX socket\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_udp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_udp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_udp_transport, i32 0, i32 0) }, i32 17, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_udp, %struct.module* null, [32 x i8] c"udp\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_tcp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_tcp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_tcp_transport, i32 0, i32 0) }, i32 6, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_tcp, %struct.module* null, [32 x i8] c"tcp\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00" }, align 8
@xs_bc_tcp_transport = internal global %struct.xprt_class { %struct.list_head { %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_bc_tcp_transport, i32 0, i32 0), %struct.list_head* getelementptr inbounds (%struct.xprt_class, %struct.xprt_class* @xs_bc_tcp_transport, i32 0, i32 0) }, i32 -2147483642, %struct.rpc_xprt* (%struct.xprt_create*)* @xs_setup_bc_tcp, %struct.module* null, [32 x i8] c"tcp NFSv4.1 backchannel\00\00\00\00\00\00\00\00\00" }, align 8
@__param_str_min_resvport = internal constant [20 x i8] c"sunrpc.min_resvport\00", align 16
@param_ops_portnr = internal constant %struct.kernel_param_ops { i32 0, i32 (i8*, %struct.kernel_param*)* @param_set_portnr, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_min_resvport = internal global i32 665, align 4
@__param_min_resvport = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_min_resvport, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_portnr, i16 420, i8 -1, i8 0, %union.anon.53 { i8* bitcast (i32* @xprt_min_resvport to i8*) } }, section "__param", align 8
@__param_str_max_resvport = internal constant [20 x i8] c"sunrpc.max_resvport\00", align 16
@xprt_max_resvport = internal global i32 1023, align 4
@__param_max_resvport = internal constant %struct.kernel_param { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__param_str_max_resvport, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_portnr, i16 420, i8 -1, i8 0, %union.anon.53 { i8* bitcast (i32* @xprt_max_resvport to i8*) } }, section "__param", align 8
@__param_str_tcp_slot_table_entries = internal constant [30 x i8] c"sunrpc.tcp_slot_table_entries\00", align 16
@param_ops_slot_table_size = internal constant %struct.kernel_param_ops { i32 0, i32 (i8*, %struct.kernel_param*)* @param_set_slot_table_size, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_tcp_slot_table_entries = internal global i32 2, align 4
@__param_tcp_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__param_str_tcp_slot_table_entries, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_slot_table_size, i16 420, i8 -1, i8 0, %union.anon.53 { i8* bitcast (i32* @xprt_tcp_slot_table_entries to i8*) } }, section "__param", align 8
@__param_str_tcp_max_slot_table_entries = internal constant [34 x i8] c"sunrpc.tcp_max_slot_table_entries\00", align 16
@param_ops_max_slot_table_size = internal constant %struct.kernel_param_ops { i32 0, i32 (i8*, %struct.kernel_param*)* @param_set_max_slot_table_size, i32 (i8*, %struct.kernel_param*)* @param_get_uint, void (i8*)* null }, align 8
@xprt_max_tcp_slot_table_entries = internal global i32 65536, align 4
@__param_tcp_max_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__param_str_tcp_max_slot_table_entries, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_max_slot_table_size, i16 420, i8 -1, i8 0, %union.anon.53 { i8* bitcast (i32* @xprt_max_tcp_slot_table_entries to i8*) } }, section "__param", align 8
@__param_str_udp_slot_table_entries = internal constant [30 x i8] c"sunrpc.udp_slot_table_entries\00", align 16
@xprt_udp_slot_table_entries = internal global i32 16, align 4
@__param_udp_slot_table_entries = internal constant %struct.kernel_param { i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__param_str_udp_slot_table_entries, i32 0, i32 0), %struct.module* null, %struct.kernel_param_ops* @param_ops_slot_table_size, i16 420, i8 -1, i8 0, %union.anon.53 { i8* bitcast (i32* @xprt_udp_slot_table_entries to i8*) } }, section "__param", align 8
@xs_local_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_tcp_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @xs_local_rpcbind, void (%struct.rpc_xprt*, i16)* @xs_local_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_local_connect, i32 (%struct.rpc_task*)* @rpc_malloc, void (%struct.rpc_task*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_local_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @xs_close, void (%struct.rpc_xprt*)* @xs_destroy, void (%struct.rpc_xprt*, i64, i64)* null, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_local_print_stats, i32 (%struct.rpc_xprt*)* @xs_enable_swap, void (%struct.rpc_xprt*)* @xs_disable_swap, void (%struct.rpc_xprt*)* null, i32 (%struct.rpc_xprt*, i32)* null, i32 (%struct.svc_serv*, %struct.net*)* null, i64 (%struct.rpc_xprt*)* null, void (%struct.rpc_rqst*)* null, void (%struct.rpc_xprt*, i32)* null }, align 8
@xs_local_default_timeout = internal constant %struct.rpc_timeout { i64 10000, i64 10000, i64 0, i32 2, i8 0 }, align 8
@.str = private unnamed_addr constant [6 x i8] c"local\00", align 1
@xs_setup_xprt.__key = internal global %struct.lock_class_key zeroinitializer, align 1
@.str.1 = private unnamed_addr constant [17 x i8] c"&new->recv_mutex\00", align 1
@xs_init_anyaddr.sin = internal constant %struct.sockaddr_in { i16 2, i16 0, %struct.in_addr zeroinitializer, [8 x i8] zeroinitializer }, align 4
@xs_init_anyaddr.sin6 = internal constant { i16, i16, i32, { { [16 x i8] } }, i32 } { i16 10, i16 0, i32 0, { { [16 x i8] } } zeroinitializer, i32 0 }, align 4
@.str.2 = private unnamed_addr constant [13 x i8] c"packet data:\00", align 1
@__tracepoint_rpc_socket_close = external global %struct.tracepoint, align 8
@cpu_number = external global i32, align 4
@__cpu_online_mask = external global %struct.cpumask, align 8
@jiffies = external global i64, align 8
@.str.3 = private unnamed_addr constant [66 x i8] c"\09xprt:\09local %lu %lu %lu %ld %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"%08x\00", align 1
@.str.5 = private unnamed_addr constant [5 x i8] c"%pi6\00", align 1
@.str.6 = private unnamed_addr constant [22 x i8] c"net/sunrpc/xprtsock.c\00", align 1
@.str.7 = private unnamed_addr constant [3 x i8] c"%u\00", align 1
@.str.8 = private unnamed_addr constant [5 x i8] c"%4hx\00", align 1
@.str.9 = private unnamed_addr constant [45 x i8] c"\013%s: unhandled error (%d) connecting to %s\0A\00", align 1
@__func__.xs_local_setup_socket = private unnamed_addr constant [22 x i8] c"xs_local_setup_socket\00", align 1
@xprtiod_workqueue = external global %struct.workqueue_struct*, align 8
@__tracepoint_rpc_socket_error = external global %struct.tracepoint, align 8
@__tracepoint_rpc_socket_connect = external global %struct.tracepoint, align 8
@xs_udp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* @xs_udp_set_buffer_size, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt_cong, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt_cong, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* @rpcb_getport_async, void (%struct.rpc_xprt*, i16)* @xs_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_connect, i32 (%struct.rpc_task*)* @rpc_malloc, void (%struct.rpc_task*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_udp_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_rtt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_udp_timer, void (%struct.rpc_task*)* @xprt_release_rqst_cong, void (%struct.rpc_xprt*)* @xs_close, void (%struct.rpc_xprt*)* @xs_destroy, void (%struct.rpc_xprt*, i64, i64)* null, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_udp_print_stats, i32 (%struct.rpc_xprt*)* @xs_enable_swap, void (%struct.rpc_xprt*)* @xs_disable_swap, void (%struct.rpc_xprt*)* @xs_inject_disconnect, i32 (%struct.rpc_xprt*, i32)* null, i32 (%struct.svc_serv*, %struct.net*)* null, i64 (%struct.rpc_xprt*)* null, void (%struct.rpc_rqst*)* null, void (%struct.rpc_xprt*, i32)* null }, align 8
@xs_udp_default_timeout = internal constant %struct.rpc_timeout { i64 5000, i64 30000, i64 5000, i32 5, i8 0 }, align 8
@.str.10 = private unnamed_addr constant [4 x i8] c"udp\00", align 1
@.str.11 = private unnamed_addr constant [5 x i8] c"udp6\00", align 1
@xs_connect.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.12 = private unnamed_addr constant [55 x i8] c"\09xprt:\09udp %u %lu %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"add\00", align 1
@xs_tcp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_tcp_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_lock_and_alloc_slot, void (%struct.rpc_task*)* @rpcb_getport_async, void (%struct.rpc_xprt*, i16)* @xs_set_port, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xs_connect, i32 (%struct.rpc_task*)* @rpc_malloc, void (%struct.rpc_task*)* @rpc_free, i32 (%struct.rpc_task*)* @xs_tcp_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @xs_tcp_shutdown, void (%struct.rpc_xprt*)* @xs_destroy, void (%struct.rpc_xprt*, i64, i64)* @xs_tcp_set_connect_timeout, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_tcp_print_stats, i32 (%struct.rpc_xprt*)* @xs_enable_swap, void (%struct.rpc_xprt*)* @xs_disable_swap, void (%struct.rpc_xprt*)* @xs_inject_disconnect, i32 (%struct.rpc_xprt*, i32)* null, i32 (%struct.svc_serv*, %struct.net*)* null, i64 (%struct.rpc_xprt*)* null, void (%struct.rpc_rqst*)* null, void (%struct.rpc_xprt*, i32)* null }, align 8
@xs_tcp_default_timeout = internal constant %struct.rpc_timeout { i64 60000, i64 60000, i64 0, i32 2, i8 0 }, align 8
@.str.14 = private unnamed_addr constant [4 x i8] c"tcp\00", align 1
@.str.15 = private unnamed_addr constant [5 x i8] c"tcp6\00", align 1
@xs_tcp_send_request.__warned = internal global i8 0, section ".data.unlikely", align 1
@__tracepoint_rpc_socket_shutdown = external global %struct.tracepoint, align 8
@.str.16 = private unnamed_addr constant [67 x i8] c"\09xprt:\09tcp %u %lu %lu %lu %ld %lu %lu %lu %llu %llu %lu %llu %llu\0A\00", align 1
@__tracepoint_xs_tcp_data_recv = external global %struct.tracepoint, align 8
@__tracepoint_xs_tcp_data_ready = external global %struct.tracepoint, align 8
@.str.17 = private unnamed_addr constant [41 x i8] c"%s: connect returned unhandled error %d\0A\00", align 1
@__func__.xs_tcp_setup_socket = private unnamed_addr constant [20 x i8] c"xs_tcp_setup_socket\00", align 1
@__tracepoint_rpc_socket_state_change = external global %struct.tracepoint, align 8
@bc_tcp_ops = internal global %struct.rpc_xprt_ops { void (%struct.rpc_xprt*, i64, i64)* null, i32 (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_reserve_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_release_xprt, void (%struct.rpc_xprt*, %struct.rpc_task*)* @xprt_alloc_slot, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*, i16)* null, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, i32 (%struct.rpc_task*)* @bc_malloc, void (%struct.rpc_task*)* @bc_free, i32 (%struct.rpc_task*)* @bc_send_request, void (%struct.rpc_task*)* @xprt_set_retrans_timeout_def, void (%struct.rpc_xprt*, %struct.rpc_task*)* null, void (%struct.rpc_task*)* null, void (%struct.rpc_xprt*)* @bc_close, void (%struct.rpc_xprt*)* @bc_destroy, void (%struct.rpc_xprt*, i64, i64)* null, void (%struct.rpc_xprt*, %struct.seq_file*)* @xs_tcp_print_stats, i32 (%struct.rpc_xprt*)* @xs_enable_swap, void (%struct.rpc_xprt*)* @xs_disable_swap, void (%struct.rpc_xprt*)* @xs_inject_disconnect, i32 (%struct.rpc_xprt*, i32)* null, i32 (%struct.svc_serv*, %struct.net*)* null, i64 (%struct.rpc_xprt*)* null, void (%struct.rpc_rqst*)* null, void (%struct.rpc_xprt*, i32)* null }, align 8
@bc_malloc.__warned = internal global i8 0, section ".data.unlikely", align 1
@.str.18 = private unnamed_addr constant [46 x i8] c"xprtsock: large bc buffer request (size %zu)\0A\00", align 1
@.str.19 = private unnamed_addr constant [34 x i8] c"\015Error sending entire callback!\0A\00", align 1
@phys_base = external global i64, align 8
@llvm.used = appending global [5 x i8*] [i8* bitcast (%struct.kernel_param* @__param_min_resvport to i8*), i8* bitcast (%struct.kernel_param* @__param_max_resvport to i8*), i8* bitcast (%struct.kernel_param* @__param_tcp_slot_table_entries to i8*), i8* bitcast (%struct.kernel_param* @__param_tcp_max_slot_table_entries to i8*), i8* bitcast (%struct.kernel_param* @__param_udp_slot_table_entries to i8*)], section "llvm.metadata"

; Function Attrs: nounwind uwtable
define i32 @init_socket_xprt() #0 {
entry:
  %call = call i32 @xprt_register_transport(%struct.xprt_class* @xs_local_transport)
  %call1 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_udp_transport)
  %call2 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_tcp_transport)
  %call3 = call i32 @xprt_register_transport(%struct.xprt_class* @xs_bc_tcp_transport)
  ret i32 0
}

declare i32 @xprt_register_transport(%struct.xprt_class*) #1

; Function Attrs: nounwind uwtable
define void @cleanup_socket_xprt() #0 {
entry:
  %call = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_local_transport)
  %call1 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_udp_transport)
  %call2 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_tcp_transport)
  %call3 = call i32 @xprt_unregister_transport(%struct.xprt_class* @xs_bc_tcp_transport)
  ret void
}

declare i32 @xprt_unregister_transport(%struct.xprt_class*) #1

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_local(%struct.xprt_create* %args) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %.compoundliteral11 = alloca %struct.atomic64_t, align 8
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !2
  %1 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_un*
  %2 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !9
  %3 = load i32, i32* @xprt_max_tcp_slot_table_entries, align 4, !tbaa !9
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %2, i32 %3)
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %4)
  br i1 %call1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %5 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 0, i32* %prot, align 8, !tbaa !10
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !28
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !29
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 60000, i64* %bind_timeout, align 8, !tbaa !30
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  store i64 3000, i64* %reestablish_timeout, align 8, !tbaa !31
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  store i64 300000, i64* %idle_timeout, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_local_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !33
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_local_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !34
  %recv_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  call void @__init_work(%struct.work_struct* %recv_worker, i32 0)
  %recv_worker2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker2, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !35
  %7 = bitcast %struct.atomic64_t* %data to i8*
  %8 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 8, i32 8, i1 false), !tbaa.struct !36
  %recv_worker3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  %entry4 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker3, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry4)
  %recv_worker5 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker5, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_local_data_receive_workfn, void (%struct.work_struct*)** %func, align 8, !tbaa !38
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %connect_worker8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work9 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker8, i32 0, i32 0
  %data10 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work9, i32 0, i32 0
  %counter12 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral11, i32 0, i32 0
  store i64 68719476704, i64* %counter12, align 8, !tbaa !35
  %9 = bitcast %struct.atomic64_t* %data10 to i8*
  %10 = bitcast %struct.atomic64_t* %.compoundliteral11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 8, i32 8, i1 false), !tbaa.struct !36
  %connect_worker13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work14 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker13, i32 0, i32 0
  %entry15 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work14, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry15)
  %connect_worker16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work17 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker16, i32 0, i32 0
  %func18 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work17, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_dummy_setup_socket, void (%struct.work_struct*)** %func18, align 8, !tbaa !38
  %connect_worker22 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker22, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2097152, i8* null, %struct.lock_class_key* null)
  %connect_worker23 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %timer24 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker23, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer24, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !39
  %connect_worker25 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %11 = ptrtoint %struct.delayed_work* %connect_worker25 to i64
  %connect_worker26 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %timer27 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker26, i32 0, i32 1
  %data28 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer27, i32 0, i32 3
  store i64 %11, i64* %data28, align 8, !tbaa !40
  %sun_family = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %1, i32 0, i32 0
  %12 = load i16, i16* %sun_family, align 2, !tbaa !41
  %conv = zext i16 %12 to i32
  %cond = icmp eq i32 %conv, 1
  br i1 %cond, label %sw.bb, label %out_err.sink.split

sw.bb:                                            ; preds = %if.end
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %1, i32 0, i32 1
  %arrayidx = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i64 0, i64 0
  %13 = load i8, i8* %arrayidx, align 2, !tbaa !43
  %conv33 = sext i8 %13 to i32
  %cmp = icmp ne i32 %conv33, 47
  br i1 %cmp, label %out_err.sink.split, label %if.end40

if.end40:                                         ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str, i32 0, i32 0))
  %call41 = call i32 @xs_local_setup_socket(%struct.sock_xprt* %6)
  %conv42 = sext i32 %call41 to i64
  %call43 = call i8* @ERR_PTR(i64 %conv42)
  %14 = bitcast i8* %call43 to %struct.rpc_xprt*
  %tobool = icmp ne %struct.rpc_xprt* %14, null
  br i1 %tobool, label %out_err, label %do.end49

do.end49:                                         ; preds = %if.end40
  %call50 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call50, label %cleanup, label %out_err.sink.split

out_err.sink.split:                               ; preds = %if.end, %sw.bb, %do.end49
  %.sink = phi i64 [ -22, %do.end49 ], [ -22, %sw.bb ], [ -97, %if.end ]
  %call53 = call i8* @ERR_PTR(i64 %.sink)
  %15 = bitcast i8* %call53 to %struct.rpc_xprt*
  br label %out_err

out_err:                                          ; preds = %out_err.sink.split, %if.end40
  %ret.0 = phi %struct.rpc_xprt* [ %14, %if.end40 ], [ %15, %out_err.sink.split ]
  call void @xs_xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %do.end49, %entry, %out_err
  %retval.0 = phi %struct.rpc_xprt* [ %ret.0, %out_err ], [ %call, %entry ], [ %call, %do.end49 ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #2

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %slot_table_size, i32 %max_slot_table_size) #0 {
entry:
  %addrlen = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %0 = load i64, i64* %addrlen, align 8, !tbaa !44
  %cmp = icmp ugt i64 %0, 128
  br i1 %cmp, label %do.end, label %if.end

do.end:                                           ; preds = %entry
  %call = call i8* @ERR_PTR(i64 -9)
  %1 = bitcast i8* %call to %struct.rpc_xprt*
  br label %cleanup33

if.end:                                           ; preds = %entry
  %net = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 1
  %2 = load %struct.net*, %struct.net** %net, align 8, !tbaa !45
  %call1 = call %struct.rpc_xprt* @xprt_alloc(%struct.net* %2, i64 1744, i32 %slot_table_size, i32 %max_slot_table_size)
  %cmp2 = icmp eq %struct.rpc_xprt* %call1, null
  br i1 %cmp2, label %do.end6, label %if.end8

do.end6:                                          ; preds = %if.end
  %call7 = call i8* @ERR_PTR(i64 -12)
  %3 = bitcast i8* %call7 to %struct.rpc_xprt*
  br label %cleanup33

if.end8:                                          ; preds = %if.end
  %4 = bitcast %struct.rpc_xprt* %call1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %recv_mutex = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 13
  call void @__mutex_init(%struct.mutex* %recv_mutex, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.1, i32 0, i32 0), %struct.lock_class_key* @xs_setup_xprt.__key)
  %addrlen12 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %6 = load i64, i64* %addrlen12, align 8, !tbaa !44
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call1, i32 0, i32 3
  %7 = bitcast %struct.__kernel_sockaddr_storage* %addr to i8*
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %8 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !2
  %9 = bitcast %struct.sockaddr* %8 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %9, i64 %6, i32 2, i1 false)
  %addrlen14 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %10 = load i64, i64* %addrlen14, align 8, !tbaa !44
  %addrlen15 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call1, i32 0, i32 4
  store i64 %10, i64* %addrlen15, align 8, !tbaa !46
  %srcaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 2
  %11 = load %struct.sockaddr*, %struct.sockaddr** %srcaddr, align 8, !tbaa !47
  %tobool = icmp ne %struct.sockaddr* %11, null
  br i1 %tobool, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end8
  %addrlen18 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 4
  %12 = load i64, i64* %addrlen18, align 8, !tbaa !44
  %srcaddr20 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 14
  %13 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr20 to i8*
  %srcaddr21 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 2
  %14 = load %struct.sockaddr*, %struct.sockaddr** %srcaddr21, align 8, !tbaa !47
  %15 = bitcast %struct.sockaddr* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %15, i64 %12, i32 2, i1 false)
  br label %if.end32

if.else:                                          ; preds = %if.end8
  %dstaddr23 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %16 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr23, align 8, !tbaa !2
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %16, i32 0, i32 0
  %17 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %17 to i32
  %srcaddr24 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 14
  %18 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr24 to %struct.sockaddr*
  %call25 = call i32 @xs_init_anyaddr(i32 %conv, %struct.sockaddr* %18)
  %cmp26 = icmp ne i32 %call25, 0
  br i1 %cmp26, label %if.then28, label %cleanup

if.then28:                                        ; preds = %if.else
  call void @xprt_free(%struct.rpc_xprt* %call1)
  %conv29 = sext i32 %call25 to i64
  %call30 = call i8* @ERR_PTR(i64 %conv29)
  %19 = bitcast i8* %call30 to %struct.rpc_xprt*
  br label %cleanup

cleanup:                                          ; preds = %if.else, %if.then28
  %cleanup.dest.slot.0 = phi i32 [ 1, %if.then28 ], [ 0, %if.else ]
  %retval.0 = phi %struct.rpc_xprt* [ %19, %if.then28 ], [ undef, %if.else ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %if.end32, label %cleanup33

if.end32:                                         ; preds = %cleanup, %if.then16
  br label %cleanup33

cleanup33:                                        ; preds = %cleanup, %if.end32, %do.end6, %do.end
  %retval.1 = phi %struct.rpc_xprt* [ %1, %do.end ], [ %3, %do.end6 ], [ %call1, %if.end32 ], [ %retval.0, %cleanup ]
  ret %struct.rpc_xprt* %retval.1
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @IS_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  %1 = inttoptr i64 %0 to i8*
  %2 = ptrtoint i8* %1 to i64
  %cmp = icmp uge i64 %2, -4095
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  ret i1 %tobool
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @__init_work(%struct.work_struct* %work, i32 %onstack) #3 {
entry:
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @INIT_LIST_HEAD(%struct.list_head* %list) #3 {
entry:
  %__u = alloca %union.anon.108, align 8
  %0 = bitcast %union.anon.108* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %__val = bitcast %union.anon.108* %__u to %struct.list_head**
  store %struct.list_head* %list, %struct.list_head** %__val, align 8, !tbaa !43
  %next = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 0
  %1 = bitcast %struct.list_head** %next to i8*
  %__c = bitcast %union.anon.108* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %1, i8* %arraydecay, i32 8)
  %__val1 = bitcast %union.anon.108* %__u to %struct.list_head**
  %2 = load %struct.list_head*, %struct.list_head** %__val1, align 8, !tbaa !43
  %3 = bitcast %union.anon.108* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %prev = getelementptr inbounds %struct.list_head, %struct.list_head* %list, i32 0, i32 1
  store %struct.list_head* %list, %struct.list_head** %prev, align 8, !tbaa !50
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_data_receive_workfn(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1464
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  call void @xs_local_data_receive(%struct.sock_xprt* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_dummy_setup_socket(%struct.work_struct* %work) #0 {
entry:
  ret void
}

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) #1

declare void @delayed_work_timer_fn(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @ERR_PTR(i64 %error) #3 {
entry:
  %0 = inttoptr i64 %error to i8*
  ret i8* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_set_bound(%struct.rpc_xprt* %xprt) #3 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call zeroext i1 @test_and_set_bit(i64 4, i64* %state)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_peer_addresses(%struct.rpc_xprt* %xprt, i8* %protocol, i8* %netid) #0 {
entry:
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 2
  store i8* %protocol, i8** %arrayidx, align 8, !tbaa !51
  %address_strings1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings1, i64 0, i64 5
  store i8* %netid, i8** %arrayidx2, align 8, !tbaa !51
  call void @xs_format_common_peer_addresses(%struct.rpc_xprt* %xprt)
  call void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_setup_socket(%struct.sock_xprt* %transport) #0 {
entry:
  %sock = alloca %struct.socket*, align 8
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %0 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 39
  %1 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !52
  %call = call i32 @__sock_create(%struct.net* %1, i32 1, i32 1, i32 0, %struct.socket** %sock, i32 1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !51
  call void @xs_reclassify_socket(i32 1, %struct.socket* %2)
  %3 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !51
  %call5 = call i32 @xs_local_finish_connecting(%struct.rpc_xprt* %xprt1, %struct.socket* %3)
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !51
  call void @trace_rpc_socket_connect(%struct.rpc_xprt* %xprt1, %struct.socket* %4, i32 %call5)
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %if.end
  %Pivot10 = icmp slt i32 %call5, -2
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %call5, 0
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %call5, 0
  br i1 %SwitchLeaf6, label %do.end8, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %call5, -2
  br i1 %SwitchLeaf4, label %out, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %call5, -105
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call5, -105
  br i1 %SwitchLeaf2, label %out, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call5, -111
  br i1 %SwitchLeaf, label %out, label %NewDefault

do.end8:                                          ; preds = %LeafBlock5
  call void @xprt_set_connected(%struct.rpc_xprt* %xprt1)
  br label %out

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %sub = sub nsw i32 0, %call5
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt1, i32 0, i32 41
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 0
  %5 = load i8*, i8** %arrayidx, align 8, !tbaa !51
  %call17 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.xs_local_setup_socket, i32 0, i32 0), i32 %sub, i8* %5)
  br label %out

out:                                              ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock, %do.end8, %sw.default, %entry
  %status.0 = phi i32 [ %call, %entry ], [ %call5, %LeafBlock ], [ %call5, %LeafBlock1 ], [ %call5, %sw.default ], [ %call5, %do.end8 ], [ %call5, %LeafBlock3 ]
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt1)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt1, i32 %status.0)
  %6 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  ret i32 %status.0
}

declare zeroext i1 @try_module_get(%struct.module*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_xprt_free(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void @xs_free_peer_addresses(%struct.rpc_xprt* %xprt)
  call void @xprt_free(%struct.rpc_xprt* %xprt)
  ret void
}

declare %struct.rpc_xprt* @xprt_alloc(%struct.net*, i64, i32, i32) #1

declare void @__mutex_init(%struct.mutex*, i8*, %struct.lock_class_key*) #1

; Function Attrs: nounwind uwtable
define internal i32 @xs_init_anyaddr(i32 %family, %struct.sockaddr* %sap) #0 {
entry:
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %entry
  %Pivot6 = icmp slt i32 %family, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %family, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %family, 10
  br i1 %SwitchLeaf4, label %sw.bb1, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %family, 2
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %family, 1
  br i1 %SwitchLeaf, label %sw.epilog, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %cmp = icmp uge i64 16, 64
  %0 = bitcast %struct.sockaddr* %sap to i8*
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %call = call i8* @__memcpy(i8* %0, i8* bitcast (%struct.sockaddr_in* @xs_init_anyaddr.sin to i8*), i64 16)
  br label %sw.epilog

if.else:                                          ; preds = %sw.bb
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast (%struct.sockaddr_in* @xs_init_anyaddr.sin to i8*), i64 16, i32 2, i1 false)
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock3
  %cmp4 = icmp uge i64 28, 64
  %1 = bitcast %struct.sockaddr* %sap to i8*
  br i1 %cmp4, label %if.then5, label %if.else7

if.then5:                                         ; preds = %sw.bb1
  %call6 = call i8* @__memcpy(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @xs_init_anyaddr.sin6 to i8*), i64 28)
  br label %sw.epilog

if.else7:                                         ; preds = %sw.bb1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ({ i16, i16, i32, { { [16 x i8] } }, i32 }* @xs_init_anyaddr.sin6 to i8*), i64 28, i32 2, i1 false)
  br label %sw.epilog

sw.epilog:                                        ; preds = %LeafBlock, %if.then5, %if.else7, %if.then, %if.else
  br label %return

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %return

return:                                           ; preds = %NewDefault, %sw.epilog
  %retval.0 = phi i32 [ 0, %sw.epilog ], [ -97, %NewDefault ]
  ret i32 %retval.0
}

declare void @xprt_free(%struct.rpc_xprt*) #1

declare i8* @__memcpy(i8*, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @llvm.expect.i64(i64, i64) #4

declare i32 @xprt_reserve_xprt(%struct.rpc_xprt*, %struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_release_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %snd_task = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 35
  %0 = load %struct.rpc_task*, %struct.rpc_task** %snd_task, align 8, !tbaa !53
  %cmp = icmp ne %struct.rpc_task* %task, %0
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %cmp1 = icmp eq %struct.rpc_task* %task, null
  br i1 %cmp1, label %out_release, label %if.end3

if.end3:                                          ; preds = %if.end
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %1 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %cmp4 = icmp eq %struct.rpc_rqst* %1, null
  br i1 %cmp4, label %out_release, label %if.end6

if.end6:                                          ; preds = %if.end3
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 25
  %2 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !57
  %cmp7 = icmp eq i32 %2, 0
  br i1 %cmp7, label %out_release, label %if.end9

if.end9:                                          ; preds = %if.end6
  %rq_bytes_sent10 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 25
  %3 = load i32, i32* %rq_bytes_sent10, align 8, !tbaa !57
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %1, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  %4 = load i32, i32* %len, align 8, !tbaa !60
  %cmp11 = icmp eq i32 %3, %4
  br i1 %cmp11, label %out_release, label %if.end13

if.end13:                                         ; preds = %if.end9
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @set_bit(i64 3, i64* %state)
  br label %out_release

out_release:                                      ; preds = %if.end9, %if.end6, %if.end3, %if.end, %if.end13
  call void @xprt_release_xprt(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %out_release, %entry
  ret void
}

declare void @xprt_alloc_slot(%struct.rpc_xprt*, %struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_local_rpcbind(%struct.rpc_task* %task) #0 {
entry:
  %tk_xprt = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 13
  %0 = load %struct.rpc_xprt*, %struct.rpc_xprt** %tk_xprt, align 8, !tbaa !61
  call void @xprt_set_bound(%struct.rpc_xprt* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_set_port(%struct.rpc_xprt* %xprt, i16 zeroext %port) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_connect(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 18
  %2 = load i16, i16* %tk_flags, align 4, !tbaa !62
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @rpc_exit(%struct.rpc_task* %task, i32 -107)
  br label %cleanup.cont

if.end:                                           ; preds = %entry
  %call = call i32 @xs_local_setup_socket(%struct.sock_xprt* %1)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %land.lhs.true, label %cleanup.cont

land.lhs.true:                                    ; preds = %if.end
  %tk_flags2 = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 18
  %3 = load i16, i16* %tk_flags2, align 4, !tbaa !62
  %conv3 = zext i16 %3 to i32
  %and4 = and i32 %conv3, 1024
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %cleanup.cont, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %call7 = call i64 @msleep_interruptible(i32 15000)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then, %if.then6, %land.lhs.true, %if.end
  ret void
}

declare i32 @rpc_malloc(%struct.rpc_task*) #1

declare void @rpc_free(%struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_send_request(%struct.rpc_task* %task) #0 {
entry:
  %sent = alloca i32, align 4
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !63
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %4 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #7
  store i32 0, i32* %sent, align 4, !tbaa !9
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf1)
  %rq_snd_buf2 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay, i32 0, i32 0
  %5 = load i8*, i8** %iov_base, align 8, !tbaa !64
  %6 = bitcast i8* %5 to i32*
  %rq_snd_buf3 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head4 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf3, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head4, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay5, i32 0, i32 1
  %7 = load i64, i64* %iov_len, align 8, !tbaa !66
  %conv = trunc i64 %7 to i32
  call void @xs_pktdump(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.2, i32 0, i32 0), i32* %6, i32 %conv)
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %8 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !67
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %9 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !57
  %call = call i32 @xs_sendpages(%struct.socket* %8, %struct.sockaddr* null, i32 0, %struct.xdr_buf* %rq_snd_buf, i32 %9, i1 zeroext true, i32* %sent)
  %cmp = icmp eq i32 %call, -11
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %10 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %call7 = call zeroext i1 @sock_writeable(%struct.sock* %10)
  %.call = select i1 %call7, i32 -105, i32 %call
  br label %if.end

if.end:                                           ; preds = %land.lhs.true, %entry
  %status.0 = phi i32 [ %call, %entry ], [ %.call, %land.lhs.true ]
  %11 = load i32, i32* %sent, align 4, !tbaa !9
  %cmp9 = icmp sgt i32 %11, 0
  %lnot = xor i1 %cmp9, true
  %lnot11 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 1)
  %tobool = icmp ne i64 %expval, 0
  %cmp13 = icmp eq i32 %status.0, 0
  %or.cond = or i1 %tobool, %cmp13
  br i1 %or.cond, label %if.then15, label %if.end33

if.then15:                                        ; preds = %if.end
  %12 = load i32, i32* %sent, align 4, !tbaa !9
  %rq_bytes_sent16 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %13 = load i32, i32* %rq_bytes_sent16, align 8, !tbaa !57
  %add = add i32 %13, %12
  store i32 %add, i32* %rq_bytes_sent16, align 8, !tbaa !57
  %14 = load i32, i32* %sent, align 4, !tbaa !9
  %conv17 = sext i32 %14 to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 17
  %15 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !74
  %add18 = add i64 %15, %conv17
  store i64 %add18, i64* %rq_xmit_bytes_sent, align 8, !tbaa !74
  %rq_bytes_sent19 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %16 = load i32, i32* %rq_bytes_sent19, align 8, !tbaa !57
  %rq_snd_buf20 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf20, i32 0, i32 7
  %17 = load i32, i32* %len, align 8, !tbaa !60
  %cmp21 = icmp uge i32 %16, %17
  %lnot23 = xor i1 %cmp21, true
  %lnot25 = xor i1 %lnot23, true
  %lnot.ext26 = zext i1 %lnot25 to i32
  %conv27 = sext i32 %lnot.ext26 to i64
  %expval28 = call i64 @llvm.expect.i64(i64 %conv27, i64 1)
  %tobool29 = icmp ne i64 %expval28, 0
  br i1 %tobool29, label %if.then30, label %if.end33

if.then30:                                        ; preds = %if.then15
  %rq_bytes_sent31 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  store i32 0, i32* %rq_bytes_sent31, align 8, !tbaa !57
  br label %cleanup

if.end33:                                         ; preds = %if.then15, %if.end
  %status.1 = phi i32 [ %status.0, %if.end ], [ -11, %if.then15 ]
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end33
  %Pivot = icmp slt i32 %status.1, -11
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %status.1, -11
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %status.1, -105
  br i1 %SwitchLeaf, label %cleanup, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %call34 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.bb38

sw.bb38:                                          ; preds = %NewDefault
  call void @xs_close(%struct.rpc_xprt* %1)
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock, %sw.bb, %sw.bb38, %if.then30
  %retval.0 = phi i32 [ 0, %if.then30 ], [ -107, %sw.bb38 ], [ %call34, %sw.bb ], [ %status.1, %LeafBlock ]
  %18 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %18) #7
  ret i32 %retval.0
}

declare void @xprt_set_retrans_timeout_def(%struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_close(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  call void @xs_reset_transport(%struct.sock_xprt* %1)
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !31
  call void @xprt_disconnect_done(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_destroy(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 11
  %call = call zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work* %connect_worker)
  call void @xs_close(%struct.rpc_xprt* %xprt)
  %recv_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 12
  %call1 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %recv_worker)
  call void @xs_xprt_free(%struct.rpc_xprt* %xprt)
  call void @module_put(%struct.module* null)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #0 {
entry:
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !37
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 28
  %1 = load i64, i64* %last_used, align 8, !tbaa !75
  %sub = sub i64 %0, %1
  %div = sdiv i64 %sub, 1000
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %idle_time.0 = phi i64 [ %div, %if.then ], [ 0, %entry ]
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bind_count = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat, i32 0, i32 0
  %2 = load i64, i64* %bind_count, align 8, !tbaa !76
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_count = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat1, i32 0, i32 1
  %3 = load i64, i64* %connect_count, align 8, !tbaa !77
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_time = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat2, i32 0, i32 3
  %4 = load i64, i64* %connect_time, align 8, !tbaa !78
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %sends = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat3, i32 0, i32 4
  %5 = load i64, i64* %sends, align 8, !tbaa !79
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %recvs = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat4, i32 0, i32 5
  %6 = load i64, i64* %recvs, align 8, !tbaa !80
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bad_xids = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat5, i32 0, i32 6
  %7 = load i64, i64* %bad_xids, align 8, !tbaa !81
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %req_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat6, i32 0, i32 8
  %8 = load i64, i64* %req_u, align 8, !tbaa !82
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bklog_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat7, i32 0, i32 9
  %9 = load i64, i64* %bklog_u, align 8, !tbaa !83
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %max_slots = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat8, i32 0, i32 7
  %10 = load i64, i64* %max_slots, align 8, !tbaa !84
  %stat9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %sending_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat9, i32 0, i32 10
  %11 = load i64, i64* %sending_u, align 8, !tbaa !85
  %stat10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %pending_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat10, i32 0, i32 11
  %12 = load i64, i64* %pending_u, align 8, !tbaa !86
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.3, i32 0, i32 0), i64 %2, i64 %3, i64 %4, i64 %idle_time.0, i64 %5, i64 %6, i64 %7, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_enable_swap(%struct.rpc_xprt* %xprt) #0 {
entry:
  ret i32 -22
}

; Function Attrs: nounwind uwtable
define internal void @xs_disable_swap(%struct.rpc_xprt* %xprt) #0 {
entry:
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @set_bit(i64 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #7, !srcloc !87
  ret void
}

declare void @xprt_release_xprt(%struct.rpc_xprt*, %struct.rpc_task*) #1

declare void @rpc_exit(%struct.rpc_task*, i32) #1

declare i64 @msleep_interruptible(i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_encode_stream_record_marker(%struct.xdr_buf* %buf) #3 {
entry:
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !88
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 4
  %conv1 = trunc i64 %sub to i32
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 0
  %1 = load i8*, i8** %iov_base, align 8, !tbaa !64
  %2 = bitcast i8* %1 to i32*
  %or = or i32 -2147483648, %conv1
  %call = call i32 @__fswab32(i32 %or) #4
  store i32 %call, i32* %2, align 4, !tbaa !9
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_pktdump(i8* %msg, i32* %packet, i32 %count) #3 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_sendpages(%struct.socket* %sock, %struct.sockaddr* %addr, i32 %addrlen, %struct.xdr_buf* %xdr, i32 %base, i1 zeroext %zerocopy, i32* %sent_p) #0 {
entry:
  %sent = alloca i32, align 4
  %frombool = zext i1 %zerocopy to i8
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 7
  %0 = load i32, i32* %len, align 8, !tbaa !88
  %sub = sub i32 %0, %base
  %1 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  store i32 0, i32* %sent, align 4, !tbaa !9
  %tobool = icmp ne %struct.socket* %sock, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %cleanup80, label %if.end

if.end:                                           ; preds = %entry
  %cmp = icmp ne i32 %base, 0
  %.addrlen = select i1 %cmp, i32 0, i32 %addrlen
  %.addr = select i1 %cmp, %struct.sockaddr* null, %struct.sockaddr* %addr
  %conv7 = zext i32 %base to i64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 1
  %2 = load i64, i64* %iov_len, align 8, !tbaa !66
  %cmp8 = icmp ult i64 %conv7, %2
  %cmp10 = icmp ne %struct.sockaddr* %.addr, null
  %or.cond = or i1 %cmp8, %cmp10
  %head14 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx15 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head14, i64 0, i64 0
  %iov_len16 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx15, i32 0, i32 1
  %3 = load i64, i64* %iov_len16, align 8, !tbaa !66
  %conv17 = zext i32 %base to i64
  br i1 %or.cond, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %sub18 = sub i64 %3, %conv17
  %conv19 = trunc i64 %sub18 to i32
  %sub20 = sub i32 %sub, %conv19
  %head21 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 0
  %arrayidx22 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head21, i64 0, i64 0
  %cmp23 = icmp ne i32 %sub20, 0
  %conv24 = zext i1 %cmp23 to i32
  %call = call i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* %.addr, i32 %.addrlen, %struct.kvec* %arrayidx22, i32 %base, i32 %conv24)
  %cmp25 = icmp eq i32 %sub20, 0
  %cmp28 = icmp ne i32 %call, %conv19
  %or.cond1 = or i1 %cmp25, %cmp28
  br i1 %or.cond1, label %cleanup, label %if.end31

if.end31:                                         ; preds = %if.then12
  %4 = load i32, i32* %sent_p, align 4, !tbaa !9
  %add = add nsw i32 %4, %call
  store i32 %add, i32* %sent_p, align 4, !tbaa !9
  br label %cleanup

cleanup:                                          ; preds = %if.then12, %if.end31
  %base.addr.0 = phi i32 [ 0, %if.end31 ], [ %base, %if.then12 ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end31 ], [ 2, %if.then12 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %if.end38, label %out

if.else:                                          ; preds = %if.end
  %sub36 = sub i64 %conv17, %3
  %conv37 = trunc i64 %sub36 to i32
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %if.else
  %remainder.0 = phi i32 [ %sub, %if.else ], [ %sub20, %cleanup ]
  %base.addr.1 = phi i32 [ %conv37, %if.else ], [ %base.addr.0, %cleanup ]
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %5 = load i32, i32* %page_len, align 4, !tbaa !89
  %cmp39 = icmp ult i32 %base.addr.1, %5
  %page_len43 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %6 = load i32, i32* %page_len43, align 4, !tbaa !89
  br i1 %cmp39, label %if.then41, label %if.else61

if.then41:                                        ; preds = %if.end38
  %sub44 = sub i32 %6, %base.addr.1
  %sub45 = sub i32 %remainder.0, %sub44
  %cmp46 = icmp ne i32 %sub45, 0
  %conv47 = zext i1 %cmp46 to i32
  %tobool48 = trunc i8 %frombool to i1
  %call49 = call i32 @xs_send_pagedata(%struct.socket* %sock, %struct.xdr_buf* %xdr, i32 %base.addr.1, i32 %conv47, i1 zeroext %tobool48, i32* %sent)
  %7 = load i32, i32* %sent, align 4, !tbaa !9
  %8 = load i32, i32* %sent_p, align 4, !tbaa !9
  %add50 = add nsw i32 %8, %7
  store i32 %add50, i32* %sent_p, align 4, !tbaa !9
  %cmp51 = icmp eq i32 %sub45, 0
  %9 = load i32, i32* %sent, align 4
  %cmp54 = icmp ne i32 %9, %sub44
  %or.cond3 = or i1 %cmp51, %cmp54
  %base.addr.2 = select i1 %or.cond3, i32 %base.addr.1, i32 0
  br i1 %or.cond3, label %out, label %if.end64

if.else61:                                        ; preds = %if.end38
  %sub63 = sub i32 %base.addr.1, %6
  br label %if.end64

if.end64:                                         ; preds = %if.then41, %if.else61
  %base.addr.3 = phi i32 [ %sub63, %if.else61 ], [ %base.addr.2, %if.then41 ]
  %conv65 = zext i32 %base.addr.3 to i64
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx66 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail, i64 0, i64 0
  %iov_len67 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx66, i32 0, i32 1
  %10 = load i64, i64* %iov_len67, align 8, !tbaa !66
  %cmp68 = icmp uge i64 %conv65, %10
  br i1 %cmp68, label %cleanup80, label %if.end71

if.end71:                                         ; preds = %if.end64
  %tail72 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 1
  %arrayidx73 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail72, i64 0, i64 0
  %call74 = call i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* null, i32 0, %struct.kvec* %arrayidx73, i32 %base.addr.3, i32 0)
  br label %out

out:                                              ; preds = %if.then41, %cleanup, %if.end71
  %err.0 = phi i32 [ %call, %cleanup ], [ %call49, %if.then41 ], [ %call74, %if.end71 ]
  %cmp75 = icmp sgt i32 %err.0, 0
  br i1 %cmp75, label %if.then77, label %cleanup80

if.then77:                                        ; preds = %out
  %11 = load i32, i32* %sent_p, align 4, !tbaa !9
  %add78 = add nsw i32 %11, %err.0
  store i32 %add78, i32* %sent_p, align 4, !tbaa !9
  br label %cleanup80

cleanup80:                                        ; preds = %out, %if.then77, %if.end64, %entry
  %retval.0 = phi i32 [ -88, %entry ], [ 0, %if.end64 ], [ 0, %if.then77 ], [ %err.0, %out ]
  %12 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #7
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @sock_writeable(%struct.sock* %sk) #3 {
entry:
  %sk_wmem_alloc = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 19
  %call = call i32 @atomic_read(%struct.atomic_t* %sk_wmem_alloc)
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 17
  %0 = load i32, i32* %sk_sndbuf, align 4, !tbaa !90
  %shr = ashr i32 %0, 1
  %cmp = icmp slt i32 %call, %shr
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_nospace(%struct.rpc_task* %task) #0 {
entry:
  %__u = alloca %union.anon.106, align 8
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !63
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %4 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 32
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sk_write_pending = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 24
  %5 = load i32, i32* %sk_write_pending, align 4, !tbaa !104
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %sk_write_pending, align 4, !tbaa !104
  call void @xprt_wait_for_buffer_space(%struct.rpc_task* %task, void (%struct.rpc_task*)* @xs_nospace_callback)
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  %ret.0 = phi i32 [ -11, %if.then ], [ -107, %entry ]
  %transport_lock1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock1)
  %cmp = icmp eq i32 %ret.0, -11
  br i1 %cmp, label %if.then2, label %if.end12

if.then2:                                         ; preds = %if.end
  call void @rcu_read_lock()
  %6 = bitcast %union.anon.106* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #7
  %7 = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 12
  %sk_wq = bitcast %union.anon.50* %7 to %struct.socket_wq**
  %8 = bitcast %struct.socket_wq** %sk_wq to i8*
  %__c = bitcast %union.anon.106* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %8, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.106* %__u to %struct.socket_wq**
  %9 = load %struct.socket_wq*, %struct.socket_wq** %__val, align 8, !tbaa !43
  %10 = bitcast %union.anon.106* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %flags = getelementptr inbounds %struct.socket_wq, %struct.socket_wq* %9, i32 0, i32 2
  call void @set_bit(i64 0, i64* %flags)
  call void @rcu_read_unlock()
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 64
  %11 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !105
  call void %11(%struct.sock* %4)
  br label %if.end12

if.end12:                                         ; preds = %if.then2, %if.end
  ret i32 %ret.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__fswab32(i32 %val) #6 {
entry:
  %call = call i32 @__arch_swab32(i32 %val) #4
  ret i32 %call
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal i32 @__arch_swab32(i32 %val) #6 {
entry:
  %0 = call i32 asm "bswapl $0", "=r,0,~{dirflag},~{fpsr},~{flags}"(i32 %val) #4, !srcloc !106
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_send_kvec(%struct.socket* %sock, %struct.sockaddr* %addr, i32 %addrlen, %struct.kvec* %vec, i32 %base, i32 %more) #0 {
entry:
  %msg = alloca %struct.msghdr, align 8
  %iov = alloca %struct.kvec, align 8
  %0 = bitcast %struct.msghdr* %msg to i8*
  call void @llvm.lifetime.start.p0i8(i64 88, i8* %0) #7
  %1 = bitcast %struct.msghdr* %msg to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 88, i32 8, i1 false)
  %msg_name = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 0
  %2 = bitcast %struct.sockaddr* %addr to i8*
  store i8* %2, i8** %msg_name, align 8, !tbaa !107
  %msg_namelen = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 1
  store i32 %addrlen, i32* %msg_namelen, align 8, !tbaa !110
  %msg_flags = getelementptr inbounds %struct.msghdr, %struct.msghdr* %msg, i32 0, i32 5
  %tobool = icmp ne i32 %more, 0
  %3 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 32768, i32 0
  %or = or i32 16448, %cond
  store i32 %or, i32* %msg_flags, align 8, !tbaa !111
  %4 = bitcast %struct.kvec* %iov to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* %4) #7
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 0
  %iov_base1 = getelementptr inbounds %struct.kvec, %struct.kvec* %vec, i32 0, i32 0
  %5 = load i8*, i8** %iov_base1, align 8, !tbaa !64
  %idx.ext = zext i32 %base to i64
  %add.ptr = getelementptr i8, i8* %5, i64 %idx.ext
  store i8* %add.ptr, i8** %iov_base, align 8, !tbaa !64
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 1
  %iov_len2 = getelementptr inbounds %struct.kvec, %struct.kvec* %vec, i32 0, i32 1
  %6 = load i64, i64* %iov_len2, align 8, !tbaa !66
  %conv = zext i32 %base to i64
  %sub = sub i64 %6, %conv
  store i64 %sub, i64* %iov_len, align 8, !tbaa !66
  %iov_len3 = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 1
  %7 = load i64, i64* %iov_len3, align 8, !tbaa !66
  %cmp = icmp ne i64 %7, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %iov_len5 = getelementptr inbounds %struct.kvec, %struct.kvec* %iov, i32 0, i32 1
  %8 = load i64, i64* %iov_len5, align 8, !tbaa !66
  %call = call i32 @kernel_sendmsg(%struct.socket* %sock, %struct.msghdr* %msg, %struct.kvec* %iov, i64 1, i64 %8)
  br label %cleanup

if.end:                                           ; preds = %entry
  %call6 = call i32 @kernel_sendmsg(%struct.socket* %sock, %struct.msghdr* %msg, %struct.kvec* null, i64 0, i64 0)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %retval.0 = phi i32 [ %call, %if.then ], [ %call6, %if.end ]
  %9 = bitcast %struct.kvec* %iov to i8*
  call void @llvm.lifetime.end.p0i8(i64 16, i8* %9) #7
  %10 = bitcast %struct.msghdr* %msg to i8*
  call void @llvm.lifetime.end.p0i8(i64 88, i8* %10) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_send_pagedata(%struct.socket* %sock, %struct.xdr_buf* %xdr, i32 %base, i32 %more, i1 zeroext %zerocopy, i32* %sent_p) #0 {
entry:
  %__UNIQUE_ID_min1_56 = alloca i32, align 4
  %__UNIQUE_ID_min2_57 = alloca i32, align 4
  %frombool = zext i1 %zerocopy to i8
  %page_len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 4
  %0 = load i32, i32* %page_len, align 4, !tbaa !89
  %sub = sub i32 %0, %base
  %page_base = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 3
  %1 = load i32, i32* %page_base, align 8, !tbaa !112
  %add = add i32 %base, %1
  %pages = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %xdr, i32 0, i32 2
  %2 = load %struct.page**, %struct.page*** %pages, align 8, !tbaa !113
  %shr = lshr i32 %add, 12
  %idx.ext = zext i32 %shr to i64
  %add.ptr = getelementptr inbounds %struct.page*, %struct.page** %2, i64 %idx.ext
  %conv = zext i32 %add to i64
  %and = and i64 %conv, 4095
  %conv1 = trunc i64 %and to i32
  %ops = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 6
  %3 = load %struct.proto_ops*, %struct.proto_ops** %ops, align 8, !tbaa !114
  %sendpage = getelementptr inbounds %struct.proto_ops, %struct.proto_ops* %3, i32 0, i32 20
  %4 = load i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)** %sendpage, align 8, !tbaa !116
  %tobool = trunc i8 %frombool to i1
  %.sock_no_sendpage = select i1 %tobool, i64 (%struct.socket*, %struct.page*, i32, i64, i32)* %4, i64 (%struct.socket*, %struct.page*, i32, i64, i32)* @sock_no_sendpage
  br label %for.cond

for.cond:                                         ; preds = %cleanup.cont, %entry
  %ppage.0 = phi %struct.page** [ %add.ptr, %entry ], [ %ppage.1, %cleanup.cont ]
  %remainder.0 = phi i32 [ %sub, %entry ], [ %sub8, %cleanup.cont ]
  %base.addr.0 = phi i32 [ %conv1, %entry ], [ %base.addr.1, %cleanup.cont ]
  %5 = bitcast i32* %__UNIQUE_ID_min1_56 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #7
  %conv2 = zext i32 %base.addr.0 to i64
  %sub3 = sub i64 4096, %conv2
  %conv4 = trunc i64 %sub3 to i32
  store i32 %conv4, i32* %__UNIQUE_ID_min1_56, align 4, !tbaa !9
  %6 = bitcast i32* %__UNIQUE_ID_min2_57 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #7
  store i32 %remainder.0, i32* %__UNIQUE_ID_min2_57, align 4, !tbaa !9
  %cmp = icmp eq i32* %__UNIQUE_ID_min1_56, %__UNIQUE_ID_min2_57
  %conv5 = zext i1 %cmp to i32
  %7 = load i32, i32* %__UNIQUE_ID_min1_56, align 4, !tbaa !9
  %8 = load i32, i32* %__UNIQUE_ID_min2_57, align 4, !tbaa !9
  %cmp6 = icmp ult i32 %7, %8
  %9 = load i32, i32* %__UNIQUE_ID_min1_56, align 4
  %10 = load i32, i32* %__UNIQUE_ID_min2_57, align 4
  %cond = select i1 %cmp6, i32 %9, i32 %10
  %11 = bitcast i32* %__UNIQUE_ID_min2_57 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %11) #7
  %12 = bitcast i32* %__UNIQUE_ID_min1_56 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #7
  %sub8 = sub i32 %remainder.0, %cond
  %tobool9 = icmp ne i32 %more, 0
  %or = or i32 16448, 32768
  %or. = select i1 %tobool9, i32 %or, i32 16448
  %cmp12 = icmp ne i32 %sub8, 0
  %or15 = or i32 %or., 163840
  %flags.1 = select i1 %cmp12, i32 %or15, i32 %or.
  %13 = load %struct.page*, %struct.page** %ppage.0, align 8, !tbaa !51
  %conv17 = zext i32 %cond to i64
  %call = call i64 %.sock_no_sendpage(%struct.socket* %sock, %struct.page* %13, i32 %base.addr.0, i64 %conv17, i32 %flags.1)
  %conv18 = trunc i64 %call to i32
  %cmp19 = icmp eq i32 %sub8, 0
  %cmp21 = icmp ne i32 %conv18, %cond
  %or.cond = or i1 %cmp19, %cmp21
  br i1 %or.cond, label %cleanup, label %if.end24

if.end24:                                         ; preds = %for.cond
  %14 = load i32, i32* %sent_p, align 4, !tbaa !9
  %add25 = add nsw i32 %14, %conv18
  store i32 %add25, i32* %sent_p, align 4, !tbaa !9
  %incdec.ptr = getelementptr inbounds %struct.page*, %struct.page** %ppage.0, i32 1
  br label %cleanup

cleanup:                                          ; preds = %for.cond, %if.end24
  %ppage.1 = phi %struct.page** [ %incdec.ptr, %if.end24 ], [ %ppage.0, %for.cond ]
  %base.addr.1 = phi i32 [ 0, %if.end24 ], [ %base.addr.0, %for.cond ]
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end24 ], [ 2, %for.cond ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %cleanup.cont, label %for.end

cleanup.cont:                                     ; preds = %cleanup
  br label %for.cond

for.end:                                          ; preds = %cleanup
  %cmp27 = icmp sgt i32 %conv18, 0
  br i1 %cmp27, label %if.then29, label %if.end31

if.then29:                                        ; preds = %for.end
  %15 = load i32, i32* %sent_p, align 4, !tbaa !9
  %add30 = add nsw i32 %15, %conv18
  store i32 %add30, i32* %sent_p, align 4, !tbaa !9
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %for.end
  %err.0 = phi i32 [ 0, %if.then29 ], [ %conv18, %for.end ]
  ret i32 %err.0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #2

declare i32 @kernel_sendmsg(%struct.socket*, %struct.msghdr*, %struct.kvec*, i64, i64) #1

declare i64 @sock_no_sendpage(%struct.socket*, %struct.page*, i32, i64, i32) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @atomic_read(%struct.atomic_t* %v) #5 {
entry:
  %__u = alloca %union.anon.105, align 4
  %0 = bitcast %union.anon.105* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %counter = getelementptr inbounds %struct.atomic_t, %struct.atomic_t* %v, i32 0, i32 0
  %1 = bitcast i32* %counter to i8*
  %__c = bitcast %union.anon.105* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %1, i8* %arraydecay, i32 4)
  %__val = bitcast %union.anon.105* %__u to i32*
  %2 = load i32, i32* %__val, align 4, !tbaa !43
  %3 = bitcast %union.anon.105* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #7
  ret i32 %2
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__read_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load volatile i8, i8* %p, align 1, !tbaa !43
  store i8 %0, i8* %res, align 1, !tbaa !43
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %p to i16*
  %2 = load volatile i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %res to i16*
  store i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %p to i32*
  %5 = load volatile i32, i32* %4, align 4, !tbaa !9
  %6 = bitcast i8* %res to i32*
  store i32 %5, i32* %6, align 4, !tbaa !9
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %p to i64*
  %8 = load volatile i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %res to i64*
  store i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !120
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %res, i8* %p, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !121
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock_bh(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_connected(%struct.rpc_xprt* %xprt) #3 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call zeroext i1 @constant_test_bit(i64 1, i64* %state)
  %conv = zext i1 %call to i32
  ret i32 %conv
}

declare void @xprt_wait_for_buffer_space(%struct.rpc_task*, void (%struct.rpc_task*)*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_nospace_callback(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !63
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %4 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %sk_write_pending = getelementptr inbounds %struct.sock, %struct.sock* %4, i32 0, i32 24
  %5 = load i32, i32* %sk_write_pending, align 4, !tbaa !104
  %dec = add nsw i32 %5, -1
  store i32 %dec, i32* %sk_write_pending, align 4, !tbaa !104
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock_bh(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @_raw_spin_unlock_bh(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock() #3 {
entry:
  call void @__rcu_read_lock()
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock() #3 {
entry:
  call void @__rcu_read_unlock()
  ret void
}

declare void @_raw_spin_lock_bh(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @constant_test_bit(i64 %nr, i64* %addr) #5 {
entry:
  %and = and i64 %nr, 63
  %shl = shl i64 1, %and
  %shr = ashr i64 %nr, 6
  %arrayidx = getelementptr inbounds i64, i64* %addr, i64 %shr
  %0 = load volatile i64, i64* %arrayidx, align 8, !tbaa !37
  %and1 = and i64 %shl, %0
  %cmp = icmp ne i64 %and1, 0
  ret i1 %cmp
}

declare void @_raw_spin_unlock_bh(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_lock() #3 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @__rcu_read_unlock() #3 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_reset_transport(%struct.sock_xprt* %transport) #0 {
entry:
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  %0 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !67
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %1 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %xprt2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %cmp = icmp eq %struct.sock* %1, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %xprt3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %swapper = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt3, i32 0, i32 20
  %call = call i32 @atomic_read(%struct.atomic_t* %swapper)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @sk_clear_memalloc(%struct.sock* %1)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %call6 = call i32 @kernel_sock_shutdown(%struct.socket* %0, i32 2)
  %recv_mutex = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_lock(%struct.mutex* %recv_mutex)
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 44
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %inet7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  store %struct.sock* null, %struct.sock** %inet7, align 8, !tbaa !73
  %sock8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 1
  store %struct.socket* null, %struct.socket** %sock8, align 8, !tbaa !67
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 58
  store i8* null, i8** %sk_user_data, align 8, !tbaa !122
  call void @xs_restore_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %1)
  call void @xprt_clear_connected(%struct.rpc_xprt* %xprt2)
  %sk_callback_lock9 = getelementptr inbounds %struct.sock, %struct.sock* %1, i32 0, i32 44
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock9)
  call void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt2)
  %recv_mutex10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %recv_mutex10)
  call void @trace_rpc_socket_close(%struct.rpc_xprt* %xprt2, %struct.socket* %0)
  call void @sock_release(%struct.socket* %0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end5, %entry
  ret void
}

declare void @xprt_disconnect_done(%struct.rpc_xprt*) #1

declare void @sk_clear_memalloc(%struct.sock*) #1

declare i32 @kernel_sock_shutdown(%struct.socket*, i32) #1

declare void @mutex_lock(%struct.mutex*) #1

declare void @_raw_write_lock_bh(%struct.rwlock_t*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @xs_restore_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %sk) #0 {
entry:
  %old_data_ready = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 19
  %0 = load void (%struct.sock*)*, void (%struct.sock*)** %old_data_ready, align 8, !tbaa !123
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 63
  store void (%struct.sock*)* %0, void (%struct.sock*)** %sk_data_ready, align 8, !tbaa !124
  %old_state_change = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 20
  %1 = load void (%struct.sock*)*, void (%struct.sock*)** %old_state_change, align 8, !tbaa !125
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 62
  store void (%struct.sock*)* %1, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !126
  %old_write_space = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 21
  %2 = load void (%struct.sock*)*, void (%struct.sock*)** %old_write_space, align 8, !tbaa !127
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 64
  store void (%struct.sock*)* %2, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !105
  %old_error_report = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 22
  %3 = load void (%struct.sock*)*, void (%struct.sock*)** %old_error_report, align 8, !tbaa !128
  %sk_error_report = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 65
  store void (%struct.sock*)* %3, void (%struct.sock*)** %sk_error_report, align 8, !tbaa !129
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_connected(%struct.rpc_xprt* %xprt) #3 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i64 1, i64* %state)
  ret void
}

declare void @_raw_write_unlock_bh(%struct.rwlock_t*) #1 section ".spinlock.text"

; Function Attrs: nounwind uwtable
define internal void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !130
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i64 3, i64* %state)
  %state1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i64 6, i64* %state1)
  call void @xs_sock_reset_state_flags(%struct.rpc_xprt* %xprt)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !131
  ret void
}

declare void @mutex_unlock(%struct.mutex*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_socket_close(%struct.rpc_xprt* %xprt, %struct.socket* %socket) #3 {
entry:
  %__u = alloca %union.anon.107, align 8
  %call = call zeroext i1 @static_key_false(%struct.static_key* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_close, i32 0, i32 1))
  br i1 %call, label %do.end, label %if.end26

do.end:                                           ; preds = %entry
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !132
  %call3 = call i32 @cpumask_test_cpu(i32 %0, %struct.cpumask* @__cpu_online_mask)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %do.end
  call void @rcu_read_lock_sched_notrace()
  %1 = bitcast %union.anon.107* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %__c = bitcast %union.anon.107* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* bitcast (%struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_close, i32 0, i32 4) to i8*), i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.107* %__u to %struct.tracepoint_func**
  %2 = load %struct.tracepoint_func*, %struct.tracepoint_func** %__val, align 8, !tbaa !43
  %3 = bitcast %union.anon.107* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %tobool14 = icmp ne %struct.tracepoint_func* %2, null
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end
  br label %do.body16

do.body16:                                        ; preds = %do.body16, %if.then15
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %2, %if.then15 ], [ %incdec.ptr, %do.body16 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %4 = load i8*, i8** %func, align 8, !tbaa !133
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %5 = load i8*, i8** %data, align 8, !tbaa !135
  %6 = bitcast i8* %4 to void (i8*, %struct.rpc_xprt*, %struct.socket*)*
  call void %6(i8* %5, %struct.rpc_xprt* %xprt, %struct.socket* %socket)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func18 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %7 = load i8*, i8** %func18, align 8, !tbaa !133
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %do.body16, label %if.end21

if.end21:                                         ; preds = %do.body16, %if.end
  call void @rcu_read_unlock_sched_notrace()
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end21
  ret void

if.end26:                                         ; preds = %entry
  ret void
}

declare void @sock_release(%struct.socket*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @clear_bit(i64 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #7, !srcloc !136
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_sock_reset_state_flags(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  call void @clear_bit(i64 2, i64* %sock_state)
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @static_key_false(%struct.static_key* %key) #5 {
entry:
  %call = call i32 @static_key_count(%struct.static_key* %key)
  %cmp = icmp sgt i32 %call, 0
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  %. = select i1 %tobool, i1 true, i1 false
  ret i1 %.
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cpumask_test_cpu(i32 %cpu, %struct.cpumask* %cpumask) #3 {
entry:
  %call = call i32 @cpumask_check(i32 %cpu)
  %conv = zext i32 %call to i64
  %bits = getelementptr inbounds %struct.cpumask, %struct.cpumask* %cpumask, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x i64], [1 x i64]* %bits, i32 0, i32 0
  %call1 = call zeroext i1 @variable_test_bit(i64 %conv, i64* %arraydecay)
  %conv2 = zext i1 %call1 to i32
  ret i32 %conv2
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_lock_sched_notrace() #3 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !137
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rcu_read_unlock_sched_notrace() #3 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !138
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @static_key_count(%struct.static_key* %key) #3 {
entry:
  %enabled = getelementptr inbounds %struct.static_key, %struct.static_key* %key, i32 0, i32 0
  %call = call i32 @atomic_read(%struct.atomic_t* %enabled)
  ret i32 %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @variable_test_bit(i64 %nr, i64* %addr) #5 {
entry:
  %oldbit = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %oldbit) #7
  call void asm sideeffect "bt $2,$1\0A\09\0A\09setc $0\0A", "=*qm,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i8* %oldbit, i64* %addr, i64 %nr) #7, !srcloc !139
  %0 = load i8, i8* %oldbit, align 1, !tbaa !140, !range !142
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %oldbit) #7
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @cpumask_check(i32 %cpu) #3 {
entry:
  ret i32 %cpu
}

declare zeroext i1 @cancel_delayed_work_sync(%struct.delayed_work*) #1

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) #1

declare void @module_put(%struct.module*) #1

declare void @seq_printf(%struct.seq_file*, i8*, ...) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__write_once_size(i8* %p, i8* %res, i32 %size) #5 {
entry:
  br label %NodeBlock9

NodeBlock9:                                       ; preds = %entry
  %Pivot10 = icmp slt i32 %size, 4
  br i1 %Pivot10, label %NodeBlock, label %NodeBlock7

NodeBlock7:                                       ; preds = %NodeBlock9
  %Pivot8 = icmp slt i32 %size, 8
  br i1 %Pivot8, label %LeafBlock3, label %LeafBlock5

LeafBlock5:                                       ; preds = %NodeBlock7
  %SwitchLeaf6 = icmp eq i32 %size, 8
  br i1 %SwitchLeaf6, label %sw.bb3, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock7
  %SwitchLeaf4 = icmp eq i32 %size, 4
  br i1 %SwitchLeaf4, label %sw.bb2, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock9
  %Pivot = icmp slt i32 %size, 2
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %size, 2
  br i1 %SwitchLeaf2, label %sw.bb1, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %size, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %0 = load i8, i8* %res, align 1, !tbaa !43
  store volatile i8 %0, i8* %p, align 1, !tbaa !43
  br label %sw.epilog

sw.bb1:                                           ; preds = %LeafBlock1
  %1 = bitcast i8* %res to i16*
  %2 = load i16, i16* %1, align 2, !tbaa !118
  %3 = bitcast i8* %p to i16*
  store volatile i16 %2, i16* %3, align 2, !tbaa !118
  br label %sw.epilog

sw.bb2:                                           ; preds = %LeafBlock3
  %4 = bitcast i8* %res to i32*
  %5 = load i32, i32* %4, align 4, !tbaa !9
  %6 = bitcast i8* %p to i32*
  store volatile i32 %5, i32* %6, align 4, !tbaa !9
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock5
  %7 = bitcast i8* %res to i64*
  %8 = load i64, i64* %7, align 8, !tbaa !119
  %9 = bitcast i8* %p to i64*
  store volatile i64 %8, i64* %9, align 8, !tbaa !119
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock5, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !143
  %conv = sext i32 %size to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %res, i64 %conv, i32 1, i1 false)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !144
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_local_data_receive(%struct.sock_xprt* %transport) #0 {
entry:
  %err = alloca i32, align 4
  %0 = bitcast i32* %err to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %recv_mutex = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_lock(%struct.mutex* %recv_mutex)
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %1 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %cmp = icmp eq %struct.sock* %1, null
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.cond.backedge, %if.end
  %call = call %struct.sk_buff* @skb_recv_datagram(%struct.sock* %1, i32 0, i32 1, i32* %err)
  %cmp1 = icmp ne %struct.sk_buff* %call, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %for.cond
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  call void @xs_local_data_read_skb(%struct.rpc_xprt* %xprt, %struct.sock* %1, %struct.sk_buff* %call)
  call void @skb_free_datagram(%struct.sock* %1, %struct.sk_buff* %call)
  br label %for.cond.backedge

for.cond.backedge:                                ; preds = %if.end3, %if.then2
  br label %for.cond

if.end3:                                          ; preds = %for.cond
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 10
  %call4 = call zeroext i1 @test_and_clear_bit(i64 2, i64* %sock_state)
  br i1 %call4, label %for.cond.backedge, label %out

out:                                              ; preds = %if.end3, %entry
  %recv_mutex7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %recv_mutex7)
  %2 = bitcast i32* %err to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %2) #7
  ret void
}

declare %struct.sk_buff* @skb_recv_datagram(%struct.sock*, i32, i32, i32*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_local_data_read_skb(%struct.rpc_xprt* %xprt, %struct.sock* %sk, %struct.sk_buff* %skb) #0 {
entry:
  %_xid = alloca i32, align 4
  %0 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %1 = load i32, i32* %len, align 8, !tbaa !145
  %conv = zext i32 %1 to i64
  %sub = sub i64 %conv, 4
  %conv1 = trunc i64 %sub to i32
  %cmp = icmp slt i32 %conv1, 4
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i32* %_xid to i8*
  %call = call i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 4, i32 4, i8* %2)
  %3 = bitcast i8* %call to i32*
  %cmp3 = icmp eq i32* %3, null
  br i1 %cmp3, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %4 = load i32, i32* %3, align 4, !tbaa !9
  %call7 = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %xprt, i32 %4)
  %tobool = icmp ne %struct.rpc_rqst* %call7, null
  br i1 %tobool, label %if.end9, label %out_unlock

if.end9:                                          ; preds = %if.end6
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call7, i32 0, i32 3
  %5 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !147
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call7, i32 0, i32 19
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 6
  %6 = load i32, i32* %buflen, align 4, !tbaa !148
  %cmp10 = icmp sgt i32 %6, %conv1
  %conv1. = select i1 %cmp10, i32 %conv1, i32 %6
  %rq_private_buf14 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call7, i32 0, i32 19
  %call15 = call i32 @xs_local_copy_to_xdr(%struct.xdr_buf* %rq_private_buf14, %struct.sk_buff* %skb)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %out_unlock, label %if.end21

if.end21:                                         ; preds = %if.end9
  call void @xprt_complete_rqst(%struct.rpc_task* %5, i32 %conv1.)
  br label %out_unlock

out_unlock:                                       ; preds = %if.end9, %if.end6, %if.end21
  %transport_lock22 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock22)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %out_unlock
  %7 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #7
  ret void
}

declare void @skb_free_datagram(%struct.sock*, %struct.sk_buff*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @test_and_clear_bit(i64 %nr, i64* %addr) #5 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i8* %c, i64 %nr, i64* %addr) #7, !srcloc !149
  %0 = load i8, i8* %c, align 1, !tbaa !140, !range !142
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #7
  ret i1 %tobool
}

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %buffer) #3 {
entry:
  %data = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 40
  %0 = load i8*, i8** %data, align 8, !tbaa !150
  %call = call i32 @skb_headlen(%struct.sk_buff* %skb)
  %call1 = call i8* @__skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %0, i32 %call, i8* %buffer)
  ret i8* %call1
}

declare %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_copy_to_xdr(%struct.xdr_buf* %xdr, %struct.sk_buff* %skb) #0 {
entry:
  %desc = alloca %struct.xdr_skb_reader, align 8
  %0 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %skb1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb1, align 8, !tbaa !151
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  store i32 4, i32* %offset, align 8, !tbaa !153
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %1 = load i32, i32* %len, align 8, !tbaa !145
  %conv = zext i32 %1 to i64
  %sub = sub i64 %conv, 4
  store i64 %sub, i64* %count, align 8, !tbaa !154
  %csum = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 0, i32* %csum, align 8, !tbaa !155
  %call = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %xdr, i32 0, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  %cmp = icmp slt i64 %call, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %count3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %2 = load i64, i64* %count3, align 8, !tbaa !154
  %tobool = icmp ne i64 %2, 0
  %. = select i1 %tobool, i32 -1, i32 0
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry
  %retval.0 = phi i32 [ -1, %entry ], [ %., %if.end ]
  %3 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %3) #7
  ret i32 %retval.0
}

declare void @xprt_complete_rqst(%struct.rpc_task*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i8* @__skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %data, i32 %hlen, i8* %buffer) #3 {
entry:
  %sub = sub nsw i32 %hlen, %offset
  %cmp = icmp sge i32 %sub, %len
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %idx.ext = sext i32 %offset to i64
  %add.ptr = getelementptr i8, i8* %data, i64 %idx.ext
  br label %return

if.end:                                           ; preds = %entry
  %tobool = icmp ne %struct.sk_buff* %skb, null
  br i1 %tobool, label %lor.lhs.false, label %return

lor.lhs.false:                                    ; preds = %if.end
  %call = call i32 @skb_copy_bits(%struct.sk_buff* %skb, i32 %offset, i8* %buffer, i32 %len)
  %cmp1 = icmp slt i32 %call, 0
  %.buffer = select i1 %cmp1, i8* null, i8* %buffer
  ret i8* %.buffer

return:                                           ; preds = %if.end, %if.then
  %retval.0 = phi i8* [ %add.ptr, %if.then ], [ null, %if.end ]
  ret i8* %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @skb_headlen(%struct.sk_buff* %skb) #3 {
entry:
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %0 = load i32, i32* %len, align 8, !tbaa !145
  %data_len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 9
  %1 = load i32, i32* %data_len, align 4, !tbaa !156
  %sub = sub i32 %0, %1
  ret i32 %sub
}

declare i32 @skb_copy_bits(%struct.sk_buff*, i32, i8*, i32) #1

declare i64 @xdr_partial_copy_from_skb(%struct.xdr_buf*, i32, %struct.xdr_skb_reader*, i64 (%struct.xdr_skb_reader*, i8*, i64)*) #1

declare i64 @xdr_skb_read_bits(%struct.xdr_skb_reader*, i8*, i64) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal zeroext i1 @test_and_set_bit(i64 %nr, i64* %addr) #5 {
entry:
  %c = alloca i8, align 1
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %c) #7
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0;\0A\09setc $1\0A", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i8* %c, i64 %nr, i64* %addr) #7, !srcloc !157
  %0 = load i8, i8* %c, align 1, !tbaa !140, !range !142
  %tobool = trunc i8 %0 to i1
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %c) #7
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_common_peer_addresses(%struct.rpc_xprt* %xprt) #0 {
entry:
  %buf = alloca [128 x i8], align 16
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %0 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call, i32 0, i32 0
  %1 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %1 to i32
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %entry
  %Pivot6 = icmp slt i32 %conv, 2
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf4, label %sw.bb17, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf2, label %sw.bb6, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call1 = call %struct.sockaddr_un* @xs_addr_un(%struct.rpc_xprt* %xprt)
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %call1, i32 0, i32 1
  %arraydecay2 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i32 0, i32 0
  %call3 = call i64 @strlcpy(i8* %arraydecay, i8* %arraydecay2, i64 128)
  %arraydecay4 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call5 = call noalias i8* @kstrdup(i8* %arraydecay4, i32 20971712)
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 0
  store i8* %call5, i8** %arrayidx, align 8, !tbaa !51
  br label %sw.epilog

sw.bb6:                                           ; preds = %LeafBlock1
  %arraydecay7 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call8 = call i64 @rpc_ntop(%struct.sockaddr* %call, i8* %arraydecay7, i64 128)
  %arraydecay9 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call10 = call noalias i8* @kstrdup(i8* %arraydecay9, i32 20971712)
  %address_strings11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx12 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings11, i64 0, i64 0
  store i8* %call10, i8** %arrayidx12, align 8, !tbaa !51
  %call13 = call %struct.sockaddr_in* @xs_addr_in(%struct.rpc_xprt* %xprt)
  %arraydecay14 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %call13, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.in_addr, %struct.in_addr* %sin_addr, i32 0, i32 0
  %2 = load i32, i32* %s_addr, align 4, !tbaa !158
  %call15 = call i32 @__fswab32(i32 %2) #4
  %call16 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay14, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i32 %call15)
  br label %sw.epilog

sw.bb17:                                          ; preds = %LeafBlock3
  %arraydecay18 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call19 = call i64 @rpc_ntop(%struct.sockaddr* %call, i8* %arraydecay18, i64 128)
  %arraydecay20 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call21 = call noalias i8* @kstrdup(i8* %arraydecay20, i32 20971712)
  %address_strings22 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx23 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings22, i64 0, i64 0
  store i8* %call21, i8** %arrayidx23, align 8, !tbaa !51
  %call24 = call %struct.sockaddr_in6* @xs_addr_in6(%struct.rpc_xprt* %xprt)
  %arraydecay25 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %call24, i32 0, i32 3
  %call26 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay25, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.5, i32 0, i32 0), %struct.in6_addr* %sin6_addr)
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %do.body

do.body:                                          ; preds = %NewDefault
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.6, i32 0, i32 0), i32 275, i64 12) #7, !srcloc !161
  br label %do.body27

do.body27:                                        ; preds = %do.body27, %do.body
  br label %do.body27

sw.epilog:                                        ; preds = %sw.bb17, %sw.bb6, %sw.bb
  %arraydecay30 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call31 = call noalias i8* @kstrdup(i8* %arraydecay30, i32 20971712)
  %address_strings32 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx33 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings32, i64 0, i64 3
  store i8* %call31, i8** %arrayidx33, align 8, !tbaa !51
  %3 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %3) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt) #0 {
entry:
  %buf = alloca [128 x i8], align 16
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %0 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  %arraydecay = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call1 = call zeroext i16 @rpc_get_port(%struct.sockaddr* %call)
  %conv = zext i16 %call1 to i32
  %call2 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 128, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.7, i32 0, i32 0), i32 %conv)
  %arraydecay3 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call4 = call noalias i8* @kstrdup(i8* %arraydecay3, i32 20971712)
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 1
  store i8* %call4, i8** %arrayidx, align 8, !tbaa !51
  %arraydecay5 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call6 = call zeroext i16 @rpc_get_port(%struct.sockaddr* %call)
  %conv7 = zext i16 %call6 to i32
  %call8 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay5, i64 128, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.8, i32 0, i32 0), i32 %conv7)
  %arraydecay9 = getelementptr inbounds [128 x i8], [128 x i8]* %buf, i32 0, i32 0
  %call10 = call noalias i8* @kstrdup(i8* %arraydecay9, i32 20971712)
  %address_strings11 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx12 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings11, i64 0, i64 4
  store i8* %call10, i8** %arrayidx12, align 8, !tbaa !51
  %1 = bitcast [128 x i8]* %buf to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %1) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt) #3 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr*
  ret %struct.sockaddr* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_un* @xs_addr_un(%struct.rpc_xprt* %xprt) #3 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_un*
  ret %struct.sockaddr_un* %0
}

declare i64 @strlcpy(i8*, i8*, i64) #1

declare noalias i8* @kstrdup(i8*, i32) #1

declare i64 @rpc_ntop(%struct.sockaddr*, i8*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in* @xs_addr_in(%struct.rpc_xprt* %xprt) #3 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_in*
  ret %struct.sockaddr_in* %0
}

declare i32 @snprintf(i8*, i64, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sockaddr_in6* @xs_addr_in6(%struct.rpc_xprt* %xprt) #3 {
entry:
  %addr = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 3
  %0 = bitcast %struct.__kernel_sockaddr_storage* %addr to %struct.sockaddr_in6*
  ret %struct.sockaddr_in6* %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i16 @rpc_get_port(%struct.sockaddr* %sap) #3 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %0 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  br label %return.sink.split

sw.bb3:                                           ; preds = %LeafBlock1
  %2 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  br label %return.sink.split

return.sink.split:                                ; preds = %sw.bb, %sw.bb3
  %sin6_port.sink = phi i16* [ %sin6_port, %sw.bb3 ], [ %sin_port, %sw.bb ]
  %3 = load i16, i16* %sin6_port.sink, align 2, !tbaa !118
  %call4 = call zeroext i16 @__fswab16(i16 zeroext %3) #4
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  br label %return

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %return

return:                                           ; preds = %NewDefault, %return.sink.split
  %retval.0 = phi i16 [ 0, %NewDefault ], [ %conv6, %return.sink.split ]
  ret i16 %retval.0
}

; Function Attrs: inlinehint nounwind readnone uwtable
define internal zeroext i16 @__fswab16(i16 zeroext %val) #6 {
entry:
  %conv = zext i16 %val to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %conv1 = zext i16 %val to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

declare i32 @__sock_create(%struct.net*, i32, i32, i32, %struct.socket**, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_reclassify_socket(i32 %family, %struct.socket* %sock) #3 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_local_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !162
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 44
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !122
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 63
  store void (%struct.sock*)* @xs_data_ready, void (%struct.sock*)** %sk_data_ready, align 8, !tbaa !124
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 64
  store void (%struct.sock*)* @xs_udp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !105
  call void @sock_set_flag(%struct.sock* %3, i32 17)
  %sk_error_report = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 65
  store void (%struct.sock*)* @xs_error_report, void (%struct.sock*)** %sk_error_report, align 8, !tbaa !129
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 37
  store i32 20971520, i32* %sk_allocation, align 8, !tbaa !163
  call void @xprt_clear_connected(%struct.rpc_xprt* %xprt)
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock2, align 8, !tbaa !67
  %inet3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet3, align 8, !tbaa !73
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 44
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_count = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat, i32 0, i32 1
  %5 = load i64, i64* %connect_count, align 8, !tbaa !77
  %inc = add i64 %5, 1
  store i64 %inc, i64* %connect_count, align 8, !tbaa !77
  %6 = load volatile i64, i64* @jiffies, align 8, !tbaa !37
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_start = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat5, i32 0, i32 2
  store i64 %6, i64* %connect_start, align 8, !tbaa !164
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %7 = load i64, i64* %addrlen, align 8, !tbaa !46
  %conv = trunc i64 %7 to i32
  %call6 = call i32 @kernel_connect(%struct.socket* %sock, %struct.sockaddr* %call, i32 %conv, i32 0)
  ret i32 %call6
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_socket_connect(%struct.rpc_xprt* %xprt, %struct.socket* %socket, i32 %error) #3 {
entry:
  %__u = alloca %union.anon.111, align 8
  %call = call zeroext i1 @static_key_false(%struct.static_key* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_connect, i32 0, i32 1))
  br i1 %call, label %do.end, label %if.end26

do.end:                                           ; preds = %entry
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !165
  %call3 = call i32 @cpumask_test_cpu(i32 %0, %struct.cpumask* @__cpu_online_mask)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %do.end
  call void @rcu_read_lock_sched_notrace()
  %1 = bitcast %union.anon.111* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %__c = bitcast %union.anon.111* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* bitcast (%struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_connect, i32 0, i32 4) to i8*), i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.111* %__u to %struct.tracepoint_func**
  %2 = load %struct.tracepoint_func*, %struct.tracepoint_func** %__val, align 8, !tbaa !43
  %3 = bitcast %union.anon.111* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %tobool14 = icmp ne %struct.tracepoint_func* %2, null
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end
  br label %do.body16

do.body16:                                        ; preds = %do.body16, %if.then15
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %2, %if.then15 ], [ %incdec.ptr, %do.body16 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %4 = load i8*, i8** %func, align 8, !tbaa !133
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %5 = load i8*, i8** %data, align 8, !tbaa !135
  %6 = bitcast i8* %4 to void (i8*, %struct.rpc_xprt*, %struct.socket*, i32)*
  call void %6(i8* %5, %struct.rpc_xprt* %xprt, %struct.socket* %socket, i32 %error)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func18 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %7 = load i8*, i8** %func18, align 8, !tbaa !133
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %do.body16, label %if.end21

if.end21:                                         ; preds = %do.body16, %if.end
  call void @rcu_read_unlock_sched_notrace()
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end21
  ret void

if.end26:                                         ; preds = %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_set_connected(%struct.rpc_xprt* %xprt) #3 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @set_bit(i64 1, i64* %state)
  ret void
}

declare i32 @printk(i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @xprt_clear_connecting(%struct.rpc_xprt* %xprt) #3 {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !166
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  call void @clear_bit(i64 2, i64* %state)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !167
  ret void
}

declare void @xprt_wake_pending_tasks(%struct.rpc_xprt*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @xs_save_old_callbacks(%struct.sock_xprt* %transport, %struct.sock* %sk) #0 {
entry:
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 63
  %0 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_data_ready, align 8, !tbaa !124
  %old_data_ready = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 19
  store void (%struct.sock*)* %0, void (%struct.sock*)** %old_data_ready, align 8, !tbaa !123
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 62
  %1 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !126
  %old_state_change = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 20
  store void (%struct.sock*)* %1, void (%struct.sock*)** %old_state_change, align 8, !tbaa !125
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 64
  %2 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !105
  %old_write_space = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 21
  store void (%struct.sock*)* %2, void (%struct.sock*)** %old_write_space, align 8, !tbaa !127
  %sk_error_report = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 65
  %3 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_error_report, align 8, !tbaa !129
  %old_error_report = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 22
  store void (%struct.sock*)* %3, void (%struct.sock*)** %old_error_report, align 8, !tbaa !128
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_data_ready(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %cmp = icmp ne %struct.rpc_xprt* %call, null
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %old_data_ready = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 19
  %2 = load void (%struct.sock*)*, void (%struct.sock*)** %old_data_ready, align 8, !tbaa !123
  call void %2(%struct.sock* %sk)
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  %3 = load i64, i64* %reestablish_timeout, align 8, !tbaa !31
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.then1, label %if.end

if.then1:                                         ; preds = %if.then
  %reestablish_timeout2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  store i64 0, i64* %reestablish_timeout2, align 8, !tbaa !31
  br label %if.end

if.end:                                           ; preds = %if.then1, %if.then
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call3 = call zeroext i1 @test_and_set_bit(i64 2, i64* %sock_state)
  br i1 %call3, label %if.end7, label %if.then4

if.then4:                                         ; preds = %if.end
  %4 = load %struct.workqueue_struct*, %struct.workqueue_struct** @xprtiod_workqueue, align 8, !tbaa !51
  %recv_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 12
  %call5 = call zeroext i1 @queue_work(%struct.workqueue_struct* %4, %struct.work_struct* %recv_worker)
  br label %if.end7

if.end7:                                          ; preds = %if.end, %if.then4, %entry
  %sk_callback_lock8 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock8)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_write_space(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call zeroext i1 @sock_writeable(%struct.sock* %sk)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xs_write_space(%struct.sock* %sk)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sk_callback_lock1 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sock_set_flag(%struct.sock* %sk, i32 %flag) #3 {
entry:
  %conv = zext i32 %flag to i64
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %0 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 13
  %skc_flags = bitcast %union.anon.44* %0 to i64*
  call void @__set_bit(i64 %conv, i64* %skc_flags)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_error_report(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool = icmp ne %struct.rpc_xprt* %call, null
  br i1 %tobool, label %if.end, label %out

if.end:                                           ; preds = %entry
  %sk_err = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 45
  %0 = load i32, i32* %sk_err, align 8, !tbaa !168
  %sub = sub nsw i32 0, %0
  %cmp = icmp eq i32 %sub, 0
  br i1 %cmp, label %out, label %if.end2

if.end2:                                          ; preds = %if.end
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %1 = load volatile i8, i8* %skc_state, align 2, !tbaa !169
  %conv = zext i8 %1 to i32
  %cmp3 = icmp eq i32 %conv, 7
  br i1 %cmp3, label %if.then5, label %do.end

if.then5:                                         ; preds = %if.end2
  call void @xs_sock_mark_closed(%struct.rpc_xprt* %call)
  br label %do.end

do.end:                                           ; preds = %if.end2, %if.then5
  %sk_socket = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 57
  %2 = load %struct.socket*, %struct.socket** %sk_socket, align 8, !tbaa !170
  call void @trace_rpc_socket_error(%struct.rpc_xprt* %call, %struct.socket* %2, i32 %sub)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %call, i32 %sub)
  br label %out

out:                                              ; preds = %if.end, %entry, %do.end
  %sk_callback_lock7 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock7)
  ret void
}

declare i32 @kernel_connect(%struct.socket*, %struct.sockaddr*, i32, i32) #1

declare void @_raw_read_lock_bh(%struct.rwlock_t*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk) #3 {
entry:
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 58
  %0 = load i8*, i8** %sk_user_data, align 8, !tbaa !122
  %1 = bitcast i8* %0 to %struct.rpc_xprt*
  ret %struct.rpc_xprt* %1
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) #3 {
entry:
  %call = call zeroext i1 @queue_work_on(i32 64, %struct.workqueue_struct* %wq, %struct.work_struct* %work)
  ret i1 %call
}

declare void @_raw_read_unlock_bh(%struct.rwlock_t*) #1 section ".spinlock.text"

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_write_space(%struct.sock* %sk) #0 {
entry:
  %__u = alloca %union.anon.109, align 8
  %sk_socket = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 57
  %0 = load %struct.socket*, %struct.socket** %sk_socket, align 8, !tbaa !170
  %tobool = icmp ne %struct.socket* %0, null
  br i1 %tobool, label %if.end, label %cleanup.cont

if.end:                                           ; preds = %entry
  %sk_socket1 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 57
  %1 = load %struct.socket*, %struct.socket** %sk_socket1, align 8, !tbaa !170
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %1, i32 0, i32 2
  call void @clear_bit(i64 2, i64* %flags)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool2 = icmp ne %struct.rpc_xprt* %call, null
  %lnot = xor i1 %tobool2, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %cleanup.cont, label %if.end7

if.end7:                                          ; preds = %if.end
  call void @rcu_read_lock()
  %2 = bitcast %union.anon.109* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %2) #7
  %3 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 12
  %sk_wq = bitcast %union.anon.50* %3 to %struct.socket_wq**
  %4 = bitcast %struct.socket_wq** %sk_wq to i8*
  %__c = bitcast %union.anon.109* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* %4, i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.109* %__u to %struct.socket_wq**
  %5 = load %struct.socket_wq*, %struct.socket_wq** %__val, align 8, !tbaa !43
  %6 = bitcast %union.anon.109* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %tobool13 = icmp ne %struct.socket_wq* %5, null
  br i1 %tobool13, label %lor.lhs.false, label %out

lor.lhs.false:                                    ; preds = %if.end7
  %flags14 = getelementptr inbounds %struct.socket_wq, %struct.socket_wq* %5, i32 0, i32 2
  %call15 = call zeroext i1 @test_and_clear_bit(i64 0, i64* %flags14)
  %conv16 = zext i1 %call15 to i32
  %cmp = icmp eq i32 %conv16, 0
  br i1 %cmp, label %out, label %if.end19

if.end19:                                         ; preds = %lor.lhs.false
  call void @xprt_write_space(%struct.rpc_xprt* %call)
  br label %out

out:                                              ; preds = %if.end7, %lor.lhs.false, %if.end19
  call void @rcu_read_unlock()
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %out, %entry, %if.end
  ret void
}

declare void @xprt_write_space(%struct.rpc_xprt*) #1

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__set_bit(i64 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect "bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #7, !srcloc !171
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_sock_mark_closed(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void @xs_sock_reset_connection_flags(%struct.rpc_xprt* %xprt)
  call void @xprt_disconnect_done(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_socket_error(%struct.rpc_xprt* %xprt, %struct.socket* %socket, i32 %error) #3 {
entry:
  %__u = alloca %union.anon.110, align 8
  %call = call zeroext i1 @static_key_false(%struct.static_key* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_error, i32 0, i32 1))
  br i1 %call, label %do.end, label %if.end26

do.end:                                           ; preds = %entry
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !172
  %call3 = call i32 @cpumask_test_cpu(i32 %0, %struct.cpumask* @__cpu_online_mask)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %do.end
  call void @rcu_read_lock_sched_notrace()
  %1 = bitcast %union.anon.110* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %__c = bitcast %union.anon.110* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* bitcast (%struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_error, i32 0, i32 4) to i8*), i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.110* %__u to %struct.tracepoint_func**
  %2 = load %struct.tracepoint_func*, %struct.tracepoint_func** %__val, align 8, !tbaa !43
  %3 = bitcast %union.anon.110* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %tobool14 = icmp ne %struct.tracepoint_func* %2, null
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end
  br label %do.body16

do.body16:                                        ; preds = %do.body16, %if.then15
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %2, %if.then15 ], [ %incdec.ptr, %do.body16 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %4 = load i8*, i8** %func, align 8, !tbaa !133
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %5 = load i8*, i8** %data, align 8, !tbaa !135
  %6 = bitcast i8* %4 to void (i8*, %struct.rpc_xprt*, %struct.socket*, i32)*
  call void %6(i8* %5, %struct.rpc_xprt* %xprt, %struct.socket* %socket, i32 %error)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func18 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %7 = load i8*, i8** %func18, align 8, !tbaa !133
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %do.body16, label %if.end21

if.end21:                                         ; preds = %do.body16, %if.end
  call void @rcu_read_unlock_sched_notrace()
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end21
  ret void

if.end26:                                         ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_free_peer_addresses(%struct.rpc_xprt* %xprt) #0 {
entry:
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp ult i32 %i.0, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %NodeBlock

NodeBlock:                                        ; preds = %for.body
  %Pivot = icmp slt i32 %i.0, 5
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %i.0, 5
  br i1 %SwitchLeaf2, label %for.inc, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %i.0, 2
  br i1 %SwitchLeaf, label %for.inc, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %idxprom = zext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 %idxprom
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !51
  call void @kfree(i8* %0)
  br label %for.inc

for.inc:                                          ; preds = %LeafBlock1, %LeafBlock, %sw.default
  %inc = add i32 %i.0, 1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @kfree(i8*) #1

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_udp(%struct.xprt_create* %args) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %.compoundliteral11 = alloca %struct.atomic64_t, align 8
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !2
  %1 = load i32, i32* @xprt_udp_slot_table_entries, align 4, !tbaa !9
  %2 = load i32, i32* @xprt_udp_slot_table_entries, align 4, !tbaa !9
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %1, i32 %2)
  %3 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %3)
  br i1 %call1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 17, i32* %prot, align 8, !tbaa !10
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 0, i32* %tsh_size, align 8, !tbaa !28
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 64384, i64* %max_payload, align 8, !tbaa !29
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 60000, i64* %bind_timeout, align 8, !tbaa !30
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  store i64 2000, i64* %reestablish_timeout, align 8, !tbaa !31
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  store i64 300000, i64* %idle_timeout, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_udp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !33
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_udp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !34
  %recv_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 12
  call void @__init_work(%struct.work_struct* %recv_worker, i32 0)
  %recv_worker2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 12
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker2, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !35
  %6 = bitcast %struct.atomic64_t* %data to i8*
  %7 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 8, i32 8, i1 false), !tbaa.struct !36
  %recv_worker3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 12
  %entry4 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker3, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry4)
  %recv_worker5 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 12
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker5, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_udp_data_receive_workfn, void (%struct.work_struct*)** %func, align 8, !tbaa !38
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %connect_worker8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %work9 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker8, i32 0, i32 0
  %data10 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work9, i32 0, i32 0
  %counter12 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral11, i32 0, i32 0
  store i64 68719476704, i64* %counter12, align 8, !tbaa !35
  %8 = bitcast %struct.atomic64_t* %data10 to i8*
  %9 = bitcast %struct.atomic64_t* %.compoundliteral11 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* %9, i64 8, i32 8, i1 false), !tbaa.struct !36
  %connect_worker13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %work14 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker13, i32 0, i32 0
  %entry15 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work14, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry15)
  %connect_worker16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %work17 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker16, i32 0, i32 0
  %func18 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work17, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_udp_setup_socket, void (%struct.work_struct*)** %func18, align 8, !tbaa !38
  %connect_worker22 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker22, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2097152, i8* null, %struct.lock_class_key* null)
  %connect_worker23 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %timer24 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker23, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer24, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !39
  %connect_worker25 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %10 = ptrtoint %struct.delayed_work* %connect_worker25 to i64
  %connect_worker26 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 11
  %timer27 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker26, i32 0, i32 1
  %data28 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer27, i32 0, i32 3
  store i64 %10, i64* %data28, align 8, !tbaa !40
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %11 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %11 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb37, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %12 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %12, i32 0, i32 1
  %13 = load i16, i16* %sin_port, align 2, !tbaa !173
  %conv33 = zext i16 %13 to i32
  %cmp = icmp ne i32 %conv33, 0
  br i1 %cmp, label %if.then35, label %if.end36

if.then35:                                        ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %sw.bb
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0))
  br label %sw.epilog

sw.bb37:                                          ; preds = %LeafBlock1
  %14 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %14, i32 0, i32 1
  %15 = load i16, i16* %sin6_port, align 2, !tbaa !174
  %conv38 = zext i16 %15 to i32
  %cmp39 = icmp ne i32 %conv38, 0
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %sw.bb37
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %sw.bb37
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end42, %if.end36
  %call44 = call i32 @xprt_bound(%struct.rpc_xprt* %call)
  %tobool = icmp ne i32 %call44, 0
  %call53 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call53, label %cleanup, label %out_err

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out_err

out_err:                                          ; preds = %NewDefault, %sw.epilog
  %.sink = phi i64 [ -22, %sw.epilog ], [ -97, %NewDefault ]
  %call56 = call i8* @ERR_PTR(i64 %.sink)
  %16 = bitcast i8* %call56 to %struct.rpc_xprt*
  call void @xs_xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry, %out_err
  %retval.0 = phi %struct.rpc_xprt* [ %16, %out_err ], [ %call, %entry ], [ %call, %sw.epilog ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_data_receive_workfn(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1464
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  call void @xs_udp_data_receive(%struct.sock_xprt* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_setup_socket(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1368
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 0
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock2, align 8, !tbaa !67
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt1)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call, i32 0, i32 0
  %3 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %3 to i32
  %call3 = call %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt1, %struct.sock_xprt* %1, i32 %conv, i32 2, i32 17, i1 zeroext false)
  %4 = bitcast %struct.socket* %call3 to i8*
  %call4 = call zeroext i1 @IS_ERR(i8* %4)
  br i1 %call4, label %out, label %do.end

do.end:                                           ; preds = %entry
  call void @xs_udp_finish_connecting(%struct.rpc_xprt* %xprt1, %struct.socket* %call3)
  call void @trace_rpc_socket_connect(%struct.rpc_xprt* %xprt1, %struct.socket* %call3, i32 0)
  br label %out

out:                                              ; preds = %entry, %do.end
  %status.0 = phi i32 [ 0, %do.end ], [ -5, %entry ]
  %5 = bitcast %struct.sock_xprt* %1 to i8*
  call void @xprt_unlock_connect(%struct.rpc_xprt* %xprt1, i8* %5)
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt1)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt1, i32 %status.0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_bound(%struct.rpc_xprt* %xprt) #3 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call zeroext i1 @constant_test_bit(i64 4, i64* %state)
  %conv = zext i1 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_set_buffer_size(%struct.rpc_xprt* %xprt, i64 %sndsize, i64 %rcvsize) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sndsize1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 17
  store i64 0, i64* %sndsize1, align 8, !tbaa !176
  %tobool = icmp ne i64 %sndsize, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %add = add i64 %sndsize, 1024
  %sndsize2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 17
  store i64 %add, i64* %sndsize2, align 8, !tbaa !176
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %rcvsize3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 16
  store i64 0, i64* %rcvsize3, align 8, !tbaa !177
  %tobool4 = icmp ne i64 %rcvsize, 0
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  %add6 = add i64 %rcvsize, 1024
  %rcvsize7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 16
  store i64 %add6, i64* %rcvsize7, align 8, !tbaa !177
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  call void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt)
  ret void
}

declare i32 @xprt_reserve_xprt_cong(%struct.rpc_xprt*, %struct.rpc_task*) #1

declare void @xprt_release_xprt_cong(%struct.rpc_xprt*, %struct.rpc_task*) #1

declare void @rpcb_getport_async(%struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_set_port(%struct.rpc_xprt* %xprt, i16 zeroext %port) #0 {
entry:
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  call void @rpc_set_port(%struct.sockaddr* %call, i16 zeroext %port)
  call void @xs_update_peer_port(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_connect(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = bitcast %struct.sock_xprt* %1 to i8*
  %call = call zeroext i1 @xprt_lock_connect(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task, i8* %2)
  %lnot = xor i1 %call, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %tobool = icmp ne i32 %lnot.ext, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %3 = load i8, i8* @xs_connect.__warned, align 1, !tbaa !140, !range !142
  %tobool3 = trunc i8 %3 to i1
  %lnot4 = xor i1 %tobool3, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %lnot4, %land.rhs ]
  %lnot6 = xor i1 %4, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext9 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then, label %if.end28

if.then:                                          ; preds = %land.end
  store i8 1, i8* @xs_connect.__warned, align 1, !tbaa !140
  %tobool11 = icmp ne i32 1, 0
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot.ext15 = zext i1 %lnot14 to i32
  %conv16 = sext i32 %lnot.ext15 to i64
  %expval17 = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool18 = icmp ne i64 %expval17, 0
  br i1 %tobool18, label %if.then19, label %if.end

if.then19:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.6, i32 0, i32 0), i32 2484)
  br label %if.end

if.end:                                           ; preds = %if.then19, %if.then
  %tobool21 = icmp ne i32 1, 0
  %lnot22 = xor i1 %tobool21, true
  %lnot24 = xor i1 %lnot22, true
  %lnot.ext25 = zext i1 %lnot24 to i32
  %conv26 = sext i32 %lnot.ext25 to i64
  %expval27 = call i64 @llvm.expect.i64(i64 %conv26, i64 0)
  br label %if.end28

if.end28:                                         ; preds = %if.end, %land.end
  %tobool30 = icmp ne i32 %lnot.ext, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot.ext34 = zext i1 %lnot33 to i32
  %conv35 = sext i32 %lnot.ext34 to i64
  %expval36 = call i64 @llvm.expect.i64(i64 %conv35, i64 0)
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %5 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !67
  %cmp = icmp ne %struct.socket* %5, null
  br i1 %cmp, label %do.end, label %if.end43

do.end:                                           ; preds = %if.end28
  call void @xs_reset_transport(%struct.sock_xprt* %1)
  %call39 = call i64 @xs_reconnect_delay(%struct.rpc_xprt* %xprt)
  call void @xs_reconnect_backoff(%struct.rpc_xprt* %xprt)
  br label %if.end43

if.end43:                                         ; preds = %if.end28, %do.end
  %delay.0 = phi i64 [ %call39, %do.end ], [ 0, %if.end28 ]
  %6 = load %struct.workqueue_struct*, %struct.workqueue_struct** @xprtiod_workqueue, align 8, !tbaa !51
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 11
  %call44 = call zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %6, %struct.delayed_work* %connect_worker, i64 %delay.0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_udp_send_request(%struct.rpc_task* %task) #0 {
entry:
  %sent = alloca i32, align 4
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !63
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %4 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #7
  store i32 0, i32* %sent, align 4, !tbaa !9
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf1, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay, i32 0, i32 0
  %5 = load i8*, i8** %iov_base, align 8, !tbaa !64
  %6 = bitcast i8* %5 to i32*
  %rq_snd_buf2 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head3 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf2, i32 0, i32 0
  %arraydecay4 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head3, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay4, i32 0, i32 1
  %7 = load i64, i64* %iov_len, align 8, !tbaa !66
  %conv = trunc i64 %7 to i32
  call void @xs_pktdump(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.2, i32 0, i32 0), i32* %6, i32 %conv)
  %call = call i32 @xprt_bound(%struct.rpc_xprt* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %8 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !67
  %call5 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %1)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 4
  %9 = load i64, i64* %addrlen, align 8, !tbaa !46
  %conv6 = trunc i64 %9 to i32
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %10 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !57
  %call7 = call i32 @xs_sendpages(%struct.socket* %8, %struct.sockaddr* %call5, i32 %conv6, %struct.xdr_buf* %rq_snd_buf, i32 %10, i1 zeroext true, i32* %sent)
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %call7, -1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call7, -1
  br i1 %SwitchLeaf2, label %process_status, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call7, -11
  br i1 %SwitchLeaf, label %land.lhs.true, label %NewDefault

land.lhs.true:                                    ; preds = %LeafBlock
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 2
  %11 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %call13 = call zeroext i1 @sock_writeable(%struct.sock* %11)
  %.call7 = select i1 %call13, i32 -105, i32 %call7
  br label %if.end16

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %if.end16

if.end16:                                         ; preds = %NewDefault, %land.lhs.true
  %status.0 = phi i32 [ %call7, %NewDefault ], [ %.call7, %land.lhs.true ]
  %12 = load i32, i32* %sent, align 4, !tbaa !9
  %cmp17 = icmp sgt i32 %12, 0
  %cmp19 = icmp eq i32 %status.0, 0
  %or.cond = or i1 %cmp17, %cmp19
  br i1 %or.cond, label %if.then21, label %process_status

if.then21:                                        ; preds = %if.end16
  %13 = load i32, i32* %sent, align 4, !tbaa !9
  %conv22 = sext i32 %13 to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 17
  %14 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !74
  %add = add i64 %14, %conv22
  store i64 %add, i64* %rq_xmit_bytes_sent, align 8, !tbaa !74
  %15 = load i32, i32* %sent, align 4, !tbaa !9
  %rq_snd_buf23 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf23, i32 0, i32 7
  %16 = load i32, i32* %len, align 8, !tbaa !60
  %cmp24 = icmp uge i32 %15, %16
  br i1 %cmp24, label %cleanup, label %process_status

process_status:                                   ; preds = %LeafBlock1, %if.end16, %if.then21
  %status.2 = phi i32 [ %call7, %LeafBlock1 ], [ %status.0, %if.end16 ], [ -11, %if.then21 ]
  br label %NodeBlock28

NodeBlock28:                                      ; preds = %process_status
  %Pivot29 = icmp slt i32 %status.2, -88
  br i1 %Pivot29, label %NodeBlock12, label %NodeBlock26

NodeBlock26:                                      ; preds = %NodeBlock28
  %Pivot27 = icmp slt i32 %status.2, -11
  br i1 %Pivot27, label %NodeBlock18, label %NodeBlock24

NodeBlock24:                                      ; preds = %NodeBlock26
  %Pivot25 = icmp slt i32 %status.2, -1
  br i1 %Pivot25, label %LeafBlock20, label %LeafBlock22

LeafBlock22:                                      ; preds = %NodeBlock24
  %SwitchLeaf23 = icmp eq i32 %status.2, -1
  br i1 %SwitchLeaf23, label %sw.bb31, label %NewDefault3

LeafBlock20:                                      ; preds = %NodeBlock24
  %SwitchLeaf21 = icmp eq i32 %status.2, -11
  br i1 %SwitchLeaf21, label %sw.bb29, label %NewDefault3

NodeBlock18:                                      ; preds = %NodeBlock26
  %Pivot19 = icmp slt i32 %status.2, -32
  br i1 %Pivot19, label %LeafBlock14, label %LeafBlock16

LeafBlock16:                                      ; preds = %NodeBlock18
  %SwitchLeaf17 = icmp eq i32 %status.2, -32
  br i1 %SwitchLeaf17, label %sw.bb31, label %NewDefault3

LeafBlock14:                                      ; preds = %NodeBlock18
  %SwitchLeaf15 = icmp eq i32 %status.2, -88
  br i1 %SwitchLeaf15, label %cleanup, label %NewDefault3

NodeBlock12:                                      ; preds = %NodeBlock28
  %Pivot13 = icmp slt i32 %status.2, -105
  br i1 %Pivot13, label %LeafBlock4, label %NodeBlock10

NodeBlock10:                                      ; preds = %NodeBlock12
  %Pivot11 = icmp slt i32 %status.2, -101
  br i1 %Pivot11, label %LeafBlock6, label %LeafBlock8

LeafBlock8:                                       ; preds = %NodeBlock10
  %SwitchLeaf9 = icmp eq i32 %status.2, -101
  br i1 %SwitchLeaf9, label %sw.bb31, label %NewDefault3

LeafBlock6:                                       ; preds = %NodeBlock10
  %SwitchLeaf7 = icmp eq i32 %status.2, -105
  br i1 %SwitchLeaf7, label %sw.bb31, label %NewDefault3

LeafBlock4:                                       ; preds = %NodeBlock12
  %SwitchLeaf5 = icmp eq i32 %status.2, -111
  br i1 %SwitchLeaf5, label %sw.bb31, label %NewDefault3

sw.bb29:                                          ; preds = %LeafBlock20
  %call30 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

sw.bb31:                                          ; preds = %LeafBlock22, %LeafBlock16, %LeafBlock8, %LeafBlock6, %LeafBlock4
  br label %cleanup

NewDefault3:                                      ; preds = %LeafBlock22, %LeafBlock20, %LeafBlock16, %LeafBlock14, %LeafBlock8, %LeafBlock6, %LeafBlock4
  br label %do.end34

do.end34:                                         ; preds = %NewDefault3
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock14, %sw.bb29, %sw.bb31, %do.end34, %if.then21, %entry
  %retval.0 = phi i32 [ -107, %entry ], [ 0, %if.then21 ], [ %status.2, %do.end34 ], [ %status.2, %sw.bb31 ], [ %call30, %sw.bb29 ], [ -107, %LeafBlock14 ]
  %17 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %17) #7
  ret i32 %retval.0
}

declare void @xprt_set_retrans_timeout_rtt(%struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_udp_timer(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task) #0 {
entry:
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  call void @xprt_adjust_cwnd(%struct.rpc_xprt* %xprt, %struct.rpc_task* %task, i32 -110)
  %transport_lock1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock1)
  ret void
}

declare void @xprt_release_rqst_cong(%struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_udp_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 15
  %2 = load i16, i16* %srcport, align 8, !tbaa !178
  %conv = zext i16 %2 to i32
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bind_count = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat, i32 0, i32 0
  %3 = load i64, i64* %bind_count, align 8, !tbaa !76
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %sends = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat1, i32 0, i32 4
  %4 = load i64, i64* %sends, align 8, !tbaa !79
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %recvs = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat2, i32 0, i32 5
  %5 = load i64, i64* %recvs, align 8, !tbaa !80
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bad_xids = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat3, i32 0, i32 6
  %6 = load i64, i64* %bad_xids, align 8, !tbaa !81
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %req_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat4, i32 0, i32 8
  %7 = load i64, i64* %req_u, align 8, !tbaa !82
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bklog_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat5, i32 0, i32 9
  %8 = load i64, i64* %bklog_u, align 8, !tbaa !83
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %max_slots = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat6, i32 0, i32 7
  %9 = load i64, i64* %max_slots, align 8, !tbaa !84
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %sending_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat7, i32 0, i32 10
  %10 = load i64, i64* %sending_u, align 8, !tbaa !85
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %pending_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat8, i32 0, i32 11
  %11 = load i64, i64* %pending_u, align 8, !tbaa !86
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.12, i32 0, i32 0), i32 %conv, i64 %3, i64 %4, i64 %5, i64 %6, i64 %7, i64 %8, i64 %9, i64 %10, i64 %11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_inject_disconnect(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void @xprt_disconnect_done(%struct.rpc_xprt* %xprt)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %rcvsize = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 16
  %3 = load i64, i64* %rcvsize, align 8, !tbaa !177
  %tobool = icmp ne i64 %3, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %sk_userlocks = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 40
  %bf.load = load i32, i32* %sk_userlocks, align 8
  %bf.lshr = lshr i32 %bf.load, 4
  %bf.clear = and i32 %bf.lshr, 15
  %or = or i32 %bf.clear, 2
  %bf.load1 = load i32, i32* %sk_userlocks, align 8
  %bf.value = and i32 %or, 15
  %bf.shl = shl i32 %bf.value, 4
  %bf.clear2 = and i32 %bf.load1, -241
  %bf.set = or i32 %bf.clear2, %bf.shl
  store i32 %bf.set, i32* %sk_userlocks, align 8
  %rcvsize3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 16
  %4 = load i64, i64* %rcvsize3, align 8, !tbaa !177
  %max_reqs = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %5 = load i32, i32* %max_reqs, align 8, !tbaa !179
  %conv = zext i32 %5 to i64
  %mul = mul i64 %4, %conv
  %mul4 = mul i64 %mul, 2
  %conv5 = trunc i64 %mul4 to i32
  %sk_rcvbuf = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 10
  store i32 %conv5, i32* %sk_rcvbuf, align 4, !tbaa !180
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sndsize = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 17
  %6 = load i64, i64* %sndsize, align 8, !tbaa !176
  %tobool6 = icmp ne i64 %6, 0
  br i1 %tobool6, label %if.then7, label %if.end24

if.then7:                                         ; preds = %if.end
  %sk_userlocks8 = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 40
  %bf.load9 = load i32, i32* %sk_userlocks8, align 8
  %bf.lshr10 = lshr i32 %bf.load9, 4
  %bf.clear11 = and i32 %bf.lshr10, 15
  %or12 = or i32 %bf.clear11, 1
  %bf.load13 = load i32, i32* %sk_userlocks8, align 8
  %bf.value14 = and i32 %or12, 15
  %bf.shl15 = shl i32 %bf.value14, 4
  %bf.clear16 = and i32 %bf.load13, -241
  %bf.set17 = or i32 %bf.clear16, %bf.shl15
  store i32 %bf.set17, i32* %sk_userlocks8, align 8
  %sndsize18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 17
  %7 = load i64, i64* %sndsize18, align 8, !tbaa !176
  %max_reqs19 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 15
  %8 = load i32, i32* %max_reqs19, align 8, !tbaa !179
  %conv20 = zext i32 %8 to i64
  %mul21 = mul i64 %7, %conv20
  %mul22 = mul i64 %mul21, 2
  %conv23 = trunc i64 %mul22 to i32
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 17
  store i32 %conv23, i32* %sk_sndbuf, align 4, !tbaa !90
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %2, i32 0, i32 64
  %9 = load void (%struct.sock*)*, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !105
  call void %9(%struct.sock* %2)
  br label %if.end24

if.end24:                                         ; preds = %if.then7, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @rpc_set_port(%struct.sockaddr* %sap, i16 zeroext %port) #3 {
entry:
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sap, i32 0, i32 0
  %0 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %0 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %entry
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb3, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %call = call zeroext i16 @__fswab16(i16 zeroext %port) #4
  %conv1 = zext i16 %call to i32
  %conv2 = trunc i32 %conv1 to i16
  %1 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %1, i32 0, i32 1
  store i16 %conv2, i16* %sin_port, align 2, !tbaa !173
  br label %sw.epilog

sw.bb3:                                           ; preds = %LeafBlock1
  %call4 = call zeroext i16 @__fswab16(i16 zeroext %port) #4
  %conv5 = zext i16 %call4 to i32
  %conv6 = trunc i32 %conv5 to i16
  %2 = bitcast %struct.sockaddr* %sap to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %2, i32 0, i32 1
  store i16 %conv6, i16* %sin6_port, align 2, !tbaa !174
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %sw.epilog

sw.epilog:                                        ; preds = %NewDefault, %sw.bb3, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_update_peer_port(%struct.rpc_xprt* %xprt) #0 {
entry:
  %address_strings = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings, i64 0, i64 4
  %0 = load i8*, i8** %arrayidx, align 8, !tbaa !51
  call void @kfree(i8* %0)
  %address_strings1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 41
  %arrayidx2 = getelementptr inbounds [6 x i8*], [6 x i8*]* %address_strings1, i64 0, i64 1
  %1 = load i8*, i8** %arrayidx2, align 8, !tbaa !51
  call void @kfree(i8* %1)
  call void @xs_format_common_peer_ports(%struct.rpc_xprt* %xprt)
  ret void
}

declare zeroext i1 @xprt_lock_connect(%struct.rpc_xprt*, %struct.rpc_task*, i8*) #1

declare void @warn_slowpath_null(i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @xs_reconnect_delay(%struct.rpc_xprt* %xprt) #0 {
entry:
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy1 = alloca i64, align 8
  %__dummy22 = alloca i64, align 8
  %0 = load volatile i64, i64* @jiffies, align 8, !tbaa !37
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_start = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat, i32 0, i32 2
  %1 = load i64, i64* %connect_start, align 8, !tbaa !164
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %2 = load i64, i64* %reestablish_timeout, align 8, !tbaa !31
  %add = add i64 %1, %2
  %3 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %3) #7
  %4 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #7
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %5 = bitcast i64* %__dummy2 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %5) #7
  %6 = bitcast i64* %__dummy to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %6) #7
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.lhs.true, label %cleanup

land.lhs.true:                                    ; preds = %entry
  %7 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #7
  %8 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %8) #7
  %cmp3 = icmp eq i64* %__dummy1, %__dummy22
  %conv4 = zext i1 %cmp3 to i32
  %9 = bitcast i64* %__dummy22 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %9) #7
  %10 = bitcast i64* %__dummy1 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %10) #7
  %sub = sub i64 %0, %add
  %cmp8 = icmp slt i64 %sub, 0
  %sub10 = sub i64 %add, %0
  %sub10. = select i1 %cmp8, i64 %sub10, i64 0
  ret i64 %sub10.

cleanup:                                          ; preds = %entry
  ret i64 0
}

; Function Attrs: nounwind uwtable
define internal void @xs_reconnect_backoff(%struct.rpc_xprt* %xprt) #0 {
entry:
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %0 = load i64, i64* %reestablish_timeout, align 8, !tbaa !31
  %shl = shl i64 %0, 1
  store i64 %shl, i64* %reestablish_timeout, align 8, !tbaa !31
  %reestablish_timeout1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %1 = load i64, i64* %reestablish_timeout1, align 8, !tbaa !31
  %max_reconnect_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 31
  %2 = load i64, i64* %max_reconnect_timeout, align 8, !tbaa !181
  %cmp = icmp ugt i64 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %max_reconnect_timeout2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 31
  %3 = load i64, i64* %max_reconnect_timeout2, align 8, !tbaa !181
  %reestablish_timeout3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  store i64 %3, i64* %reestablish_timeout3, align 8, !tbaa !31
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %reestablish_timeout4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %4 = load i64, i64* %reestablish_timeout4, align 8, !tbaa !31
  %cmp5 = icmp ult i64 %4, 3000
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end
  %reestablish_timeout7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  store i64 3000, i64* %reestablish_timeout7, align 8, !tbaa !31
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @queue_delayed_work(%struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay) #3 {
entry:
  %call = call zeroext i1 @queue_delayed_work_on(i32 64, %struct.workqueue_struct* %wq, %struct.delayed_work* %dwork, i64 %delay)
  ret i1 %call
}

declare zeroext i1 @queue_delayed_work_on(i32, %struct.workqueue_struct*, %struct.delayed_work*, i64) #1

declare void @xprt_adjust_cwnd(%struct.rpc_xprt*, %struct.rpc_task*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @xs_udp_data_receive(%struct.sock_xprt* %transport) #0 {
entry:
  %err = alloca i32, align 4
  %0 = bitcast i32* %err to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %recv_mutex = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_lock(%struct.mutex* %recv_mutex)
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %1 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %cmp = icmp eq %struct.sock* %1, null
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.cond.backedge, %if.end
  %call = call %struct.sk_buff* @skb_recv_udp(%struct.sock* %1, i32 0, i32 1, i32* %err)
  %cmp1 = icmp ne %struct.sk_buff* %call, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %for.cond
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  call void @xs_udp_data_read_skb(%struct.rpc_xprt* %xprt, %struct.sock* %1, %struct.sk_buff* %call)
  call void @consume_skb(%struct.sk_buff* %call)
  br label %for.cond.backedge

for.cond.backedge:                                ; preds = %if.end3, %if.then2
  br label %for.cond

if.end3:                                          ; preds = %for.cond
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 10
  %call4 = call zeroext i1 @test_and_clear_bit(i64 2, i64* %sock_state)
  br i1 %call4, label %for.cond.backedge, label %out

out:                                              ; preds = %if.end3, %entry
  %recv_mutex7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %recv_mutex7)
  %2 = bitcast i32* %err to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %2) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sk_buff* @skb_recv_udp(%struct.sock* %sk, i32 %flags, i32 %noblock, i32* %err) #3 {
entry:
  %peeked = alloca i32, align 4
  %off = alloca i32, align 4
  %0 = bitcast i32* %peeked to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %1 = bitcast i32* %off to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  store i32 0, i32* %off, align 4, !tbaa !9
  %call = call %struct.sk_buff* @__skb_recv_udp(%struct.sock* %sk, i32 %flags, i32 %noblock, i32* %peeked, i32* %off, i32* %err)
  %2 = bitcast i32* %off to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %2) #7
  %3 = bitcast i32* %peeked to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %3) #7
  ret %struct.sk_buff* %call
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_data_read_skb(%struct.rpc_xprt* %xprt, %struct.sock* %sk, %struct.sk_buff* %skb) #0 {
entry:
  %_xid = alloca i32, align 4
  %0 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %len = getelementptr inbounds %struct.sk_buff, %struct.sk_buff* %skb, i32 0, i32 8
  %1 = load i32, i32* %len, align 8, !tbaa !145
  %cmp = icmp slt i32 %1, 4
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %2 = bitcast i32* %_xid to i8*
  %call = call i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 0, i32 4, i8* %2)
  %3 = bitcast i8* %call to i32*
  %cmp1 = icmp eq i32* %3, null
  br i1 %cmp1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %4 = load i32, i32* %3, align 4, !tbaa !9
  %call4 = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %xprt, i32 %4)
  %tobool = icmp ne %struct.rpc_rqst* %call4, null
  br i1 %tobool, label %if.end6, label %out_unlock

if.end6:                                          ; preds = %if.end3
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call4, i32 0, i32 3
  %5 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !147
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call4, i32 0, i32 19
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 6
  %6 = load i32, i32* %buflen, align 4, !tbaa !148
  %cmp7 = icmp sgt i32 %6, %1
  %. = select i1 %cmp7, i32 %1, i32 %6
  %rq_private_buf10 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call4, i32 0, i32 19
  %call11 = call i32 @csum_partial_copy_to_xdr(%struct.xdr_buf* %rq_private_buf10, %struct.sk_buff* %skb)
  %tobool12 = icmp ne i32 %call11, 0
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_family = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 3
  %7 = load i16, i16* %skc_family, align 8, !tbaa !182
  %conv = zext i16 %7 to i32
  %cmp15 = icmp eq i32 %conv, 2
  call void @__this_cpu_preempt_check(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0))
  %call24 = call %struct.net* @sock_net(%struct.sock* %sk)
  %mib = getelementptr inbounds %struct.net, %struct.net* %call24, i32 0, i32 26
  br i1 %tobool12, label %do.body14, label %do.body53

do.body14:                                        ; preds = %if.end6
  br i1 %cmp15, label %do.body18, label %do.body31

do.body18:                                        ; preds = %do.body14
  %udp_statistics = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 3
  %8 = load %struct.udp_mib*, %struct.udp_mib** %udp_statistics, align 8, !tbaa !183
  %mibs = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %8, i32 0, i32 0
  %arrayidx = getelementptr inbounds [9 x i64], [9 x i64]* %mibs, i64 0, i64 3
  call void asm "incq %gs:$0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx, i64* %arrayidx) #7, !srcloc !222
  br label %out_unlock

do.body31:                                        ; preds = %do.body14
  %udp_stats_in6 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 8
  %9 = load %struct.udp_mib*, %struct.udp_mib** %udp_stats_in6, align 8, !tbaa !223
  %mibs41 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %9, i32 0, i32 0
  %arrayidx42 = getelementptr inbounds [9 x i64], [9 x i64]* %mibs41, i64 0, i64 3
  call void asm "incq %gs:$0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx42, i64* %arrayidx42) #7, !srcloc !224
  br label %out_unlock

do.body53:                                        ; preds = %if.end6
  br i1 %cmp15, label %do.body60, label %do.body80

do.body60:                                        ; preds = %do.body53
  %udp_statistics70 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 3
  %10 = load %struct.udp_mib*, %struct.udp_mib** %udp_statistics70, align 8, !tbaa !183
  %mibs71 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %10, i32 0, i32 0
  %arrayidx72 = getelementptr inbounds [9 x i64], [9 x i64]* %mibs71, i64 0, i64 1
  call void asm "incq %gs:$0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx72, i64* %arrayidx72) #7, !srcloc !225
  br label %do.end101

do.body80:                                        ; preds = %do.body53
  %udp_stats_in690 = getelementptr inbounds %struct.netns_mib, %struct.netns_mib* %mib, i32 0, i32 8
  %11 = load %struct.udp_mib*, %struct.udp_mib** %udp_stats_in690, align 8, !tbaa !223
  %mibs91 = getelementptr inbounds %struct.udp_mib, %struct.udp_mib* %11, i32 0, i32 0
  %arrayidx92 = getelementptr inbounds [9 x i64], [9 x i64]* %mibs91, i64 0, i64 1
  call void asm "incq %gs:$0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i64* %arrayidx92, i64* %arrayidx92) #7, !srcloc !226
  br label %do.end101

do.end101:                                        ; preds = %do.body80, %do.body60
  call void @xprt_adjust_cwnd(%struct.rpc_xprt* %xprt, %struct.rpc_task* %5, i32 %.)
  call void @xprt_complete_rqst(%struct.rpc_task* %5, i32 %.)
  br label %out_unlock

out_unlock:                                       ; preds = %do.body18, %do.body31, %if.end3, %do.end101
  %transport_lock102 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock102)
  br label %cleanup

cleanup:                                          ; preds = %if.end, %entry, %out_unlock
  %12 = bitcast i32* %_xid to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #7
  ret void
}

declare void @consume_skb(%struct.sk_buff*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.sk_buff* @__skb_recv_udp(%struct.sock* %sk, i32 %flags, i32 %noblock, i32* %peeked, i32* %off, i32* %err) #3 {
entry:
  %tobool = icmp ne i32 %noblock, 0
  %0 = zext i1 %tobool to i64
  %cond = select i1 %tobool, i32 64, i32 0
  %or = or i32 %flags, %cond
  %call = call %struct.sk_buff* @__skb_recv_datagram(%struct.sock* %sk, i32 %or, void (%struct.sock*, %struct.sk_buff*)* @udp_skb_destructor, i32* %peeked, i32* %off, i32* %err)
  ret %struct.sk_buff* %call
}

declare %struct.sk_buff* @__skb_recv_datagram(%struct.sock*, i32, void (%struct.sock*, %struct.sk_buff*)*, i32*, i32*, i32*) #1

declare void @udp_skb_destructor(%struct.sock*, %struct.sk_buff*) #1

declare i32 @csum_partial_copy_to_xdr(%struct.xdr_buf*, %struct.sk_buff*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @__this_cpu_preempt_check(i8* %op) #3 {
entry:
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @sock_net(%struct.sock* %sk) #3 {
entry:
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_net = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 9
  %call = call %struct.net* @read_pnet(%struct.possible_net_t* %skc_net)
  ret %struct.net* %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.net* @read_pnet(%struct.possible_net_t* %pnet) #3 {
entry:
  %net = getelementptr inbounds %struct.possible_net_t, %struct.possible_net_t* %pnet, i32 0, i32 0
  %0 = load %struct.net*, %struct.net** %net, align 8, !tbaa !227
  ret %struct.net* %0
}

; Function Attrs: nounwind uwtable
define internal %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt, %struct.sock_xprt* %transport, i32 %family, i32 %type, i32 %protocol, i1 zeroext %reuseport) #0 {
entry:
  %sock = alloca %struct.socket*, align 8
  %frombool = zext i1 %reuseport to i8
  %0 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %0) #7
  %xprt_net = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 39
  %1 = load %struct.net*, %struct.net** %xprt_net, align 8, !tbaa !52
  %call = call i32 @__sock_create(%struct.net* %1, i32 %family, i32 %type, i32 %protocol, %struct.socket** %sock, i32 1)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %2 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !51
  call void @xs_reclassify_socket(i32 %family, %struct.socket* %2)
  %tobool = trunc i8 %frombool to i1
  br i1 %tobool, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  %3 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !51
  call void @xs_sock_set_reuseport(%struct.socket* %3)
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  %4 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !51
  %call3 = call i32 @xs_bind(%struct.sock_xprt* %transport, %struct.socket* %4)
  %tobool4 = icmp ne i32 %call3, 0
  %5 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !51
  br i1 %tobool4, label %if.then5, label %cleanup

if.then5:                                         ; preds = %if.end2
  call void @sock_release(%struct.socket* %5)
  br label %out

out:                                              ; preds = %entry, %if.then5
  %err.0 = phi i32 [ %call3, %if.then5 ], [ %call, %entry ]
  %conv = sext i32 %err.0 to i64
  %call7 = call i8* @ERR_PTR(i64 %conv)
  %6 = bitcast i8* %call7 to %struct.socket*
  br label %cleanup

cleanup:                                          ; preds = %if.end2, %out
  %retval.0 = phi %struct.socket* [ %6, %out ], [ %5, %if.end2 ]
  %7 = bitcast %struct.socket** %sock to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %7) #7
  ret %struct.socket* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_udp_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !162
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 44
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %4 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  store i8* %4, i8** %sk_user_data, align 8, !tbaa !122
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 63
  store void (%struct.sock*)* @xs_data_ready, void (%struct.sock*)** %sk_data_ready, align 8, !tbaa !124
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 64
  store void (%struct.sock*)* @xs_udp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !105
  call void @sock_set_flag(%struct.sock* %3, i32 17)
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 37
  store i32 20971520, i32* %sk_allocation, align 8, !tbaa !163
  call void @xprt_set_connected(%struct.rpc_xprt* %xprt)
  %sock2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock2, align 8, !tbaa !67
  %inet3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet3, align 8, !tbaa !73
  call void @xs_set_memalloc(%struct.rpc_xprt* %xprt)
  %sk_callback_lock4 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 44
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @xs_udp_do_set_buffer_size(%struct.rpc_xprt* %xprt)
  %5 = load volatile i64, i64* @jiffies, align 8, !tbaa !37
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_start = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat, i32 0, i32 2
  store i64 %5, i64* %connect_start, align 8, !tbaa !164
  ret void
}

declare void @xprt_unlock_connect(%struct.rpc_xprt*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_sock_set_reuseport(%struct.socket* %sock) #0 {
entry:
  %opt = alloca i32, align 4
  %0 = bitcast i32* %opt to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  store i32 1, i32* %opt, align 4, !tbaa !9
  %1 = bitcast i32* %opt to i8*
  %call = call i32 @kernel_setsockopt(%struct.socket* %sock, i32 1, i32 15, i8* %1, i32 4)
  %2 = bitcast i32* %opt to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %2) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_bind(%struct.sock_xprt* %transport, %struct.socket* %sock) #0 {
entry:
  %myaddr = alloca %struct.__kernel_sockaddr_storage, align 8
  %0 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  %call = call zeroext i16 @xs_get_srcport(%struct.sock_xprt* %transport)
  %conv = zext i16 %call to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %1 = load i64, i64* %addrlen, align 8, !tbaa !228
  %2 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to i8*
  %srcaddr = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 14
  %3 = bitcast %struct.__kernel_sockaddr_storage* %srcaddr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 %1, i32 8, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.end9, %if.end
  %nloop.0 = phi i32 [ 0, %if.end ], [ %inc.nloop.0, %if.end9 ]
  %port.0 = phi i16 [ %call, %if.end ], [ %call10, %if.end9 ]
  %4 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to %struct.sockaddr*
  call void @rpc_set_port(%struct.sockaddr* %4, i16 zeroext %port.0)
  %5 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to %struct.sockaddr*
  %xprt2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %addrlen3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt2, i32 0, i32 4
  %6 = load i64, i64* %addrlen3, align 8, !tbaa !228
  %conv4 = trunc i64 %6 to i32
  %call5 = call i32 @kernel_bind(%struct.socket* %sock, %struct.sockaddr* %5, i32 %conv4)
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %do.body
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  store i16 %port.0, i16* %srcport, align 8, !tbaa !178
  br label %do.end

if.end9:                                          ; preds = %do.body
  %call10 = call zeroext i16 @xs_next_srcport(%struct.sock_xprt* %transport, i16 zeroext %port.0)
  %conv11 = zext i16 %call10 to i32
  %conv12 = zext i16 %port.0 to i32
  %cmp13 = icmp sgt i32 %conv11, %conv12
  %inc = add nsw i32 %nloop.0, 1
  %inc.nloop.0 = select i1 %cmp13, i32 %inc, i32 %nloop.0
  %cmp17 = icmp eq i32 %call5, -98
  %cmp19 = icmp ne i32 %inc.nloop.0, 2
  %7 = select i1 %cmp17, i1 %cmp19, i1 false
  br i1 %7, label %do.body, label %do.end

do.end:                                           ; preds = %if.end9, %if.then8
  %ss_family = getelementptr inbounds %struct.__kernel_sockaddr_storage, %struct.__kernel_sockaddr_storage* %myaddr, i32 0, i32 0
  %8 = load i16, i16* %ss_family, align 8, !tbaa !229
  %conv21 = zext i16 %8 to i32
  %cmp22 = icmp eq i32 %conv21, 2
  br label %cleanup

cleanup:                                          ; preds = %entry, %do.end
  %retval.0 = phi i32 [ %call5, %do.end ], [ 0, %entry ]
  %9 = bitcast %struct.__kernel_sockaddr_storage* %myaddr to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %9) #7
  ret i32 %retval.0
}

declare i32 @kernel_setsockopt(%struct.socket*, i32, i32, i8*, i32) #1

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_get_srcport(%struct.sock_xprt* %transport) #0 {
entry:
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  %0 = load i16, i16* %srcport, align 8, !tbaa !178
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %resvport = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 19
  %bf.load = load i8, i8* %resvport, align 8
  %bf.clear = and i8 %bf.load, 1
  %conv2 = zext i8 %bf.clear to i32
  %tobool = icmp ne i32 %conv2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call = call zeroext i16 @xs_get_random_port()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %port.0 = phi i16 [ %call, %if.then ], [ %0, %land.lhs.true ], [ %0, %entry ]
  ret i16 %port.0
}

declare i32 @kernel_bind(%struct.socket*, %struct.sockaddr*, i32) #1

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_next_srcport(%struct.sock_xprt* %transport, i16 zeroext %port) #0 {
entry:
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  %0 = load i16, i16* %srcport, align 8, !tbaa !178
  %conv = zext i16 %0 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %srcport2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  store i16 0, i16* %srcport2, align 8, !tbaa !178
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %resvport = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 19
  %bf.load = load i8, i8* %resvport, align 8
  %bf.clear = and i8 %bf.load, 1
  %tobool = icmp ne i8 %bf.clear, 0
  br i1 %tobool, label %if.end4, label %return

if.end4:                                          ; preds = %if.end
  %conv5 = zext i16 %port to i32
  %1 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !9
  %cmp6 = icmp ule i32 %conv5, %1
  br i1 %cmp6, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end4
  %conv8 = zext i16 %port to i32
  %2 = load i32, i32* @xprt_max_resvport, align 4, !tbaa !9
  %cmp9 = icmp ugt i32 %conv8, %2
  br i1 %cmp9, label %if.then11, label %if.end13

if.then11:                                        ; preds = %lor.lhs.false, %if.end4
  %3 = load i32, i32* @xprt_max_resvport, align 4, !tbaa !9
  %conv12 = trunc i32 %3 to i16
  br label %return

if.end13:                                         ; preds = %lor.lhs.false
  %dec = add i16 %port, -1
  br label %return

return:                                           ; preds = %if.end, %if.end13, %if.then11
  %retval.0 = phi i16 [ %conv12, %if.then11 ], [ %dec, %if.end13 ], [ 0, %if.end ]
  ret i16 %retval.0
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_get_random_port() #0 {
entry:
  %0 = load i32, i32* @xprt_max_resvport, align 4, !tbaa !9
  %1 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !9
  %sub = sub i32 %0, %1
  %add = add i32 %sub, 1
  %conv = trunc i32 %add to i16
  %call = call i32 @prandom_u32()
  %conv1 = trunc i32 %call to i16
  %conv2 = zext i16 %conv1 to i32
  %conv3 = zext i16 %conv to i32
  %rem = srem i32 %conv2, %conv3
  %conv4 = trunc i32 %rem to i16
  %conv5 = zext i16 %conv4 to i32
  %2 = load i32, i32* @xprt_min_resvport, align 4, !tbaa !9
  %add6 = add i32 %conv5, %2
  %conv7 = trunc i32 %add6 to i16
  ret i16 %conv7
}

declare i32 @prandom_u32() #1

; Function Attrs: nounwind uwtable
define internal void @xs_set_memalloc(%struct.rpc_xprt* %xprt) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_tcp(%struct.xprt_create* %args) #0 {
entry:
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %.compoundliteral16 = alloca %struct.atomic64_t, align 8
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !2
  %1 = load i32, i32* @xprt_max_tcp_slot_table_entries, align 4, !tbaa !9
  %flags = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 8
  %2 = load i32, i32* %flags, align 8, !tbaa !230
  %and = and i32 %2, 1
  %tobool = icmp ne i32 %and, 0
  %. = select i1 %tobool, i32 65536, i32 %1
  %3 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !9
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %3, i32 %.)
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %4)
  br i1 %call1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %entry
  %5 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 0
  %6 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 6, i32* %prot, align 8, !tbaa !10
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !28
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !29
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 60000, i64* %bind_timeout, align 8, !tbaa !30
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  store i64 3000, i64* %reestablish_timeout, align 8, !tbaa !31
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  store i64 300000, i64* %idle_timeout, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @xs_tcp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !33
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_tcp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !34
  %timeout4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  %7 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout4, align 8, !tbaa !34
  %to_maxval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %7, i32 0, i32 1
  %8 = load i64, i64* %to_maxval, align 8, !tbaa !231
  %max_reconnect_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 31
  store i64 %8, i64* %max_reconnect_timeout, align 8, !tbaa !181
  %timeout5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  %9 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout5, align 8, !tbaa !34
  %to_initval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %9, i32 0, i32 0
  %10 = load i64, i64* %to_initval, align 8, !tbaa !232
  %timeout6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  %11 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout6, align 8, !tbaa !34
  %to_retries = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %11, i32 0, i32 3
  %12 = load i32, i32* %to_retries, align 8, !tbaa !233
  %add = add i32 %12, 1
  %conv = zext i32 %add to i64
  %mul = mul i64 %10, %conv
  %connect_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 30
  store i64 %mul, i64* %connect_timeout, align 8, !tbaa !234
  %recv_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  call void @__init_work(%struct.work_struct* %recv_worker, i32 0)
  %recv_worker7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  %data = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker7, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8, !tbaa !35
  %13 = bitcast %struct.atomic64_t* %data to i8*
  %14 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 8, i32 8, i1 false), !tbaa.struct !36
  %recv_worker8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  %entry9 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker8, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry9)
  %recv_worker10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 12
  %func = getelementptr inbounds %struct.work_struct, %struct.work_struct* %recv_worker10, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_tcp_data_receive_workfn, void (%struct.work_struct*)** %func, align 8, !tbaa !38
  %connect_worker = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker, i32 0, i32 0
  call void @__init_work(%struct.work_struct* %work, i32 0)
  %connect_worker13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work14 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker13, i32 0, i32 0
  %data15 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work14, i32 0, i32 0
  %counter17 = getelementptr inbounds %struct.atomic64_t, %struct.atomic64_t* %.compoundliteral16, i32 0, i32 0
  store i64 68719476704, i64* %counter17, align 8, !tbaa !35
  %15 = bitcast %struct.atomic64_t* %data15 to i8*
  %16 = bitcast %struct.atomic64_t* %.compoundliteral16 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 8, i32 8, i1 false), !tbaa.struct !36
  %connect_worker18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work19 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker18, i32 0, i32 0
  %entry20 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work19, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry20)
  %connect_worker21 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %work22 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker21, i32 0, i32 0
  %func23 = getelementptr inbounds %struct.work_struct, %struct.work_struct* %work22, i32 0, i32 2
  store void (%struct.work_struct*)* @xs_tcp_setup_socket, void (%struct.work_struct*)** %func23, align 8, !tbaa !38
  %connect_worker27 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %timer = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker27, i32 0, i32 1
  call void @init_timer_key(%struct.timer_list* %timer, i32 2097152, i8* null, %struct.lock_class_key* null)
  %connect_worker28 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %timer29 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker28, i32 0, i32 1
  %function = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer29, i32 0, i32 2
  store void (i64)* @delayed_work_timer_fn, void (i64)** %function, align 8, !tbaa !39
  %connect_worker30 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %17 = ptrtoint %struct.delayed_work* %connect_worker30 to i64
  %connect_worker31 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %6, i32 0, i32 11
  %timer32 = getelementptr inbounds %struct.delayed_work, %struct.delayed_work* %connect_worker31, i32 0, i32 1
  %data33 = getelementptr inbounds %struct.timer_list, %struct.timer_list* %timer32, i32 0, i32 3
  store i64 %17, i64* %data33, align 8, !tbaa !40
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %18 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv38 = zext i16 %18 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end3
  %Pivot = icmp slt i32 %conv38, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv38, 10
  br i1 %SwitchLeaf2, label %sw.bb43, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv38, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %19 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %19, i32 0, i32 1
  %20 = load i16, i16* %sin_port, align 2, !tbaa !173
  %conv39 = zext i16 %20 to i32
  %cmp = icmp ne i32 %conv39, 0
  br i1 %cmp, label %if.then41, label %if.end42

if.then41:                                        ; preds = %sw.bb
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %sw.bb
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0))
  br label %sw.epilog

sw.bb43:                                          ; preds = %LeafBlock1
  %21 = bitcast %struct.sockaddr* %0 to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %21, i32 0, i32 1
  %22 = load i16, i16* %sin6_port, align 2, !tbaa !174
  %conv44 = zext i16 %22 to i32
  %cmp45 = icmp ne i32 %conv44, 0
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %sw.bb43
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %sw.bb43
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15, i32 0, i32 0))
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end48, %if.end42
  %call50 = call i32 @xprt_bound(%struct.rpc_xprt* %call)
  %tobool51 = icmp ne i32 %call50, 0
  %call60 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call60, label %cleanup, label %out_err

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out_err

out_err:                                          ; preds = %NewDefault, %sw.epilog
  %.sink = phi i64 [ -22, %sw.epilog ], [ -97, %NewDefault ]
  %call63 = call i8* @ERR_PTR(i64 %.sink)
  %23 = bitcast i8* %call63 to %struct.rpc_xprt*
  call void @xs_xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %entry, %out_err
  %retval.0 = phi %struct.rpc_xprt* [ %23, %out_err ], [ %call, %entry ], [ %call, %sw.epilog ]
  ret %struct.rpc_xprt* %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_data_receive_workfn(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1464
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  call void @xs_tcp_data_receive(%struct.sock_xprt* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_setup_socket(%struct.work_struct* %work) #0 {
entry:
  %0 = bitcast %struct.work_struct* %work to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 -1368
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !67
  %xprt2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 0
  %tobool = icmp ne %struct.socket* %2, null
  br i1 %tobool, label %do.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt2)
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %call, i32 0, i32 0
  %3 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %3 to i32
  %call3 = call %struct.socket* @xs_create_sock(%struct.rpc_xprt* %xprt2, %struct.sock_xprt* %1, i32 %conv, i32 1, i32 6, i1 zeroext true)
  %4 = bitcast %struct.socket* %call3 to i8*
  %call4 = call zeroext i1 @IS_ERR(i8* %4)
  br i1 %call4, label %if.then5, label %do.end

if.then5:                                         ; preds = %if.then
  %5 = bitcast %struct.socket* %call3 to i8*
  %call6 = call i64 @PTR_ERR(i8* %5)
  %conv7 = trunc i64 %call6 to i32
  br label %out

do.end:                                           ; preds = %entry, %if.then
  %sock.0 = phi %struct.socket* [ %2, %entry ], [ %call3, %if.then ]
  %call9 = call i32 @xs_tcp_finish_connecting(%struct.rpc_xprt* %xprt2, %struct.socket* %sock.0)
  call void @trace_rpc_socket_connect(%struct.rpc_xprt* %xprt2, %struct.socket* %sock.0, i32 %call9)
  br label %NodeBlock24

NodeBlock24:                                      ; preds = %do.end
  %Pivot25 = icmp slt i32 %call9, -99
  br i1 %Pivot25, label %NodeBlock10, label %NodeBlock22

NodeBlock22:                                      ; preds = %NodeBlock24
  %Pivot23 = icmp slt i32 %call9, -22
  br i1 %Pivot23, label %NodeBlock14, label %NodeBlock20

NodeBlock20:                                      ; preds = %NodeBlock22
  %Pivot21 = icmp slt i32 %call9, 0
  br i1 %Pivot21, label %LeafBlock16, label %LeafBlock18

LeafBlock18:                                      ; preds = %NodeBlock20
  %SwitchLeaf19 = icmp eq i32 %call9, 0
  br i1 %SwitchLeaf19, label %sw.bb14, label %NewDefault

LeafBlock16:                                      ; preds = %NodeBlock20
  %SwitchLeaf17 = icmp eq i32 %call9, -22
  br i1 %SwitchLeaf17, label %sw.bb15, label %NewDefault

NodeBlock14:                                      ; preds = %NodeBlock22
  %Pivot15 = icmp slt i32 %call9, -98
  br i1 %Pivot15, label %sw.bb, label %LeafBlock12

LeafBlock12:                                      ; preds = %NodeBlock14
  %SwitchLeaf13 = icmp eq i32 %call9, -98
  br i1 %SwitchLeaf13, label %sw.bb15, label %NewDefault

NodeBlock10:                                      ; preds = %NodeBlock24
  %Pivot11 = icmp slt i32 %call9, -105
  br i1 %Pivot11, label %NodeBlock, label %NodeBlock8

NodeBlock8:                                       ; preds = %NodeBlock10
  %Pivot9 = icmp slt i32 %call9, -101
  br i1 %Pivot9, label %LeafBlock3, label %LeafBlock6

LeafBlock6:                                       ; preds = %NodeBlock8
  %SwitchLeaf7 = icmp eq i32 %call9, -101
  br i1 %SwitchLeaf7, label %sw.bb15, label %NewDefault

LeafBlock3:                                       ; preds = %NodeBlock8
  %call9.off4 = add i32 %call9, 105
  %SwitchLeaf5 = icmp ule i32 %call9.off4, 1
  br i1 %SwitchLeaf5, label %sw.bb15, label %NewDefault

NodeBlock:                                        ; preds = %NodeBlock10
  %Pivot = icmp slt i32 %call9, -111
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call9, -111
  br i1 %SwitchLeaf2, label %sw.bb15, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %call9.off = add i32 %call9, 115
  %SwitchLeaf = icmp ule i32 %call9.off, 1
  br i1 %SwitchLeaf, label %sw.bb14, label %NewDefault

NewDefault:                                       ; preds = %LeafBlock18, %LeafBlock16, %LeafBlock12, %LeafBlock6, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %sw.default

sw.default:                                       ; preds = %NewDefault
  %call13 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.xs_tcp_setup_socket, i32 0, i32 0), i32 %call9)
  br label %sw.bb

sw.bb:                                            ; preds = %NodeBlock14, %sw.default
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt2)
  br label %out

sw.bb14:                                          ; preds = %LeafBlock18, %LeafBlock
  %6 = bitcast %struct.sock_xprt* %1 to i8*
  call void @xprt_unlock_connect(%struct.rpc_xprt* %xprt2, i8* %6)
  br label %cleanup.cont

sw.bb15:                                          ; preds = %LeafBlock16, %LeafBlock12, %LeafBlock6, %LeafBlock3, %LeafBlock1
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt2)
  br label %out

out:                                              ; preds = %sw.bb, %sw.bb15, %if.then5
  %status.0 = phi i32 [ -11, %sw.bb ], [ %call9, %sw.bb15 ], [ %conv7, %if.then5 ]
  %7 = bitcast %struct.sock_xprt* %1 to i8*
  call void @xprt_unlock_connect(%struct.rpc_xprt* %xprt2, i8* %7)
  call void @xprt_clear_connecting(%struct.rpc_xprt* %xprt2)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %xprt2, i32 %status.0)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.bb14, %out
  ret void
}

declare void @xprt_lock_and_alloc_slot(%struct.rpc_xprt*, %struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_send_request(%struct.rpc_task* %task) #0 {
entry:
  %sent = alloca i32, align 4
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !63
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %4 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #7
  %rq_snd_buf1 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf1)
  %rq_snd_buf2 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf2, i32 0, i32 0
  %arraydecay = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i32 0, i32 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay, i32 0, i32 0
  %5 = load i8*, i8** %iov_base, align 8, !tbaa !64
  %6 = bitcast i8* %5 to i32*
  %rq_snd_buf3 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %head4 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf3, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head4, i32 0, i32 0
  %iov_len = getelementptr inbounds %struct.kvec, %struct.kvec* %arraydecay5, i32 0, i32 1
  %7 = load i64, i64* %iov_len, align 8, !tbaa !66
  %conv = trunc i64 %7 to i32
  call void @xs_pktdump(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.2, i32 0, i32 0), i32* %6, i32 %conv)
  %tk_flags = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 18
  %8 = load i16, i16* %tk_flags, align 4, !tbaa !62
  %conv6 = zext i16 %8 to i32
  %and = and i32 %conv6, 2048
  %tobool = icmp ne i32 %and, 0
  %. = select i1 %tobool, i8 0, i8 1
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 10
  %call = call zeroext i1 @constant_test_bit(i64 3, i64* %sock_state)
  br i1 %call, label %if.then11, label %if.end12

if.then11:                                        ; preds = %entry
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %9 = load %struct.socket*, %struct.socket** %sock, align 8, !tbaa !67
  call void @xs_tcp_set_socket_timeouts(%struct.rpc_xprt* %1, %struct.socket* %9)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %entry
  br label %while.cond

while.cond:                                       ; preds = %while.cond.backedge, %if.end12
  %vm_wait.0 = phi i8 [ 0, %if.end12 ], [ %vm_wait.0.be, %while.cond.backedge ]
  store i32 0, i32* %sent, align 4, !tbaa !9
  %sock13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %10 = load %struct.socket*, %struct.socket** %sock13, align 8, !tbaa !67
  %rq_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %11 = load i32, i32* %rq_bytes_sent, align 8, !tbaa !57
  %tobool14 = trunc i8 %. to i1
  %call15 = call i32 @xs_sendpages(%struct.socket* %10, %struct.sockaddr* null, i32 0, %struct.xdr_buf* %rq_snd_buf, i32 %11, i1 zeroext %tobool14, i32* %sent)
  %12 = load i32, i32* %sent, align 4, !tbaa !9
  %rq_bytes_sent16 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %13 = load i32, i32* %rq_bytes_sent16, align 8, !tbaa !57
  %add = add i32 %13, %12
  store i32 %add, i32* %rq_bytes_sent16, align 8, !tbaa !57
  %14 = load i32, i32* %sent, align 4, !tbaa !9
  %conv17 = sext i32 %14 to i64
  %rq_xmit_bytes_sent = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 17
  %15 = load i64, i64* %rq_xmit_bytes_sent, align 8, !tbaa !74
  %add18 = add i64 %15, %conv17
  store i64 %add18, i64* %rq_xmit_bytes_sent, align 8, !tbaa !74
  %rq_bytes_sent19 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  %16 = load i32, i32* %rq_bytes_sent19, align 8, !tbaa !57
  %rq_snd_buf20 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 1
  %len = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf20, i32 0, i32 7
  %17 = load i32, i32* %len, align 8, !tbaa !60
  %cmp = icmp uge i32 %16, %17
  %lnot = xor i1 %cmp, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  %conv23 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv23, i64 1)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %while.cond
  %rq_bytes_sent26 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 25
  store i32 0, i32* %rq_bytes_sent26, align 8, !tbaa !57
  br label %cleanup

if.end27:                                         ; preds = %while.cond
  %18 = load i32, i32* %sent, align 4, !tbaa !9
  %cmp28 = icmp eq i32 %18, 0
  %cmp30 = icmp eq i32 %call15, 0
  %cmp30. = select i1 %cmp28, i1 %cmp30, i1 false
  %lnot32 = xor i1 %cmp30., true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %tobool36 = icmp ne i32 %lnot.ext35, 0
  br i1 %tobool36, label %land.rhs37, label %land.end41

land.rhs37:                                       ; preds = %if.end27
  %19 = load i8, i8* @xs_tcp_send_request.__warned, align 1, !tbaa !140, !range !142
  %tobool38 = trunc i8 %19 to i1
  %lnot39 = xor i1 %tobool38, true
  br label %land.end41

land.end41:                                       ; preds = %land.rhs37, %if.end27
  %20 = phi i1 [ false, %if.end27 ], [ %lnot39, %land.rhs37 ]
  %lnot42 = xor i1 %20, true
  %lnot44 = xor i1 %lnot42, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  %expval47 = call i64 @llvm.expect.i64(i64 %conv46, i64 0)
  %tobool48 = icmp ne i64 %expval47, 0
  br i1 %tobool48, label %if.then49, label %if.end68

if.then49:                                        ; preds = %land.end41
  store i8 1, i8* @xs_tcp_send_request.__warned, align 1, !tbaa !140
  %tobool50 = icmp ne i32 1, 0
  %lnot51 = xor i1 %tobool50, true
  %lnot53 = xor i1 %lnot51, true
  %lnot.ext54 = zext i1 %lnot53 to i32
  %conv55 = sext i32 %lnot.ext54 to i64
  %expval56 = call i64 @llvm.expect.i64(i64 %conv55, i64 0)
  %tobool57 = icmp ne i64 %expval56, 0
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.then49
  call void @warn_slowpath_null(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.6, i32 0, i32 0), i32 694)
  br label %if.end59

if.end59:                                         ; preds = %if.then58, %if.then49
  %tobool61 = icmp ne i32 1, 0
  %lnot62 = xor i1 %tobool61, true
  %lnot64 = xor i1 %lnot62, true
  %lnot.ext65 = zext i1 %lnot64 to i32
  %conv66 = sext i32 %lnot.ext65 to i64
  %expval67 = call i64 @llvm.expect.i64(i64 %conv66, i64 0)
  br label %if.end68

if.end68:                                         ; preds = %if.end59, %land.end41
  %tobool70 = icmp ne i32 %lnot.ext35, 0
  %lnot71 = xor i1 %tobool70, true
  %lnot73 = xor i1 %lnot71, true
  %lnot.ext74 = zext i1 %lnot73 to i32
  %conv75 = sext i32 %lnot.ext74 to i64
  %expval76 = call i64 @llvm.expect.i64(i64 %conv75, i64 0)
  %cmp77 = icmp eq i32 %call15, -11
  br i1 %cmp77, label %cond.true80, label %if.end98

cond.true80:                                      ; preds = %if.end68
  %sock81 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 1
  %21 = load %struct.socket*, %struct.socket** %sock81, align 8, !tbaa !67
  %flags = getelementptr inbounds %struct.socket, %struct.socket* %21, i32 0, i32 2
  %call82 = call zeroext i1 @constant_test_bit(i64 2, i64* %flags)
  br i1 %call82, label %while.end, label %if.end90

if.end90:                                         ; preds = %cond.true80
  %22 = load i32, i32* %sent, align 4, !tbaa !9
  %cmp91 = icmp eq i32 %22, 0
  br i1 %cmp91, label %if.then93, label %while.cond.backedge

if.then93:                                        ; preds = %if.end90
  %tobool94 = trunc i8 %vm_wait.0 to i1
  br i1 %tobool94, label %while.end, label %while.cond.backedge

while.cond.backedge:                              ; preds = %if.end98, %if.end90, %if.then93
  %vm_wait.0.be = phi i8 [ %vm_wait.0, %if.end90 ], [ 1, %if.then93 ], [ 0, %if.end98 ]
  br label %while.cond

if.end98:                                         ; preds = %if.end68
  %cmp99 = icmp slt i32 %call15, 0
  br i1 %cmp99, label %while.end, label %while.cond.backedge

while.end:                                        ; preds = %if.end98, %if.then93, %cond.true80
  %status.0 = phi i32 [ %call15, %cond.true80 ], [ -105, %if.then93 ], [ %call15, %if.end98 ]
  br label %NodeBlock21

NodeBlock21:                                      ; preds = %while.end
  %Pivot22 = icmp slt i32 %status.0, -98
  br i1 %Pivot22, label %NodeBlock5, label %NodeBlock19

NodeBlock19:                                      ; preds = %NodeBlock21
  %Pivot20 = icmp slt i32 %status.0, -32
  br i1 %Pivot20, label %NodeBlock11, label %NodeBlock17

NodeBlock17:                                      ; preds = %NodeBlock19
  %Pivot18 = icmp slt i32 %status.0, -11
  br i1 %Pivot18, label %LeafBlock13, label %LeafBlock15

LeafBlock15:                                      ; preds = %NodeBlock17
  %SwitchLeaf16 = icmp eq i32 %status.0, -11
  br i1 %SwitchLeaf16, label %sw.bb103, label %NewDefault

LeafBlock13:                                      ; preds = %NodeBlock17
  %SwitchLeaf14 = icmp eq i32 %status.0, -32
  br i1 %SwitchLeaf14, label %sw.bb105, label %NewDefault

NodeBlock11:                                      ; preds = %NodeBlock19
  %Pivot12 = icmp slt i32 %status.0, -88
  br i1 %Pivot12, label %LeafBlock7, label %LeafBlock9

LeafBlock9:                                       ; preds = %NodeBlock11
  %SwitchLeaf10 = icmp eq i32 %status.0, -88
  br i1 %SwitchLeaf10, label %cleanup, label %NewDefault

LeafBlock7:                                       ; preds = %NodeBlock11
  %SwitchLeaf8 = icmp eq i32 %status.0, -98
  br i1 %SwitchLeaf8, label %sw.bb105, label %NewDefault

NodeBlock5:                                       ; preds = %NodeBlock21
  %Pivot6 = icmp slt i32 %status.0, -107
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %status.0, -105
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %status.0.off = add i32 %status.0, 105
  %SwitchLeaf4 = icmp ule i32 %status.0.off, 1
  br i1 %SwitchLeaf4, label %sw.bb105, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %status.0, -107
  br i1 %SwitchLeaf2, label %sw.bb105, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %status.0, -111
  br i1 %SwitchLeaf, label %sw.bb105, label %NewDefault

sw.bb103:                                         ; preds = %LeafBlock15
  %call104 = call i32 @xs_nospace(%struct.rpc_task* %task)
  br label %cleanup

sw.bb105:                                         ; preds = %LeafBlock13, %LeafBlock7, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %cleanup

NewDefault:                                       ; preds = %LeafBlock15, %LeafBlock13, %LeafBlock9, %LeafBlock7, %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %do.end108

do.end108:                                        ; preds = %NewDefault
  br label %cleanup

cleanup:                                          ; preds = %LeafBlock9, %sw.bb103, %sw.bb105, %do.end108, %if.then25
  %retval.0 = phi i32 [ 0, %if.then25 ], [ %status.0, %do.end108 ], [ %status.0, %sw.bb105 ], [ %call104, %sw.bb103 ], [ -107, %LeafBlock9 ]
  %23 = bitcast i32* %sent to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %23) #7
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_shutdown(%struct.rpc_xprt* %xprt) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  %2 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !67
  %cmp = icmp eq %struct.socket* %2, null
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %call3 = call i32 @kernel_sock_shutdown(%struct.socket* %2, i32 2)
  call void @trace_rpc_socket_shutdown(%struct.rpc_xprt* %xprt, %struct.socket* %2)
  br label %cleanup.cont

if.else:                                          ; preds = %if.end
  call void @xs_reset_transport(%struct.sock_xprt* %1)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %entry, %if.else, %if.then2
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_set_connect_timeout(%struct.rpc_xprt* %xprt, i64 %connect_timeout, i64 %reconnect_timeout) #0 {
entry:
  %to = alloca %struct.rpc_timeout, align 8
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = bitcast %struct.rpc_timeout* %to to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %2) #7
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %max_reconnect_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 31
  %3 = load i64, i64* %max_reconnect_timeout, align 8, !tbaa !181
  %cmp = icmp ult i64 %reconnect_timeout, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %max_reconnect_timeout1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 31
  store i64 %reconnect_timeout, i64* %max_reconnect_timeout1, align 8, !tbaa !181
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %connect_timeout2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  %4 = load i64, i64* %connect_timeout2, align 8, !tbaa !234
  %cmp3 = icmp ult i64 %connect_timeout, %4
  br i1 %cmp3, label %if.then4, label %if.end31

if.then4:                                         ; preds = %if.end
  %cmp5 = icmp uge i64 32, 64
  %5 = bitcast %struct.rpc_timeout* %to to i8*
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 2
  %6 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout, align 8, !tbaa !34
  %7 = bitcast %struct.rpc_timeout* %6 to i8*
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then4
  %call = call i8* @__memcpy(i8* %5, i8* %7, i64 32)
  br label %if.end8

if.else:                                          ; preds = %if.then4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %7, i64 32, i32 8, i1 false)
  br label %if.end8

if.end8:                                          ; preds = %if.else, %if.then6
  %__ret.0 = phi i8* [ %call, %if.then6 ], [ %5, %if.else ]
  %to_retries = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %to, i32 0, i32 3
  %8 = load i32, i32* %to_retries, align 8, !tbaa !233
  %add = add i32 %8, 1
  %conv = zext i32 %add to i64
  %add10 = add i64 %connect_timeout, %conv
  %sub = sub i64 %add10, 1
  %to_retries11 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %to, i32 0, i32 3
  %9 = load i32, i32* %to_retries11, align 8, !tbaa !233
  %add12 = add i32 %9, 1
  %conv13 = zext i32 %add12 to i64
  %div = udiv i64 %sub, %conv13
  %cmp14 = icmp ult i64 %div, 6000
  %.div = select i1 %cmp14, i64 6000, i64 %div
  %to_initval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %to, i32 0, i32 0
  store i64 %.div, i64* %to_initval, align 8, !tbaa !232
  %to_maxval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %to, i32 0, i32 1
  store i64 %.div, i64* %to_maxval, align 8, !tbaa !231
  %cmp20 = icmp uge i64 32, 64
  %tcp_timeout = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 18
  %10 = bitcast %struct.rpc_timeout* %tcp_timeout to i8*
  %11 = bitcast %struct.rpc_timeout* %to to i8*
  br i1 %cmp20, label %if.then22, label %if.else24

if.then22:                                        ; preds = %if.end8
  %call23 = call i8* @__memcpy(i8* %10, i8* %11, i64 32)
  br label %if.end26

if.else24:                                        ; preds = %if.end8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %11, i64 32, i32 8, i1 false)
  br label %if.end26

if.end26:                                         ; preds = %if.else24, %if.then22
  %__ret19.0 = phi i8* [ %call23, %if.then22 ], [ %10, %if.else24 ]
  %tcp_timeout28 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 18
  %timeout29 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 2
  store %struct.rpc_timeout* %tcp_timeout28, %struct.rpc_timeout** %timeout29, align 8, !tbaa !34
  %connect_timeout30 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 30
  store i64 %connect_timeout, i64* %connect_timeout30, align 8, !tbaa !234
  br label %if.end31

if.end31:                                         ; preds = %if.end26, %if.end
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  call void @set_bit(i64 3, i64* %sock_state)
  %transport_lock32 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock32)
  %12 = bitcast %struct.rpc_timeout* %to to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %12) #7
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_print_stats(%struct.rpc_xprt* %xprt, %struct.seq_file* %seq) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %call = call i32 @xprt_connected(%struct.rpc_xprt* %xprt)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load volatile i64, i64* @jiffies, align 8, !tbaa !37
  %last_used = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 28
  %3 = load i64, i64* %last_used, align 8, !tbaa !75
  %sub = sub i64 %2, %3
  %div = sdiv i64 %sub, 1000
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %idle_time.0 = phi i64 [ %div, %if.then ], [ 0, %entry ]
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 15
  %4 = load i16, i16* %srcport, align 8, !tbaa !178
  %conv = zext i16 %4 to i32
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bind_count = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat, i32 0, i32 0
  %5 = load i64, i64* %bind_count, align 8, !tbaa !76
  %stat1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_count = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat1, i32 0, i32 1
  %6 = load i64, i64* %connect_count, align 8, !tbaa !77
  %stat2 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_time = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat2, i32 0, i32 3
  %7 = load i64, i64* %connect_time, align 8, !tbaa !78
  %stat3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %sends = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat3, i32 0, i32 4
  %8 = load i64, i64* %sends, align 8, !tbaa !79
  %stat4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %recvs = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat4, i32 0, i32 5
  %9 = load i64, i64* %recvs, align 8, !tbaa !80
  %stat5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bad_xids = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat5, i32 0, i32 6
  %10 = load i64, i64* %bad_xids, align 8, !tbaa !81
  %stat6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %req_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat6, i32 0, i32 8
  %11 = load i64, i64* %req_u, align 8, !tbaa !82
  %stat7 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %bklog_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat7, i32 0, i32 9
  %12 = load i64, i64* %bklog_u, align 8, !tbaa !83
  %stat8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %max_slots = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat8, i32 0, i32 7
  %13 = load i64, i64* %max_slots, align 8, !tbaa !84
  %stat9 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %sending_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat9, i32 0, i32 10
  %14 = load i64, i64* %sending_u, align 8, !tbaa !85
  %stat10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %pending_u = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat10, i32 0, i32 11
  %15 = load i64, i64* %pending_u, align 8, !tbaa !86
  call void (%struct.seq_file*, i8*, ...) @seq_printf(%struct.seq_file* %seq, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @.str.16, i32 0, i32 0), i32 %conv, i64 %5, i64 %6, i64 %7, i64 %idle_time.0, i64 %8, i64 %9, i64 %10, i64 %11, i64 %12, i64 %13, i64 %14, i64 %15)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_set_socket_timeouts(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #0 {
entry:
  %keepidle = alloca i32, align 4
  %keepcnt = alloca i32, align 4
  %opt_on = alloca i32, align 4
  %timeo = alloca i32, align 4
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %2 = bitcast i32* %keepidle to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %2) #7
  %3 = bitcast i32* %keepcnt to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %3) #7
  %4 = bitcast i32* %opt_on to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #7
  store i32 1, i32* %opt_on, align 4, !tbaa !9
  %5 = bitcast i32* %timeo to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %5) #7
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 2
  %6 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout, align 8, !tbaa !34
  %to_initval = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %6, i32 0, i32 0
  %7 = load i64, i64* %to_initval, align 8, !tbaa !232
  %add = add i64 %7, 1000
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 1000
  %conv = trunc i64 %div to i32
  store i32 %conv, i32* %keepidle, align 4, !tbaa !9
  %timeout1 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 2
  %8 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout1, align 8, !tbaa !34
  %to_retries = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %8, i32 0, i32 3
  %9 = load i32, i32* %to_retries, align 8, !tbaa !233
  %add2 = add i32 %9, 1
  store i32 %add2, i32* %keepcnt, align 4, !tbaa !9
  %timeout3 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 2
  %10 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout3, align 8, !tbaa !34
  %to_initval4 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %10, i32 0, i32 0
  %11 = load i64, i64* %to_initval4, align 8, !tbaa !232
  %call = call i32 @jiffies_to_msecs(i64 %11)
  %timeout5 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 2
  %12 = load %struct.rpc_timeout*, %struct.rpc_timeout** %timeout5, align 8, !tbaa !34
  %to_retries6 = getelementptr inbounds %struct.rpc_timeout, %struct.rpc_timeout* %12, i32 0, i32 3
  %13 = load i32, i32* %to_retries6, align 8, !tbaa !233
  %add7 = add i32 %13, 1
  %mul = mul i32 %call, %add7
  store i32 %mul, i32* %timeo, align 4, !tbaa !9
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  call void @clear_bit(i64 3, i64* %sock_state)
  %transport_lock8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock8)
  %14 = bitcast i32* %opt_on to i8*
  %call9 = call i32 @kernel_setsockopt(%struct.socket* %sock, i32 1, i32 9, i8* %14, i32 4)
  %15 = bitcast i32* %keepidle to i8*
  %call10 = call i32 @kernel_setsockopt(%struct.socket* %sock, i32 6, i32 4, i8* %15, i32 4)
  %16 = bitcast i32* %keepidle to i8*
  %call11 = call i32 @kernel_setsockopt(%struct.socket* %sock, i32 6, i32 5, i8* %16, i32 4)
  %17 = bitcast i32* %keepcnt to i8*
  %call12 = call i32 @kernel_setsockopt(%struct.socket* %sock, i32 6, i32 6, i8* %17, i32 4)
  %18 = bitcast i32* %timeo to i8*
  %call13 = call i32 @kernel_setsockopt(%struct.socket* %sock, i32 6, i32 18, i8* %18, i32 4)
  %19 = bitcast i32* %timeo to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %19) #7
  %20 = bitcast i32* %opt_on to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %20) #7
  %21 = bitcast i32* %keepcnt to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %21) #7
  %22 = bitcast i32* %keepidle to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %22) #7
  ret void
}

declare i32 @jiffies_to_msecs(i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_socket_shutdown(%struct.rpc_xprt* %xprt, %struct.socket* %socket) #3 {
entry:
  %__u = alloca %union.anon.112, align 8
  %call = call zeroext i1 @static_key_false(%struct.static_key* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_shutdown, i32 0, i32 1))
  br i1 %call, label %do.end, label %if.end26

do.end:                                           ; preds = %entry
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !235
  %call3 = call i32 @cpumask_test_cpu(i32 %0, %struct.cpumask* @__cpu_online_mask)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %do.end
  call void @rcu_read_lock_sched_notrace()
  %1 = bitcast %union.anon.112* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %__c = bitcast %union.anon.112* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* bitcast (%struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_shutdown, i32 0, i32 4) to i8*), i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.112* %__u to %struct.tracepoint_func**
  %2 = load %struct.tracepoint_func*, %struct.tracepoint_func** %__val, align 8, !tbaa !43
  %3 = bitcast %union.anon.112* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %tobool14 = icmp ne %struct.tracepoint_func* %2, null
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end
  br label %do.body16

do.body16:                                        ; preds = %do.body16, %if.then15
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %2, %if.then15 ], [ %incdec.ptr, %do.body16 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %4 = load i8*, i8** %func, align 8, !tbaa !133
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %5 = load i8*, i8** %data, align 8, !tbaa !135
  %6 = bitcast i8* %4 to void (i8*, %struct.rpc_xprt*, %struct.socket*)*
  call void %6(i8* %5, %struct.rpc_xprt* %xprt, %struct.socket* %socket)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func18 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %7 = load i8*, i8** %func18, align 8, !tbaa !133
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %do.body16, label %if.end21

if.end21:                                         ; preds = %do.body16, %if.end
  call void @rcu_read_unlock_sched_notrace()
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end21
  ret void

if.end26:                                         ; preds = %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_data_receive(%struct.sock_xprt* %transport) #0 {
entry:
  %rd_desc = alloca %struct.read_descriptor_t, align 8
  %xprt1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  %0 = bitcast %struct.read_descriptor_t* %rd_desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %0) #7
  %written = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 0
  store i64 0, i64* %written, align 8, !tbaa !236
  %count = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 1
  store i64 2097152, i64* %count, align 8, !tbaa !238
  %arg = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 2
  %data = bitcast %union.anon.51* %arg to i8**
  %1 = bitcast %struct.rpc_xprt* %xprt1 to i8*
  store i8* %1, i8** %data, align 8, !tbaa !43
  %error = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 3
  store i32 0, i32* %error, align 8, !tbaa !239
  %recv_mutex = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_lock(%struct.mutex* %recv_mutex)
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %cmp = icmp eq %struct.sock* %2, null
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end10, %if.end
  %total.0 = phi i64 [ 0, %if.end ], [ %total.1, %if.end10 ]
  call void @lock_sock(%struct.sock* %2)
  %call = call i32 @tcp_read_sock(%struct.sock* %2, %struct.read_descriptor_t* %rd_desc, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)* @xs_tcp_data_recv)
  %cmp2 = icmp sle i32 %call, 0
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %for.cond
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 10
  call void @clear_bit(i64 2, i64* %sock_state)
  call void @release_sock(%struct.sock* %2)
  %sock_state4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 10
  %call5 = call zeroext i1 @constant_test_bit(i64 2, i64* %sock_state4)
  br i1 %call5, label %if.end10, label %out

if.else:                                          ; preds = %for.cond
  call void @release_sock(%struct.sock* %2)
  %conv = sext i32 %call to i64
  %add = add i64 %total.0, %conv
  br label %if.end10

if.end10:                                         ; preds = %if.then3, %if.else
  %total.1 = phi i64 [ %add, %if.else ], [ %total.0, %if.then3 ]
  %count11 = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 1
  store i64 65536, i64* %count11, align 8, !tbaa !238
  br label %for.cond

out:                                              ; preds = %if.then3, %entry
  %total.2 = phi i64 [ 0, %entry ], [ %total.0, %if.then3 ]
  %read.0 = phi i32 [ 0, %entry ], [ %call, %if.then3 ]
  %recv_mutex12 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 13
  call void @mutex_unlock(%struct.mutex* %recv_mutex12)
  %conv13 = trunc i64 %total.2 to i32
  call void @trace_xs_tcp_data_ready(%struct.rpc_xprt* %xprt1, i32 %read.0, i32 %conv13)
  %3 = bitcast %struct.read_descriptor_t* %rd_desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %3) #7
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @lock_sock(%struct.sock* %sk) #3 {
entry:
  call void @lock_sock_nested(%struct.sock* %sk, i32 0)
  ret void
}

declare i32 @tcp_read_sock(%struct.sock*, %struct.read_descriptor_t*, i32 (%struct.read_descriptor_t*, %struct.sk_buff*, i32, i64)*) #1

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_data_recv(%struct.read_descriptor_t* %rd_desc, %struct.sk_buff* %skb, i32 %offset, i64 %len) #0 {
entry:
  %desc = alloca %struct.xdr_skb_reader, align 8
  %arg = getelementptr inbounds %struct.read_descriptor_t, %struct.read_descriptor_t* %rd_desc, i32 0, i32 2
  %data = bitcast %union.anon.51* %arg to i8**
  %0 = load i8*, i8** %data, align 8, !tbaa !43
  %1 = bitcast i8* %0 to %struct.rpc_xprt*
  %2 = bitcast %struct.rpc_xprt* %1 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 0
  %3 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %4 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %4) #7
  %skb1 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 0
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb1, align 8, !tbaa !151
  %offset2 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  store i32 %offset, i32* %offset2, align 8, !tbaa !153
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  store i64 %len, i64* %count, align 8, !tbaa !154
  %csum = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 3
  store i32 0, i32* %csum, align 8, !tbaa !155
  br label %do.body3

do.body3:                                         ; preds = %do.cond19, %entry
  call void @trace_xs_tcp_data_recv(%struct.sock_xprt* %3)
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %and = and i64 %5, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body3
  call void @xs_tcp_read_fraghdr(%struct.rpc_xprt* %1, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end:                                           ; preds = %do.body3
  %tcp_flags4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %6 = load i64, i64* %tcp_flags4, align 8, !tbaa !240
  %and5 = and i64 %6, 4
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  call void @xs_tcp_read_xid(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end8:                                          ; preds = %if.end
  %tcp_flags9 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags9, align 8, !tbaa !240
  %and10 = and i64 %7, 16
  %tobool11 = icmp ne i64 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  call void @xs_tcp_read_calldir(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end13:                                         ; preds = %if.end8
  %tcp_flags14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %3, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags14, align 8, !tbaa !240
  %and15 = and i64 %8, 8
  %tobool16 = icmp ne i64 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end13
  call void @xs_tcp_read_data(%struct.rpc_xprt* %1, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

if.end18:                                         ; preds = %if.end13
  call void @xs_tcp_read_discard(%struct.sock_xprt* %3, %struct.xdr_skb_reader* %desc)
  br label %do.cond19

do.cond19:                                        ; preds = %if.end18, %if.then17, %if.then12, %if.then7, %if.then
  %count20 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %9 = load i64, i64* %count20, align 8, !tbaa !154
  %tobool21 = icmp ne i64 %9, 0
  br i1 %tobool21, label %do.body3, label %do.end22

do.end22:                                         ; preds = %do.cond19
  call void @trace_xs_tcp_data_recv(%struct.sock_xprt* %3)
  %count26 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %10 = load i64, i64* %count26, align 8, !tbaa !154
  %sub = sub i64 %len, %10
  %conv = trunc i64 %sub to i32
  %11 = bitcast %struct.xdr_skb_reader* %desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %11) #7
  ret i32 %conv
}

declare void @release_sock(%struct.sock*) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_xs_tcp_data_ready(%struct.rpc_xprt* %xprt, i32 %err, i32 %total) #3 {
entry:
  %__u = alloca %union.anon.114, align 8
  %call = call zeroext i1 @static_key_false(%struct.static_key* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_xs_tcp_data_ready, i32 0, i32 1))
  br i1 %call, label %do.end, label %if.end26

do.end:                                           ; preds = %entry
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !241
  %call3 = call i32 @cpumask_test_cpu(i32 %0, %struct.cpumask* @__cpu_online_mask)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %do.end
  call void @rcu_read_lock_sched_notrace()
  %1 = bitcast %union.anon.114* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %__c = bitcast %union.anon.114* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* bitcast (%struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_xs_tcp_data_ready, i32 0, i32 4) to i8*), i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.114* %__u to %struct.tracepoint_func**
  %2 = load %struct.tracepoint_func*, %struct.tracepoint_func** %__val, align 8, !tbaa !43
  %3 = bitcast %union.anon.114* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %tobool14 = icmp ne %struct.tracepoint_func* %2, null
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end
  br label %do.body16

do.body16:                                        ; preds = %do.body16, %if.then15
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %2, %if.then15 ], [ %incdec.ptr, %do.body16 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %4 = load i8*, i8** %func, align 8, !tbaa !133
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %5 = load i8*, i8** %data, align 8, !tbaa !135
  %6 = bitcast i8* %4 to void (i8*, %struct.rpc_xprt*, i32, i32)*
  call void %6(i8* %5, %struct.rpc_xprt* %xprt, i32 %err, i32 %total)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func18 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %7 = load i8*, i8** %func18, align 8, !tbaa !133
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %do.body16, label %if.end21

if.end21:                                         ; preds = %do.body16, %if.end
  call void @rcu_read_unlock_sched_notrace()
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end21
  ret void

if.end26:                                         ; preds = %entry
  ret void
}

declare void @lock_sock_nested(%struct.sock*, i32) #1

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_xs_tcp_data_recv(%struct.sock_xprt* %xs) #3 {
entry:
  %__u = alloca %union.anon.113, align 8
  %call = call zeroext i1 @static_key_false(%struct.static_key* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_xs_tcp_data_recv, i32 0, i32 1))
  br i1 %call, label %do.end, label %if.end26

do.end:                                           ; preds = %entry
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !242
  %call3 = call i32 @cpumask_test_cpu(i32 %0, %struct.cpumask* @__cpu_online_mask)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %do.end
  call void @rcu_read_lock_sched_notrace()
  %1 = bitcast %union.anon.113* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %__c = bitcast %union.anon.113* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* bitcast (%struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_xs_tcp_data_recv, i32 0, i32 4) to i8*), i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.113* %__u to %struct.tracepoint_func**
  %2 = load %struct.tracepoint_func*, %struct.tracepoint_func** %__val, align 8, !tbaa !43
  %3 = bitcast %union.anon.113* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %tobool14 = icmp ne %struct.tracepoint_func* %2, null
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end
  br label %do.body16

do.body16:                                        ; preds = %do.body16, %if.then15
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %2, %if.then15 ], [ %incdec.ptr, %do.body16 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %4 = load i8*, i8** %func, align 8, !tbaa !133
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %5 = load i8*, i8** %data, align 8, !tbaa !135
  %6 = bitcast i8* %4 to void (i8*, %struct.sock_xprt*)*
  call void %6(i8* %5, %struct.sock_xprt* %xs)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func18 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %7 = load i8*, i8** %func18, align 8, !tbaa !133
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %do.body16, label %if.end21

if.end21:                                         ; preds = %do.body16, %if.end
  call void @rcu_read_unlock_sched_notrace()
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end21
  ret void

if.end26:                                         ; preds = %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_fraghdr(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #3 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %tcp_fraghdr = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 3
  %2 = bitcast i32* %tcp_fraghdr to i8*
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %3 = load i32, i32* %tcp_offset, align 4, !tbaa !243
  %idx.ext = zext i32 %3 to i64
  %add.ptr1 = getelementptr inbounds i8, i8* %2, i64 %idx.ext
  %tcp_offset2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %4 = load i32, i32* %tcp_offset2, align 4, !tbaa !243
  %conv = zext i32 %4 to i64
  %sub = sub i64 4, %conv
  %call = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr1, i64 %sub)
  %tcp_offset3 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %5 = load i32, i32* %tcp_offset3, align 4, !tbaa !243
  %conv4 = zext i32 %5 to i64
  %add = add i64 %conv4, %call
  %conv5 = trunc i64 %add to i32
  store i32 %conv5, i32* %tcp_offset3, align 4, !tbaa !243
  %cmp = icmp ne i64 %call, %sub
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tcp_fraghdr7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 3
  %6 = load i32, i32* %tcp_fraghdr7, align 8, !tbaa !244
  %call8 = call i32 @__fswab32(i32 %6) #4
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  store i32 %call8, i32* %tcp_reclen, align 8, !tbaa !245
  %tcp_reclen9 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %7 = load i32, i32* %tcp_reclen9, align 8, !tbaa !245
  %and = and i32 %7, -2147483648
  %tobool = icmp ne i32 %and, 0
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %and12 = and i64 %8, -2
  %or = or i64 %8, 1
  %and12.sink = select i1 %tobool, i64 %or, i64 %and12
  store i64 %and12.sink, i64* %tcp_flags, align 8, !tbaa !240
  %tcp_reclen14 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %9 = load i32, i32* %tcp_reclen14, align 8, !tbaa !245
  %and15 = and i32 %9, 2147483647
  store i32 %and15, i32* %tcp_reclen14, align 8, !tbaa !245
  %tcp_flags16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %10 = load i64, i64* %tcp_flags16, align 8, !tbaa !240
  %and17 = and i64 %10, -3
  store i64 %and17, i64* %tcp_flags16, align 8, !tbaa !240
  %tcp_offset18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  store i32 0, i32* %tcp_offset18, align 4, !tbaa !243
  %tcp_reclen19 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %11 = load i32, i32* %tcp_reclen19, align 8, !tbaa !245
  %cmp20 = icmp ult i32 %11, 8
  %lnot = xor i1 %cmp20, true
  %lnot22 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot22 to i32
  %conv23 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %do.end, label %cleanup.cont

do.end:                                           ; preds = %if.end
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %do.end, %entry, %if.end
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_xid(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #3 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !243
  %conv = zext i32 %0 to i64
  %sub = sub i64 4, %conv
  %tcp_xid = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 4
  %1 = bitcast i32* %tcp_xid to i8*
  %tcp_offset1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %2 = load i32, i32* %tcp_offset1, align 4, !tbaa !243
  %idx.ext = zext i32 %2 to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %call = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr, i64 %sub)
  %tcp_offset2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %3 = load i32, i32* %tcp_offset2, align 4, !tbaa !243
  %conv3 = zext i32 %3 to i64
  %add = add i64 %conv3, %call
  %conv4 = trunc i64 %add to i32
  store i32 %conv4, i32* %tcp_offset2, align 4, !tbaa !243
  %cmp = icmp ne i64 %call, %sub
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %4 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %and = and i64 %4, -5
  store i64 %and, i64* %tcp_flags, align 8, !tbaa !240
  %tcp_flags6 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags6, align 8, !tbaa !240
  %or = or i64 %5, 16
  store i64 %or, i64* %tcp_flags6, align 8, !tbaa !240
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 8
  store i64 4, i64* %tcp_copied, align 8, !tbaa !246
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.end, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_calldir(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #3 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !243
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 4
  %conv1 = trunc i64 %sub to i32
  %conv2 = zext i32 %conv1 to i64
  %sub3 = sub i64 4, %conv2
  %tcp_calldir = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 5
  %1 = bitcast i32* %tcp_calldir to i8*
  %idx.ext = zext i32 %conv1 to i64
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %idx.ext
  %call = call i64 @xdr_skb_read_bits(%struct.xdr_skb_reader* %desc, i8* %add.ptr, i64 %sub3)
  %tcp_offset4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %2 = load i32, i32* %tcp_offset4, align 4, !tbaa !243
  %conv5 = zext i32 %2 to i64
  %add = add i64 %conv5, %call
  %conv6 = trunc i64 %add to i32
  store i32 %conv6, i32* %tcp_offset4, align 4, !tbaa !243
  %cmp = icmp ne i64 %call, %sub3
  br i1 %cmp, label %cleanup.cont, label %if.end

if.end:                                           ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %3 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %and = and i64 %3, -17
  store i64 %and, i64* %tcp_flags, align 8, !tbaa !240
  %tcp_calldir8 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 5
  %4 = load i32, i32* %tcp_calldir8, align 8, !tbaa !247
  %call9 = call i32 @__fswab32(i32 %4) #4
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %call9, 1
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call9, 1
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %call9, 0
  br i1 %SwitchLeaf, label %sw.bb15, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %tcp_flags10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags10, align 8, !tbaa !240
  %or = or i64 %5, 32
  store i64 %or, i64* %tcp_flags10, align 8, !tbaa !240
  %tcp_flags11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %6 = load i64, i64* %tcp_flags11, align 8, !tbaa !240
  %or12 = or i64 %6, 8
  store i64 %or12, i64* %tcp_flags11, align 8, !tbaa !240
  %tcp_flags13 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags13, align 8, !tbaa !240
  %or14 = or i64 %7, 64
  store i64 %or14, i64* %tcp_flags13, align 8, !tbaa !240
  br label %sw.epilog

sw.bb15:                                          ; preds = %LeafBlock
  %tcp_flags16 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %8 = load i64, i64* %tcp_flags16, align 8, !tbaa !240
  %or17 = or i64 %8, 32
  store i64 %or17, i64* %tcp_flags16, align 8, !tbaa !240
  %tcp_flags18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %9 = load i64, i64* %tcp_flags18, align 8, !tbaa !240
  %or19 = or i64 %9, 8
  store i64 %or19, i64* %tcp_flags18, align 8, !tbaa !240
  %tcp_flags20 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %10 = load i64, i64* %tcp_flags20, align 8, !tbaa !240
  %and21 = and i64 %10, -65
  store i64 %and21, i64* %tcp_flags20, align 8, !tbaa !240
  br label %sw.epilog

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %do.end24

do.end24:                                         ; preds = %NewDefault
  %xprt = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 0
  call void @xs_tcp_force_close(%struct.rpc_xprt* %xprt)
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end24, %sw.bb15, %sw.bb
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %sw.epilog, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #0 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %call = call i32 @_xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %and = and i64 %2, -9
  store i64 %and, i64* %tcp_flags, align 8, !tbaa !240
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_discard(%struct.sock_xprt* %transport, %struct.xdr_skb_reader* %desc) #3 {
entry:
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 7
  %0 = load i32, i32* %tcp_reclen, align 8, !tbaa !245
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %1 = load i32, i32* %tcp_offset, align 4, !tbaa !243
  %sub = sub i32 %0, %1
  %conv = zext i32 %sub to i64
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %2 = load i64, i64* %count, align 8, !tbaa !154
  %cmp = icmp ugt i64 %conv, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %count2 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %3 = load i64, i64* %count2, align 8, !tbaa !154
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.0 = phi i64 [ %3, %if.then ], [ %conv, %entry ]
  %count3 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %4 = load i64, i64* %count3, align 8, !tbaa !154
  %sub4 = sub i64 %4, %len.0
  store i64 %sub4, i64* %count3, align 8, !tbaa !154
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %5 = load i32, i32* %offset, align 8, !tbaa !153
  %conv5 = zext i32 %5 to i64
  %add = add i64 %conv5, %len.0
  %conv6 = trunc i64 %add to i32
  store i32 %conv6, i32* %offset, align 8, !tbaa !153
  %tcp_offset7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %6 = load i32, i32* %tcp_offset7, align 4, !tbaa !243
  %conv8 = zext i32 %6 to i64
  %add9 = add i64 %conv8, %len.0
  %conv10 = trunc i64 %add9 to i32
  store i32 %conv10, i32* %tcp_offset7, align 4, !tbaa !243
  call void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_force_close(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void @xprt_force_disconnect(%struct.rpc_xprt* %xprt)
  ret void
}

declare void @xprt_force_disconnect(%struct.rpc_xprt*) #1

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_check_fraghdr(%struct.sock_xprt* %transport) #0 {
entry:
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  %0 = load i32, i32* %tcp_offset, align 4, !tbaa !243
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 7
  %1 = load i32, i32* %tcp_reclen, align 8, !tbaa !245
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %or = or i64 %2, 2
  store i64 %or, i64* %tcp_flags, align 8, !tbaa !240
  %tcp_offset1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 6
  store i32 0, i32* %tcp_offset1, align 4, !tbaa !243
  %tcp_flags2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %3 = load i64, i64* %tcp_flags2, align 8, !tbaa !240
  %and = and i64 %3, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.then
  %tcp_flags4 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %4 = load i64, i64* %tcp_flags4, align 8, !tbaa !240
  %and5 = and i64 %4, -9
  store i64 %and5, i64* %tcp_flags4, align 8, !tbaa !240
  %tcp_flags6 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 9
  %5 = load i64, i64* %tcp_flags6, align 8, !tbaa !240
  %or7 = or i64 %5, 4
  store i64 %or7, i64* %tcp_flags6, align 8, !tbaa !240
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 8
  store i64 0, i64* %tcp_copied, align 8, !tbaa !246
  br label %if.end8

if.end8:                                          ; preds = %if.then, %if.then3, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @_xs_tcp_read_data(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #3 {
entry:
  %call = call i32 @xs_tcp_read_reply(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xs_tcp_read_reply(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc) #3 {
entry:
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_lock_bh(%struct.spinlock* %transport_lock)
  %tcp_xid = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 4
  %2 = load i32, i32* %tcp_xid, align 4, !tbaa !248
  %call = call %struct.rpc_rqst* @xprt_lookup_rqst(%struct.rpc_xprt* %xprt, i32 %2)
  %tobool = icmp ne %struct.rpc_rqst* %call, null
  br i1 %tobool, label %if.end, label %do.end3

do.end3:                                          ; preds = %entry
  %transport_lock4 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock4)
  br label %cleanup

if.end:                                           ; preds = %entry
  call void @xs_tcp_read_common(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc, %struct.rpc_rqst* %call)
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %3 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %and = and i64 %3, 8
  %tobool5 = icmp ne i64 %and, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  %rq_task = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %call, i32 0, i32 3
  %4 = load %struct.rpc_task*, %struct.rpc_task** %rq_task, align 8, !tbaa !147
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %5 = load i64, i64* %tcp_copied, align 8, !tbaa !246
  %conv = trunc i64 %5 to i32
  call void @xprt_complete_rqst(%struct.rpc_task* %4, i32 %conv)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %transport_lock8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 32
  call void @spin_unlock_bh(%struct.spinlock* %transport_lock8)
  br label %cleanup

cleanup:                                          ; preds = %if.end7, %do.end3
  %retval.0 = phi i32 [ 0, %if.end7 ], [ -1, %do.end3 ]
  ret i32 %retval.0
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @xs_tcp_read_common(%struct.rpc_xprt* %xprt, %struct.xdr_skb_reader* %desc, %struct.rpc_rqst* %req) #3 {
entry:
  %my_desc = alloca %struct.xdr_skb_reader, align 8
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %rq_private_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %2 = load i64, i64* %tcp_flags, align 8, !tbaa !240
  %and = and i64 %2, 32
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %cmp = icmp uge i64 4, 64
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf, i32 0, i32 0
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 0
  %3 = load i8*, i8** %iov_base, align 8, !tbaa !64
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %4 = load i64, i64* %tcp_copied, align 8, !tbaa !246
  %add.ptr2 = getelementptr i8, i8* %3, i64 %4
  %tcp_calldir = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 5
  %5 = bitcast i32* %tcp_calldir to i8*
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %call = call i8* @__memcpy(i8* %add.ptr2, i8* %5, i64 4)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr2, i8* %5, i64 4, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then1
  %__ret.0 = phi i8* [ %call, %if.then1 ], [ %add.ptr2, %if.else ]
  %tcp_copied10 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %6 = load i64, i64* %tcp_copied10, align 8, !tbaa !246
  %add = add i64 %6, 4
  store i64 %add, i64* %tcp_copied10, align 8, !tbaa !246
  %tcp_flags11 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %7 = load i64, i64* %tcp_flags11, align 8, !tbaa !240
  %and12 = and i64 %7, -33
  store i64 %and12, i64* %tcp_flags11, align 8, !tbaa !240
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry
  %count = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %8 = load i64, i64* %count, align 8, !tbaa !154
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %9 = load i32, i32* %tcp_reclen, align 8, !tbaa !245
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %10 = load i32, i32* %tcp_offset, align 4, !tbaa !243
  %sub = sub i32 %9, %10
  %conv = zext i32 %sub to i64
  %cmp14 = icmp ugt i64 %8, %conv
  br i1 %cmp14, label %if.then16, label %if.else39

if.then16:                                        ; preds = %if.end13
  %11 = bitcast %struct.xdr_skb_reader* %my_desc to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* %11) #7
  %tcp_reclen17 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %12 = load i32, i32* %tcp_reclen17, align 8, !tbaa !245
  %tcp_offset18 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %13 = load i32, i32* %tcp_offset18, align 4, !tbaa !243
  %sub19 = sub i32 %12, %13
  %conv20 = zext i32 %sub19 to i64
  %cmp23 = icmp uge i64 32, 64
  %14 = bitcast %struct.xdr_skb_reader* %my_desc to i8*
  %15 = bitcast %struct.xdr_skb_reader* %desc to i8*
  br i1 %cmp23, label %if.then25, label %if.else27

if.then25:                                        ; preds = %if.then16
  %call26 = call i8* @__memcpy(i8* %14, i8* %15, i64 32)
  br label %if.end28

if.else27:                                        ; preds = %if.then16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 32, i32 8, i1 false)
  br label %if.end28

if.end28:                                         ; preds = %if.else27, %if.then25
  %__ret22.0 = phi i8* [ %call26, %if.then25 ], [ %14, %if.else27 ]
  %count30 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %my_desc, i32 0, i32 2
  store i64 %conv20, i64* %count30, align 8, !tbaa !154
  %tcp_copied31 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %16 = load i64, i64* %tcp_copied31, align 8, !tbaa !246
  %conv32 = trunc i64 %16 to i32
  %call33 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %rq_private_buf, i32 %conv32, %struct.xdr_skb_reader* %my_desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  %count34 = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 2
  %17 = load i64, i64* %count34, align 8, !tbaa !154
  %sub35 = sub i64 %17, %call33
  store i64 %sub35, i64* %count34, align 8, !tbaa !154
  %offset = getelementptr inbounds %struct.xdr_skb_reader, %struct.xdr_skb_reader* %desc, i32 0, i32 1
  %18 = load i32, i32* %offset, align 8, !tbaa !153
  %conv36 = zext i32 %18 to i64
  %add37 = add nsw i64 %conv36, %call33
  %conv38 = trunc i64 %add37 to i32
  store i32 %conv38, i32* %offset, align 8, !tbaa !153
  %19 = bitcast %struct.xdr_skb_reader* %my_desc to i8*
  call void @llvm.lifetime.end.p0i8(i64 32, i8* %19) #7
  br label %if.end43

if.else39:                                        ; preds = %if.end13
  %tcp_copied40 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %20 = load i64, i64* %tcp_copied40, align 8, !tbaa !246
  %conv41 = trunc i64 %20 to i32
  %call42 = call i64 @xdr_partial_copy_from_skb(%struct.xdr_buf* %rq_private_buf, i32 %conv41, %struct.xdr_skb_reader* %desc, i64 (%struct.xdr_skb_reader*, i8*, i64)* @xdr_skb_read_bits)
  br label %if.end43

if.end43:                                         ; preds = %if.else39, %if.end28
  %len.0 = phi i64 [ %conv20, %if.end28 ], [ %8, %if.else39 ]
  %r.0 = phi i64 [ %call33, %if.end28 ], [ %call42, %if.else39 ]
  %cmp44 = icmp sgt i64 %r.0, 0
  br i1 %cmp44, label %if.then46, label %if.end53

if.then46:                                        ; preds = %if.end43
  %tcp_copied47 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %21 = load i64, i64* %tcp_copied47, align 8, !tbaa !246
  %add48 = add i64 %21, %r.0
  store i64 %add48, i64* %tcp_copied47, align 8, !tbaa !246
  %tcp_offset49 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %22 = load i32, i32* %tcp_offset49, align 4, !tbaa !243
  %conv50 = zext i32 %22 to i64
  %add51 = add nsw i64 %conv50, %r.0
  %conv52 = trunc i64 %add51 to i32
  store i32 %conv52, i32* %tcp_offset49, align 4, !tbaa !243
  br label %if.end53

if.end53:                                         ; preds = %if.then46, %if.end43
  %cmp54 = icmp ne i64 %r.0, %len.0
  br i1 %cmp54, label %if.then56, label %do.end68

if.then56:                                        ; preds = %if.end53
  %tcp_flags57 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %23 = load i64, i64* %tcp_flags57, align 8, !tbaa !240
  %and58 = and i64 %23, -9
  store i64 %and58, i64* %tcp_flags57, align 8, !tbaa !240
  br label %cleanup.cont

do.end68:                                         ; preds = %if.end53
  %tcp_copied69 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  %24 = load i64, i64* %tcp_copied69, align 8, !tbaa !246
  %rq_private_buf70 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 19
  %buflen = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_private_buf70, i32 0, i32 6
  %25 = load i32, i32* %buflen, align 4, !tbaa !148
  %conv71 = zext i32 %25 to i64
  %cmp72 = icmp eq i64 %24, %conv71
  br i1 %cmp72, label %if.then74, label %if.else77

if.then74:                                        ; preds = %do.end68
  %tcp_flags75 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %26 = load i64, i64* %tcp_flags75, align 8, !tbaa !240
  %and76 = and i64 %26, -9
  store i64 %and76, i64* %tcp_flags75, align 8, !tbaa !240
  br label %cleanup.cont

if.else77:                                        ; preds = %do.end68
  %tcp_offset78 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  %27 = load i32, i32* %tcp_offset78, align 4, !tbaa !243
  %tcp_reclen79 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  %28 = load i32, i32* %tcp_reclen79, align 8, !tbaa !245
  %cmp80 = icmp eq i32 %27, %28
  br i1 %cmp80, label %if.then82, label %cleanup.cont

if.then82:                                        ; preds = %if.else77
  %tcp_flags83 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %29 = load i64, i64* %tcp_flags83, align 8, !tbaa !240
  %and84 = and i64 %29, 1
  %tobool85 = icmp ne i64 %and84, 0
  br i1 %tobool85, label %if.then86, label %cleanup.cont

if.then86:                                        ; preds = %if.then82
  %tcp_flags87 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  %30 = load i64, i64* %tcp_flags87, align 8, !tbaa !240
  %and88 = and i64 %30, -9
  store i64 %and88, i64* %tcp_flags87, align 8, !tbaa !240
  br label %cleanup.cont

cleanup.cont:                                     ; preds = %if.then56, %if.else77, %if.then86, %if.then82, %if.then74
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @PTR_ERR(i8* %ptr) #3 {
entry:
  %0 = ptrtoint i8* %ptr to i64
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal i32 @xs_tcp_finish_connecting(%struct.rpc_xprt* %xprt, %struct.socket* %sock) #0 {
entry:
  %addr_pref = alloca i32, align 4
  %0 = bitcast %struct.rpc_xprt* %xprt to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  %2 = load %struct.sock*, %struct.sock** %inet, align 8, !tbaa !73
  %tobool = icmp ne %struct.sock* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %sk1 = getelementptr inbounds %struct.socket, %struct.socket* %sock, i32 0, i32 5
  %3 = load %struct.sock*, %struct.sock** %sk1, align 8, !tbaa !162
  %4 = bitcast i32* %addr_pref to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #7
  store i32 2, i32* %addr_pref, align 4, !tbaa !9
  %5 = bitcast i32* %addr_pref to i8*
  %call = call i32 @kernel_setsockopt(%struct.socket* %sock, i32 41, i32 72, i8* %5, i32 4)
  call void @xs_tcp_set_socket_timeouts(%struct.rpc_xprt* %xprt, %struct.socket* %sock)
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 44
  call void @_raw_write_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  call void @xs_save_old_callbacks(%struct.sock_xprt* %1, %struct.sock* %3)
  %6 = bitcast %struct.rpc_xprt* %xprt to i8*
  %sk_user_data = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 58
  store i8* %6, i8** %sk_user_data, align 8, !tbaa !122
  %sk_data_ready = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 63
  store void (%struct.sock*)* @xs_data_ready, void (%struct.sock*)** %sk_data_ready, align 8, !tbaa !124
  %sk_state_change = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 62
  store void (%struct.sock*)* @xs_tcp_state_change, void (%struct.sock*)** %sk_state_change, align 8, !tbaa !126
  %sk_write_space = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 64
  store void (%struct.sock*)* @xs_tcp_write_space, void (%struct.sock*)** %sk_write_space, align 8, !tbaa !105
  call void @sock_set_flag(%struct.sock* %3, i32 17)
  %sk_error_report = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 65
  store void (%struct.sock*)* @xs_error_report, void (%struct.sock*)** %sk_error_report, align 8, !tbaa !129
  %sk_allocation = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 37
  store i32 20971520, i32* %sk_allocation, align 8, !tbaa !163
  call void @sock_reset_flag(%struct.sock* %3, i32 4)
  %call2 = call %struct.tcp_sock* @tcp_sk(%struct.sock* %3)
  %nonagle = getelementptr inbounds %struct.tcp_sock, %struct.tcp_sock* %call2, i32 0, i32 32
  %bf.load = load i16, i16* %nonagle, align 4
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 15
  %bf.cast = trunc i16 %bf.clear to i8
  %conv = zext i8 %bf.cast to i32
  %or = or i32 %conv, 1
  %conv3 = trunc i32 %or to i8
  %7 = zext i8 %conv3 to i16
  %bf.load4 = load i16, i16* %nonagle, align 4
  %bf.value = and i16 %7, 15
  %bf.shl = shl i16 %bf.value, 8
  %bf.clear5 = and i16 %bf.load4, -3841
  %bf.set = or i16 %bf.clear5, %bf.shl
  store i16 %bf.set, i16* %nonagle, align 4
  %bf.result.cast = trunc i16 %bf.value to i8
  call void @xprt_clear_connected(%struct.rpc_xprt* %xprt)
  %sock6 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 1
  store %struct.socket* %sock, %struct.socket** %sock6, align 8, !tbaa !67
  %inet7 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 2
  store %struct.sock* %3, %struct.sock** %inet7, align 8, !tbaa !73
  %sk_callback_lock8 = getelementptr inbounds %struct.sock, %struct.sock* %3, i32 0, i32 44
  call void @_raw_write_unlock_bh(%struct.rwlock_t* %sk_callback_lock8)
  %8 = bitcast i32* %addr_pref to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #7
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call9 = call i32 @xprt_bound(%struct.rpc_xprt* %xprt)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end12, label %out

if.end12:                                         ; preds = %if.end
  call void @xs_set_memalloc(%struct.rpc_xprt* %xprt)
  %stat = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_count = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat, i32 0, i32 1
  %9 = load i64, i64* %connect_count, align 8, !tbaa !77
  %inc = add i64 %9, 1
  store i64 %inc, i64* %connect_count, align 8, !tbaa !77
  %10 = load volatile i64, i64* @jiffies, align 8, !tbaa !37
  %stat13 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 38
  %connect_start = getelementptr inbounds %struct.anon.86, %struct.anon.86* %stat13, i32 0, i32 2
  store i64 %10, i64* %connect_start, align 8, !tbaa !164
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  call void @set_bit(i64 1, i64* %sock_state)
  %call14 = call %struct.sockaddr* @xs_addr(%struct.rpc_xprt* %xprt)
  %addrlen = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 4
  %11 = load i64, i64* %addrlen, align 8, !tbaa !46
  %conv15 = trunc i64 %11 to i32
  %call16 = call i32 @kernel_connect(%struct.socket* %sock, %struct.sockaddr* %call14, i32 %conv15, i32 2048)
  br label %NodeBlock5

NodeBlock5:                                       ; preds = %if.end12
  %Pivot6 = icmp slt i32 %call16, -99
  br i1 %Pivot6, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock5
  %Pivot = icmp slt i32 %call16, 0
  br i1 %Pivot, label %LeafBlock1, label %LeafBlock3

LeafBlock3:                                       ; preds = %NodeBlock
  %SwitchLeaf4 = icmp eq i32 %call16, 0
  br i1 %SwitchLeaf4, label %sw.bb, label %NewDefault

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %call16, -99
  br i1 %SwitchLeaf2, label %sw.bb22, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock5
  %SwitchLeaf = icmp eq i32 %call16, -115
  br i1 %SwitchLeaf, label %sw.bb17, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock3
  call void @xs_set_srcport(%struct.sock_xprt* %1, %struct.socket* %sock)
  br label %sw.bb17

sw.bb17:                                          ; preds = %LeafBlock, %sw.bb
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  %12 = load i64, i64* %reestablish_timeout, align 8, !tbaa !31
  %cmp = icmp ult i64 %12, 3000
  br i1 %cmp, label %if.then19, label %out

if.then19:                                        ; preds = %sw.bb17
  %reestablish_timeout20 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 24
  store i64 3000, i64* %reestablish_timeout20, align 8, !tbaa !31
  br label %out

sw.bb22:                                          ; preds = %LeafBlock1
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 15
  store i16 0, i16* %srcport, align 8, !tbaa !178
  br label %out

NewDefault:                                       ; preds = %LeafBlock3, %LeafBlock1, %LeafBlock
  br label %out

out:                                              ; preds = %NewDefault, %sw.bb22, %if.then19, %sw.bb17, %if.end
  %ret.0 = phi i32 [ -107, %if.end ], [ %call16, %sw.bb17 ], [ %call16, %if.then19 ], [ %call16, %sw.bb22 ], [ %call16, %NewDefault ]
  ret i32 %ret.0
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_state_change(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call %struct.rpc_xprt* @xprt_from_sock(%struct.sock* %sk)
  %tobool = icmp ne %struct.rpc_xprt* %call, null
  br i1 %tobool, label %do.end3, label %out

do.end3:                                          ; preds = %entry
  %0 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %0, i64 0
  %1 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sk_socket = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 57
  %2 = load %struct.socket*, %struct.socket** %sk_socket, align 8, !tbaa !170
  call void @trace_rpc_socket_state_change(%struct.rpc_xprt* %call, %struct.socket* %2)
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_state = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 4
  %3 = load volatile i8, i8* %skc_state, align 2, !tbaa !169
  %conv = zext i8 %3 to i32
  br label %NodeBlock13

NodeBlock13:                                      ; preds = %do.end3
  %Pivot14 = icmp slt i32 %conv, 8
  br i1 %Pivot14, label %NodeBlock3, label %NodeBlock11

NodeBlock11:                                      ; preds = %NodeBlock13
  %Pivot12 = icmp slt i32 %conv, 9
  br i1 %Pivot12, label %sw.bb14, label %NodeBlock9

NodeBlock9:                                       ; preds = %NodeBlock11
  %Pivot10 = icmp slt i32 %conv, 11
  br i1 %Pivot10, label %LeafBlock5, label %LeafBlock7

LeafBlock7:                                       ; preds = %NodeBlock9
  %SwitchLeaf8 = icmp eq i32 %conv, 11
  br i1 %SwitchLeaf8, label %sw.bb18, label %NewDefault

LeafBlock5:                                       ; preds = %NodeBlock9
  %SwitchLeaf6 = icmp eq i32 %conv, 9
  br i1 %SwitchLeaf6, label %sw.bb24, label %NewDefault

NodeBlock3:                                       ; preds = %NodeBlock13
  %Pivot4 = icmp slt i32 %conv, 4
  br i1 %Pivot4, label %LeafBlock, label %NodeBlock

NodeBlock:                                        ; preds = %NodeBlock3
  %Pivot = icmp slt i32 %conv, 7
  br i1 %Pivot, label %LeafBlock1, label %sw.bb27

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 4
  br i1 %SwitchLeaf2, label %sw.bb9, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock3
  %SwitchLeaf = icmp eq i32 %conv, 1
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  %transport_lock = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 32
  call void @spin_lock(%struct.spinlock* %transport_lock)
  %call4 = call i32 @xprt_test_and_set_connected(%struct.rpc_xprt* %call)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %sw.bb
  %tcp_offset = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 6
  store i32 0, i32* %tcp_offset, align 4, !tbaa !243
  %tcp_reclen = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 7
  store i32 0, i32* %tcp_reclen, align 8, !tbaa !245
  %tcp_copied = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 8
  store i64 0, i64* %tcp_copied, align 8, !tbaa !246
  %tcp_flags = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 9
  store i64 6, i64* %tcp_flags, align 8, !tbaa !240
  %connect_cookie = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 25
  %4 = load i32, i32* %connect_cookie, align 8, !tbaa !249
  %inc = add i32 %4, 1
  store i32 %inc, i32* %connect_cookie, align 8, !tbaa !249
  %sock_state = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  call void @clear_bit(i64 1, i64* %sock_state)
  call void @xprt_clear_connecting(%struct.rpc_xprt* %call)
  call void @xprt_wake_pending_tasks(%struct.rpc_xprt* %call, i32 -11)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %sw.bb
  %transport_lock8 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 32
  call void @spin_unlock(%struct.spinlock* %transport_lock8)
  br label %out

sw.bb9:                                           ; preds = %LeafBlock1
  %connect_cookie10 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 25
  %5 = load i32, i32* %connect_cookie10, align 8, !tbaa !249
  %inc11 = add i32 %5, 1
  store i32 %inc11, i32* %connect_cookie10, align 8, !tbaa !249
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !31
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @set_bit(i64 6, i64* %state)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !250
  %state12 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i64 1, i64* %state12)
  %state13 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i64 3, i64* %state13)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !251
  br label %out

sw.bb14:                                          ; preds = %NodeBlock11
  %connect_cookie15 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 25
  %6 = load i32, i32* %connect_cookie15, align 8, !tbaa !249
  %inc16 = add i32 %6, 1
  store i32 %inc16, i32* %connect_cookie15, align 8, !tbaa !249
  %state17 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i64 1, i64* %state17)
  call void @xs_tcp_force_close(%struct.rpc_xprt* %call)
  br label %sw.bb18

sw.bb18:                                          ; preds = %LeafBlock7, %sw.bb14
  %reestablish_timeout19 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  %7 = load i64, i64* %reestablish_timeout19, align 8, !tbaa !31
  %cmp = icmp ult i64 %7, 3000
  br i1 %cmp, label %if.then21, label %out

if.then21:                                        ; preds = %sw.bb18
  %reestablish_timeout22 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  store i64 3000, i64* %reestablish_timeout22, align 8, !tbaa !31
  br label %out

sw.bb24:                                          ; preds = %LeafBlock5
  %state25 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @set_bit(i64 6, i64* %state25)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !252
  %state26 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 18
  call void @clear_bit(i64 1, i64* %state26)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !253
  br label %out

sw.bb27:                                          ; preds = %NodeBlock
  %sock_state28 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %1, i32 0, i32 10
  %call29 = call zeroext i1 @test_and_clear_bit(i64 1, i64* %sock_state28)
  br i1 %call29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %sw.bb27
  call void @xprt_clear_connecting(%struct.rpc_xprt* %call)
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %sw.bb27
  call void @xs_sock_mark_closed(%struct.rpc_xprt* %call)
  br label %out

NewDefault:                                       ; preds = %LeafBlock7, %LeafBlock5, %LeafBlock1, %LeafBlock
  br label %out

out:                                              ; preds = %NewDefault, %if.end7, %sw.bb9, %sw.bb24, %if.end31, %if.then21, %sw.bb18, %entry
  %sk_callback_lock32 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock32)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @xs_tcp_write_space(%struct.sock* %sk) #0 {
entry:
  %sk_callback_lock = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_lock_bh(%struct.rwlock_t* %sk_callback_lock)
  %call = call zeroext i1 @sk_stream_is_writeable(%struct.sock* %sk)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xs_write_space(%struct.sock* %sk)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %sk_callback_lock1 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 44
  call void @_raw_read_unlock_bh(%struct.rwlock_t* %sk_callback_lock1)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @sock_reset_flag(%struct.sock* %sk, i32 %flag) #3 {
entry:
  %conv = zext i32 %flag to i64
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %0 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 13
  %skc_flags = bitcast %union.anon.44* %0 to i64*
  call void @__clear_bit(i64 %conv, i64* %skc_flags)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.tcp_sock* @tcp_sk(%struct.sock* %sk) #3 {
entry:
  %0 = bitcast %struct.sock* %sk to %struct.tcp_sock*
  ret %struct.tcp_sock* %0
}

; Function Attrs: nounwind uwtable
define internal void @xs_set_srcport(%struct.sock_xprt* %transport, %struct.socket* %sock) #0 {
entry:
  %srcport = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  %0 = load i16, i16* %srcport, align 8, !tbaa !178
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call zeroext i16 @xs_sock_getport(%struct.socket* %sock)
  %srcport2 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %transport, i32 0, i32 15
  store i16 %call, i16* %srcport2, align 8, !tbaa !178
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @trace_rpc_socket_state_change(%struct.rpc_xprt* %xprt, %struct.socket* %socket) #3 {
entry:
  %__u = alloca %union.anon.125, align 8
  %call = call zeroext i1 @static_key_false(%struct.static_key* getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_state_change, i32 0, i32 1))
  br i1 %call, label %do.end, label %if.end26

do.end:                                           ; preds = %entry
  %0 = call i32 asm "movl %gs:$1,$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) #8, !srcloc !254
  %call3 = call i32 @cpumask_test_cpu(i32 %0, %struct.cpumask* @__cpu_online_mask)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %do.end
  call void @rcu_read_lock_sched_notrace()
  %1 = bitcast %union.anon.125* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %1) #7
  %__c = bitcast %union.anon.125* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__read_once_size(i8* bitcast (%struct.tracepoint_func** getelementptr inbounds (%struct.tracepoint, %struct.tracepoint* @__tracepoint_rpc_socket_state_change, i32 0, i32 4) to i8*), i8* %arraydecay, i32 8)
  %__val = bitcast %union.anon.125* %__u to %struct.tracepoint_func**
  %2 = load %struct.tracepoint_func*, %struct.tracepoint_func** %__val, align 8, !tbaa !43
  %3 = bitcast %union.anon.125* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %3) #7
  %tobool14 = icmp ne %struct.tracepoint_func* %2, null
  br i1 %tobool14, label %if.then15, label %if.end21

if.then15:                                        ; preds = %if.end
  br label %do.body16

do.body16:                                        ; preds = %do.body16, %if.then15
  %it_func_ptr.0 = phi %struct.tracepoint_func* [ %2, %if.then15 ], [ %incdec.ptr, %do.body16 ]
  %func = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 0
  %4 = load i8*, i8** %func, align 8, !tbaa !133
  %data = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 0, i32 1
  %5 = load i8*, i8** %data, align 8, !tbaa !135
  %6 = bitcast i8* %4 to void (i8*, %struct.rpc_xprt*, %struct.socket*)*
  call void %6(i8* %5, %struct.rpc_xprt* %xprt, %struct.socket* %socket)
  %incdec.ptr = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %it_func_ptr.0, i32 1
  %func18 = getelementptr inbounds %struct.tracepoint_func, %struct.tracepoint_func* %incdec.ptr, i32 0, i32 0
  %7 = load i8*, i8** %func18, align 8, !tbaa !133
  %tobool19 = icmp ne i8* %7, null
  br i1 %tobool19, label %do.body16, label %if.end21

if.end21:                                         ; preds = %do.body16, %if.end
  call void @rcu_read_unlock_sched_notrace()
  br label %cleanup

cleanup:                                          ; preds = %do.end, %if.end21
  ret void

if.end26:                                         ; preds = %entry
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_lock(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @xprt_test_and_set_connected(%struct.rpc_xprt* %xprt) #3 {
entry:
  %state = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %xprt, i32 0, i32 18
  %call = call zeroext i1 @test_and_set_bit(i64 1, i64* %state)
  %conv = zext i1 %call to i32
  ret i32 %conv
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @spin_unlock(%struct.spinlock* %lock) #5 {
entry:
  %0 = getelementptr inbounds %struct.spinlock, %struct.spinlock* %lock, i32 0, i32 0
  %rlock = bitcast %union.anon* %0 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock)
  ret void
}

declare void @_raw_spin_lock(%struct.raw_spinlock*) #1 section ".spinlock.text"

; Function Attrs: inlinehint nounwind uwtable
define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) #3 {
entry:
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %lock)
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !255
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) #3 {
entry:
  %raw_lock = getelementptr inbounds %struct.raw_spinlock, %struct.raw_spinlock* %lock, i32 0, i32 0
  call void @queued_spin_unlock(%struct.qspinlock* %raw_lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @queued_spin_unlock(%struct.qspinlock* %lock) #3 {
entry:
  call void @native_queued_spin_unlock(%struct.qspinlock* %lock)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @native_queued_spin_unlock(%struct.qspinlock* %lock) #3 {
entry:
  %__u = alloca %union.anon.126, align 1
  %tobool = trunc i8 0 to i1
  br i1 %tobool, label %if.then, label %do.body2

if.then:                                          ; preds = %entry
  call void @__compiletime_assert_17()
  br label %do.body2

do.body2:                                         ; preds = %entry, %if.then
  %tobool3 = trunc i8 0 to i1
  %conv = zext i1 %tobool3 to i32
  %mul = mul nsw i32 2, %conv
  %sub = sub nsw i32 1, %mul
  %0 = zext i32 %sub to i64
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #7, !srcloc !256
  %1 = bitcast %union.anon.126* %__u to i8*
  call void @llvm.lifetime.start.p0i8(i64 1, i8* %1) #7
  %2 = bitcast %union.anon.126* %__u to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 1, i32 1, i1 false)
  %3 = bitcast %struct.qspinlock* %lock to i8*
  %__c = bitcast %union.anon.126* %__u to [1 x i8]*
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %__c, i32 0, i32 0
  call void @__write_once_size(i8* %3, i8* %arraydecay, i32 1)
  %__val = bitcast %union.anon.126* %__u to i8*
  %4 = load i8, i8* %__val, align 1, !tbaa !43
  %5 = bitcast %union.anon.126* %__u to i8*
  call void @llvm.lifetime.end.p0i8(i64 1, i8* %5) #7
  ret void
}

declare void @__compiletime_assert_17() #1

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @sk_stream_is_writeable(%struct.sock* %sk) #3 {
entry:
  %call = call i32 @sk_stream_wspace(%struct.sock* %sk)
  %call1 = call i32 @sk_stream_min_wspace(%struct.sock* %sk)
  %cmp = icmp sge i32 %call, %call1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %call2 = call zeroext i1 @sk_stream_memory_free(%struct.sock* %sk)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %0 = phi i1 [ false, %entry ], [ %call2, %land.rhs ]
  ret i1 %0
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_wspace(%struct.sock* %sk) #3 {
entry:
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 17
  %0 = load i32, i32* %sk_sndbuf, align 4, !tbaa !90
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 18
  %1 = load i32, i32* %sk_wmem_queued, align 8, !tbaa !257
  %sub = sub nsw i32 %0, %1
  ret i32 %sub
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @sk_stream_min_wspace(%struct.sock* %sk) #3 {
entry:
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 18
  %0 = load i32, i32* %sk_wmem_queued, align 8, !tbaa !257
  %shr = ashr i32 %0, 1
  ret i32 %shr
}

; Function Attrs: inlinehint nounwind uwtable
define internal zeroext i1 @sk_stream_memory_free(%struct.sock* %sk) #3 {
entry:
  %sk_wmem_queued = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 18
  %0 = load i32, i32* %sk_wmem_queued, align 8, !tbaa !257
  %sk_sndbuf = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 17
  %1 = load i32, i32* %sk_sndbuf, align 4, !tbaa !90
  %cmp = icmp sge i32 %0, %1
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %__sk_common = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_prot = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common, i32 0, i32 8
  %2 = load %struct.proto*, %struct.proto** %skc_prot, align 8, !tbaa !258
  %stream_memory_free = getelementptr inbounds %struct.proto, %struct.proto* %2, i32 0, i32 25
  %3 = load i1 (%struct.sock*)*, i1 (%struct.sock*)** %stream_memory_free, align 8, !tbaa !259
  %tobool = icmp ne i1 (%struct.sock*)* %3, null
  br i1 %tobool, label %cond.true, label %cond.end

cond.true:                                        ; preds = %if.end
  %__sk_common1 = getelementptr inbounds %struct.sock, %struct.sock* %sk, i32 0, i32 0
  %skc_prot2 = getelementptr inbounds %struct.sock_common, %struct.sock_common* %__sk_common1, i32 0, i32 8
  %4 = load %struct.proto*, %struct.proto** %skc_prot2, align 8, !tbaa !258
  %stream_memory_free3 = getelementptr inbounds %struct.proto, %struct.proto* %4, i32 0, i32 25
  %5 = load i1 (%struct.sock*)*, i1 (%struct.sock*)** %stream_memory_free3, align 8, !tbaa !259
  %call = call zeroext i1 %5(%struct.sock* %sk)
  %conv = zext i1 %call to i32
  br label %cond.end

cond.end:                                         ; preds = %if.end, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ 1, %if.end ]
  %tobool4 = icmp ne i32 %cond, 0
  br label %return

return:                                           ; preds = %entry, %cond.end
  %retval.0 = phi i1 [ %tobool4, %cond.end ], [ false, %entry ]
  ret i1 %retval.0
}

; Function Attrs: alwaysinline nounwind uwtable
define internal void @__clear_bit(i64 %nr, i64* %addr) #5 {
entry:
  call void asm sideeffect "btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i64 %nr, i64* %addr) #7, !srcloc !261
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i16 @xs_sock_getport(%struct.socket* %sock) #0 {
entry:
  %buf = alloca %struct.__kernel_sockaddr_storage, align 8
  %buflen = alloca i32, align 4
  %0 = bitcast %struct.__kernel_sockaddr_storage* %buf to i8*
  call void @llvm.lifetime.start.p0i8(i64 128, i8* %0) #7
  %1 = bitcast i32* %buflen to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %1) #7
  %2 = bitcast %struct.__kernel_sockaddr_storage* %buf to %struct.sockaddr*
  %call = call i32 @kernel_getsockname(%struct.socket* %sock, %struct.sockaddr* %2, i32* %buflen)
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %out, label %if.end

if.end:                                           ; preds = %entry
  %ss_family = getelementptr inbounds %struct.__kernel_sockaddr_storage, %struct.__kernel_sockaddr_storage* %buf, i32 0, i32 0
  %3 = load i16, i16* %ss_family, align 8, !tbaa !229
  %conv = zext i16 %3 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb4, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock1
  %4 = bitcast %struct.__kernel_sockaddr_storage* %buf to %struct.sockaddr_in6*
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %4, i32 0, i32 1
  br label %sw.epilog.sink.split

sw.bb4:                                           ; preds = %LeafBlock
  %5 = bitcast %struct.__kernel_sockaddr_storage* %buf to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %5, i32 0, i32 1
  br label %sw.epilog.sink.split

sw.epilog.sink.split:                             ; preds = %sw.bb, %sw.bb4
  %sin_port.sink = phi i16* [ %sin_port, %sw.bb4 ], [ %sin6_port, %sw.bb ]
  %6 = load i16, i16* %sin_port.sink, align 2, !tbaa !118
  %call5 = call zeroext i16 @__fswab16(i16 zeroext %6) #4
  %conv6 = zext i16 %call5 to i32
  %conv7 = trunc i32 %conv6 to i16
  br label %out

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out

out:                                              ; preds = %NewDefault, %sw.epilog.sink.split, %entry
  %port.1 = phi i16 [ 0, %entry ], [ 0, %NewDefault ], [ %conv7, %sw.epilog.sink.split ]
  %7 = bitcast i32* %buflen to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #7
  %8 = bitcast %struct.__kernel_sockaddr_storage* %buf to i8*
  call void @llvm.lifetime.end.p0i8(i64 128, i8* %8) #7
  ret i16 %port.1
}

declare i32 @kernel_getsockname(%struct.socket*, %struct.sockaddr*, i32*) #1

; Function Attrs: nounwind uwtable
define internal %struct.rpc_xprt* @xs_setup_bc_tcp(%struct.xprt_create* %args) #0 {
entry:
  %dstaddr = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 3
  %0 = load %struct.sockaddr*, %struct.sockaddr** %dstaddr, align 8, !tbaa !2
  %1 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !9
  %2 = load i32, i32* @xprt_tcp_slot_table_entries, align 4, !tbaa !9
  %call = call %struct.rpc_xprt* @xs_setup_xprt(%struct.xprt_create* %args, i32 %1, i32 %2)
  %3 = bitcast %struct.rpc_xprt* %call to i8*
  %call1 = call zeroext i1 @IS_ERR(i8* %3)
  br i1 %call1, label %cleanup, label %if.end

if.end:                                           ; preds = %entry
  %4 = bitcast %struct.rpc_xprt* %call to i8*
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 0
  %5 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %prot = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 5
  store i32 6, i32* %prot, align 8, !tbaa !10
  %tsh_size = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 9
  store i32 1, i32* %tsh_size, align 8, !tbaa !28
  %max_payload = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 8
  store i64 2147483647, i64* %max_payload, align 8, !tbaa !29
  %timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 2
  store %struct.rpc_timeout* @xs_tcp_default_timeout, %struct.rpc_timeout** %timeout, align 8, !tbaa !34
  call void @xprt_set_bound(%struct.rpc_xprt* %call)
  %bind_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 23
  store i64 0, i64* %bind_timeout, align 8, !tbaa !30
  %reestablish_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 24
  store i64 0, i64* %reestablish_timeout, align 8, !tbaa !31
  %idle_timeout = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 29
  store i64 0, i64* %idle_timeout, align 8, !tbaa !32
  %ops = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 1
  store %struct.rpc_xprt_ops* @bc_tcp_ops, %struct.rpc_xprt_ops** %ops, align 8, !tbaa !33
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %0, i32 0, i32 0
  %6 = load i16, i16* %sa_family, align 2, !tbaa !48
  %conv = zext i16 %6 to i32
  br label %NodeBlock

NodeBlock:                                        ; preds = %if.end
  %Pivot = icmp slt i32 %conv, 10
  br i1 %Pivot, label %LeafBlock, label %LeafBlock1

LeafBlock1:                                       ; preds = %NodeBlock
  %SwitchLeaf2 = icmp eq i32 %conv, 10
  br i1 %SwitchLeaf2, label %sw.bb2, label %NewDefault

LeafBlock:                                        ; preds = %NodeBlock
  %SwitchLeaf = icmp eq i32 %conv, 2
  br i1 %SwitchLeaf, label %sw.bb, label %NewDefault

sw.bb:                                            ; preds = %LeafBlock
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0))
  br label %do.end

sw.bb2:                                           ; preds = %LeafBlock1
  call void @xs_format_peer_addresses(%struct.rpc_xprt* %call, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15, i32 0, i32 0))
  br label %do.end

do.end:                                           ; preds = %sw.bb, %sw.bb2
  %call4 = call %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt* %call)
  %bc_xprt = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %7 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !262
  %xpt_bc_xprt = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %7, i32 0, i32 20
  store %struct.rpc_xprt* %call, %struct.rpc_xprt** %xpt_bc_xprt, align 8, !tbaa !263
  %bc_xprt5 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %8 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt5, align 8, !tbaa !262
  %bc_xprt6 = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %call, i32 0, i32 36
  store %struct.svc_xprt* %8, %struct.svc_xprt** %bc_xprt6, align 8, !tbaa !265
  %bc_xprt8 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %9 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt8, align 8, !tbaa !262
  %10 = bitcast %struct.svc_xprt* %9 to i8*
  %add.ptr10 = getelementptr inbounds i8, i8* %10, i64 0
  %11 = bitcast i8* %add.ptr10 to %struct.svc_sock*
  %sk_sock = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %11, i32 0, i32 1
  %12 = load %struct.socket*, %struct.socket** %sk_sock, align 8, !tbaa !266
  %sock = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 1
  store %struct.socket* %12, %struct.socket** %sock, align 8, !tbaa !67
  %sk_sk = getelementptr inbounds %struct.svc_sock, %struct.svc_sock* %11, i32 0, i32 2
  %13 = load %struct.sock*, %struct.sock** %sk_sk, align 8, !tbaa !268
  %inet = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %5, i32 0, i32 2
  store %struct.sock* %13, %struct.sock** %inet, align 8, !tbaa !73
  call void @xprt_set_connected(%struct.rpc_xprt* %call)
  %call11 = call zeroext i1 @try_module_get(%struct.module* null)
  br i1 %call11, label %cleanup, label %if.end13

if.end13:                                         ; preds = %do.end
  %bc_xprt14 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %14 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt14, align 8, !tbaa !262
  %xpt_bc_xprt15 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %14, i32 0, i32 20
  store %struct.rpc_xprt* null, %struct.rpc_xprt** %xpt_bc_xprt15, align 8, !tbaa !263
  %bc_xprt16 = getelementptr inbounds %struct.xprt_create, %struct.xprt_create* %args, i32 0, i32 6
  %15 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt16, align 8, !tbaa !262
  %xpt_bc_xps = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %15, i32 0, i32 21
  store %struct.rpc_xprt_switch* null, %struct.rpc_xprt_switch** %xpt_bc_xps, align 8, !tbaa !269
  call void @xprt_put(%struct.rpc_xprt* %call)
  br label %out_err

NewDefault:                                       ; preds = %LeafBlock1, %LeafBlock
  br label %out_err

out_err:                                          ; preds = %NewDefault, %if.end13
  %.sink = phi i64 [ -22, %if.end13 ], [ -97, %NewDefault ]
  %call17 = call i8* @ERR_PTR(i64 %.sink)
  %16 = bitcast i8* %call17 to %struct.rpc_xprt*
  call void @xs_xprt_free(%struct.rpc_xprt* %call)
  br label %cleanup

cleanup:                                          ; preds = %do.end, %entry, %out_err
  %retval.0 = phi %struct.rpc_xprt* [ %16, %out_err ], [ %call, %entry ], [ %call, %do.end ]
  ret %struct.rpc_xprt* %retval.0
}

declare %struct.rpc_xprt* @xprt_get(%struct.rpc_xprt*) #1

declare void @xprt_put(%struct.rpc_xprt*) #1

; Function Attrs: nounwind uwtable
define internal i32 @bc_malloc(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_callsize = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 14
  %1 = load i64, i64* %rq_callsize, align 8, !tbaa !270
  %cmp = icmp ugt i64 %1, 4088
  br i1 %cmp, label %if.then, label %if.end31

if.then:                                          ; preds = %entry
  %tobool = icmp ne i32 1, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %2 = load i8, i8* @bc_malloc.__warned, align 1, !tbaa !140, !range !142
  %tobool1 = trunc i8 %2 to i1
  %lnot = xor i1 %tobool1, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %3 = phi i1 [ false, %if.then ], [ %lnot, %land.rhs ]
  %lnot2 = xor i1 %3, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then5, label %if.end22

if.then5:                                         ; preds = %land.end
  store i8 1, i8* @bc_malloc.__warned, align 1, !tbaa !140
  %tobool6 = icmp ne i32 1, 0
  %lnot7 = xor i1 %tobool6, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.then5
  call void (i8*, i32, i8*, ...) @warn_slowpath_fmt(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.6, i32 0, i32 0), i32 2603, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.18, i32 0, i32 0), i64 %1)
  br label %if.end

if.end:                                           ; preds = %if.then14, %if.then5
  %tobool15 = icmp ne i32 1, 0
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  br label %if.end22

if.end22:                                         ; preds = %if.end, %land.end
  %tobool24 = icmp ne i32 1, 0
  %lnot25 = xor i1 %tobool24, true
  %lnot27 = xor i1 %lnot25, true
  %lnot.ext28 = zext i1 %lnot27 to i32
  %conv29 = sext i32 %lnot.ext28 to i64
  %expval30 = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  br label %cleanup

if.end31:                                         ; preds = %entry
  %call = call %struct.page* @alloc_pages(i32 20971712, i32 0)
  %tobool32 = icmp ne %struct.page* %call, null
  br i1 %tobool32, label %if.end34, label %cleanup

if.end34:                                         ; preds = %if.end31
  %call35 = call i8* @lowmem_page_address(%struct.page* %call)
  %4 = bitcast i8* %call35 to %struct.rpc_buffer*
  %len = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %4, i32 0, i32 0
  store i64 4096, i64* %len, align 8, !tbaa !37
  %data = getelementptr inbounds %struct.rpc_buffer, %struct.rpc_buffer* %4, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i8], [0 x i8]* %data, i32 0, i32 0
  %rq_buffer = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 13
  store i8* %arraydecay, i8** %rq_buffer, align 8, !tbaa !271
  %rq_buffer36 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 13
  %5 = load i8*, i8** %rq_buffer36, align 8, !tbaa !271
  %rq_callsize37 = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 14
  %6 = load i64, i64* %rq_callsize37, align 8, !tbaa !270
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 %6
  %rq_rbuffer = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 15
  store i8* %add.ptr, i8** %rq_rbuffer, align 8, !tbaa !272
  br label %cleanup

cleanup:                                          ; preds = %if.end31, %if.end34, %if.end22
  %retval.0 = phi i32 [ -22, %if.end22 ], [ 0, %if.end34 ], [ -12, %if.end31 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bc_free(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_buffer = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 13
  %1 = load i8*, i8** %rq_buffer, align 8, !tbaa !271
  %2 = bitcast i8* %1 to [0 x i8]*
  %3 = bitcast [0 x i8]* %2 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %3, i64 -8
  %4 = bitcast i8* %add.ptr to %struct.rpc_buffer*
  %5 = ptrtoint %struct.rpc_buffer* %4 to i64
  call void @free_pages(i64 %5, i32 0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @bc_send_request(%struct.rpc_task* %task) #0 {
entry:
  %tk_rqstp = getelementptr inbounds %struct.rpc_task, %struct.rpc_task* %task, i32 0, i32 14
  %0 = load %struct.rpc_rqst*, %struct.rpc_rqst** %tk_rqstp, align 8, !tbaa !54
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %0, i32 0, i32 0
  %1 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !63
  %bc_xprt = getelementptr inbounds %struct.rpc_xprt, %struct.rpc_xprt* %1, i32 0, i32 36
  %2 = load %struct.svc_xprt*, %struct.svc_xprt** %bc_xprt, align 8, !tbaa !265
  %xpt_mutex = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 9
  %call = call i32 @mutex_trylock(%struct.mutex* %xpt_mutex)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.true, label %if.then

if.then:                                          ; preds = %entry
  %xpt_bc_pending = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 17
  call void @rpc_sleep_on(%struct.rpc_wait_queue* %xpt_bc_pending, %struct.rpc_task* %task, void (%struct.rpc_task*)* null)
  %xpt_mutex1 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 9
  %call2 = call i32 @mutex_trylock(%struct.mutex* %xpt_mutex1)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end, label %cleanup

if.end:                                           ; preds = %if.then
  %xpt_bc_pending5 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 17
  call void @rpc_wake_up_queued_task(%struct.rpc_wait_queue* %xpt_bc_pending5, %struct.rpc_task* %task)
  br label %cond.true

cond.true:                                        ; preds = %entry, %if.end
  %xpt_flags = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 5
  %call7 = call zeroext i1 @constant_test_bit(i64 6, i64* %xpt_flags)
  br i1 %call7, label %if.end12, label %if.else

if.else:                                          ; preds = %cond.true
  %call11 = call i32 @bc_sendto(%struct.rpc_rqst* %0)
  br label %if.end12

if.end12:                                         ; preds = %cond.true, %if.else
  %len.0 = phi i32 [ %call11, %if.else ], [ -107, %cond.true ]
  %xpt_mutex13 = getelementptr inbounds %struct.svc_xprt, %struct.svc_xprt* %2, i32 0, i32 9
  call void @mutex_unlock(%struct.mutex* %xpt_mutex13)
  %cmp = icmp sgt i32 %len.0, 0
  %.len.0 = select i1 %cmp, i32 0, i32 %len.0
  br label %cleanup

cleanup:                                          ; preds = %if.then, %if.end12
  %retval.0 = phi i32 [ %.len.0, %if.end12 ], [ -11, %if.then ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal void @bc_close(%struct.rpc_xprt* %xprt) #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @bc_destroy(%struct.rpc_xprt* %xprt) #0 {
entry:
  call void @xs_xprt_free(%struct.rpc_xprt* %xprt)
  call void @module_put(%struct.module* null)
  ret void
}

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) #1

; Function Attrs: inlinehint nounwind uwtable
define internal %struct.page* @alloc_pages(i32 %gfp_mask, i32 %order) #3 {
entry:
  %call = call %struct.page* @alloc_pages_current(i32 %gfp_mask, i32 %order)
  ret %struct.page* %call
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i8* @lowmem_page_address(%struct.page* %page) #5 {
entry:
  %sub.ptr.lhs.cast = ptrtoint %struct.page* %page to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, -24189255811072
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 64
  %shl = shl i64 %sub.ptr.div, 12
  %add = add i64 %shl, -131941395333120
  %0 = inttoptr i64 %add to i8*
  ret i8* %0
}

declare %struct.page* @alloc_pages_current(i32, i32) #1

declare void @free_pages(i64, i32) #1

declare i32 @mutex_trylock(%struct.mutex*) #1

declare void @rpc_sleep_on(%struct.rpc_wait_queue*, %struct.rpc_task*, void (%struct.rpc_task*)*) #1

declare void @rpc_wake_up_queued_task(%struct.rpc_wait_queue*, %struct.rpc_task*) #1

; Function Attrs: nounwind uwtable
define internal i32 @bc_sendto(%struct.rpc_rqst* %req) #0 {
entry:
  %rq_snd_buf = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 1
  %rq_xprt = getelementptr inbounds %struct.rpc_rqst, %struct.rpc_rqst* %req, i32 0, i32 0
  %0 = load %struct.rpc_xprt*, %struct.rpc_xprt** %rq_xprt, align 8, !tbaa !63
  %1 = bitcast %struct.rpc_xprt* %0 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 0
  %2 = bitcast i8* %add.ptr to %struct.sock_xprt*
  %sock1 = getelementptr inbounds %struct.sock_xprt, %struct.sock_xprt* %2, i32 0, i32 1
  %3 = load %struct.socket*, %struct.socket** %sock1, align 8, !tbaa !67
  call void @xs_encode_stream_record_marker(%struct.xdr_buf* %rq_snd_buf)
  %tail = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail, i64 0, i64 0
  %iov_base = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx, i32 0, i32 0
  %4 = load i8*, i8** %iov_base, align 8, !tbaa !64
  %5 = ptrtoint i8* %4 to i64
  %and = and i64 %5, 4095
  %head = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx2 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head, i64 0, i64 0
  %iov_base3 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx2, i32 0, i32 0
  %6 = load i8*, i8** %iov_base3, align 8, !tbaa !64
  %7 = ptrtoint i8* %6 to i64
  %and4 = and i64 %7, 4095
  %head5 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 0
  %arrayidx6 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %head5, i64 0, i64 0
  %iov_base7 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx6, i32 0, i32 0
  %8 = load i8*, i8** %iov_base7, align 8, !tbaa !64
  %9 = ptrtoint i8* %8 to i64
  %call = call i64 @__phys_addr_nodebug(i64 %9)
  %shr = lshr i64 %call, 12
  %add.ptr8 = getelementptr inbounds %struct.page, %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %tail9 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 1
  %arrayidx10 = getelementptr inbounds [1 x %struct.kvec], [1 x %struct.kvec]* %tail9, i64 0, i64 0
  %iov_base11 = getelementptr inbounds %struct.kvec, %struct.kvec* %arrayidx10, i32 0, i32 0
  %10 = load i8*, i8** %iov_base11, align 8, !tbaa !64
  %11 = bitcast i8* %10 to %struct.page*
  %call12 = call i32 @svc_send_common(%struct.socket* %3, %struct.xdr_buf* %rq_snd_buf, %struct.page* %add.ptr8, i64 %and4, %struct.page* %11, i64 %and)
  %len13 = getelementptr inbounds %struct.xdr_buf, %struct.xdr_buf* %rq_snd_buf, i32 0, i32 7
  %12 = load i32, i32* %len13, align 8, !tbaa !88
  %cmp = icmp ne i32 %call12, %12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call14 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.19, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %len.0 = phi i32 [ -11, %if.then ], [ %call12, %entry ]
  ret i32 %len.0
}

declare i32 @svc_send_common(%struct.socket*, %struct.xdr_buf*, %struct.page*, i64, %struct.page*, i64) #1

; Function Attrs: inlinehint nounwind uwtable
define internal i64 @__phys_addr_nodebug(i64 %x) #3 {
entry:
  %sub = sub i64 %x, -2147483648
  %cmp = icmp ugt i64 %x, %sub
  %0 = load i64, i64* @phys_base, align 8
  %cond = select i1 %cmp, i64 %0, i64 131939247849472
  %add = add i64 %sub, %cond
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define internal i32 @param_set_portnr(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %0 = getelementptr inbounds %struct.kernel_param, %struct.kernel_param* %kp, i32 0, i32 6
  %arg = bitcast %union.anon.53* %0 to i8**
  %1 = load i8*, i8** %arg, align 8, !tbaa !43
  %cmp = icmp eq i8* %1, bitcast (i32* @xprt_min_resvport to i8*)
  %2 = load i32, i32* @xprt_min_resvport, align 4
  %3 = load i32, i32* @xprt_max_resvport, align 4
  %.sink1 = select i1 %cmp, i32 %3, i32 65535
  %.sink = select i1 %cmp, i32 1, i32 %2
  %call1 = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 %.sink, i32 %.sink1)
  ret i32 %call1
}

declare i32 @param_get_uint(i8*, %struct.kernel_param*) #1

; Function Attrs: nounwind uwtable
define internal i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 %min, i32 %max) #0 {
entry:
  %num = alloca i32, align 4
  %0 = bitcast i32* %num to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %0) #7
  %tobool = icmp ne i8* %val, null
  br i1 %tobool, label %if.end, label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @kstrtouint(i8* %val, i32 0, i32* %num)
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %cleanup, label %if.end3

if.end3:                                          ; preds = %if.end
  %1 = load i32, i32* %num, align 4, !tbaa !9
  %cmp = icmp ult i32 %1, %min
  %2 = load i32, i32* %num, align 4
  %cmp4 = icmp ugt i32 %2, %max
  %or.cond = or i1 %cmp, %cmp4
  br i1 %or.cond, label %cleanup, label %if.end6

if.end6:                                          ; preds = %if.end3
  %3 = load i32, i32* %num, align 4, !tbaa !9
  %4 = getelementptr inbounds %struct.kernel_param, %struct.kernel_param* %kp, i32 0, i32 6
  %arg = bitcast %union.anon.53* %4 to i8**
  %5 = load i8*, i8** %arg, align 8, !tbaa !43
  %6 = bitcast i8* %5 to i32*
  store i32 %3, i32* %6, align 4, !tbaa !9
  br label %cleanup

cleanup:                                          ; preds = %if.end3, %if.end, %entry, %if.end6
  %retval.0 = phi i32 [ 0, %if.end6 ], [ -22, %entry ], [ %call, %if.end ], [ -22, %if.end3 ]
  %7 = bitcast i32* %num to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %7) #7
  ret i32 %retval.0
}

declare i32 @kstrtouint(i8*, i32, i32*) #1

; Function Attrs: nounwind uwtable
define internal i32 @param_set_slot_table_size(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 2, i32 65536)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @param_set_max_slot_table_size(i8* %val, %struct.kernel_param* %kp) #0 {
entry:
  %call = call i32 @param_set_uint_minmax(i8* %val, %struct.kernel_param* %kp, i32 2, i32 65536)
  ret i32 %call
}

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { inlinehint nounwind readnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { nounwind readonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !7, i64 24}
!3 = !{!"xprt_create", !4, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !8, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !4, i64 64}
!4 = !{!"int", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"any pointer", !5, i64 0}
!8 = !{!"long", !5, i64 0}
!9 = !{!4, !4, i64 0}
!10 = !{!11, !4, i64 160}
!11 = !{!"rpc_xprt", !12, i64 0, !7, i64 8, !7, i64 16, !15, i64 24, !8, i64 152, !4, i64 160, !8, i64 168, !8, i64 176, !8, i64 184, !4, i64 192, !17, i64 200, !17, i64 368, !17, i64 536, !17, i64 704, !22, i64 872, !4, i64 888, !4, i64 892, !14, i64 896, !8, i64 904, !5, i64 912, !14, i64 916, !4, i64 920, !22, i64 928, !8, i64 944, !8, i64 952, !4, i64 960, !23, i64 968, !20, i64 1000, !8, i64 1048, !8, i64 1056, !8, i64 1064, !8, i64 1072, !18, i64 1080, !18, i64 1084, !4, i64 1088, !7, i64 1096, !7, i64 1104, !22, i64 1112, !25, i64 1128, !7, i64 1224, !7, i64 1232, !5, i64 1240, !27, i64 1288}
!12 = !{!"kref", !13, i64 0}
!13 = !{!"refcount_struct", !14, i64 0}
!14 = !{!"", !4, i64 0}
!15 = !{!"__kernel_sockaddr_storage", !16, i64 0, !5, i64 2}
!16 = !{!"short", !5, i64 0}
!17 = !{!"rpc_wait_queue", !18, i64 0, !5, i64 8, !4, i64 72, !5, i64 76, !5, i64 77, !5, i64 78, !16, i64 80, !19, i64 88, !7, i64 160}
!18 = !{!"spinlock", !5, i64 0}
!19 = !{!"rpc_timer", !20, i64 0, !22, i64 48, !8, i64 64}
!20 = !{!"timer_list", !21, i64 0, !8, i64 16, !7, i64 24, !8, i64 32, !4, i64 40}
!21 = !{!"hlist_node", !7, i64 0, !7, i64 8}
!22 = !{!"list_head", !7, i64 0, !7, i64 8}
!23 = !{!"work_struct", !24, i64 0, !22, i64 8, !7, i64 24}
!24 = !{!"", !8, i64 0}
!25 = !{!"", !8, i64 0, !8, i64 8, !8, i64 16, !8, i64 24, !8, i64 32, !8, i64 40, !8, i64 48, !8, i64 56, !26, i64 64, !26, i64 72, !26, i64 80, !26, i64 88}
!26 = !{!"long long", !5, i64 0}
!27 = !{!"callback_head", !7, i64 0, !7, i64 8}
!28 = !{!11, !4, i64 192}
!29 = !{!11, !8, i64 184}
!30 = !{!11, !8, i64 944}
!31 = !{!11, !8, i64 952}
!32 = !{!11, !8, i64 1056}
!33 = !{!11, !7, i64 8}
!34 = !{!11, !7, i64 16}
!35 = !{!24, !8, i64 0}
!36 = !{i64 0, i64 8, !37}
!37 = !{!8, !8, i64 0}
!38 = !{!23, !7, i64 24}
!39 = !{!20, !7, i64 24}
!40 = !{!20, !8, i64 32}
!41 = !{!42, !16, i64 0}
!42 = !{!"sockaddr_un", !16, i64 0, !5, i64 2}
!43 = !{!5, !5, i64 0}
!44 = !{!3, !8, i64 32}
!45 = !{!3, !7, i64 8}
!46 = !{!11, !8, i64 152}
!47 = !{!3, !7, i64 16}
!48 = !{!49, !16, i64 0}
!49 = !{!"sockaddr", !16, i64 0, !5, i64 2}
!50 = !{!22, !7, i64 8}
!51 = !{!7, !7, i64 0}
!52 = !{!11, !7, i64 1224}
!53 = !{!11, !7, i64 1096}
!54 = !{!55, !7, i64 184}
!55 = !{!"rpc_task", !14, i64 0, !4, i64 4, !22, i64 8, !7, i64 24, !7, i64 32, !8, i64 40, !8, i64 48, !7, i64 56, !5, i64 64, !56, i64 120, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192, !26, i64 200, !4, i64 208, !16, i64 212, !16, i64 214, !16, i64 216, !5, i64 218, !5, i64 218, !5, i64 218, !5, i64 218}
!56 = !{!"rpc_message", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24}
!57 = !{!58, !4, i64 352}
!58 = !{!"rpc_rqst", !7, i64 0, !59, i64 8, !59, i64 72, !7, i64 136, !7, i64 144, !4, i64 152, !4, i64 156, !4, i64 160, !4, i64 164, !7, i64 168, !7, i64 176, !22, i64 184, !7, i64 200, !7, i64 208, !8, i64 216, !7, i64 224, !8, i64 232, !8, i64 240, !8, i64 248, !59, i64 256, !8, i64 320, !8, i64 328, !26, i64 336, !4, i64 344, !4, i64 348, !4, i64 352, !26, i64 360, !4, i64 368}
!59 = !{!"xdr_buf", !5, i64 0, !5, i64 16, !7, i64 32, !4, i64 40, !4, i64 44, !4, i64 48, !4, i64 52, !4, i64 56}
!60 = !{!58, !4, i64 64}
!61 = !{!55, !7, i64 176}
!62 = !{!55, !16, i64 212}
!63 = !{!58, !7, i64 0}
!64 = !{!65, !7, i64 0}
!65 = !{!"kvec", !7, i64 0, !8, i64 8}
!66 = !{!65, !8, i64 8}
!67 = !{!68, !7, i64 1304}
!68 = !{!"sock_xprt", !11, i64 0, !7, i64 1304, !7, i64 1312, !4, i64 1320, !4, i64 1324, !4, i64 1328, !4, i64 1332, !4, i64 1336, !8, i64 1344, !8, i64 1352, !8, i64 1360, !69, i64 1368, !23, i64 1464, !70, i64 1496, !15, i64 1528, !16, i64 1656, !8, i64 1664, !8, i64 1672, !72, i64 1680, !7, i64 1712, !7, i64 1720, !7, i64 1728, !7, i64 1736}
!69 = !{!"delayed_work", !23, i64 0, !20, i64 32, !7, i64 80, !4, i64 88}
!70 = !{!"mutex", !24, i64 0, !18, i64 8, !71, i64 12, !22, i64 16}
!71 = !{!"optimistic_spin_queue", !14, i64 0}
!72 = !{!"rpc_timeout", !8, i64 0, !8, i64 8, !8, i64 16, !4, i64 24, !5, i64 28}
!73 = !{!68, !7, i64 1312}
!74 = !{!58, !8, i64 240}
!75 = !{!11, !8, i64 1048}
!76 = !{!11, !8, i64 1128}
!77 = !{!11, !8, i64 1136}
!78 = !{!11, !8, i64 1152}
!79 = !{!11, !8, i64 1160}
!80 = !{!11, !8, i64 1168}
!81 = !{!11, !8, i64 1176}
!82 = !{!11, !26, i64 1192}
!83 = !{!11, !26, i64 1200}
!84 = !{!11, !8, i64 1184}
!85 = !{!11, !26, i64 1208}
!86 = !{!11, !26, i64 1216}
!87 = !{i32 -2147015368, i32 -2147015329, i32 -2147015308, i32 -2147015271, i32 -2147015248, i32 -2147015378}
!88 = !{!59, !4, i64 56}
!89 = !{!59, !4, i64 44}
!90 = !{!91, !4, i64 316}
!91 = !{!"sock", !92, i64 0, !95, i64 136, !14, i64 168, !4, i64 172, !97, i64 176, !97, i64 200, !98, i64 224, !4, i64 248, !4, i64 252, !4, i64 256, !4, i64 260, !7, i64 264, !5, i64 272, !5, i64 280, !7, i64 296, !7, i64 304, !14, i64 312, !4, i64 316, !4, i64 320, !14, i64 324, !8, i64 328, !7, i64 336, !97, i64 344, !4, i64 368, !4, i64 372, !4, i64 376, !8, i64 384, !20, i64 392, !4, i64 440, !4, i64 444, !4, i64 448, !4, i64 452, !99, i64 456, !26, i64 472, !26, i64 480, !4, i64 488, !4, i64 492, !4, i64 496, !4, i64 500, !5, i64 504, !4, i64 504, !4, i64 504, !4, i64 504, !4, i64 504, !4, i64 504, !4, i64 505, !4, i64 506, !16, i64 508, !8, i64 512, !7, i64 520, !100, i64 528, !4, i64 536, !4, i64 540, !4, i64 544, !4, i64 548, !14, i64 552, !7, i64 560, !7, i64 568, !8, i64 576, !26, i64 584, !16, i64 592, !5, i64 594, !4, i64 596, !7, i64 600, !7, i64 608, !7, i64 616, !103, i64 624, !7, i64 624, !7, i64 632, !7, i64 640, !7, i64 648, !7, i64 656, !7, i64 664, !7, i64 672, !7, i64 680, !27, i64 688}
!92 = !{!"sock_common", !5, i64 0, !5, i64 8, !5, i64 12, !16, i64 16, !5, i64 18, !5, i64 19, !5, i64 19, !5, i64 19, !5, i64 19, !4, i64 20, !5, i64 24, !7, i64 40, !93, i64 48, !94, i64 56, !94, i64 72, !24, i64 88, !5, i64 96, !5, i64 104, !5, i64 104, !4, i64 120, !5, i64 124, !14, i64 128, !5, i64 132, !5, i64 132}
!93 = !{!"", !7, i64 0}
!94 = !{!"in6_addr", !5, i64 0}
!95 = !{!"", !18, i64 0, !4, i64 4, !96, i64 8}
!96 = !{!"__wait_queue_head", !18, i64 0, !22, i64 8}
!97 = !{!"sk_buff_head", !7, i64 0, !7, i64 8, !4, i64 16, !18, i64 20}
!98 = !{!"", !14, i64 0, !4, i64 4, !7, i64 8, !7, i64 16}
!99 = !{!"page_frag", !7, i64 0, !4, i64 8, !4, i64 12}
!100 = !{!"", !101, i64 0}
!101 = !{!"qrwlock", !14, i64 0, !102, i64 4}
!102 = !{!"qspinlock", !14, i64 0}
!103 = !{!"sock_cgroup_data"}
!104 = !{!91, !4, i64 372}
!105 = !{!91, !7, i64 648}
!106 = !{i32 501691}
!107 = !{!108, !7, i64 0}
!108 = !{!"msghdr", !7, i64 0, !4, i64 8, !109, i64 16, !7, i64 56, !8, i64 64, !4, i64 72, !7, i64 80}
!109 = !{!"iov_iter", !4, i64 0, !8, i64 8, !8, i64 16, !5, i64 24, !5, i64 32}
!110 = !{!108, !4, i64 8}
!111 = !{!108, !4, i64 72}
!112 = !{!59, !4, i64 40}
!113 = !{!59, !7, i64 32}
!114 = !{!115, !7, i64 40}
!115 = !{!"socket", !5, i64 0, !16, i64 4, !8, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40}
!116 = !{!117, !7, i64 160}
!117 = !{!"proto_ops", !4, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !7, i64 192}
!118 = !{!16, !16, i64 0}
!119 = !{!26, !26, i64 0}
!120 = !{i32 -2147294788}
!121 = !{i32 -2147294750}
!122 = !{!91, !7, i64 608}
!123 = !{!68, !7, i64 1712}
!124 = !{!91, !7, i64 640}
!125 = !{!68, !7, i64 1720}
!126 = !{!91, !7, i64 632}
!127 = !{!68, !7, i64 1728}
!128 = !{!68, !7, i64 1736}
!129 = !{!91, !7, i64 656}
!130 = !{i32 -2139590751}
!131 = !{i32 -2139590670}
!132 = !{i32 -2140569494}
!133 = !{!134, !7, i64 0}
!134 = !{!"tracepoint_func", !7, i64 0, !7, i64 8, !4, i64 16}
!135 = !{!134, !7, i64 8}
!136 = !{i32 -2147014622, i32 -2147014583, i32 -2147014562, i32 -2147014525, i32 -2147014502, i32 -2147014632}
!137 = !{i32 -2145973470}
!138 = !{i32 -2145973164}
!139 = !{i32 463135, i32 463146, i32 -2147005308}
!140 = !{!141, !141, i64 0}
!141 = !{!"_Bool", !5, i64 0}
!142 = !{i8 0, i8 2}
!143 = !{i32 -2147294051}
!144 = !{i32 -2147294013}
!145 = !{!146, !4, i64 120}
!146 = !{!"sk_buff", !5, i64 0, !7, i64 24, !5, i64 32, !5, i64 40, !8, i64 88, !7, i64 96, !7, i64 104, !8, i64 112, !4, i64 120, !4, i64 124, !16, i64 128, !16, i64 130, !16, i64 132, !5, i64 134, !5, i64 134, !5, i64 134, !5, i64 134, !5, i64 134, !5, i64 134, !5, i64 134, !5, i64 134, !5, i64 136, !5, i64 136, !5, i64 136, !5, i64 136, !5, i64 136, !5, i64 136, !5, i64 136, !5, i64 137, !5, i64 137, !5, i64 137, !5, i64 137, !5, i64 137, !5, i64 137, !5, i64 137, !5, i64 137, !5, i64 138, !5, i64 138, !5, i64 138, !5, i64 138, !5, i64 138, !5, i64 138, !5, i64 139, !5, i64 139, !5, i64 139, !5, i64 139, !5, i64 139, !5, i64 139, !5, i64 139, !16, i64 140, !5, i64 144, !4, i64 148, !4, i64 152, !4, i64 156, !16, i64 160, !16, i64 162, !5, i64 164, !4, i64 168, !5, i64 172, !5, i64 176, !16, i64 178, !16, i64 180, !16, i64 182, !16, i64 184, !16, i64 186, !16, i64 188, !16, i64 190, !5, i64 192, !4, i64 192, !4, i64 196, !7, i64 200, !7, i64 208, !4, i64 216, !14, i64 220}
!147 = !{!58, !7, i64 136}
!148 = !{!58, !4, i64 308}
!149 = !{i32 -2147011109, i32 -2147011070, i32 -2147011049, i32 -2147011012, i32 -2147010989, i32 -2147010980, i32 -2147010926}
!150 = !{!146, !7, i64 208}
!151 = !{!152, !7, i64 0}
!152 = !{!"xdr_skb_reader", !7, i64 0, !4, i64 8, !8, i64 16, !4, i64 24}
!153 = !{!152, !4, i64 8}
!154 = !{!152, !8, i64 16}
!155 = !{!152, !4, i64 24}
!156 = !{!146, !4, i64 124}
!157 = !{i32 -2147012297, i32 -2147012258, i32 -2147012237, i32 -2147012200, i32 -2147012177, i32 -2147012168, i32 -2147012114}
!158 = !{!159, !4, i64 4}
!159 = !{!"sockaddr_in", !16, i64 0, !16, i64 2, !160, i64 4, !5, i64 8}
!160 = !{!"in_addr", !4, i64 0}
!161 = !{i32 -2139598956, i32 -2139598931, i32 -2139598661, i32 -2139598864, i32 -2139598833, i32 -2139598803}
!162 = !{!115, !7, i64 32}
!163 = !{!91, !4, i64 496}
!164 = !{!11, !8, i64 1144}
!165 = !{i32 -2140731552}
!166 = !{i32 -2141788175}
!167 = !{i32 -2141788098}
!168 = !{!91, !4, i64 536}
!169 = !{!91, !5, i64 18}
!170 = !{!91, !7, i64 600}
!171 = !{i32 456487}
!172 = !{i32 -2140679003}
!173 = !{!159, !16, i64 2}
!174 = !{!175, !16, i64 2}
!175 = !{!"sockaddr_in6", !16, i64 0, !16, i64 2, !4, i64 4, !94, i64 8, !4, i64 24}
!176 = !{!68, !8, i64 1672}
!177 = !{!68, !8, i64 1664}
!178 = !{!68, !16, i64 1656}
!179 = !{!11, !4, i64 888}
!180 = !{!91, !4, i64 260}
!181 = !{!11, !8, i64 1072}
!182 = !{!91, !16, i64 16}
!183 = !{!184, !7, i64 400}
!184 = !{!"net", !14, i64 0, !14, i64 4, !18, i64 8, !24, i64 16, !22, i64 24, !22, i64 40, !22, i64 56, !7, i64 72, !7, i64 80, !18, i64 88, !185, i64 96, !187, i64 120, !7, i64 144, !7, i64 152, !188, i64 160, !7, i64 264, !7, i64 272, !22, i64 280, !7, i64 296, !7, i64 304, !4, i64 312, !4, i64 316, !4, i64 320, !22, i64 328, !7, i64 344, !192, i64 352, !193, i64 376, !194, i64 480, !196, i64 520, !197, i64 576, !206, i64 1344, !209, i64 2112, !210, i64 3080, !211, i64 3296, !218, i64 3648, !7, i64 3840, !7, i64 3848, !7, i64 3856, !219, i64 3904, !7, i64 4928, !14, i64 4936}
!185 = !{!"idr", !186, i64 0, !4, i64 16}
!186 = !{!"radix_tree_root", !4, i64 0, !7, i64 8}
!187 = !{!"ns_common", !24, i64 0, !7, i64 8, !4, i64 16}
!188 = !{!"ctl_table_set", !7, i64 0, !189, i64 8}
!189 = !{!"ctl_dir", !190, i64 0, !191, i64 88}
!190 = !{!"ctl_table_header", !5, i64 0, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !22, i64 72}
!191 = !{!"rb_root", !7, i64 0}
!192 = !{!"netns_core", !7, i64 0, !4, i64 8, !7, i64 16}
!193 = !{!"netns_mib", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96}
!194 = !{!"netns_packet", !70, i64 0, !195, i64 32}
!195 = !{!"hlist_head", !7, i64 0}
!196 = !{!"netns_unix", !4, i64 0, !7, i64 8}
!197 = !{!"netns_ipv4", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !141, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !141, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !198, i64 192, !7, i64 256, !7, i64 264, !7, i64 272, !7, i64 280, !7, i64 288, !7, i64 296, !4, i64 304, !4, i64 308, !4, i64 312, !4, i64 316, !4, i64 320, !4, i64 324, !201, i64 328, !4, i64 348, !4, i64 352, !4, i64 356, !4, i64 360, !4, i64 364, !4, i64 368, !4, i64 372, !4, i64 376, !4, i64 380, !4, i64 384, !4, i64 388, !4, i64 392, !4, i64 396, !4, i64 400, !4, i64 404, !4, i64 408, !4, i64 412, !4, i64 416, !4, i64 420, !4, i64 424, !4, i64 428, !4, i64 432, !4, i64 436, !4, i64 440, !4, i64 444, !4, i64 448, !4, i64 452, !204, i64 512, !4, i64 640, !4, i64 644, !4, i64 648, !4, i64 652, !4, i64 656, !205, i64 660, !14, i64 676, !7, i64 680, !4, i64 688, !7, i64 696, !4, i64 704, !4, i64 708, !14, i64 712}
!198 = !{!"netns_frags", !199, i64 0, !4, i64 40, !4, i64 44, !4, i64 48, !4, i64 52}
!199 = !{!"percpu_counter", !200, i64 0, !26, i64 8, !22, i64 16, !7, i64 32}
!200 = !{!"raw_spinlock", !102, i64 0}
!201 = !{!"local_ports", !202, i64 0, !5, i64 8, !141, i64 16}
!202 = !{!"", !203, i64 0, !18, i64 4}
!203 = !{!"seqcount", !4, i64 0}
!204 = !{!"inet_timewait_death_row", !14, i64 0, !7, i64 64, !4, i64 72, !4, i64 76}
!205 = !{!"ping_group_range", !202, i64 0, !5, i64 8}
!206 = !{!"netns_ipv6", !207, i64 0, !7, i64 112, !7, i64 120, !7, i64 128, !198, i64 192, !7, i64 256, !7, i64 264, !7, i64 272, !7, i64 280, !7, i64 288, !7, i64 296, !7, i64 304, !20, i64 312, !7, i64 360, !7, i64 368, !22, i64 376, !208, i64 448, !100, i64 640, !18, i64 648, !4, i64 652, !8, i64 656, !7, i64 664, !7, i64 672, !7, i64 680, !7, i64 688, !7, i64 696, !14, i64 704, !14, i64 708, !7, i64 712}
!207 = !{!"netns_sysctl_ipv6", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !4, i64 40, !4, i64 44, !4, i64 48, !4, i64 52, !4, i64 56, !4, i64 60, !4, i64 64, !4, i64 68, !4, i64 72, !4, i64 76, !4, i64 80, !4, i64 84, !4, i64 88, !4, i64 92, !4, i64 96, !4, i64 100, !4, i64 104, !4, i64 108}
!208 = !{!"dst_ops", !16, i64 0, !4, i64 4, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !199, i64 128}
!209 = !{!"netns_nf", !7, i64 0, !7, i64 8, !5, i64 16, !7, i64 120, !5, i64 128, !141, i64 960, !141, i64 961}
!210 = !{!"netns_xt", !5, i64 0, !141, i64 208, !141, i64 209}
!211 = !{!"netns_ct", !14, i64 0, !4, i64 4, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !4, i64 48, !4, i64 52, !4, i64 56, !4, i64 60, !141, i64 64, !4, i64 68, !4, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !212, i64 112}
!212 = !{!"nf_ip_net", !213, i64 0, !215, i64 32, !216, i64 128, !217, i64 160, !217, i64 192}
!213 = !{!"nf_generic_net", !214, i64 0, !4, i64 24}
!214 = !{!"nf_proto_net", !7, i64 0, !7, i64 8, !4, i64 16}
!215 = !{!"nf_tcp_net", !214, i64 0, !5, i64 24, !4, i64 80, !4, i64 84, !4, i64 88}
!216 = !{!"nf_udp_net", !214, i64 0, !5, i64 24}
!217 = !{!"nf_icmp_net", !214, i64 0, !4, i64 24}
!218 = !{!"netns_nf_frag", !207, i64 0, !198, i64 128}
!219 = !{!"netns_xfrm", !22, i64 0, !7, i64 16, !7, i64 24, !7, i64 32, !4, i64 40, !4, i64 44, !23, i64 48, !22, i64 80, !7, i64 96, !4, i64 104, !5, i64 112, !5, i64 136, !5, i64 184, !23, i64 208, !220, i64 240, !7, i64 288, !7, i64 296, !4, i64 304, !4, i64 308, !4, i64 312, !4, i64 316, !7, i64 320, !208, i64 384, !208, i64 576, !18, i64 768, !18, i64 772, !70, i64 776, !221, i64 808, !14, i64 896, !22, i64 904, !14, i64 920, !18, i64 924, !23, i64 928, !23, i64 960, !70, i64 992}
!220 = !{!"xfrm_policy_hthresh", !23, i64 0, !202, i64 32, !5, i64 40, !5, i64 41, !5, i64 42, !5, i64 43}
!221 = !{!"flow_cache", !4, i64 0, !7, i64 8, !21, i64 16, !4, i64 32, !4, i64 36, !20, i64 40}
!222 = !{i32 -2139557089}
!223 = !{!184, !7, i64 440}
!224 = !{i32 -2139519396}
!225 = !{i32 -2139484998}
!226 = !{i32 -2139450934}
!227 = !{!93, !7, i64 0}
!228 = !{!68, !8, i64 152}
!229 = !{!15, !16, i64 0}
!230 = !{!3, !4, i64 64}
!231 = !{!72, !8, i64 8}
!232 = !{!72, !8, i64 0}
!233 = !{!72, !4, i64 24}
!234 = !{!11, !8, i64 1064}
!235 = !{i32 -2140517543}
!236 = !{!237, !8, i64 0}
!237 = !{!"", !8, i64 0, !8, i64 8, !5, i64 16, !4, i64 24}
!238 = !{!237, !8, i64 8}
!239 = !{!237, !4, i64 24}
!240 = !{!68, !8, i64 1352}
!241 = !{i32 -2140306519}
!242 = !{i32 -2140255255}
!243 = !{!68, !4, i64 1332}
!244 = !{!68, !4, i64 1320}
!245 = !{!68, !4, i64 1336}
!246 = !{!68, !8, i64 1344}
!247 = !{!68, !4, i64 1328}
!248 = !{!68, !4, i64 1324}
!249 = !{!11, !4, i64 960}
!250 = !{i32 -2139439907}
!251 = !{i32 -2139439826}
!252 = !{i32 -2139439694}
!253 = !{i32 -2139439617}
!254 = !{i32 -2140784297}
!255 = !{i32 -2146312622}
!256 = !{i32 -2146340597}
!257 = !{!91, !4, i64 320}
!258 = !{!91, !7, i64 40}
!259 = !{!260, !7, i64 200}
!260 = !{!"proto", !7, i64 0, !7, i64 8, !7, i64 16, !7, i64 24, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !7, i64 64, !7, i64 72, !7, i64 80, !7, i64 88, !7, i64 96, !7, i64 104, !7, i64 112, !7, i64 120, !7, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168, !7, i64 176, !7, i64 184, !4, i64 192, !7, i64 200, !7, i64 208, !7, i64 216, !7, i64 224, !7, i64 232, !7, i64 240, !7, i64 248, !7, i64 256, !4, i64 264, !141, i64 268, !7, i64 272, !4, i64 280, !4, i64 284, !7, i64 288, !7, i64 296, !7, i64 304, !5, i64 312, !7, i64 320, !5, i64 328, !22, i64 360, !7, i64 376}
!261 = !{i32 457677}
!262 = !{!3, !7, i64 48}
!263 = !{!264, !7, i64 608}
!264 = !{!"svc_xprt", !7, i64 0, !7, i64 8, !12, i64 16, !22, i64 24, !22, i64 40, !8, i64 56, !7, i64 64, !14, i64 72, !14, i64 76, !70, i64 80, !18, i64 112, !7, i64 120, !22, i64 128, !15, i64 144, !8, i64 272, !15, i64 280, !8, i64 408, !17, i64 416, !22, i64 584, !7, i64 600, !7, i64 608, !7, i64 616}
!265 = !{!11, !7, i64 1104}
!266 = !{!267, !7, i64 624}
!267 = !{!"svc_sock", !264, i64 0, !7, i64 624, !7, i64 632, !7, i64 640, !7, i64 648, !7, i64 656, !4, i64 664, !4, i64 668, !4, i64 672, !5, i64 680}
!268 = !{!267, !7, i64 632}
!269 = !{!264, !7, i64 616}
!270 = !{!58, !8, i64 216}
!271 = !{!58, !7, i64 208}
!272 = !{!58, !7, i64 224}
