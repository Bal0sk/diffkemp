; ModuleID = 'drivers/watchdog/sbc8360.bc'
source_filename = "drivers/watchdog/sbc8360.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kernel_param_ops = type { i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon }
%union.anon = type { i8* }
%struct.miscdevice = type { i32, i8*, %struct.file_operations*, %struct.list_head, %struct.device*, %struct.device*, i8*, i16 }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, %struct.files_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, %struct.list_head, %struct.list_head, %struct.task_struct*, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.sysfs_dirent*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.2 }
%union.anon.2 = type { %struct.raw_spinlock }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.3 }
%union.anon.3 = type { i16 }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)*, i8* (%struct.kobject*, %struct.attribute*)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type opaque
%struct.sysfs_dirent = type opaque
%struct.kref = type { %struct.atomic_t }
%struct.atomic_t = type { i32 }
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type { i8*, %struct.static_key, void ()*, void ()*, %struct.tracepoint_func* }
%struct.static_key = type { %struct.atomic_t }
%struct.tracepoint_func = type { i8*, i8* }
%struct.ftrace_event_call = type opaque
%struct.task_struct = type opaque
%struct.module_ref = type { i64, i64 }
%struct.file = type { %union.anon.0, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, i32, %struct.atomic64_t, i32, i32, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.0 = type { %struct.list_head }
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.vfsmount = type opaque
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], i32, %struct.spinlock, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.11, %struct.list_head, %struct.hlist_node }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.1, i8* }
%union.anon.1 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.inode*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*, %struct.inode*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head*, %struct.list_head, %struct.list_head, i32, [28 x i8], %struct.spinlock, %struct.list_head, i32, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, [20 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.lock_class_key = type {}
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i32 (%struct.super_block*)*, void (%struct.super_block*, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.seq_file = type opaque
%struct.page = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.kqid = type { %union.anon.4, i32 }
%union.anon.4 = type { i32 }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.export_operations = type opaque
%struct.rw_semaphore = type { i64, %struct.raw_spinlock, %struct.list_head }
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, %struct.rw_semaphore, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, i8* }
%struct.shrinker = type { i32 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, %struct.list_head, %struct.atomic64_t }
%struct.shrink_control = type { i32, i64 }
%union.anon.11 = type { %struct.list_head }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.inode = type { i16, i16, i32, i32, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.6, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.7, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.10, i32, i32, %struct.hlist_head, i8* }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, [8 x i8] }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.kstat = type { i64, i32, i16, i32, i32, i32, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.6 = type { i32 }
%struct.timespec = type { i64, i64 }
%union.anon.7 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.file_lock = type { %struct.file_lock*, %struct.list_head, %struct.list_head, %struct.files_struct*, i32, i8, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.8 }
%struct.files_struct = type opaque
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.8 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, i32, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type opaque
%struct.rb_root = type { %struct.rb_node* }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i64)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iovec*, i64, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, %struct.read_descriptor_t*, i64)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.kiocb = type opaque
%struct.iovec = type opaque
%struct.read_descriptor_t = type { i64, i64, %union.anon.5, i32 }
%union.anon.5 = type { i8* }
%struct.swap_info_struct = type opaque
%union.anon.10 = type { %struct.pipe_inode_info* }
%struct.pipe_inode_info = type opaque
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, i32, i32, i32 }
%struct.rwlock_t = type { %union.arch_rwlock_t }
%union.arch_rwlock_t = type { i32 }
%struct.cred = type opaque
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.poll_table_struct = type opaque
%struct.vm_area_struct = type opaque
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group* }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, i32*, i32*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.bus_attribute*, %struct.device_attribute*, %struct.driver_attribute*, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.bus_attribute = type { %struct.attribute, i64 (%struct.bus_type*, i8*)*, i64 (%struct.bus_type*, i8*, i64)* }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.driver_attribute = type { %struct.attribute, i64 (%struct.device_driver*, i8*)*, i64 (%struct.device_driver*, i8*, i64)* }
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type opaque
%struct.acpi_device_id = type opaque
%struct.driver_private = type opaque
%struct.dev_pm_info = type { %struct.pm_message, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.pm_subsys_data*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%union.ktime = type { i64 }
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type opaque
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type opaque
%struct.device_node = type opaque
%struct.acpi_dev_node = type { i8* }
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.device_attribute*, %struct.bin_attribute*, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)*, i8* (%struct.class*, %struct.class_attribute*)* }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute** }
%struct.iommu_group = type opaque
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.module_version_attribute = type { %struct.module_attribute, i8*, i8* }
%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.cpumask = type { [1 x i64] }

@__param_str_timeout = internal constant [16 x i8] c"sbc8360.timeout\00", align 16
@param_ops_int = external global %struct.kernel_param_ops, align 8
@timeout = internal global i32 27, align 4
@__param_timeout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @__param_str_timeout, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon { i8* bitcast (i32* @timeout to i8*) } }, section "__param", align 8
@__param_str_nowayout = internal constant [17 x i8] c"sbc8360.nowayout\00", align 16
@param_ops_bool = external global %struct.kernel_param_ops, align 8
@nowayout = internal global i8 0, align 1
@__param_nowayout = internal constant %struct.kernel_param { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__param_str_nowayout, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_bool, i16 0, i16 -1, %union.anon { i8* @nowayout } }, section "__param", align 8
@sbc8360_miscdev = internal global %struct.miscdevice { i32 130, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), %struct.file_operations* @sbc8360_fops, %struct.list_head zeroinitializer, %struct.device* null, %struct.device* null, i8* null, i16 0 }, align 8
@sbc8360_notifier = internal global %struct.notifier_block { i32 (%struct.notifier_block*, i64, i8*)* @sbc8360_notify_sys, %struct.notifier_block* null, i32 0 }, align 8
@ioport_resource = external global %struct.resource, align 8
@__initcall_sbc8360_init6 = internal global i32 ()* @sbc8360_init, section ".initcall6.init", align 8
@__exitcall_sbc8360_exit = internal global void ()* @sbc8360_exit, section ".exitcall.exit", align 8
@___modver_attr = internal global %struct.module_version_attribute { %struct.module_attribute { %struct.attribute { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.9, i32 0, i32 0), i16 292 }, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)* @__modver_version_show, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)* null, void (%struct.module*, i8*)* null, i32 (%struct.module*)* null, void (%struct.module*)* null }, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.10, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11, i32 0, i32 0) }, align 8
@__modver_attr = internal constant %struct.module_version_attribute* @___modver_attr, section "__modver", align 8
@smp_ops = external global %struct.smp_ops, align 8
@.str = private unnamed_addr constant [9 x i8] c"watchdog\00", align 1
@sbc8360_fops = internal constant %struct.file_operations { %struct.module* null, i64 (%struct.file*, i64, i32)* @no_llseek, i64 (%struct.file*, i8*, i64, i64*)* null, i64 (%struct.file*, i8*, i64, i64*)* @sbc8360_write, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)* null, i32 (%struct.file*, i8*, i32 (i8*, i8*, i32, i64, i64, i32)*)* null, i32 (%struct.file*, %struct.poll_table_struct*)* null, i64 (%struct.file*, i32, i64)* null, i64 (%struct.file*, i32, i64)* null, i32 (%struct.file*, %struct.vm_area_struct*)* null, i32 (%struct.inode*, %struct.file*)* @sbc8360_open, i32 (%struct.file*, %struct.files_struct*)* null, i32 (%struct.inode*, %struct.file*)* @sbc8360_close, i32 (%struct.file*, i64, i64, i32)* null, i32 (%struct.kiocb*, i32)* null, i32 (i32, %struct.file*, i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)* null, i64 (%struct.file*, i64, i64, i64, i64)* null, i32 (i32)* null, i32 (%struct.file*, i32, %struct.file_lock*)* null, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)* null, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)* null, i32 (%struct.file*, i64, %struct.file_lock**)* null, i64 (%struct.file*, i32, i64, i64)* null, i32 (%struct.seq_file*, %struct.file*)* null }, align 8
@expect_close = internal global i8 0, align 1
@wd_margin = internal global i32 11, align 4
@sbc8360_is_open = internal global i64 0, align 8
@wd_multiplier = internal global i32 2, align 4
@.str.1 = private unnamed_addr constant [72 x i8] c"\012sbc8360: SBC8360 device closed unexpectedly.  SBC8360 will not stop!\0A\00", align 1
@.str.2 = private unnamed_addr constant [49 x i8] c"\013sbc8360: Invalid timeout index (must be 0-63)\0A\00", align 1
@.str.3 = private unnamed_addr constant [8 x i8] c"SBC8360\00", align 1
@.str.4 = private unnamed_addr constant [50 x i8] c"\013sbc8360: ENABLE method I/O %X is not available\0A\00", align 1
@.str.5 = private unnamed_addr constant [52 x i8] c"\013sbc8360: BASETIME method I/O %X is not available\0A\00", align 1
@.str.6 = private unnamed_addr constant [47 x i8] c"\013sbc8360: Failed to register reboot notifier\0A\00", align 1
@.str.7 = private unnamed_addr constant [43 x i8] c"\013sbc8360: failed to register misc device\0A\00", align 1
@wd_times = internal global [64 x [2 x i32]] [[2 x i32] [i32 0, i32 1], [2 x i32] [i32 1, i32 1], [2 x i32] [i32 2, i32 1], [2 x i32] [i32 3, i32 1], [2 x i32] [i32 4, i32 1], [2 x i32] [i32 5, i32 1], [2 x i32] [i32 6, i32 1], [2 x i32] [i32 7, i32 1], [2 x i32] [i32 8, i32 1], [2 x i32] [i32 9, i32 1], [2 x i32] [i32 10, i32 1], [2 x i32] [i32 11, i32 1], [2 x i32] [i32 12, i32 1], [2 x i32] [i32 13, i32 1], [2 x i32] [i32 14, i32 1], [2 x i32] [i32 15, i32 1], [2 x i32] [i32 0, i32 2], [2 x i32] [i32 1, i32 2], [2 x i32] [i32 2, i32 2], [2 x i32] [i32 3, i32 2], [2 x i32] [i32 4, i32 2], [2 x i32] [i32 5, i32 2], [2 x i32] [i32 6, i32 2], [2 x i32] [i32 7, i32 2], [2 x i32] [i32 8, i32 2], [2 x i32] [i32 9, i32 2], [2 x i32] [i32 10, i32 2], [2 x i32] [i32 11, i32 2], [2 x i32] [i32 12, i32 2], [2 x i32] [i32 13, i32 2], [2 x i32] [i32 14, i32 2], [2 x i32] [i32 15, i32 2], [2 x i32] [i32 0, i32 3], [2 x i32] [i32 1, i32 3], [2 x i32] [i32 2, i32 3], [2 x i32] [i32 3, i32 3], [2 x i32] [i32 4, i32 3], [2 x i32] [i32 5, i32 3], [2 x i32] [i32 6, i32 3], [2 x i32] [i32 7, i32 3], [2 x i32] [i32 8, i32 3], [2 x i32] [i32 9, i32 3], [2 x i32] [i32 10, i32 3], [2 x i32] [i32 11, i32 3], [2 x i32] [i32 12, i32 3], [2 x i32] [i32 13, i32 3], [2 x i32] [i32 14, i32 3], [2 x i32] [i32 15, i32 3], [2 x i32] [i32 0, i32 4], [2 x i32] [i32 1, i32 4], [2 x i32] [i32 2, i32 4], [2 x i32] [i32 3, i32 4], [2 x i32] [i32 4, i32 4], [2 x i32] [i32 5, i32 4], [2 x i32] [i32 6, i32 4], [2 x i32] [i32 7, i32 4], [2 x i32] [i32 8, i32 4], [2 x i32] [i32 9, i32 4], [2 x i32] [i32 10, i32 4], [2 x i32] [i32 11, i32 4], [2 x i32] [i32 12, i32 4], [2 x i32] [i32 13, i32 4], [2 x i32] [i32 14, i32 4], [2 x i32] [i32 15, i32 4]], align 16
@.str.8 = private unnamed_addr constant [34 x i8] c"\016sbc8360: Timeout set at %ld ms\0A\00", align 1
@.str.9 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.10 = private unnamed_addr constant [8 x i8] c"sbc8360\00", align 1
@.str.11 = private unnamed_addr constant [5 x i8] c"1.01\00", align 1
@llvm.used = appending global [6 x i8*] [i8* bitcast (%struct.kernel_param* @__param_timeout to i8*), i8* bitcast (%struct.kernel_param* @__param_nowayout to i8*), i8* bitcast (void ()* @sbc8360_exit to i8*), i8* bitcast (i32 ()** @__initcall_sbc8360_init6 to i8*), i8* bitcast (void ()** @__exitcall_sbc8360_exit to i8*), i8* bitcast (%struct.module_version_attribute** @__modver_attr to i8*)], section "llvm.metadata"

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_stop() #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 3), align 8, !tbaa !2
  call void %0(i32 0)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_send_reschedule(i32 %cpu) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 4), align 8, !tbaa !7
  call void %0(i32 %cpu)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_cpus(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 1), align 8, !tbaa !8
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) #0 {
entry:
  %0 = load i32 (i32, %struct.task_struct*)*, i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 5), align 8, !tbaa !9
  %call = call i32 %0(i32 %cpu, %struct.task_struct* %tidle)
  ret i32 %call
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_cpus_done(i32 %max_cpus) #0 {
entry:
  %0 = load void (i32)*, void (i32)** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 2), align 8, !tbaa !10
  call void %0(i32 %max_cpus)
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal void @smp_prepare_boot_cpu() #0 {
entry:
  %0 = load void ()*, void ()** getelementptr inbounds (%struct.smp_ops, %struct.smp_ops* @smp_ops, i32 0, i32 0), align 8, !tbaa !11
  call void %0()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sbc8360_exit() #1 section ".exit.text" {
entry:
  %call = call i32 @misc_deregister(%struct.miscdevice* @sbc8360_miscdev)
  %call1 = call i32 @unregister_reboot_notifier(%struct.notifier_block* @sbc8360_notifier)
  call void @__release_region(%struct.resource* @ioport_resource, i64 288, i64 1)
  call void @__release_region(%struct.resource* @ioport_resource, i64 289, i64 1)
  ret void
}

declare i32 @misc_deregister(%struct.miscdevice*) #2

declare i32 @unregister_reboot_notifier(%struct.notifier_block*) #2

declare void @__release_region(%struct.resource*, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal i32 @sbc8360_init() #1 section ".init.text" {
entry:
  %0 = load i32, i32* @timeout, align 4, !tbaa !12
  %cmp = icmp slt i32 %0, 0
  %1 = load i32, i32* @timeout, align 4
  %cmp1 = icmp sgt i32 %1, 63
  %or.cond = or i1 %cmp, %cmp1
  br i1 %or.cond, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.2, i32 0, i32 0))
  br label %cleanup

if.end:                                           ; preds = %entry
  %call2 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 288, i64 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.3, i32 0, i32 0), i32 0)
  %tobool = icmp ne %struct.resource* %call2, null
  br i1 %tobool, label %if.end5, label %if.then3

if.then3:                                         ; preds = %if.end
  %call4 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.4, i32 0, i32 0), i32 288)
  br label %cleanup

if.end5:                                          ; preds = %if.end
  %call6 = call %struct.resource* @__request_region(%struct.resource* @ioport_resource, i64 289, i64 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.3, i32 0, i32 0), i32 0)
  %tobool7 = icmp ne %struct.resource* %call6, null
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %if.end5
  %call9 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.5, i32 0, i32 0), i32 289)
  br label %out_nobasetimereg

if.end10:                                         ; preds = %if.end5
  %call11 = call i32 @register_reboot_notifier(%struct.notifier_block* @sbc8360_notifier)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end10
  %call14 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.6, i32 0, i32 0))
  br label %out_noreboot

if.end15:                                         ; preds = %if.end10
  %call16 = call i32 @misc_register(%struct.miscdevice* @sbc8360_miscdev)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end15
  %call19 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.7, i32 0, i32 0))
  %call52 = call i32 @unregister_reboot_notifier(%struct.notifier_block* @sbc8360_notifier)
  br label %out_noreboot

if.end20:                                         ; preds = %if.end15
  %2 = load i32, i32* @timeout, align 4, !tbaa !12
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [64 x [2 x i32]], [64 x [2 x i32]]* @wd_times, i64 0, i64 %idxprom
  %arrayidx21 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx, i64 0, i64 0
  %3 = load i32, i32* %arrayidx21, align 8, !tbaa !12
  store i32 %3, i32* @wd_margin, align 4, !tbaa !12
  %4 = load i32, i32* @timeout, align 4, !tbaa !12
  %idxprom22 = sext i32 %4 to i64
  %arrayidx23 = getelementptr inbounds [64 x [2 x i32]], [64 x [2 x i32]]* @wd_times, i64 0, i64 %idxprom22
  %arrayidx24 = getelementptr inbounds [2 x i32], [2 x i32]* %arrayidx23, i64 0, i64 1
  %5 = load i32, i32* %arrayidx24, align 4, !tbaa !12
  store i32 %5, i32* @wd_multiplier, align 4, !tbaa !12
  %6 = load i32, i32* @wd_multiplier, align 4, !tbaa !12
  %cmp25 = icmp eq i32 %6, 1
  br i1 %cmp25, label %if.then26, label %if.else

if.then26:                                        ; preds = %if.end20
  %7 = load i32, i32* @wd_margin, align 4, !tbaa !12
  %add = add nsw i32 %7, 1
  %mul = mul nsw i32 %add, 500
  %conv = sext i32 %mul to i64
  br label %if.end50

if.else:                                          ; preds = %if.end20
  %8 = load i32, i32* @wd_multiplier, align 4, !tbaa !12
  %cmp27 = icmp eq i32 %8, 2
  br i1 %cmp27, label %if.then29, label %if.else33

if.then29:                                        ; preds = %if.else
  %9 = load i32, i32* @wd_margin, align 4, !tbaa !12
  %add30 = add nsw i32 %9, 1
  %mul31 = mul nsw i32 %add30, 5000
  %conv32 = sext i32 %mul31 to i64
  br label %if.end50

if.else33:                                        ; preds = %if.else
  %10 = load i32, i32* @wd_multiplier, align 4, !tbaa !12
  %cmp34 = icmp eq i32 %10, 3
  br i1 %cmp34, label %if.then36, label %if.else40

if.then36:                                        ; preds = %if.else33
  %11 = load i32, i32* @wd_margin, align 4, !tbaa !12
  %add37 = add nsw i32 %11, 1
  %mul38 = mul nsw i32 %add37, 50000
  %conv39 = sext i32 %mul38 to i64
  br label %if.end50

if.else40:                                        ; preds = %if.else33
  %12 = load i32, i32* @wd_multiplier, align 4, !tbaa !12
  %cmp41 = icmp eq i32 %12, 4
  br i1 %cmp41, label %if.then43, label %if.end50

if.then43:                                        ; preds = %if.else40
  %13 = load i32, i32* @wd_margin, align 4, !tbaa !12
  %add44 = add nsw i32 %13, 1
  %mul45 = mul nsw i32 %add44, 100000
  %conv46 = sext i32 %mul45 to i64
  br label %if.end50

if.end50:                                         ; preds = %if.then29, %if.else40, %if.then43, %if.then36, %if.then26
  %mseconds.3 = phi i64 [ %conv, %if.then26 ], [ %conv32, %if.then29 ], [ %conv39, %if.then36 ], [ %conv46, %if.then43 ], [ 60000, %if.else40 ]
  %call51 = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.8, i32 0, i32 0), i64 %mseconds.3)
  br label %cleanup

out_noreboot:                                     ; preds = %if.then18, %if.then13
  %res.0 = phi i32 [ %call11, %if.then13 ], [ %call16, %if.then18 ]
  call void @__release_region(%struct.resource* @ioport_resource, i64 289, i64 1)
  br label %out_nobasetimereg

out_nobasetimereg:                                ; preds = %out_noreboot, %if.then8
  %res.1 = phi i32 [ %res.0, %out_noreboot ], [ -5, %if.then8 ]
  call void @__release_region(%struct.resource* @ioport_resource, i64 288, i64 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then, %if.then3, %out_nobasetimereg, %if.end50
  %retval.0 = phi i32 [ 0, %if.end50 ], [ -22, %if.then ], [ %res.1, %out_nobasetimereg ], [ -5, %if.then3 ]
  ret i32 %retval.0
}

declare i64 @no_llseek(%struct.file*, i64, i32) #2

; Function Attrs: nounwind uwtable
define internal i64 @sbc8360_write(%struct.file* %file, i8* %buf, i64 %count, i64* %ppos) #1 {
entry:
  %tobool = icmp ne i64 %count, 0
  br i1 %tobool, label %if.then, label %return

if.then:                                          ; preds = %entry
  %0 = load i8, i8* @nowayout, align 1, !tbaa !14, !range !16
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %if.end14, label %if.then2

if.then2:                                         ; preds = %if.then
  store i8 0, i8* @expect_close, align 1, !tbaa !17
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then2
  %i.0 = phi i64 [ 0, %if.then2 ], [ %inc, %for.inc ]
  %retval.0 = phi i64 [ undef, %if.then2 ], [ %retval.1, %for.inc ]
  %cmp = icmp ne i64 %i.0, %count
  br i1 %cmp, label %for.body, label %cleanup11

for.body:                                         ; preds = %for.cond
  call void @might_fault()
  %add.ptr = getelementptr inbounds i8, i8* %buf, i64 %i.0
  %1 = call { i8*, i64 } asm sideeffect "call __get_user_${3:P}", "={ax},={edx},0,i,~{dirflag},~{fpsr},~{flags}"(i8* %add.ptr, i64 1) #5, !srcloc !18
  %asmresult = extractvalue { i8*, i64 } %1, 0
  %asmresult3 = extractvalue { i8*, i64 } %1, 1
  %2 = ptrtoint i8* %asmresult to i64
  %3 = trunc i64 %2 to i32
  %conv = trunc i64 %asmresult3 to i8
  %tobool4 = icmp ne i32 %3, 0
  br i1 %tobool4, label %cleanup, label %if.end

if.end:                                           ; preds = %for.body
  %conv6 = sext i8 %conv to i32
  %cmp7 = icmp eq i32 %conv6, 86
  br i1 %cmp7, label %if.then9, label %cleanup

if.then9:                                         ; preds = %if.end
  store i8 42, i8* @expect_close, align 1, !tbaa !17
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then9, %for.body
  %cleanup.dest.slot.0 = phi i32 [ 1, %for.body ], [ 0, %if.then9 ], [ 0, %if.end ]
  %retval.1 = phi i64 [ -14, %for.body ], [ %retval.0, %if.then9 ], [ %retval.0, %if.end ]
  %cond = icmp eq i32 %cleanup.dest.slot.0, 0
  br i1 %cond, label %for.inc, label %cleanup11

for.inc:                                          ; preds = %cleanup
  %inc = add i64 %i.0, 1
  br label %for.cond

cleanup11:                                        ; preds = %cleanup, %for.cond
  %cleanup.dest.slot.1 = phi i32 [ 0, %for.cond ], [ %cleanup.dest.slot.0, %cleanup ]
  %retval.2 = phi i64 [ %retval.0, %for.cond ], [ %retval.1, %cleanup ]
  %switch = icmp ult i32 %cleanup.dest.slot.1, 1
  br i1 %switch, label %if.end14, label %return

if.end14:                                         ; preds = %cleanup11, %if.then
  call void @sbc8360_ping()
  br label %return

return:                                           ; preds = %entry, %if.end14, %cleanup11
  %retval.3 = phi i64 [ %retval.2, %cleanup11 ], [ %count, %if.end14 ], [ %count, %entry ]
  ret i64 %retval.3
}

; Function Attrs: nounwind uwtable
define internal i32 @sbc8360_open(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %call = call i32 @test_and_set_bit(i32 0, i64* @sbc8360_is_open)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %0 = load i8, i8* @nowayout, align 1, !tbaa !14, !range !16
  %tobool1 = trunc i8 %0 to i1
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @__module_get(%struct.module* null)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  call void @sbc8360_activate()
  call void @sbc8360_ping()
  %call4 = call i32 @nonseekable_open(%struct.inode* %inode, %struct.file* %file)
  br label %return

return:                                           ; preds = %entry, %if.end3
  %retval.0 = phi i32 [ %call4, %if.end3 ], [ -16, %entry ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define internal i32 @sbc8360_close(%struct.inode* %inode, %struct.file* %file) #1 {
entry:
  %0 = load i8, i8* @expect_close, align 1, !tbaa !17
  %conv = sext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 42
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @sbc8360_stop()
  br label %if.end

if.else:                                          ; preds = %entry
  %call = call i32 (i8*, ...) @printk(i8* getelementptr inbounds ([72 x i8], [72 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  call void @clear_bit(i32 0, i64* @sbc8360_is_open)
  store i8 0, i8* @expect_close, align 1, !tbaa !17
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #3

; Function Attrs: inlinehint nounwind uwtable
define internal void @might_fault() #0 {
entry:
  %call = call i32 @_cond_resched()
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture) #3

; Function Attrs: nounwind uwtable
define internal void @sbc8360_ping() #1 {
entry:
  %0 = load i32, i32* @wd_margin, align 4, !tbaa !12
  %conv = trunc i32 %0 to i8
  call void @outb(i8 zeroext %conv, i32 289)
  ret void
}

declare i32 @_cond_resched() #2

; Function Attrs: inlinehint nounwind uwtable
define internal void @outb(i8 zeroext %value, i32 %port) #0 {
entry:
  call void asm sideeffect "outb ${0:b}, ${1:w}", "{ax},N{dx},~{dirflag},~{fpsr},~{flags}"(i8 %value, i32 %port) #5, !srcloc !19
  ret void
}

; Function Attrs: inlinehint nounwind uwtable
define internal i32 @test_and_set_bit(i32 %nr, i64* %addr) #0 {
entry:
  %0 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2,$1\0A\09sbb $0,$0", "=r,=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #5, !srcloc !20
  ret i32 %0
}

declare void @__module_get(%struct.module*) #2

; Function Attrs: nounwind uwtable
define internal void @sbc8360_activate() #1 {
entry:
  call void @outb(i8 zeroext 10, i32 288)
  %call = call i64 @msleep_interruptible(i32 100)
  call void @outb(i8 zeroext 11, i32 288)
  %call1 = call i64 @msleep_interruptible(i32 100)
  %0 = load i32, i32* @wd_multiplier, align 4, !tbaa !12
  %conv = trunc i32 %0 to i8
  call void @outb(i8 zeroext %conv, i32 288)
  %call2 = call i64 @msleep_interruptible(i32 100)
  ret void
}

declare i32 @nonseekable_open(%struct.inode*, %struct.file*) #2

declare i64 @msleep_interruptible(i32) #2

; Function Attrs: nounwind uwtable
define internal void @sbc8360_stop() #1 {
entry:
  call void @outb(i8 zeroext 0, i32 288)
  ret void
}

declare i32 @printk(i8*, ...) #2

; Function Attrs: alwaysinline nounwind uwtable
define internal void @clear_bit(i32 %nr, i64* %addr) #4 {
entry:
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %addr, i32 %nr, i64* %addr) #5, !srcloc !21
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @sbc8360_notify_sys(%struct.notifier_block* %this, i64 %code, i8* %unused) #1 {
entry:
  %code.off = add i64 %code, -1
  %switch = icmp ult i64 %code.off, 2
  br i1 %switch, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @sbc8360_stop()
  br label %if.end

if.end:                                           ; preds = %entry, %if.then
  ret i32 0
}

declare %struct.resource* @__request_region(%struct.resource*, i64, i64, i8*, i32) #2

declare i32 @register_reboot_notifier(%struct.notifier_block*) #2

declare i32 @misc_register(%struct.miscdevice*) #2

declare i64 @__modver_version_show(%struct.module_attribute*, %struct.module_kobject*, i8*) #2

attributes #0 = { inlinehint nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { alwaysinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
!2 = !{!3, !4, i64 24}
!3 = !{!"smp_ops", !4, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !4, i64 32, !4, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80}
!4 = !{!"any pointer", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!3, !4, i64 32}
!8 = !{!3, !4, i64 8}
!9 = !{!3, !4, i64 40}
!10 = !{!3, !4, i64 16}
!11 = !{!3, !4, i64 0}
!12 = !{!13, !13, i64 0}
!13 = !{!"int", !5, i64 0}
!14 = !{!15, !15, i64 0}
!15 = !{!"_Bool", !5, i64 0}
!16 = !{i8 0, i8 2}
!17 = !{!5, !5, i64 0}
!18 = !{i32 -2145403974}
!19 = !{i32 -2146157744}
!20 = !{i32 -2147233114, i32 -2147233075, i32 -2147233054, i32 -2147233017, i32 -2147232994, i32 -2147233124, i32 201546}
!21 = !{i32 -2147234327, i32 -2147234288, i32 -2147234267, i32 -2147234230, i32 -2147234207, i32 -2147234337}
